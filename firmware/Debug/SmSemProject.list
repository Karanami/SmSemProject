
SmSemProject.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000013c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000131b4  08000140  08000140  00010140  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000002d0  080132f4  080132f4  000232f4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  080135c4  080135c4  000235c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   0000000c  080135cc  080135cc  000235cc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  080135d8  080135d8  000235d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000110  20000008  080135dc  00030008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000783c  20000118  080136ec  00030118  2**3
                  ALLOC
  8 ._user_heap_stack 00000604  20007954  080136ec  00037954  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00030118  2**0
                  CONTENTS, READONLY
 10 .comment      00000043  00000000  00000000  00030148  2**0
                  CONTENTS, READONLY
 11 .debug_info   00082c59  00000000  00000000  0003018b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_abbrev 0001201a  00000000  00000000  000b2de4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00003ae0  00000000  00000000  000c4e00  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_rnglists 000029eb  00000000  00000000  000c88e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  000439cb  00000000  00000000  000cb2cb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   00073bec  00000000  00000000  0010ec96  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    0012bde7  00000000  00000000  00182882  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_frame  0000c9ac  00000000  00000000  002ae66c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line_str 000000fc  00000000  00000000  002bb018  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000140 <__do_global_dtors_aux>:
 8000140:	b510      	push	{r4, lr}
 8000142:	4c05      	ldr	r4, [pc, #20]	; (8000158 <__do_global_dtors_aux+0x18>)
 8000144:	7823      	ldrb	r3, [r4, #0]
 8000146:	b933      	cbnz	r3, 8000156 <__do_global_dtors_aux+0x16>
 8000148:	4b04      	ldr	r3, [pc, #16]	; (800015c <__do_global_dtors_aux+0x1c>)
 800014a:	b113      	cbz	r3, 8000152 <__do_global_dtors_aux+0x12>
 800014c:	4804      	ldr	r0, [pc, #16]	; (8000160 <__do_global_dtors_aux+0x20>)
 800014e:	f3af 8000 	nop.w
 8000152:	2301      	movs	r3, #1
 8000154:	7023      	strb	r3, [r4, #0]
 8000156:	bd10      	pop	{r4, pc}
 8000158:	20000118 	.word	0x20000118
 800015c:	00000000 	.word	0x00000000
 8000160:	080132dc 	.word	0x080132dc

08000164 <frame_dummy>:
 8000164:	b508      	push	{r3, lr}
 8000166:	4b03      	ldr	r3, [pc, #12]	; (8000174 <frame_dummy+0x10>)
 8000168:	b11b      	cbz	r3, 8000172 <frame_dummy+0xe>
 800016a:	4903      	ldr	r1, [pc, #12]	; (8000178 <frame_dummy+0x14>)
 800016c:	4803      	ldr	r0, [pc, #12]	; (800017c <frame_dummy+0x18>)
 800016e:	f3af 8000 	nop.w
 8000172:	bd08      	pop	{r3, pc}
 8000174:	00000000 	.word	0x00000000
 8000178:	2000011c 	.word	0x2000011c
 800017c:	080132dc 	.word	0x080132dc

08000180 <_tx_initialize_low_level>:
    .thumb_func
_tx_initialize_low_level:
@
@    /* Disable interrupts during ThreadX initialization.  */
@
    CPSID   i
 8000180:	b672      	cpsid	i
    STR     r1, [r0]                                @ Setup first unused memory pointer
#endif
@
@    /* Setup Vector Table Offset Register.  */
@
    MOV     r0, #0xE000E000                         @ Build address of NVIC registers
 8000182:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =g_pfnVectors                           @ Pickup address of vector table
 8000186:	491a      	ldr	r1, [pc, #104]	; (80001f0 <__tx_DBGHandler+0x6>)
    STR     r1, [r0, #0xD08]                        @ Set vector table address
 8000188:	f8c0 1d08 	str.w	r1, [r0, #3336]	; 0xd08
@
@    /* Set system stack pointer from vector value.  */
@
    LDR     r0, =_tx_thread_system_stack_ptr        @ Build address of system stack pointer
 800018c:	4819      	ldr	r0, [pc, #100]	; (80001f4 <__tx_DBGHandler+0xa>)
    LDR     r1, =g_pfnVectors                           @ Pickup address of vector table
 800018e:	4918      	ldr	r1, [pc, #96]	; (80001f0 <__tx_DBGHandler+0x6>)
    LDR     r1, [r1]                                @ Pickup reset stack pointer
 8000190:	6809      	ldr	r1, [r1, #0]
    STR     r1, [r0]                                @ Save system stack pointer
 8000192:	6001      	str	r1, [r0, #0]
@
@    /* Enable the cycle count register.  */
@
    LDR     r0, =0xE0001000                         @ Build address of DWT register
 8000194:	4818      	ldr	r0, [pc, #96]	; (80001f8 <__tx_DBGHandler+0xe>)
    LDR     r1, [r0]                                @ Pickup the current value
 8000196:	6801      	ldr	r1, [r0, #0]
    ORR     r1, r1, #1                              @ Set the CYCCNTENA bit
 8000198:	f041 0101 	orr.w	r1, r1, #1
    STR     r1, [r0]                                @ Enable the cycle count register
 800019c:	6001      	str	r1, [r0, #0]
@
@    /* Configure SysTick for 100Hz clock, or 16384 cycles if no reference.  */
@
    MOV     r0, #0xE000E000                         @ Build address of NVIC registers
 800019e:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =SYSTICK_CYCLES
 80001a2:	f64f 11ff 	movw	r1, #63999	; 0xf9ff
    STR     r1, [r0, #0x14]                         @ Setup SysTick Reload Value
 80001a6:	6141      	str	r1, [r0, #20]
    MOV     r1, #0x7                                @ Build SysTick Control Enable Value
 80001a8:	f04f 0107 	mov.w	r1, #7
    STR     r1, [r0, #0x10]                         @ Setup SysTick Control
 80001ac:	6101      	str	r1, [r0, #16]
@
@    /* Configure handler priorities.  */
@
    LDR     r1, =0x00000000                         @ Rsrv, UsgF, BusF, MemM
 80001ae:	f04f 0100 	mov.w	r1, #0
    STR     r1, [r0, #0xD18]                        @ Setup System Handlers 4-7 Priority Registers
 80001b2:	f8c0 1d18 	str.w	r1, [r0, #3352]	; 0xd18

    LDR     r1, =0xFF000000                         @ SVCl, Rsrv, Rsrv, Rsrv
 80001b6:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
    STR     r1, [r0, #0xD1C]                        @ Setup System Handlers 8-11 Priority Registers
 80001ba:	f8c0 1d1c 	str.w	r1, [r0, #3356]	; 0xd1c
                                                    @ Note: SVC must be lowest priority, which is 0xFF

    LDR     r1, =0x40FF0000                         @ SysT, PnSV, Rsrv, DbgM
 80001be:	490f      	ldr	r1, [pc, #60]	; (80001fc <__tx_DBGHandler+0x12>)
    STR     r1, [r0, #0xD20]                        @ Setup System Handlers 12-15 Priority Registers
 80001c0:	f8c0 1d20 	str.w	r1, [r0, #3360]	; 0xd20
                                                    @ Note: PnSV must be lowest priority, which is 0xFF
@
@    /* Return to caller.  */
@
    BX      lr
 80001c4:	4770      	bx	lr

080001c6 <__tx_BadHandler>:
@/* Define shells for each of the unused vectors.  */
@
    .global  __tx_BadHandler
    .thumb_func
__tx_BadHandler:
    B       __tx_BadHandler
 80001c6:	f7ff bffe 	b.w	80001c6 <__tx_BadHandler>

080001ca <__tx_HardfaultHandler>:
@ /* added to catch the hardfault */

    .global  __tx_HardfaultHandler
    .thumb_func
__tx_HardfaultHandler:
    B       __tx_HardfaultHandler
 80001ca:	f7ff bffe 	b.w	80001ca <__tx_HardfaultHandler>

080001ce <__tx_SVCallHandler>:
@ /* added to catch the SVC */

    .global  __tx_SVCallHandler
    .thumb_func
__tx_SVCallHandler:
    B       __tx_SVCallHandler
 80001ce:	f7ff bffe 	b.w	80001ce <__tx_SVCallHandler>

080001d2 <__tx_IntHandler>:
    .global  __tx_IntHandler
    .thumb_func
__tx_IntHandler:
@ VOID InterruptHandler (VOID)
@ {
    PUSH    {r0, lr}
 80001d2:	b501      	push	{r0, lr}
@    /* BL <your C Function>.... */

#ifdef TX_EXECUTION_PROFILE_ENABLE
    BL      _tx_execution_isr_exit              @ Call the ISR exit function
#endif
    POP     {r0, lr}
 80001d4:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      LR
 80001d8:	4770      	bx	lr

080001da <SysTick_Handler>:
    .thumb_func
SysTick_Handler:
@ VOID TimerInterruptHandler (VOID)
@ {
@
    PUSH    {r0, lr}
 80001da:	b501      	push	{r0, lr}
#ifdef TX_EXECUTION_PROFILE_ENABLE
    BL      _tx_execution_isr_enter             @ Call the ISR enter function
#endif
    BL      _tx_timer_interrupt
 80001dc:	f000 f890 	bl	8000300 <_tx_timer_interrupt>
#ifdef TX_EXECUTION_PROFILE_ENABLE
    BL      _tx_execution_isr_exit              @ Call the ISR exit function
#endif
    POP     {r0, lr}
 80001e0:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      LR
 80001e4:	4770      	bx	lr

080001e6 <__tx_NMIHandler>:

@ /* NMI, DBG handlers */
    .global  __tx_NMIHandler
    .thumb_func
__tx_NMIHandler:
    B       __tx_NMIHandler
 80001e6:	f7ff bffe 	b.w	80001e6 <__tx_NMIHandler>

080001ea <__tx_DBGHandler>:

    .global  __tx_DBGHandler
    .thumb_func
__tx_DBGHandler:
    B       __tx_DBGHandler
 80001ea:	f7ff bffe 	b.w	80001ea <__tx_DBGHandler>
 80001ee:	0000      	.short	0x0000
    LDR     r1, =g_pfnVectors                           @ Pickup address of vector table
 80001f0:	08000000 	.word	0x08000000
    LDR     r0, =_tx_thread_system_stack_ptr        @ Build address of system stack pointer
 80001f4:	20006d00 	.word	0x20006d00
    LDR     r0, =0xE0001000                         @ Build address of DWT register
 80001f8:	e0001000 	.word	0xe0001000
    LDR     r1, =0x40FF0000                         @ SysT, PnSV, Rsrv, DbgM
 80001fc:	40ff0000 	.word	0x40ff0000

08000200 <_tx_thread_schedule>:
       from the first schedule request. Subsequent scheduling occurs
       from the PendSV handling routine below. */

    /* Clear the preempt-disable flag to enable rescheduling after initialization on Cortex-M targets.  */

    MOV     r0, #0                                  // Build value for TX_FALSE
 8000200:	f04f 0000 	mov.w	r0, #0
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 8000204:	4a2a      	ldr	r2, [pc, #168]	; (80002b0 <tx_thread_fpu_disable+0x2>)
    STR     r0, [r2, #0]                            // Clear preempt disable flag
 8000206:	6010      	str	r0, [r2, #0]

    /* Clear CONTROL.FPCA bit so VFP registers aren't unnecessarily stacked.  */

#ifdef __ARM_FP
    MRS     r0, CONTROL                             // Pickup current CONTROL register
 8000208:	f3ef 8014 	mrs	r0, CONTROL
    BIC     r0, r0, #4                              // Clear the FPCA bit
 800020c:	f020 0004 	bic.w	r0, r0, #4
    MSR     CONTROL, r0                             // Setup new CONTROL register
 8000210:	f380 8814 	msr	CONTROL, r0
#endif

    /* Enable interrupts */
    CPSIE   i
 8000214:	b662      	cpsie	i

    /* Enter the scheduler for the first time.  */

    MOV     r0, #0x10000000                         // Load PENDSVSET bit
 8000216:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    MOV     r1, #0xE000E000                         // Load NVIC base
 800021a:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    STR     r0, [r1, #0xD04]                        // Set PENDSVBIT in ICSR
 800021e:	f8c1 0d04 	str.w	r0, [r1, #3332]	; 0xd04
    DSB                                             // Complete all memory accesses
 8000222:	f3bf 8f4f 	dsb	sy
    ISB                                             // Flush pipeline
 8000226:	f3bf 8f6f 	isb	sy

0800022a <__tx_wait_here>:

    /* Wait here for the PendSV to take place.  */

__tx_wait_here:
    B       __tx_wait_here                          // Wait for the PendSV to happen
 800022a:	e7fe      	b.n	800022a <__tx_wait_here>

0800022c <PendSV_Handler>:
#else
    CPSIE   i                                       // Enable interrupts
#endif  /* TX_PORT_USE_BASEPRI */
#endif  /* EXECUTION PROFILE */

    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 800022c:	4821      	ldr	r0, [pc, #132]	; (80002b4 <tx_thread_fpu_disable+0x6>)
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 800022e:	4a22      	ldr	r2, [pc, #136]	; (80002b8 <tx_thread_fpu_disable+0xa>)
    MOV     r3, #0                                  // Build NULL value
 8000230:	f04f 0300 	mov.w	r3, #0
    LDR     r1, [r0]                                // Pickup current thread pointer
 8000234:	6801      	ldr	r1, [r0, #0]

    /* Determine if there is a current thread to finish preserving.  */

    CBZ     r1, __tx_ts_new                         // If NULL, skip preservation
 8000236:	b191      	cbz	r1, 800025e <__tx_ts_new>

    /* Recover PSP and preserve current thread context.  */

    STR     r3, [r0]                                // Set _tx_thread_current_ptr to NULL
 8000238:	6003      	str	r3, [r0, #0]
    MRS     r12, PSP                                // Pickup PSP pointer (thread's stack pointer)
 800023a:	f3ef 8c09 	mrs	ip, PSP
    STMDB   r12!, {r4-r11}                          // Save its remaining registers
 800023e:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
#ifdef __ARM_FP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
 8000242:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_save
 8000246:	d101      	bne.n	800024c <_skip_vfp_save>
    VSTMDB  r12!,{s16-s31}                          // Yes, save additional VFP registers
 8000248:	ed2c 8a10 	vstmdb	ip!, {s16-s31}

0800024c <_skip_vfp_save>:
_skip_vfp_save:
#endif
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 800024c:	4c1b      	ldr	r4, [pc, #108]	; (80002bc <tx_thread_fpu_disable+0xe>)
    STMDB   r12!, {LR}                              // Save LR on the stack
 800024e:	f84c ed04 	str.w	lr, [ip, #-4]!

    /* Determine if time-slice is active. If it isn't, skip time handling processing.  */

    LDR     r5, [r4]                                // Pickup current time-slice
 8000252:	6825      	ldr	r5, [r4, #0]
    STR     r12, [r1, #8]                           // Save the thread stack pointer
 8000254:	f8c1 c008 	str.w	ip, [r1, #8]
    CBZ     r5, __tx_ts_new                         // If not active, skip processing
 8000258:	b10d      	cbz	r5, 800025e <__tx_ts_new>

    /* Time-slice is active, save the current thread's time-slice and clear the global time-slice variable.  */

    STR     r5, [r1, #24]                           // Save current time-slice
 800025a:	618d      	str	r5, [r1, #24]

    /* Clear the global time-slice.  */

    STR     r3, [r4]                                // Clear time-slice
 800025c:	6023      	str	r3, [r4, #0]

0800025e <__tx_ts_new>:

#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
 800025e:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Is there another thread ready to execute?
 8000260:	6811      	ldr	r1, [r2, #0]
    CBZ     r1, __tx_ts_wait                        // No, skip to the wait processing
 8000262:	b1b1      	cbz	r1, 8000292 <__tx_ts_wait>

    /* Yes, another thread is ready for else, make the current thread the new thread.  */

    STR     r1, [r0]                                // Setup the current thread pointer to the new thread
 8000264:	6001      	str	r1, [r0, #0]
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
 8000266:	b662      	cpsie	i

08000268 <__tx_ts_restore>:
#endif

    /* Increment the thread run count.  */

__tx_ts_restore:
    LDR     r7, [r1, #4]                            // Pickup the current thread run count
 8000268:	684f      	ldr	r7, [r1, #4]
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 800026a:	4c14      	ldr	r4, [pc, #80]	; (80002bc <tx_thread_fpu_disable+0xe>)
    LDR     r5, [r1, #24]                           // Pickup thread's current time-slice
 800026c:	698d      	ldr	r5, [r1, #24]
    ADD     r7, r7, #1                              // Increment the thread run count
 800026e:	f107 0701 	add.w	r7, r7, #1
    STR     r7, [r1, #4]                            // Store the new run count
 8000272:	604f      	str	r7, [r1, #4]

    /* Setup global time-slice with thread's current time-slice.  */

    STR     r5, [r4]                                // Setup global time-slice
 8000274:	6025      	str	r5, [r4, #0]
    POP     {r0, r1}                                // Recover r0 and r1
#endif

    /* Restore the thread context and PSP.  */

    LDR     r12, [r1, #8]                           // Pickup thread's stack pointer
 8000276:	f8d1 c008 	ldr.w	ip, [r1, #8]
    LDMIA   r12!, {LR}                              // Pickup LR
 800027a:	f85c eb04 	ldr.w	lr, [ip], #4
#ifdef __ARM_FP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
 800027e:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_restore                       // If not, skip VFP restore
 8000282:	d101      	bne.n	8000288 <_skip_vfp_restore>
    VLDMIA  r12!, {s16-s31}                         // Yes, restore additional VFP registers
 8000284:	ecbc 8a10 	vldmia	ip!, {s16-s31}

08000288 <_skip_vfp_restore>:
_skip_vfp_restore:
#endif
    LDMIA   r12!, {r4-r11}                          // Recover thread's registers
 8000288:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
    MSR     PSP, r12                                // Setup the thread's stack pointer
 800028c:	f38c 8809 	msr	PSP, ip

    /* Return to thread.  */

    BX      lr                                      // Return to thread!
 8000290:	4770      	bx	lr

08000292 <__tx_ts_wait>:
__tx_ts_wait:
#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
 8000292:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Pickup the next thread to execute pointer
 8000294:	6811      	ldr	r1, [r2, #0]
    STR     r1, [r0]                                // Store it in the current pointer
 8000296:	6001      	str	r1, [r0, #0]
    CBNZ    r1, __tx_ts_ready                       // If non-NULL, a new thread is ready!
 8000298:	b909      	cbnz	r1, 800029e <__tx_ts_ready>

#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
 800029a:	b662      	cpsie	i
#endif
    B       __tx_ts_wait                            // Loop to continue waiting
 800029c:	e7f9      	b.n	8000292 <__tx_ts_wait>

0800029e <__tx_ts_ready>:

    /* At this point, we have a new thread ready to go. Clear any newly pended PendSV - since we are
       already in the handler!  */

__tx_ts_ready:
    MOV     r7, #0x08000000                         // Build clear PendSV value
 800029e:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
    MOV     r8, #0xE000E000                         // Build base NVIC address
 80002a2:	f04f 28e0 	mov.w	r8, #3758153728	; 0xe000e000
    STR     r7, [r8, #0xD04]                        // Clear any PendSV
 80002a6:	f8c8 7d04 	str.w	r7, [r8, #3332]	; 0xd04
    /* Re-enable interrupts and restore new thread.  */
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
 80002aa:	b662      	cpsie	i
#endif
    B       __tx_ts_restore                         // Restore the thread
 80002ac:	e7dc      	b.n	8000268 <__tx_ts_restore>

080002ae <tx_thread_fpu_disable>:
tx_thread_fpu_disable:

    /* Automatic VPF logic is supported, this function is present only for
       backward compatibility purposes and therefore simply returns.  */

    BX      LR                                      // Return to caller
 80002ae:	4770      	bx	lr
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 80002b0:	20006d9c 	.word	0x20006d9c
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 80002b4:	20006d04 	.word	0x20006d04
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 80002b8:	20006d08 	.word	0x20006d08
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
 80002bc:	20007308 	.word	0x20007308

080002c0 <_tx_thread_stack_build>:
                       pc          Initial value for pc
                       xPSR        Initial value for xPSR

    Stack Bottom: (higher memory address)  */

    LDR     r2, [r0, #16]                           // Pickup end of stack area
 80002c0:	6902      	ldr	r2, [r0, #16]
    BIC     r2, r2, #0x7                            // Align frame for 8-byte alignment
 80002c2:	f022 0207 	bic.w	r2, r2, #7
    SUB     r2, r2, #68                             // Subtract frame size
 80002c6:	f1a2 0244 	sub.w	r2, r2, #68	; 0x44
    LDR     r3, =0xFFFFFFFD                         // Build initial LR value
 80002ca:	f06f 0302 	mvn.w	r3, #2
    STR     r3, [r2, #0]                            // Save on the stack
 80002ce:	6013      	str	r3, [r2, #0]

    /* Actually build the stack frame.  */

    MOV     r3, #0                                  // Build initial register value
 80002d0:	f04f 0300 	mov.w	r3, #0
    STR     r3, [r2, #4]                            // Store initial r4
 80002d4:	6053      	str	r3, [r2, #4]
    STR     r3, [r2, #8]                            // Store initial r5
 80002d6:	6093      	str	r3, [r2, #8]
    STR     r3, [r2, #12]                           // Store initial r6
 80002d8:	60d3      	str	r3, [r2, #12]
    STR     r3, [r2, #16]                           // Store initial r7
 80002da:	6113      	str	r3, [r2, #16]
    STR     r3, [r2, #20]                           // Store initial r8
 80002dc:	6153      	str	r3, [r2, #20]
    STR     r3, [r2, #24]                           // Store initial r9
 80002de:	6193      	str	r3, [r2, #24]
    STR     r3, [r2, #28]                           // Store initial r10
 80002e0:	61d3      	str	r3, [r2, #28]
    STR     r3, [r2, #32]                           // Store initial r11
 80002e2:	6213      	str	r3, [r2, #32]

    /* Hardware stack follows.  */

    STR     r3, [r2, #36]                           // Store initial r0
 80002e4:	6253      	str	r3, [r2, #36]	; 0x24
    STR     r3, [r2, #40]                           // Store initial r1
 80002e6:	6293      	str	r3, [r2, #40]	; 0x28
    STR     r3, [r2, #44]                           // Store initial r2
 80002e8:	62d3      	str	r3, [r2, #44]	; 0x2c
    STR     r3, [r2, #48]                           // Store initial r3
 80002ea:	6313      	str	r3, [r2, #48]	; 0x30
    STR     r3, [r2, #52]                           // Store initial r12
 80002ec:	6353      	str	r3, [r2, #52]	; 0x34
    MOV     r3, #0xFFFFFFFF                         // Poison EXC_RETURN value
 80002ee:	f04f 33ff 	mov.w	r3, #4294967295
    STR     r3, [r2, #56]                           // Store initial lr
 80002f2:	6393      	str	r3, [r2, #56]	; 0x38
    STR     r1, [r2, #60]                           // Store initial pc
 80002f4:	63d1      	str	r1, [r2, #60]	; 0x3c
    MOV     r3, #0x01000000                         // Only T-bit need be set
 80002f6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    STR     r3, [r2, #64]                           // Store initial xPSR
 80002fa:	6413      	str	r3, [r2, #64]	; 0x40

    /* Setup stack pointer.  */
    // thread_ptr -> tx_thread_stack_ptr =  r2;

    STR     r2, [r0, #8]                            // Save stack pointer in thread's
 80002fc:	6082      	str	r2, [r0, #8]
                                                    //   control block
    BX      lr                                      // Return to caller
 80002fe:	4770      	bx	lr

08000300 <_tx_timer_interrupt>:
       for use.  */

    /* Increment the system clock.  */
    // _tx_timer_system_clock++;

    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
 8000300:	4922      	ldr	r1, [pc, #136]	; (800038c <__tx_timer_nothing_expired+0x6>)
    LDR     r0, [r1, #0]                            // Pickup system clock
 8000302:	6808      	ldr	r0, [r1, #0]
    ADD     r0, r0, #1                              // Increment system clock
 8000304:	f100 0001 	add.w	r0, r0, #1
    STR     r0, [r1, #0]                            // Store new system clock
 8000308:	6008      	str	r0, [r1, #0]

    /* Test for time-slice expiration.  */
    // if (_tx_timer_time_slice)
    // {

    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
 800030a:	4b21      	ldr	r3, [pc, #132]	; (8000390 <__tx_timer_nothing_expired+0xa>)
    LDR     r2, [r3, #0]                            // Pickup time-slice
 800030c:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_no_time_slice            // Is it non-active?
 800030e:	b13a      	cbz	r2, 8000320 <__tx_timer_no_time_slice>
                                                    // Yes, skip time-slice processing

       /* Decrement the time_slice.  */
       // _tx_timer_time_slice--;

    SUB     r2, r2, #1                              // Decrement the time-slice
 8000310:	f1a2 0201 	sub.w	r2, r2, #1
    STR     r2, [r3, #0]                            // Store new time-slice value
 8000314:	601a      	str	r2, [r3, #0]

       /* Check for expiration.  */
       // if (__tx_timer_time_slice == 0)

    CBNZ    r2, __tx_timer_no_time_slice            // Has it expired?
 8000316:	b91a      	cbnz	r2, 8000320 <__tx_timer_no_time_slice>
                                                    // No, skip expiration processing

       /* Set the time-slice expired flag.  */
       // _tx_timer_expired_time_slice =  TX_TRUE;

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
 8000318:	4b1e      	ldr	r3, [pc, #120]	; (8000394 <__tx_timer_nothing_expired+0xe>)
    MOV     r0, #1                                  // Build expired value
 800031a:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r3, #0]                            // Set time-slice expiration flag
 800031e:	6018      	str	r0, [r3, #0]

08000320 <__tx_timer_no_time_slice>:

    /* Test for timer expiration.  */
    // if (*_tx_timer_current_ptr)
    // {

    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
 8000320:	491d      	ldr	r1, [pc, #116]	; (8000398 <__tx_timer_nothing_expired+0x12>)
    LDR     r0, [r1, #0]                            // Pickup current timer
 8000322:	6808      	ldr	r0, [r1, #0]
    LDR     r2, [r0, #0]                            // Pickup timer list entry
 8000324:	6802      	ldr	r2, [r0, #0]
    CBZ     r2, __tx_timer_no_timer                 // Is there anything in the list?
 8000326:	b122      	cbz	r2, 8000332 <__tx_timer_no_timer>
                                                    // No, just increment the timer

        /* Set expiration flag.  */
        // _tx_timer_expired =  TX_TRUE;

    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
 8000328:	4b1c      	ldr	r3, [pc, #112]	; (800039c <__tx_timer_nothing_expired+0x16>)
    MOV     r2, #1                                  // Build expired value
 800032a:	f04f 0201 	mov.w	r2, #1
    STR     r2, [r3, #0]                            // Set expired flag
 800032e:	601a      	str	r2, [r3, #0]
    B       __tx_timer_done                         // Finished timer processing
 8000330:	e008      	b.n	8000344 <__tx_timer_done>

08000332 <__tx_timer_no_timer>:
__tx_timer_no_timer:

        /* No timer expired, increment the timer pointer.  */
        // _tx_timer_current_ptr++;

    ADD     r0, r0, #4                              // Move to next timer
 8000332:	f100 0004 	add.w	r0, r0, #4

        /* Check for wrap-around.  */
        // if (_tx_timer_current_ptr == _tx_timer_list_end)

    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
 8000336:	4b1a      	ldr	r3, [pc, #104]	; (80003a0 <__tx_timer_nothing_expired+0x1a>)
    LDR     r2, [r3, #0]                            // Pickup list end
 8000338:	681a      	ldr	r2, [r3, #0]
    CMP     r0, r2                                  // Are we at list end?
 800033a:	4290      	cmp	r0, r2
    BNE     __tx_timer_skip_wrap                    // No, skip wrap-around logic
 800033c:	d101      	bne.n	8000342 <__tx_timer_skip_wrap>

            /* Wrap to beginning of list.  */
            // _tx_timer_current_ptr =  _tx_timer_list_start;

    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
 800033e:	4b19      	ldr	r3, [pc, #100]	; (80003a4 <__tx_timer_nothing_expired+0x1e>)
    LDR     r0, [r3, #0]                            // Set current pointer to list start
 8000340:	6818      	ldr	r0, [r3, #0]

08000342 <__tx_timer_skip_wrap>:

__tx_timer_skip_wrap:

    STR     r0, [r1, #0]                            // Store new current timer pointer
 8000342:	6008      	str	r0, [r1, #0]

08000344 <__tx_timer_done>:

    /* See if anything has expired.  */
    // if ((_tx_timer_expired_time_slice) || (_tx_timer_expired))
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of expired flag
 8000344:	4b13      	ldr	r3, [pc, #76]	; (8000394 <__tx_timer_nothing_expired+0xe>)
    LDR     r2, [r3, #0]                            // Pickup time-slice expired flag
 8000346:	681a      	ldr	r2, [r3, #0]
    CBNZ    r2, __tx_something_expired              // Did a time-slice expire?
 8000348:	b912      	cbnz	r2, 8000350 <__tx_something_expired>
                                                    // If non-zero, time-slice expired
    LDR     r1, =_tx_timer_expired                  // Pickup addr of other expired flag
 800034a:	4914      	ldr	r1, [pc, #80]	; (800039c <__tx_timer_nothing_expired+0x16>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
 800034c:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_nothing_expired          // Did a timer expire?
 800034e:	b1d0      	cbz	r0, 8000386 <__tx_timer_nothing_expired>

08000350 <__tx_something_expired>:
                                                    // No, nothing expired

__tx_something_expired:

    STMDB   sp!, {r0, lr}                           // Save the lr register on the stack
 8000350:	e92d 4001 	stmdb	sp!, {r0, lr}

    /* Did a timer expire?  */
    // if (_tx_timer_expired)
    // {

    LDR     r1, =_tx_timer_expired                  // Pickup addr of expired flag
 8000354:	4911      	ldr	r1, [pc, #68]	; (800039c <__tx_timer_nothing_expired+0x16>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
 8000356:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_dont_activate            // Check for timer expiration
 8000358:	b108      	cbz	r0, 800035e <__tx_timer_dont_activate>
                                                    // If not set, skip timer activation

        /* Process timer expiration.  */
        // _tx_timer_expiration_process();

    BL      _tx_timer_expiration_process            // Call the timer expiration handling routine
 800035a:	f00e f9b9 	bl	800e6d0 <_tx_timer_expiration_process>

0800035e <__tx_timer_dont_activate>:

    /* Did time slice expire?  */
    // if (_tx_timer_expired_time_slice)
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of time-slice expired
 800035e:	4b0d      	ldr	r3, [pc, #52]	; (8000394 <__tx_timer_nothing_expired+0xe>)
    LDR     r2, [r3, #0]                            // Pickup the actual flag
 8000360:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_not_ts_expiration        // See if the flag is set
 8000362:	b172      	cbz	r2, 8000382 <__tx_timer_not_ts_expiration>
                                                    // No, skip time-slice processing

        /* Time slice interrupted thread.  */
        // _tx_thread_time_slice();

    BL      _tx_thread_time_slice                   // Call time-slice processing
 8000364:	f00e f8c2 	bl	800e4ec <_tx_thread_time_slice>
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 8000368:	480f      	ldr	r0, [pc, #60]	; (80003a8 <__tx_timer_nothing_expired+0x22>)
    LDR     r1, [r0]                                // Is the preempt disable flag set?
 800036a:	6801      	ldr	r1, [r0, #0]
    CBNZ    r1, __tx_timer_skip_time_slice          // Yes, skip the PendSV logic
 800036c:	b949      	cbnz	r1, 8000382 <__tx_timer_not_ts_expiration>
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 800036e:	480f      	ldr	r0, [pc, #60]	; (80003ac <__tx_timer_nothing_expired+0x26>)
    LDR     r1, [r0]                                // Pickup the current thread pointer
 8000370:	6801      	ldr	r1, [r0, #0]
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 8000372:	4a0f      	ldr	r2, [pc, #60]	; (80003b0 <__tx_timer_nothing_expired+0x2a>)
    LDR     r3, [r2]                                // Pickup the execute thread pointer
 8000374:	6813      	ldr	r3, [r2, #0]
    LDR     r0, =0xE000ED04                         // Build address of control register
 8000376:	480f      	ldr	r0, [pc, #60]	; (80003b4 <__tx_timer_nothing_expired+0x2e>)
    LDR     r2, =0x10000000                         // Build value for PendSV bit
 8000378:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    CMP     r1, r3                                  // Are they the same?
 800037c:	4299      	cmp	r1, r3
    BEQ     __tx_timer_skip_time_slice              // If the same, there was no time-slice performed
 800037e:	d000      	beq.n	8000382 <__tx_timer_not_ts_expiration>
    STR     r2, [r0]                                // Not the same, issue the PendSV for preemption
 8000380:	6002      	str	r2, [r0, #0]

08000382 <__tx_timer_not_ts_expiration>:

    // }

__tx_timer_not_ts_expiration:

    LDMIA   sp!, {r0, lr}                           // Recover lr register (r0 is just there for
 8000382:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

08000386 <__tx_timer_nothing_expired>:

    // }

__tx_timer_nothing_expired:

    DSB                                             // Complete all memory access
 8000386:	f3bf 8f4f 	dsb	sy
    BX      lr                                      // Return to caller
 800038a:	4770      	bx	lr
    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
 800038c:	20006da8 	.word	0x20006da8
    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
 8000390:	20007308 	.word	0x20007308
    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
 8000394:	20006dac 	.word	0x20006dac
    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
 8000398:	20006e38 	.word	0x20006e38
    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
 800039c:	20006e3c 	.word	0x20006e3c
    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
 80003a0:	20006e34 	.word	0x20006e34
    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
 80003a4:	20006e30 	.word	0x20006e30
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
 80003a8:	20006d9c 	.word	0x20006d9c
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
 80003ac:	20006d04 	.word	0x20006d04
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
 80003b0:	20006d08 	.word	0x20006d08
    LDR     r0, =0xE000ED04                         // Build address of control register
 80003b4:	e000ed04 	.word	0xe000ed04

080003b8 <strlen>:
 80003b8:	4603      	mov	r3, r0
 80003ba:	f813 2b01 	ldrb.w	r2, [r3], #1
 80003be:	2a00      	cmp	r2, #0
 80003c0:	d1fb      	bne.n	80003ba <strlen+0x2>
 80003c2:	1a18      	subs	r0, r3, r0
 80003c4:	3801      	subs	r0, #1
 80003c6:	4770      	bx	lr

080003c8 <__aeabi_uldivmod>:
 80003c8:	b953      	cbnz	r3, 80003e0 <__aeabi_uldivmod+0x18>
 80003ca:	b94a      	cbnz	r2, 80003e0 <__aeabi_uldivmod+0x18>
 80003cc:	2900      	cmp	r1, #0
 80003ce:	bf08      	it	eq
 80003d0:	2800      	cmpeq	r0, #0
 80003d2:	bf1c      	itt	ne
 80003d4:	f04f 31ff 	movne.w	r1, #4294967295
 80003d8:	f04f 30ff 	movne.w	r0, #4294967295
 80003dc:	f000 b970 	b.w	80006c0 <__aeabi_idiv0>
 80003e0:	f1ad 0c08 	sub.w	ip, sp, #8
 80003e4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80003e8:	f000 f806 	bl	80003f8 <__udivmoddi4>
 80003ec:	f8dd e004 	ldr.w	lr, [sp, #4]
 80003f0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80003f4:	b004      	add	sp, #16
 80003f6:	4770      	bx	lr

080003f8 <__udivmoddi4>:
 80003f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80003fc:	9e08      	ldr	r6, [sp, #32]
 80003fe:	460d      	mov	r5, r1
 8000400:	4604      	mov	r4, r0
 8000402:	460f      	mov	r7, r1
 8000404:	2b00      	cmp	r3, #0
 8000406:	d14a      	bne.n	800049e <__udivmoddi4+0xa6>
 8000408:	428a      	cmp	r2, r1
 800040a:	4694      	mov	ip, r2
 800040c:	d965      	bls.n	80004da <__udivmoddi4+0xe2>
 800040e:	fab2 f382 	clz	r3, r2
 8000412:	b143      	cbz	r3, 8000426 <__udivmoddi4+0x2e>
 8000414:	fa02 fc03 	lsl.w	ip, r2, r3
 8000418:	f1c3 0220 	rsb	r2, r3, #32
 800041c:	409f      	lsls	r7, r3
 800041e:	fa20 f202 	lsr.w	r2, r0, r2
 8000422:	4317      	orrs	r7, r2
 8000424:	409c      	lsls	r4, r3
 8000426:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 800042a:	fa1f f58c 	uxth.w	r5, ip
 800042e:	fbb7 f1fe 	udiv	r1, r7, lr
 8000432:	0c22      	lsrs	r2, r4, #16
 8000434:	fb0e 7711 	mls	r7, lr, r1, r7
 8000438:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 800043c:	fb01 f005 	mul.w	r0, r1, r5
 8000440:	4290      	cmp	r0, r2
 8000442:	d90a      	bls.n	800045a <__udivmoddi4+0x62>
 8000444:	eb1c 0202 	adds.w	r2, ip, r2
 8000448:	f101 37ff 	add.w	r7, r1, #4294967295
 800044c:	f080 811c 	bcs.w	8000688 <__udivmoddi4+0x290>
 8000450:	4290      	cmp	r0, r2
 8000452:	f240 8119 	bls.w	8000688 <__udivmoddi4+0x290>
 8000456:	3902      	subs	r1, #2
 8000458:	4462      	add	r2, ip
 800045a:	1a12      	subs	r2, r2, r0
 800045c:	b2a4      	uxth	r4, r4
 800045e:	fbb2 f0fe 	udiv	r0, r2, lr
 8000462:	fb0e 2210 	mls	r2, lr, r0, r2
 8000466:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 800046a:	fb00 f505 	mul.w	r5, r0, r5
 800046e:	42a5      	cmp	r5, r4
 8000470:	d90a      	bls.n	8000488 <__udivmoddi4+0x90>
 8000472:	eb1c 0404 	adds.w	r4, ip, r4
 8000476:	f100 32ff 	add.w	r2, r0, #4294967295
 800047a:	f080 8107 	bcs.w	800068c <__udivmoddi4+0x294>
 800047e:	42a5      	cmp	r5, r4
 8000480:	f240 8104 	bls.w	800068c <__udivmoddi4+0x294>
 8000484:	4464      	add	r4, ip
 8000486:	3802      	subs	r0, #2
 8000488:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 800048c:	1b64      	subs	r4, r4, r5
 800048e:	2100      	movs	r1, #0
 8000490:	b11e      	cbz	r6, 800049a <__udivmoddi4+0xa2>
 8000492:	40dc      	lsrs	r4, r3
 8000494:	2300      	movs	r3, #0
 8000496:	e9c6 4300 	strd	r4, r3, [r6]
 800049a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800049e:	428b      	cmp	r3, r1
 80004a0:	d908      	bls.n	80004b4 <__udivmoddi4+0xbc>
 80004a2:	2e00      	cmp	r6, #0
 80004a4:	f000 80ed 	beq.w	8000682 <__udivmoddi4+0x28a>
 80004a8:	2100      	movs	r1, #0
 80004aa:	e9c6 0500 	strd	r0, r5, [r6]
 80004ae:	4608      	mov	r0, r1
 80004b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80004b4:	fab3 f183 	clz	r1, r3
 80004b8:	2900      	cmp	r1, #0
 80004ba:	d149      	bne.n	8000550 <__udivmoddi4+0x158>
 80004bc:	42ab      	cmp	r3, r5
 80004be:	d302      	bcc.n	80004c6 <__udivmoddi4+0xce>
 80004c0:	4282      	cmp	r2, r0
 80004c2:	f200 80f8 	bhi.w	80006b6 <__udivmoddi4+0x2be>
 80004c6:	1a84      	subs	r4, r0, r2
 80004c8:	eb65 0203 	sbc.w	r2, r5, r3
 80004cc:	2001      	movs	r0, #1
 80004ce:	4617      	mov	r7, r2
 80004d0:	2e00      	cmp	r6, #0
 80004d2:	d0e2      	beq.n	800049a <__udivmoddi4+0xa2>
 80004d4:	e9c6 4700 	strd	r4, r7, [r6]
 80004d8:	e7df      	b.n	800049a <__udivmoddi4+0xa2>
 80004da:	b902      	cbnz	r2, 80004de <__udivmoddi4+0xe6>
 80004dc:	deff      	udf	#255	; 0xff
 80004de:	fab2 f382 	clz	r3, r2
 80004e2:	2b00      	cmp	r3, #0
 80004e4:	f040 8090 	bne.w	8000608 <__udivmoddi4+0x210>
 80004e8:	1a8a      	subs	r2, r1, r2
 80004ea:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80004ee:	fa1f fe8c 	uxth.w	lr, ip
 80004f2:	2101      	movs	r1, #1
 80004f4:	fbb2 f5f7 	udiv	r5, r2, r7
 80004f8:	fb07 2015 	mls	r0, r7, r5, r2
 80004fc:	0c22      	lsrs	r2, r4, #16
 80004fe:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8000502:	fb0e f005 	mul.w	r0, lr, r5
 8000506:	4290      	cmp	r0, r2
 8000508:	d908      	bls.n	800051c <__udivmoddi4+0x124>
 800050a:	eb1c 0202 	adds.w	r2, ip, r2
 800050e:	f105 38ff 	add.w	r8, r5, #4294967295
 8000512:	d202      	bcs.n	800051a <__udivmoddi4+0x122>
 8000514:	4290      	cmp	r0, r2
 8000516:	f200 80cb 	bhi.w	80006b0 <__udivmoddi4+0x2b8>
 800051a:	4645      	mov	r5, r8
 800051c:	1a12      	subs	r2, r2, r0
 800051e:	b2a4      	uxth	r4, r4
 8000520:	fbb2 f0f7 	udiv	r0, r2, r7
 8000524:	fb07 2210 	mls	r2, r7, r0, r2
 8000528:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 800052c:	fb0e fe00 	mul.w	lr, lr, r0
 8000530:	45a6      	cmp	lr, r4
 8000532:	d908      	bls.n	8000546 <__udivmoddi4+0x14e>
 8000534:	eb1c 0404 	adds.w	r4, ip, r4
 8000538:	f100 32ff 	add.w	r2, r0, #4294967295
 800053c:	d202      	bcs.n	8000544 <__udivmoddi4+0x14c>
 800053e:	45a6      	cmp	lr, r4
 8000540:	f200 80bb 	bhi.w	80006ba <__udivmoddi4+0x2c2>
 8000544:	4610      	mov	r0, r2
 8000546:	eba4 040e 	sub.w	r4, r4, lr
 800054a:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 800054e:	e79f      	b.n	8000490 <__udivmoddi4+0x98>
 8000550:	f1c1 0720 	rsb	r7, r1, #32
 8000554:	408b      	lsls	r3, r1
 8000556:	fa22 fc07 	lsr.w	ip, r2, r7
 800055a:	ea4c 0c03 	orr.w	ip, ip, r3
 800055e:	fa05 f401 	lsl.w	r4, r5, r1
 8000562:	fa20 f307 	lsr.w	r3, r0, r7
 8000566:	40fd      	lsrs	r5, r7
 8000568:	ea4f 491c 	mov.w	r9, ip, lsr #16
 800056c:	4323      	orrs	r3, r4
 800056e:	fbb5 f8f9 	udiv	r8, r5, r9
 8000572:	fa1f fe8c 	uxth.w	lr, ip
 8000576:	fb09 5518 	mls	r5, r9, r8, r5
 800057a:	0c1c      	lsrs	r4, r3, #16
 800057c:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000580:	fb08 f50e 	mul.w	r5, r8, lr
 8000584:	42a5      	cmp	r5, r4
 8000586:	fa02 f201 	lsl.w	r2, r2, r1
 800058a:	fa00 f001 	lsl.w	r0, r0, r1
 800058e:	d90b      	bls.n	80005a8 <__udivmoddi4+0x1b0>
 8000590:	eb1c 0404 	adds.w	r4, ip, r4
 8000594:	f108 3aff 	add.w	sl, r8, #4294967295
 8000598:	f080 8088 	bcs.w	80006ac <__udivmoddi4+0x2b4>
 800059c:	42a5      	cmp	r5, r4
 800059e:	f240 8085 	bls.w	80006ac <__udivmoddi4+0x2b4>
 80005a2:	f1a8 0802 	sub.w	r8, r8, #2
 80005a6:	4464      	add	r4, ip
 80005a8:	1b64      	subs	r4, r4, r5
 80005aa:	b29d      	uxth	r5, r3
 80005ac:	fbb4 f3f9 	udiv	r3, r4, r9
 80005b0:	fb09 4413 	mls	r4, r9, r3, r4
 80005b4:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 80005b8:	fb03 fe0e 	mul.w	lr, r3, lr
 80005bc:	45a6      	cmp	lr, r4
 80005be:	d908      	bls.n	80005d2 <__udivmoddi4+0x1da>
 80005c0:	eb1c 0404 	adds.w	r4, ip, r4
 80005c4:	f103 35ff 	add.w	r5, r3, #4294967295
 80005c8:	d26c      	bcs.n	80006a4 <__udivmoddi4+0x2ac>
 80005ca:	45a6      	cmp	lr, r4
 80005cc:	d96a      	bls.n	80006a4 <__udivmoddi4+0x2ac>
 80005ce:	3b02      	subs	r3, #2
 80005d0:	4464      	add	r4, ip
 80005d2:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80005d6:	fba3 9502 	umull	r9, r5, r3, r2
 80005da:	eba4 040e 	sub.w	r4, r4, lr
 80005de:	42ac      	cmp	r4, r5
 80005e0:	46c8      	mov	r8, r9
 80005e2:	46ae      	mov	lr, r5
 80005e4:	d356      	bcc.n	8000694 <__udivmoddi4+0x29c>
 80005e6:	d053      	beq.n	8000690 <__udivmoddi4+0x298>
 80005e8:	b156      	cbz	r6, 8000600 <__udivmoddi4+0x208>
 80005ea:	ebb0 0208 	subs.w	r2, r0, r8
 80005ee:	eb64 040e 	sbc.w	r4, r4, lr
 80005f2:	fa04 f707 	lsl.w	r7, r4, r7
 80005f6:	40ca      	lsrs	r2, r1
 80005f8:	40cc      	lsrs	r4, r1
 80005fa:	4317      	orrs	r7, r2
 80005fc:	e9c6 7400 	strd	r7, r4, [r6]
 8000600:	4618      	mov	r0, r3
 8000602:	2100      	movs	r1, #0
 8000604:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000608:	f1c3 0120 	rsb	r1, r3, #32
 800060c:	fa02 fc03 	lsl.w	ip, r2, r3
 8000610:	fa20 f201 	lsr.w	r2, r0, r1
 8000614:	fa25 f101 	lsr.w	r1, r5, r1
 8000618:	409d      	lsls	r5, r3
 800061a:	432a      	orrs	r2, r5
 800061c:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000620:	fa1f fe8c 	uxth.w	lr, ip
 8000624:	fbb1 f0f7 	udiv	r0, r1, r7
 8000628:	fb07 1510 	mls	r5, r7, r0, r1
 800062c:	0c11      	lsrs	r1, r2, #16
 800062e:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 8000632:	fb00 f50e 	mul.w	r5, r0, lr
 8000636:	428d      	cmp	r5, r1
 8000638:	fa04 f403 	lsl.w	r4, r4, r3
 800063c:	d908      	bls.n	8000650 <__udivmoddi4+0x258>
 800063e:	eb1c 0101 	adds.w	r1, ip, r1
 8000642:	f100 38ff 	add.w	r8, r0, #4294967295
 8000646:	d22f      	bcs.n	80006a8 <__udivmoddi4+0x2b0>
 8000648:	428d      	cmp	r5, r1
 800064a:	d92d      	bls.n	80006a8 <__udivmoddi4+0x2b0>
 800064c:	3802      	subs	r0, #2
 800064e:	4461      	add	r1, ip
 8000650:	1b49      	subs	r1, r1, r5
 8000652:	b292      	uxth	r2, r2
 8000654:	fbb1 f5f7 	udiv	r5, r1, r7
 8000658:	fb07 1115 	mls	r1, r7, r5, r1
 800065c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8000660:	fb05 f10e 	mul.w	r1, r5, lr
 8000664:	4291      	cmp	r1, r2
 8000666:	d908      	bls.n	800067a <__udivmoddi4+0x282>
 8000668:	eb1c 0202 	adds.w	r2, ip, r2
 800066c:	f105 38ff 	add.w	r8, r5, #4294967295
 8000670:	d216      	bcs.n	80006a0 <__udivmoddi4+0x2a8>
 8000672:	4291      	cmp	r1, r2
 8000674:	d914      	bls.n	80006a0 <__udivmoddi4+0x2a8>
 8000676:	3d02      	subs	r5, #2
 8000678:	4462      	add	r2, ip
 800067a:	1a52      	subs	r2, r2, r1
 800067c:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 8000680:	e738      	b.n	80004f4 <__udivmoddi4+0xfc>
 8000682:	4631      	mov	r1, r6
 8000684:	4630      	mov	r0, r6
 8000686:	e708      	b.n	800049a <__udivmoddi4+0xa2>
 8000688:	4639      	mov	r1, r7
 800068a:	e6e6      	b.n	800045a <__udivmoddi4+0x62>
 800068c:	4610      	mov	r0, r2
 800068e:	e6fb      	b.n	8000488 <__udivmoddi4+0x90>
 8000690:	4548      	cmp	r0, r9
 8000692:	d2a9      	bcs.n	80005e8 <__udivmoddi4+0x1f0>
 8000694:	ebb9 0802 	subs.w	r8, r9, r2
 8000698:	eb65 0e0c 	sbc.w	lr, r5, ip
 800069c:	3b01      	subs	r3, #1
 800069e:	e7a3      	b.n	80005e8 <__udivmoddi4+0x1f0>
 80006a0:	4645      	mov	r5, r8
 80006a2:	e7ea      	b.n	800067a <__udivmoddi4+0x282>
 80006a4:	462b      	mov	r3, r5
 80006a6:	e794      	b.n	80005d2 <__udivmoddi4+0x1da>
 80006a8:	4640      	mov	r0, r8
 80006aa:	e7d1      	b.n	8000650 <__udivmoddi4+0x258>
 80006ac:	46d0      	mov	r8, sl
 80006ae:	e77b      	b.n	80005a8 <__udivmoddi4+0x1b0>
 80006b0:	3d02      	subs	r5, #2
 80006b2:	4462      	add	r2, ip
 80006b4:	e732      	b.n	800051c <__udivmoddi4+0x124>
 80006b6:	4608      	mov	r0, r1
 80006b8:	e70a      	b.n	80004d0 <__udivmoddi4+0xd8>
 80006ba:	4464      	add	r4, ip
 80006bc:	3802      	subs	r0, #2
 80006be:	e742      	b.n	8000546 <__udivmoddi4+0x14e>

080006c0 <__aeabi_idiv0>:
 80006c0:	4770      	bx	lr
 80006c2:	bf00      	nop

080006c4 <tx_application_define>:
  * @brief  Define the initial system.
  * @param  first_unused_memory : Pointer to the first unused memory
  * @retval None
  */
VOID tx_application_define(VOID *first_unused_memory)
{
 80006c4:	b580      	push	{r7, lr}
 80006c6:	b084      	sub	sp, #16
 80006c8:	af00      	add	r7, sp, #0
 80006ca:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN  tx_application_define_1*/

  /* USER CODE END  tx_application_define_1 */
#if (USE_STATIC_ALLOCATION == 1)
  UINT status = TX_SUCCESS;
 80006cc:	2300      	movs	r3, #0
 80006ce:	60fb      	str	r3, [r7, #12]
  VOID *memory_ptr;

  if (tx_byte_pool_create(&tx_app_byte_pool, "Tx App memory pool", tx_byte_pool_buffer, TX_APP_MEM_POOL_SIZE) != TX_SUCCESS)
 80006d0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80006d4:	4a28      	ldr	r2, [pc, #160]	; (8000778 <tx_application_define+0xb4>)
 80006d6:	4929      	ldr	r1, [pc, #164]	; (800077c <tx_application_define+0xb8>)
 80006d8:	4829      	ldr	r0, [pc, #164]	; (8000780 <tx_application_define+0xbc>)
 80006da:	f00a ff6f 	bl	800b5bc <_tx_byte_pool_create>
 80006de:	4603      	mov	r3, r0
 80006e0:	2b00      	cmp	r3, #0
 80006e2:	d109      	bne.n	80006f8 <tx_application_define+0x34>
  {
    /* USER CODE BEGIN TX_Byte_Pool_Success */

    /* USER CODE END TX_Byte_Pool_Success */

    memory_ptr = (VOID *)&tx_app_byte_pool;
 80006e4:	4b26      	ldr	r3, [pc, #152]	; (8000780 <tx_application_define+0xbc>)
 80006e6:	60bb      	str	r3, [r7, #8]
    status = App_ThreadX_Init(memory_ptr);
 80006e8:	68b8      	ldr	r0, [r7, #8]
 80006ea:	f000 f963 	bl	80009b4 <App_ThreadX_Init>
 80006ee:	60f8      	str	r0, [r7, #12]
    if (status != TX_SUCCESS)
 80006f0:	68fb      	ldr	r3, [r7, #12]
 80006f2:	2b00      	cmp	r3, #0
 80006f4:	d000      	beq.n	80006f8 <tx_application_define+0x34>
    {
      /* USER CODE BEGIN  App_ThreadX_Init_Error */
      while(1)
 80006f6:	e7fe      	b.n	80006f6 <tx_application_define+0x32>

    /* USER CODE END  App_ThreadX_Init_Success */

  }

  if (tx_byte_pool_create(&fx_app_byte_pool, "Fx App memory pool", fx_byte_pool_buffer, FX_APP_MEM_POOL_SIZE) != TX_SUCCESS)
 80006f8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80006fc:	4a21      	ldr	r2, [pc, #132]	; (8000784 <tx_application_define+0xc0>)
 80006fe:	4922      	ldr	r1, [pc, #136]	; (8000788 <tx_application_define+0xc4>)
 8000700:	4822      	ldr	r0, [pc, #136]	; (800078c <tx_application_define+0xc8>)
 8000702:	f00a ff5b 	bl	800b5bc <_tx_byte_pool_create>
 8000706:	4603      	mov	r3, r0
 8000708:	2b00      	cmp	r3, #0
 800070a:	d109      	bne.n	8000720 <tx_application_define+0x5c>
  {
    /* USER CODE BEGIN FX_Byte_Pool_Success */

    /* USER CODE END FX_Byte_Pool_Success */

    memory_ptr = (VOID *)&fx_app_byte_pool;
 800070c:	4b1f      	ldr	r3, [pc, #124]	; (800078c <tx_application_define+0xc8>)
 800070e:	60bb      	str	r3, [r7, #8]
    status = MX_FileX_Init(memory_ptr);
 8000710:	68b8      	ldr	r0, [r7, #8]
 8000712:	f007 f971 	bl	80079f8 <MX_FileX_Init>
 8000716:	60f8      	str	r0, [r7, #12]
    if (status != FX_SUCCESS)
 8000718:	68fb      	ldr	r3, [r7, #12]
 800071a:	2b00      	cmp	r3, #0
 800071c:	d000      	beq.n	8000720 <tx_application_define+0x5c>
    {
      /* USER CODE BEGIN  MX_FileX_Init_Error */
      while(1)
 800071e:	e7fe      	b.n	800071e <tx_application_define+0x5a>
    /* USER CODE BEGIN MX_FileX_Init_Success */

    /* USER CODE END MX_FileX_Init_Success */
  }

  if (tx_byte_pool_create(&nx_app_byte_pool, "Nx App memory pool", nx_byte_pool_buffer, NX_APP_MEM_POOL_SIZE) != TX_SUCCESS)
 8000720:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8000724:	4a1a      	ldr	r2, [pc, #104]	; (8000790 <tx_application_define+0xcc>)
 8000726:	491b      	ldr	r1, [pc, #108]	; (8000794 <tx_application_define+0xd0>)
 8000728:	481b      	ldr	r0, [pc, #108]	; (8000798 <tx_application_define+0xd4>)
 800072a:	f00a ff47 	bl	800b5bc <_tx_byte_pool_create>
 800072e:	4603      	mov	r3, r0
 8000730:	2b00      	cmp	r3, #0
 8000732:	d109      	bne.n	8000748 <tx_application_define+0x84>
  {
    /* USER CODE BEGIN NX_Byte_Pool_Success */

    /* USER CODE END NX_Byte_Pool_Success */

    memory_ptr = (VOID *)&nx_app_byte_pool;
 8000734:	4b18      	ldr	r3, [pc, #96]	; (8000798 <tx_application_define+0xd4>)
 8000736:	60bb      	str	r3, [r7, #8]
    status = MX_NetXDuo_Init(memory_ptr);
 8000738:	68b8      	ldr	r0, [r7, #8]
 800073a:	f011 fc63 	bl	8012004 <MX_NetXDuo_Init>
 800073e:	60f8      	str	r0, [r7, #12]
    if (status != NX_SUCCESS)
 8000740:	68fb      	ldr	r3, [r7, #12]
 8000742:	2b00      	cmp	r3, #0
 8000744:	d000      	beq.n	8000748 <tx_application_define+0x84>
    {
      /* USER CODE BEGIN  MX_NetXDuo_Init_Error */
      while(1)
 8000746:	e7fe      	b.n	8000746 <tx_application_define+0x82>

    /* USER CODE END MX_NetXDuo_Init_Success */

  }

  if (tx_byte_pool_create(&ux_device_app_byte_pool, "Ux App memory pool", ux_device_byte_pool_buffer, UX_DEVICE_APP_MEM_POOL_SIZE) != TX_SUCCESS)
 8000748:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800074c:	4a13      	ldr	r2, [pc, #76]	; (800079c <tx_application_define+0xd8>)
 800074e:	4914      	ldr	r1, [pc, #80]	; (80007a0 <tx_application_define+0xdc>)
 8000750:	4814      	ldr	r0, [pc, #80]	; (80007a4 <tx_application_define+0xe0>)
 8000752:	f00a ff33 	bl	800b5bc <_tx_byte_pool_create>
 8000756:	4603      	mov	r3, r0
 8000758:	2b00      	cmp	r3, #0
 800075a:	d109      	bne.n	8000770 <tx_application_define+0xac>
  {
    /* USER CODE BEGIN UX_Device_Byte_Pool_Success */

    /* USER CODE END UX_Device_Byte_Pool_Success */

    memory_ptr = (VOID *)&ux_device_app_byte_pool;
 800075c:	4b11      	ldr	r3, [pc, #68]	; (80007a4 <tx_application_define+0xe0>)
 800075e:	60bb      	str	r3, [r7, #8]
    status = MX_USBX_Device_Init(memory_ptr);
 8000760:	68b8      	ldr	r0, [r7, #8]
 8000762:	f011 fc5f 	bl	8012024 <MX_USBX_Device_Init>
 8000766:	60f8      	str	r0, [r7, #12]
    if (status != UX_SUCCESS)
 8000768:	68fb      	ldr	r3, [r7, #12]
 800076a:	2b00      	cmp	r3, #0
 800076c:	d000      	beq.n	8000770 <tx_application_define+0xac>
    {
      /* USER CODE BEGIN  MX_USBX_Device_Init_Error */
      while(1)
 800076e:	e7fe      	b.n	800076e <tx_application_define+0xaa>
  /* USER CODE BEGIN DYNAMIC_MEM_ALLOC */
  (void)first_unused_memory;
  /* USER CODE END DYNAMIC_MEM_ALLOC */
#endif

}
 8000770:	bf00      	nop
 8000772:	3710      	adds	r7, #16
 8000774:	46bd      	mov	sp, r7
 8000776:	bd80      	pop	{r7, pc}
 8000778:	20000134 	.word	0x20000134
 800077c:	080132f4 	.word	0x080132f4
 8000780:	20000534 	.word	0x20000534
 8000784:	20000568 	.word	0x20000568
 8000788:	08013308 	.word	0x08013308
 800078c:	20000968 	.word	0x20000968
 8000790:	2000099c 	.word	0x2000099c
 8000794:	0801331c 	.word	0x0801331c
 8000798:	2000399c 	.word	0x2000399c
 800079c:	200039d0 	.word	0x200039d0
 80007a0:	08013330 	.word	0x08013330
 80007a4:	20003dd0 	.word	0x20003dd0

080007a8 <_ZN7GpioOutC1EP12GPIO_TypeDeftb>:
//	┗┛┣┛┗┗┛┗┛┗┻┗
//	  ┛         

GpioOut::GpioOut(GPIO_TypeDef *gpio, uint16_t pin) : gpio(gpio), pin(pin), inv(0) { }

GpioOut::GpioOut(GPIO_TypeDef *gpio, uint16_t pin, bool inv) : gpio(gpio), pin(pin), inv(inv ? pin : 0) { }
 80007a8:	b480      	push	{r7}
 80007aa:	b085      	sub	sp, #20
 80007ac:	af00      	add	r7, sp, #0
 80007ae:	60f8      	str	r0, [r7, #12]
 80007b0:	60b9      	str	r1, [r7, #8]
 80007b2:	4611      	mov	r1, r2
 80007b4:	461a      	mov	r2, r3
 80007b6:	460b      	mov	r3, r1
 80007b8:	80fb      	strh	r3, [r7, #6]
 80007ba:	4613      	mov	r3, r2
 80007bc:	717b      	strb	r3, [r7, #5]
 80007be:	68fb      	ldr	r3, [r7, #12]
 80007c0:	68ba      	ldr	r2, [r7, #8]
 80007c2:	601a      	str	r2, [r3, #0]
 80007c4:	68fb      	ldr	r3, [r7, #12]
 80007c6:	88fa      	ldrh	r2, [r7, #6]
 80007c8:	809a      	strh	r2, [r3, #4]
 80007ca:	797b      	ldrb	r3, [r7, #5]
 80007cc:	2b00      	cmp	r3, #0
 80007ce:	d001      	beq.n	80007d4 <_ZN7GpioOutC1EP12GPIO_TypeDeftb+0x2c>
 80007d0:	88fa      	ldrh	r2, [r7, #6]
 80007d2:	e000      	b.n	80007d6 <_ZN7GpioOutC1EP12GPIO_TypeDeftb+0x2e>
 80007d4:	2200      	movs	r2, #0
 80007d6:	68fb      	ldr	r3, [r7, #12]
 80007d8:	80da      	strh	r2, [r3, #6]
 80007da:	68fb      	ldr	r3, [r7, #12]
 80007dc:	4618      	mov	r0, r3
 80007de:	3714      	adds	r7, #20
 80007e0:	46bd      	mov	sp, r7
 80007e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007e6:	4770      	bx	lr

080007e8 <_Z41__static_initialization_and_destruction_0ii>:
	if(SpiDmaRequestHandler::requestCount() > 0)
	{
		SpiDmaRequestHandler::getRequest(request_buff);
		request_buff.cs->on();
	}
}
 80007e8:	b580      	push	{r7, lr}
 80007ea:	b084      	sub	sp, #16
 80007ec:	af02      	add	r7, sp, #8
 80007ee:	6078      	str	r0, [r7, #4]
 80007f0:	6039      	str	r1, [r7, #0]
 80007f2:	687b      	ldr	r3, [r7, #4]
 80007f4:	2b01      	cmp	r3, #1
 80007f6:	d11d      	bne.n	8000834 <_Z41__static_initialization_and_destruction_0ii+0x4c>
 80007f8:	683b      	ldr	r3, [r7, #0]
 80007fa:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80007fe:	4293      	cmp	r3, r2
 8000800:	d118      	bne.n	8000834 <_Z41__static_initialization_and_destruction_0ii+0x4c>
		static inline uint32_t queue_creation_status = tx_queue_create(&SpiDmaRequestHandler::queue, SpiDmaRequestHandler::queue_name, sizeof(SpiDmaRequest), SpiDmaRequestHandler::queue_data, sizeof(SpiDmaRequestHandler::queue_data));
 8000802:	4b0e      	ldr	r3, [pc, #56]	; (800083c <_Z41__static_initialization_and_destruction_0ii+0x54>)
 8000804:	681b      	ldr	r3, [r3, #0]
 8000806:	3301      	adds	r3, #1
 8000808:	4a0c      	ldr	r2, [pc, #48]	; (800083c <_Z41__static_initialization_and_destruction_0ii+0x54>)
 800080a:	6013      	str	r3, [r2, #0]
 800080c:	4b0b      	ldr	r3, [pc, #44]	; (800083c <_Z41__static_initialization_and_destruction_0ii+0x54>)
 800080e:	681b      	ldr	r3, [r3, #0]
 8000810:	2b01      	cmp	r3, #1
 8000812:	bf0c      	ite	eq
 8000814:	2301      	moveq	r3, #1
 8000816:	2300      	movne	r3, #0
 8000818:	b2db      	uxtb	r3, r3
 800081a:	2b00      	cmp	r3, #0
 800081c:	d00a      	beq.n	8000834 <_Z41__static_initialization_and_destruction_0ii+0x4c>
 800081e:	23a0      	movs	r3, #160	; 0xa0
 8000820:	9300      	str	r3, [sp, #0]
 8000822:	4b07      	ldr	r3, [pc, #28]	; (8000840 <_Z41__static_initialization_and_destruction_0ii+0x58>)
 8000824:	2214      	movs	r2, #20
 8000826:	4907      	ldr	r1, [pc, #28]	; (8000844 <_Z41__static_initialization_and_destruction_0ii+0x5c>)
 8000828:	4807      	ldr	r0, [pc, #28]	; (8000848 <_Z41__static_initialization_and_destruction_0ii+0x60>)
 800082a:	f00c fb5d 	bl	800cee8 <_tx_queue_create>
 800082e:	4603      	mov	r3, r0
 8000830:	4a06      	ldr	r2, [pc, #24]	; (800084c <_Z41__static_initialization_and_destruction_0ii+0x64>)
 8000832:	6013      	str	r3, [r2, #0]
}
 8000834:	bf00      	nop
 8000836:	3708      	adds	r7, #8
 8000838:	46bd      	mov	sp, r7
 800083a:	bd80      	pop	{r7, pc}
 800083c:	20003ee0 	.word	0x20003ee0
 8000840:	20003e3c 	.word	0x20003e3c
 8000844:	20000008 	.word	0x20000008
 8000848:	20003e04 	.word	0x20003e04
 800084c:	20003edc 	.word	0x20003edc

08000850 <_GLOBAL__sub_I__ZN13SpiDmaRequestC2EPhS0_jP7GpioOutPSt6atomicIbE>:
 8000850:	b580      	push	{r7, lr}
 8000852:	af00      	add	r7, sp, #0
 8000854:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8000858:	2001      	movs	r0, #1
 800085a:	f7ff ffc5 	bl	80007e8 <_Z41__static_initialization_and_destruction_0ii>
 800085e:	bd80      	pop	{r7, pc}

08000860 <LL_AHB2_GRP1_EnableClock>:
  *         @arg @ref LL_AHB2_GRP1_PERIPH_AES1 (*)
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
 8000860:	b480      	push	{r7}
 8000862:	b085      	sub	sp, #20
 8000864:	af00      	add	r7, sp, #0
 8000866:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB2ENR, Periphs);
 8000868:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800086c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800086e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000872:	687b      	ldr	r3, [r7, #4]
 8000874:	4313      	orrs	r3, r2
 8000876:	64cb      	str	r3, [r1, #76]	; 0x4c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8000878:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800087c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800087e:	687b      	ldr	r3, [r7, #4]
 8000880:	4013      	ands	r3, r2
 8000882:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8000884:	68fb      	ldr	r3, [r7, #12]
}
 8000886:	bf00      	nop
 8000888:	3714      	adds	r7, #20
 800088a:	46bd      	mov	sp, r7
 800088c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000890:	4770      	bx	lr
	...

08000894 <MX_ADC1_Init>:

ADC_HandleTypeDef hadc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 8000894:	b580      	push	{r7, lr}
 8000896:	b086      	sub	sp, #24
 8000898:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 800089a:	463b      	mov	r3, r7
 800089c:	2200      	movs	r2, #0
 800089e:	601a      	str	r2, [r3, #0]
 80008a0:	605a      	str	r2, [r3, #4]
 80008a2:	609a      	str	r2, [r3, #8]
 80008a4:	60da      	str	r2, [r3, #12]
 80008a6:	611a      	str	r2, [r3, #16]
 80008a8:	615a      	str	r2, [r3, #20]

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
 80008aa:	4b29      	ldr	r3, [pc, #164]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008ac:	4a29      	ldr	r2, [pc, #164]	; (8000954 <MX_ADC1_Init+0xc0>)
 80008ae:	601a      	str	r2, [r3, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 80008b0:	4b27      	ldr	r3, [pc, #156]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008b2:	2200      	movs	r2, #0
 80008b4:	605a      	str	r2, [r3, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 80008b6:	4b26      	ldr	r3, [pc, #152]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008b8:	2200      	movs	r2, #0
 80008ba:	609a      	str	r2, [r3, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 80008bc:	4b24      	ldr	r3, [pc, #144]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008be:	2200      	movs	r2, #0
 80008c0:	60da      	str	r2, [r3, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 80008c2:	4b23      	ldr	r3, [pc, #140]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008c4:	2200      	movs	r2, #0
 80008c6:	611a      	str	r2, [r3, #16]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 80008c8:	4b21      	ldr	r3, [pc, #132]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008ca:	2204      	movs	r2, #4
 80008cc:	615a      	str	r2, [r3, #20]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 80008ce:	4b20      	ldr	r3, [pc, #128]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008d0:	2200      	movs	r2, #0
 80008d2:	761a      	strb	r2, [r3, #24]
  hadc1.Init.ContinuousConvMode = DISABLE;
 80008d4:	4b1e      	ldr	r3, [pc, #120]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008d6:	2200      	movs	r2, #0
 80008d8:	765a      	strb	r2, [r3, #25]
  hadc1.Init.NbrOfConversion = 1;
 80008da:	4b1d      	ldr	r3, [pc, #116]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008dc:	2201      	movs	r2, #1
 80008de:	61da      	str	r2, [r3, #28]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 80008e0:	4b1b      	ldr	r3, [pc, #108]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008e2:	2200      	movs	r2, #0
 80008e4:	f883 2020 	strb.w	r2, [r3, #32]
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 80008e8:	4b19      	ldr	r3, [pc, #100]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008ea:	2200      	movs	r2, #0
 80008ec:	629a      	str	r2, [r3, #40]	; 0x28
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 80008ee:	4b18      	ldr	r3, [pc, #96]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008f0:	2200      	movs	r2, #0
 80008f2:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc1.Init.DMAContinuousRequests = DISABLE;
 80008f4:	4b16      	ldr	r3, [pc, #88]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008f6:	2200      	movs	r2, #0
 80008f8:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 80008fc:	4b14      	ldr	r3, [pc, #80]	; (8000950 <MX_ADC1_Init+0xbc>)
 80008fe:	2200      	movs	r2, #0
 8000900:	635a      	str	r2, [r3, #52]	; 0x34
  hadc1.Init.OversamplingMode = DISABLE;
 8000902:	4b13      	ldr	r3, [pc, #76]	; (8000950 <MX_ADC1_Init+0xbc>)
 8000904:	2200      	movs	r2, #0
 8000906:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 800090a:	4811      	ldr	r0, [pc, #68]	; (8000950 <MX_ADC1_Init+0xbc>)
 800090c:	f001 fdaa 	bl	8002464 <HAL_ADC_Init>
 8000910:	4603      	mov	r3, r0
 8000912:	2b00      	cmp	r3, #0
 8000914:	d001      	beq.n	800091a <MX_ADC1_Init+0x86>
  {
    Error_Handler();
 8000916:	f000 fce7 	bl	80012e8 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_3;
 800091a:	4b0f      	ldr	r3, [pc, #60]	; (8000958 <MX_ADC1_Init+0xc4>)
 800091c:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 800091e:	2306      	movs	r3, #6
 8000920:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
 8000922:	2300      	movs	r3, #0
 8000924:	60bb      	str	r3, [r7, #8]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000926:	237f      	movs	r3, #127	; 0x7f
 8000928:	60fb      	str	r3, [r7, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 800092a:	2304      	movs	r3, #4
 800092c:	613b      	str	r3, [r7, #16]
  sConfig.Offset = 0;
 800092e:	2300      	movs	r3, #0
 8000930:	617b      	str	r3, [r7, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000932:	463b      	mov	r3, r7
 8000934:	4619      	mov	r1, r3
 8000936:	4806      	ldr	r0, [pc, #24]	; (8000950 <MX_ADC1_Init+0xbc>)
 8000938:	f001 fee0 	bl	80026fc <HAL_ADC_ConfigChannel>
 800093c:	4603      	mov	r3, r0
 800093e:	2b00      	cmp	r3, #0
 8000940:	d001      	beq.n	8000946 <MX_ADC1_Init+0xb2>
  {
    Error_Handler();
 8000942:	f000 fcd1 	bl	80012e8 <Error_Handler>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
 8000946:	bf00      	nop
 8000948:	3718      	adds	r7, #24
 800094a:	46bd      	mov	sp, r7
 800094c:	bd80      	pop	{r7, pc}
 800094e:	bf00      	nop
 8000950:	20003ee4 	.word	0x20003ee4
 8000954:	50040000 	.word	0x50040000
 8000958:	0c900008 	.word	0x0c900008

0800095c <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 800095c:	b580      	push	{r7, lr}
 800095e:	b088      	sub	sp, #32
 8000960:	af00      	add	r7, sp, #0
 8000962:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000964:	f107 030c 	add.w	r3, r7, #12
 8000968:	2200      	movs	r2, #0
 800096a:	601a      	str	r2, [r3, #0]
 800096c:	605a      	str	r2, [r3, #4]
 800096e:	609a      	str	r2, [r3, #8]
 8000970:	60da      	str	r2, [r3, #12]
 8000972:	611a      	str	r2, [r3, #16]
  if(adcHandle->Instance==ADC1)
 8000974:	687b      	ldr	r3, [r7, #4]
 8000976:	681b      	ldr	r3, [r3, #0]
 8000978:	4a0c      	ldr	r2, [pc, #48]	; (80009ac <HAL_ADC_MspInit+0x50>)
 800097a:	4293      	cmp	r3, r2
 800097c:	d112      	bne.n	80009a4 <HAL_ADC_MspInit+0x48>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* ADC1 clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();
 800097e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8000982:	f7ff ff6d 	bl	8000860 <LL_AHB2_GRP1_EnableClock>

    __HAL_RCC_GPIOC_CLK_ENABLE();
 8000986:	2004      	movs	r0, #4
 8000988:	f7ff ff6a 	bl	8000860 <LL_AHB2_GRP1_EnableClock>
    /**ADC1 GPIO Configuration
    PC2     ------> ADC1_IN3
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 800098c:	2304      	movs	r3, #4
 800098e:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8000990:	2303      	movs	r3, #3
 8000992:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000994:	2300      	movs	r3, #0
 8000996:	617b      	str	r3, [r7, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000998:	f107 030c 	add.w	r3, r7, #12
 800099c:	4619      	mov	r1, r3
 800099e:	4804      	ldr	r0, [pc, #16]	; (80009b0 <HAL_ADC_MspInit+0x54>)
 80009a0:	f002 fd0e 	bl	80033c0 <HAL_GPIO_Init>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 80009a4:	bf00      	nop
 80009a6:	3720      	adds	r7, #32
 80009a8:	46bd      	mov	sp, r7
 80009aa:	bd80      	pop	{r7, pc}
 80009ac:	50040000 	.word	0x50040000
 80009b0:	48000800 	.word	0x48000800

080009b4 <App_ThreadX_Init>:
  * @brief  Application ThreadX Initialization.
  * @param memory_ptr: memory pointer
  * @retval int
  */
UINT App_ThreadX_Init(VOID *memory_ptr)
{
 80009b4:	b480      	push	{r7}
 80009b6:	b085      	sub	sp, #20
 80009b8:	af00      	add	r7, sp, #0
 80009ba:	6078      	str	r0, [r7, #4]
  UINT ret = TX_SUCCESS;
 80009bc:	2300      	movs	r3, #0
 80009be:	60fb      	str	r3, [r7, #12]

  /* USER CODE BEGIN App_ThreadX_Init */

  /* USER CODE END App_ThreadX_Init */

  return ret;
 80009c0:	68fb      	ldr	r3, [r7, #12]
}
 80009c2:	4618      	mov	r0, r3
 80009c4:	3714      	adds	r7, #20
 80009c6:	46bd      	mov	sp, r7
 80009c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80009cc:	4770      	bx	lr

080009ce <MX_ThreadX_Init>:
  * @brief  Function that implements the kernel's initialization.
  * @param  None
  * @retval None
  */
void MX_ThreadX_Init(void)
{
 80009ce:	b580      	push	{r7, lr}
 80009d0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN  Before_Kernel_Start */

  /* USER CODE END  Before_Kernel_Start */

  tx_kernel_enter();
 80009d2:	f00b fbfd 	bl	800c1d0 <_tx_initialize_kernel_enter>

  /* USER CODE BEGIN  Kernel_Start_Error */

  /* USER CODE END  Kernel_Start_Error */
}
 80009d6:	bf00      	nop
 80009d8:	bd80      	pop	{r7, pc}

080009da <LL_AHB1_GRP1_EnableClock>:
{
 80009da:	b480      	push	{r7}
 80009dc:	b085      	sub	sp, #20
 80009de:	af00      	add	r7, sp, #0
 80009e0:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 80009e2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80009e6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80009e8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80009ec:	687b      	ldr	r3, [r7, #4]
 80009ee:	4313      	orrs	r3, r2
 80009f0:	648b      	str	r3, [r1, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 80009f2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80009f6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80009f8:	687b      	ldr	r3, [r7, #4]
 80009fa:	4013      	ands	r3, r2
 80009fc:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 80009fe:	68fb      	ldr	r3, [r7, #12]
}
 8000a00:	bf00      	nop
 8000a02:	3714      	adds	r7, #20
 8000a04:	46bd      	mov	sp, r7
 8000a06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a0a:	4770      	bx	lr

08000a0c <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 8000a0c:	b580      	push	{r7, lr}
 8000a0e:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 8000a10:	2004      	movs	r0, #4
 8000a12:	f7ff ffe2 	bl	80009da <LL_AHB1_GRP1_EnableClock>
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000a16:	2001      	movs	r0, #1
 8000a18:	f7ff ffdf 	bl	80009da <LL_AHB1_GRP1_EnableClock>

  /* DMA interrupt init */
  /* DMA1_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 8000a1c:	2200      	movs	r2, #0
 8000a1e:	2100      	movs	r1, #0
 8000a20:	200b      	movs	r0, #11
 8000a22:	f002 fae9 	bl	8002ff8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 8000a26:	200b      	movs	r0, #11
 8000a28:	f002 fb00 	bl	800302c <HAL_NVIC_EnableIRQ>
  /* DMA1_Channel2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
 8000a2c:	2200      	movs	r2, #0
 8000a2e:	2100      	movs	r1, #0
 8000a30:	200c      	movs	r0, #12
 8000a32:	f002 fae1 	bl	8002ff8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
 8000a36:	200c      	movs	r0, #12
 8000a38:	f002 faf8 	bl	800302c <HAL_NVIC_EnableIRQ>

}
 8000a3c:	bf00      	nop
 8000a3e:	bd80      	pop	{r7, pc}

08000a40 <LL_AHB2_GRP1_EnableClock>:
{
 8000a40:	b480      	push	{r7}
 8000a42:	b085      	sub	sp, #20
 8000a44:	af00      	add	r7, sp, #0
 8000a46:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 8000a48:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000a4c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000a4e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000a52:	687b      	ldr	r3, [r7, #4]
 8000a54:	4313      	orrs	r3, r2
 8000a56:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8000a58:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000a5c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000a5e:	687b      	ldr	r3, [r7, #4]
 8000a60:	4013      	ands	r3, r2
 8000a62:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8000a64:	68fb      	ldr	r3, [r7, #12]
}
 8000a66:	bf00      	nop
 8000a68:	3714      	adds	r7, #20
 8000a6a:	46bd      	mov	sp, r7
 8000a6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a70:	4770      	bx	lr
	...

08000a74 <LL_SYSCFG_SetEXTISource>:
  *         @arg @ref LL_SYSCFG_EXTI_LINE14
  *         @arg @ref LL_SYSCFG_EXTI_LINE15
  * @retval None
  */
__STATIC_INLINE void LL_SYSCFG_SetEXTISource(uint32_t Port, uint32_t Line)
{
 8000a74:	b480      	push	{r7}
 8000a76:	b087      	sub	sp, #28
 8000a78:	af00      	add	r7, sp, #0
 8000a7a:	6078      	str	r0, [r7, #4]
 8000a7c:	6039      	str	r1, [r7, #0]
  MODIFY_REG(SYSCFG->EXTICR[Line & 0x03U], (Line >> 16U), (Port << ((POSITION_VAL((Line >> 16U))) & 0x0000000FUL)));
 8000a7e:	4a18      	ldr	r2, [pc, #96]	; (8000ae0 <LL_SYSCFG_SetEXTISource+0x6c>)
 8000a80:	683b      	ldr	r3, [r7, #0]
 8000a82:	f003 0303 	and.w	r3, r3, #3
 8000a86:	3302      	adds	r3, #2
 8000a88:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8000a8c:	683b      	ldr	r3, [r7, #0]
 8000a8e:	0c1b      	lsrs	r3, r3, #16
 8000a90:	43db      	mvns	r3, r3
 8000a92:	ea02 0103 	and.w	r1, r2, r3
 8000a96:	683b      	ldr	r3, [r7, #0]
 8000a98:	0c1b      	lsrs	r3, r3, #16
 8000a9a:	613b      	str	r3, [r7, #16]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000a9c:	693b      	ldr	r3, [r7, #16]
 8000a9e:	fa93 f3a3 	rbit	r3, r3
 8000aa2:	60fb      	str	r3, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 8000aa4:	68fb      	ldr	r3, [r7, #12]
 8000aa6:	617b      	str	r3, [r7, #20]
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 8000aa8:	697b      	ldr	r3, [r7, #20]
 8000aaa:	2b00      	cmp	r3, #0
 8000aac:	d101      	bne.n	8000ab2 <LL_SYSCFG_SetEXTISource+0x3e>
  {
    return 32U;
 8000aae:	2320      	movs	r3, #32
 8000ab0:	e003      	b.n	8000aba <LL_SYSCFG_SetEXTISource+0x46>
  }
  return __builtin_clz(value);
 8000ab2:	697b      	ldr	r3, [r7, #20]
 8000ab4:	fab3 f383 	clz	r3, r3
 8000ab8:	b2db      	uxtb	r3, r3
 8000aba:	f003 030f 	and.w	r3, r3, #15
 8000abe:	687a      	ldr	r2, [r7, #4]
 8000ac0:	409a      	lsls	r2, r3
 8000ac2:	4807      	ldr	r0, [pc, #28]	; (8000ae0 <LL_SYSCFG_SetEXTISource+0x6c>)
 8000ac4:	683b      	ldr	r3, [r7, #0]
 8000ac6:	f003 0303 	and.w	r3, r3, #3
 8000aca:	430a      	orrs	r2, r1
 8000acc:	3302      	adds	r3, #2
 8000ace:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
}
 8000ad2:	bf00      	nop
 8000ad4:	371c      	adds	r7, #28
 8000ad6:	46bd      	mov	sp, r7
 8000ad8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000adc:	4770      	bx	lr
 8000ade:	bf00      	nop
 8000ae0:	40010000 	.word	0x40010000

08000ae4 <LL_GPIO_SetPinMode>:
  *         @arg @ref LL_GPIO_MODE_ALTERNATE
  *         @arg @ref LL_GPIO_MODE_ANALOG
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
{
 8000ae4:	b480      	push	{r7}
 8000ae6:	b08b      	sub	sp, #44	; 0x2c
 8000ae8:	af00      	add	r7, sp, #0
 8000aea:	60f8      	str	r0, [r7, #12]
 8000aec:	60b9      	str	r1, [r7, #8]
 8000aee:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODE0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8000af0:	68fb      	ldr	r3, [r7, #12]
 8000af2:	681a      	ldr	r2, [r3, #0]
 8000af4:	68bb      	ldr	r3, [r7, #8]
 8000af6:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000af8:	697b      	ldr	r3, [r7, #20]
 8000afa:	fa93 f3a3 	rbit	r3, r3
 8000afe:	613b      	str	r3, [r7, #16]
  return result;
 8000b00:	693b      	ldr	r3, [r7, #16]
 8000b02:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8000b04:	69bb      	ldr	r3, [r7, #24]
 8000b06:	2b00      	cmp	r3, #0
 8000b08:	d101      	bne.n	8000b0e <LL_GPIO_SetPinMode+0x2a>
    return 32U;
 8000b0a:	2320      	movs	r3, #32
 8000b0c:	e003      	b.n	8000b16 <LL_GPIO_SetPinMode+0x32>
  return __builtin_clz(value);
 8000b0e:	69bb      	ldr	r3, [r7, #24]
 8000b10:	fab3 f383 	clz	r3, r3
 8000b14:	b2db      	uxtb	r3, r3
 8000b16:	005b      	lsls	r3, r3, #1
 8000b18:	2103      	movs	r1, #3
 8000b1a:	fa01 f303 	lsl.w	r3, r1, r3
 8000b1e:	43db      	mvns	r3, r3
 8000b20:	401a      	ands	r2, r3
 8000b22:	68bb      	ldr	r3, [r7, #8]
 8000b24:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000b26:	6a3b      	ldr	r3, [r7, #32]
 8000b28:	fa93 f3a3 	rbit	r3, r3
 8000b2c:	61fb      	str	r3, [r7, #28]
  return result;
 8000b2e:	69fb      	ldr	r3, [r7, #28]
 8000b30:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 8000b32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000b34:	2b00      	cmp	r3, #0
 8000b36:	d101      	bne.n	8000b3c <LL_GPIO_SetPinMode+0x58>
    return 32U;
 8000b38:	2320      	movs	r3, #32
 8000b3a:	e003      	b.n	8000b44 <LL_GPIO_SetPinMode+0x60>
  return __builtin_clz(value);
 8000b3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000b3e:	fab3 f383 	clz	r3, r3
 8000b42:	b2db      	uxtb	r3, r3
 8000b44:	005b      	lsls	r3, r3, #1
 8000b46:	6879      	ldr	r1, [r7, #4]
 8000b48:	fa01 f303 	lsl.w	r3, r1, r3
 8000b4c:	431a      	orrs	r2, r3
 8000b4e:	68fb      	ldr	r3, [r7, #12]
 8000b50:	601a      	str	r2, [r3, #0]
}
 8000b52:	bf00      	nop
 8000b54:	372c      	adds	r7, #44	; 0x2c
 8000b56:	46bd      	mov	sp, r7
 8000b58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b5c:	4770      	bx	lr

08000b5e <LL_GPIO_SetPinPull>:
  *         @arg @ref LL_GPIO_PULL_UP
  *         @arg @ref LL_GPIO_PULL_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
{
 8000b5e:	b480      	push	{r7}
 8000b60:	b08b      	sub	sp, #44	; 0x2c
 8000b62:	af00      	add	r7, sp, #0
 8000b64:	60f8      	str	r0, [r7, #12]
 8000b66:	60b9      	str	r1, [r7, #8]
 8000b68:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPD0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 8000b6a:	68fb      	ldr	r3, [r7, #12]
 8000b6c:	68da      	ldr	r2, [r3, #12]
 8000b6e:	68bb      	ldr	r3, [r7, #8]
 8000b70:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000b72:	697b      	ldr	r3, [r7, #20]
 8000b74:	fa93 f3a3 	rbit	r3, r3
 8000b78:	613b      	str	r3, [r7, #16]
  return result;
 8000b7a:	693b      	ldr	r3, [r7, #16]
 8000b7c:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8000b7e:	69bb      	ldr	r3, [r7, #24]
 8000b80:	2b00      	cmp	r3, #0
 8000b82:	d101      	bne.n	8000b88 <LL_GPIO_SetPinPull+0x2a>
    return 32U;
 8000b84:	2320      	movs	r3, #32
 8000b86:	e003      	b.n	8000b90 <LL_GPIO_SetPinPull+0x32>
  return __builtin_clz(value);
 8000b88:	69bb      	ldr	r3, [r7, #24]
 8000b8a:	fab3 f383 	clz	r3, r3
 8000b8e:	b2db      	uxtb	r3, r3
 8000b90:	005b      	lsls	r3, r3, #1
 8000b92:	2103      	movs	r1, #3
 8000b94:	fa01 f303 	lsl.w	r3, r1, r3
 8000b98:	43db      	mvns	r3, r3
 8000b9a:	401a      	ands	r2, r3
 8000b9c:	68bb      	ldr	r3, [r7, #8]
 8000b9e:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000ba0:	6a3b      	ldr	r3, [r7, #32]
 8000ba2:	fa93 f3a3 	rbit	r3, r3
 8000ba6:	61fb      	str	r3, [r7, #28]
  return result;
 8000ba8:	69fb      	ldr	r3, [r7, #28]
 8000baa:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 8000bac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000bae:	2b00      	cmp	r3, #0
 8000bb0:	d101      	bne.n	8000bb6 <LL_GPIO_SetPinPull+0x58>
    return 32U;
 8000bb2:	2320      	movs	r3, #32
 8000bb4:	e003      	b.n	8000bbe <LL_GPIO_SetPinPull+0x60>
  return __builtin_clz(value);
 8000bb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8000bb8:	fab3 f383 	clz	r3, r3
 8000bbc:	b2db      	uxtb	r3, r3
 8000bbe:	005b      	lsls	r3, r3, #1
 8000bc0:	6879      	ldr	r1, [r7, #4]
 8000bc2:	fa01 f303 	lsl.w	r3, r1, r3
 8000bc6:	431a      	orrs	r2, r3
 8000bc8:	68fb      	ldr	r3, [r7, #12]
 8000bca:	60da      	str	r2, [r3, #12]
}
 8000bcc:	bf00      	nop
 8000bce:	372c      	adds	r7, #44	; 0x2c
 8000bd0:	46bd      	mov	sp, r7
 8000bd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000bd6:	4770      	bx	lr

08000bd8 <LL_GPIO_ResetOutputPin>:
  *         @arg @ref LL_GPIO_PIN_15
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
 8000bd8:	b480      	push	{r7}
 8000bda:	b083      	sub	sp, #12
 8000bdc:	af00      	add	r7, sp, #0
 8000bde:	6078      	str	r0, [r7, #4]
 8000be0:	6039      	str	r1, [r7, #0]
  WRITE_REG(GPIOx->BRR, PinMask);
 8000be2:	687b      	ldr	r3, [r7, #4]
 8000be4:	683a      	ldr	r2, [r7, #0]
 8000be6:	629a      	str	r2, [r3, #40]	; 0x28
}
 8000be8:	bf00      	nop
 8000bea:	370c      	adds	r7, #12
 8000bec:	46bd      	mov	sp, r7
 8000bee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000bf2:	4770      	bx	lr

08000bf4 <MX_GPIO_Init>:
        * Free pins are configured automatically as Analog (this feature is enabled through
        * the Code Generation settings)
     PB14   ------> I2C3_SDA
*/
void MX_GPIO_Init(void)
{
 8000bf4:	b580      	push	{r7, lr}
 8000bf6:	b08a      	sub	sp, #40	; 0x28
 8000bf8:	af00      	add	r7, sp, #0

  LL_EXTI_InitTypeDef EXTI_InitStruct = {0};
 8000bfa:	f107 031c 	add.w	r3, r7, #28
 8000bfe:	2200      	movs	r2, #0
 8000c00:	601a      	str	r2, [r3, #0]
 8000c02:	605a      	str	r2, [r3, #4]
 8000c04:	609a      	str	r2, [r3, #8]
  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000c06:	1d3b      	adds	r3, r7, #4
 8000c08:	2200      	movs	r2, #0
 8000c0a:	601a      	str	r2, [r3, #0]
 8000c0c:	605a      	str	r2, [r3, #4]
 8000c0e:	609a      	str	r2, [r3, #8]
 8000c10:	60da      	str	r2, [r3, #12]
 8000c12:	611a      	str	r2, [r3, #16]
 8000c14:	615a      	str	r2, [r3, #20]

  /* GPIO Ports Clock Enable */
  LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOC);
 8000c16:	2004      	movs	r0, #4
 8000c18:	f7ff ff12 	bl	8000a40 <LL_AHB2_GRP1_EnableClock>
  LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOH);
 8000c1c:	2080      	movs	r0, #128	; 0x80
 8000c1e:	f7ff ff0f 	bl	8000a40 <LL_AHB2_GRP1_EnableClock>
  LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOB);
 8000c22:	2002      	movs	r0, #2
 8000c24:	f7ff ff0c 	bl	8000a40 <LL_AHB2_GRP1_EnableClock>
  LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOA);
 8000c28:	2001      	movs	r0, #1
 8000c2a:	f7ff ff09 	bl	8000a40 <LL_AHB2_GRP1_EnableClock>
  LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOE);
 8000c2e:	2010      	movs	r0, #16
 8000c30:	f7ff ff06 	bl	8000a40 <LL_AHB2_GRP1_EnableClock>
  LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOD);
 8000c34:	2008      	movs	r0, #8
 8000c36:	f7ff ff03 	bl	8000a40 <LL_AHB2_GRP1_EnableClock>

  /**/
  LL_GPIO_ResetOutputPin(GPIOA, LED1_Pin|LED2_Pin|M_LEFT_DIRECTION_Pin);
 8000c3a:	f240 2103 	movw	r1, #515	; 0x203
 8000c3e:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000c42:	f7ff ffc9 	bl	8000bd8 <LL_GPIO_ResetOutputPin>

  /**/
  LL_GPIO_ResetOutputPin(GPIOC, LED3_Pin|M_RIGHT_DIRECTION_Pin|SPI_EX_NCS1_Pin|SPI_EX_NCS2_Pin);
 8000c46:	f44f 6146 	mov.w	r1, #3168	; 0xc60
 8000c4a:	489d      	ldr	r0, [pc, #628]	; (8000ec0 <MX_GPIO_Init+0x2cc>)
 8000c4c:	f7ff ffc4 	bl	8000bd8 <LL_GPIO_ResetOutputPin>

  /**/
  LL_GPIO_ResetOutputPin(GPIOB, LED4_Pin|NM_SLEEP_Pin|SPI_IMU_NCS_Pin);
 8000c50:	2185      	movs	r1, #133	; 0x85
 8000c52:	489c      	ldr	r0, [pc, #624]	; (8000ec4 <MX_GPIO_Init+0x2d0>)
 8000c54:	f7ff ffc0 	bl	8000bd8 <LL_GPIO_ResetOutputPin>

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_13|LL_GPIO_PIN_14|LL_GPIO_PIN_15|LL_GPIO_PIN_1
 8000c58:	f24e 0312 	movw	r3, #57362	; 0xe012
 8000c5c:	607b      	str	r3, [r7, #4]
                          |LL_GPIO_PIN_4;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
 8000c5e:	2303      	movs	r3, #3
 8000c60:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000c62:	2300      	movs	r3, #0
 8000c64:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000c66:	1d3b      	adds	r3, r7, #4
 8000c68:	4619      	mov	r1, r3
 8000c6a:	4895      	ldr	r0, [pc, #596]	; (8000ec0 <MX_GPIO_Init+0x2cc>)
 8000c6c:	f006 f9cf 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_3;
 8000c70:	2308      	movs	r3, #8
 8000c72:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
 8000c74:	2303      	movs	r3, #3
 8000c76:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000c78:	2300      	movs	r3, #0
 8000c7a:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8000c7c:	1d3b      	adds	r3, r7, #4
 8000c7e:	4619      	mov	r1, r3
 8000c80:	4891      	ldr	r0, [pc, #580]	; (8000ec8 <MX_GPIO_Init+0x2d4>)
 8000c82:	f006 f9c4 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LED1_Pin|LED2_Pin;
 8000c86:	2303      	movs	r3, #3
 8000c88:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8000c8a:	2301      	movs	r3, #1
 8000c8c:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8000c8e:	2300      	movs	r3, #0
 8000c90:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
 8000c92:	2301      	movs	r3, #1
 8000c94:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000c96:	2300      	movs	r3, #0
 8000c98:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000c9a:	1d3b      	adds	r3, r7, #4
 8000c9c:	4619      	mov	r1, r3
 8000c9e:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000ca2:	f006 f9b4 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_4|LL_GPIO_PIN_5|LL_GPIO_PIN_15;
 8000ca6:	f248 0330 	movw	r3, #32816	; 0x8030
 8000caa:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
 8000cac:	2303      	movs	r3, #3
 8000cae:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000cb0:	2300      	movs	r3, #0
 8000cb2:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000cb4:	1d3b      	adds	r3, r7, #4
 8000cb6:	4619      	mov	r1, r3
 8000cb8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000cbc:	f006 f9a7 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = M_LEFT_DIRECTION_Pin;
 8000cc0:	f44f 7300 	mov.w	r3, #512	; 0x200
 8000cc4:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8000cc6:	2301      	movs	r3, #1
 8000cc8:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8000cca:	2300      	movs	r3, #0
 8000ccc:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8000cce:	2300      	movs	r3, #0
 8000cd0:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000cd2:	2300      	movs	r3, #0
 8000cd4:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(M_LEFT_DIRECTION_GPIO_Port, &GPIO_InitStruct);
 8000cd6:	1d3b      	adds	r3, r7, #4
 8000cd8:	4619      	mov	r1, r3
 8000cda:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8000cde:	f006 f996 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LED3_Pin;
 8000ce2:	2320      	movs	r3, #32
 8000ce4:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8000ce6:	2301      	movs	r3, #1
 8000ce8:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8000cea:	2300      	movs	r3, #0
 8000cec:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
 8000cee:	2301      	movs	r3, #1
 8000cf0:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000cf2:	2300      	movs	r3, #0
 8000cf4:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(LED3_GPIO_Port, &GPIO_InitStruct);
 8000cf6:	1d3b      	adds	r3, r7, #4
 8000cf8:	4619      	mov	r1, r3
 8000cfa:	4871      	ldr	r0, [pc, #452]	; (8000ec0 <MX_GPIO_Init+0x2cc>)
 8000cfc:	f006 f987 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LED4_Pin;
 8000d00:	2304      	movs	r3, #4
 8000d02:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8000d04:	2301      	movs	r3, #1
 8000d06:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8000d08:	2300      	movs	r3, #0
 8000d0a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
 8000d0c:	2301      	movs	r3, #1
 8000d0e:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000d10:	2300      	movs	r3, #0
 8000d12:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(LED4_GPIO_Port, &GPIO_InitStruct);
 8000d14:	1d3b      	adds	r3, r7, #4
 8000d16:	4619      	mov	r1, r3
 8000d18:	486a      	ldr	r0, [pc, #424]	; (8000ec4 <MX_GPIO_Init+0x2d0>)
 8000d1a:	f006 f978 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = NM_SLEEP_Pin|SPI_IMU_NCS_Pin;
 8000d1e:	2381      	movs	r3, #129	; 0x81
 8000d20:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8000d22:	2301      	movs	r3, #1
 8000d24:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8000d26:	2300      	movs	r3, #0
 8000d28:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8000d2a:	2300      	movs	r3, #0
 8000d2c:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000d2e:	2300      	movs	r3, #0
 8000d30:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000d32:	1d3b      	adds	r3, r7, #4
 8000d34:	4619      	mov	r1, r3
 8000d36:	4863      	ldr	r0, [pc, #396]	; (8000ec4 <MX_GPIO_Init+0x2d0>)
 8000d38:	f006 f969 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_12|LL_GPIO_PIN_13|LL_GPIO_PIN_15|LL_GPIO_PIN_6;
 8000d3c:	f24b 0340 	movw	r3, #45120	; 0xb040
 8000d40:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
 8000d42:	2303      	movs	r3, #3
 8000d44:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000d46:	2300      	movs	r3, #0
 8000d48:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000d4a:	1d3b      	adds	r3, r7, #4
 8000d4c:	4619      	mov	r1, r3
 8000d4e:	485d      	ldr	r0, [pc, #372]	; (8000ec4 <MX_GPIO_Init+0x2d0>)
 8000d50:	f006 f95d 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_14;
 8000d54:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8000d58:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8000d5a:	2302      	movs	r3, #2
 8000d5c:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8000d5e:	2300      	movs	r3, #0
 8000d60:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
 8000d62:	2301      	movs	r3, #1
 8000d64:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000d66:	2300      	movs	r3, #0
 8000d68:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_4;
 8000d6a:	2304      	movs	r3, #4
 8000d6c:	61bb      	str	r3, [r7, #24]
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000d6e:	1d3b      	adds	r3, r7, #4
 8000d70:	4619      	mov	r1, r3
 8000d72:	4854      	ldr	r0, [pc, #336]	; (8000ec4 <MX_GPIO_Init+0x2d0>)
 8000d74:	f006 f94b 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = M_RIGHT_DIRECTION_Pin|SPI_EX_NCS1_Pin|SPI_EX_NCS2_Pin;
 8000d78:	f44f 6344 	mov.w	r3, #3136	; 0xc40
 8000d7c:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
 8000d7e:	2301      	movs	r3, #1
 8000d80:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8000d82:	2300      	movs	r3, #0
 8000d84:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8000d86:	2300      	movs	r3, #0
 8000d88:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000d8a:	2300      	movs	r3, #0
 8000d8c:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000d8e:	1d3b      	adds	r3, r7, #4
 8000d90:	4619      	mov	r1, r3
 8000d92:	484b      	ldr	r0, [pc, #300]	; (8000ec0 <MX_GPIO_Init+0x2cc>)
 8000d94:	f006 f93b 	bl	800700e <LL_GPIO_Init>

  /**/
  GPIO_InitStruct.Pin = LL_GPIO_PIN_1;
 8000d98:	2302      	movs	r3, #2
 8000d9a:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
 8000d9c:	2303      	movs	r3, #3
 8000d9e:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8000da0:	2300      	movs	r3, #0
 8000da2:	617b      	str	r3, [r7, #20]
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8000da4:	1d3b      	adds	r3, r7, #4
 8000da6:	4619      	mov	r1, r3
 8000da8:	4848      	ldr	r0, [pc, #288]	; (8000ecc <MX_GPIO_Init+0x2d8>)
 8000daa:	f006 f930 	bl	800700e <LL_GPIO_Init>

  /**/
  LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTC, LL_SYSCFG_EXTI_LINE3);
 8000dae:	f04f 4170 	mov.w	r1, #4026531840	; 0xf0000000
 8000db2:	2002      	movs	r0, #2
 8000db4:	f7ff fe5e 	bl	8000a74 <LL_SYSCFG_SetEXTISource>

  /**/
  LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTE, LL_SYSCFG_EXTI_LINE4);
 8000db8:	4945      	ldr	r1, [pc, #276]	; (8000ed0 <MX_GPIO_Init+0x2dc>)
 8000dba:	2004      	movs	r0, #4
 8000dbc:	f7ff fe5a 	bl	8000a74 <LL_SYSCFG_SetEXTISource>

  /**/
  LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTC, LL_SYSCFG_EXTI_LINE12);
 8000dc0:	4944      	ldr	r1, [pc, #272]	; (8000ed4 <MX_GPIO_Init+0x2e0>)
 8000dc2:	2002      	movs	r0, #2
 8000dc4:	f7ff fe56 	bl	8000a74 <LL_SYSCFG_SetEXTISource>

  /**/
  LL_SYSCFG_SetEXTISource(LL_SYSCFG_EXTI_PORTD, LL_SYSCFG_EXTI_LINE0);
 8000dc8:	f44f 2170 	mov.w	r1, #983040	; 0xf0000
 8000dcc:	2003      	movs	r0, #3
 8000dce:	f7ff fe51 	bl	8000a74 <LL_SYSCFG_SetEXTISource>

  /**/
  EXTI_InitStruct.Line_0_31 = LL_EXTI_LINE_3;
 8000dd2:	2308      	movs	r3, #8
 8000dd4:	61fb      	str	r3, [r7, #28]
  EXTI_InitStruct.Line_32_63 = LL_EXTI_LINE_NONE;
 8000dd6:	2300      	movs	r3, #0
 8000dd8:	623b      	str	r3, [r7, #32]
  EXTI_InitStruct.LineCommand = ENABLE;
 8000dda:	2301      	movs	r3, #1
 8000ddc:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 8000de0:	2300      	movs	r3, #0
 8000de2:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
  EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_RISING;
 8000de6:	2301      	movs	r3, #1
 8000de8:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  LL_EXTI_Init(&EXTI_InitStruct);
 8000dec:	f107 031c 	add.w	r3, r7, #28
 8000df0:	4618      	mov	r0, r3
 8000df2:	f005 fed1 	bl	8006b98 <LL_EXTI_Init>

  /**/
  EXTI_InitStruct.Line_0_31 = LL_EXTI_LINE_4;
 8000df6:	2310      	movs	r3, #16
 8000df8:	61fb      	str	r3, [r7, #28]
  EXTI_InitStruct.Line_32_63 = LL_EXTI_LINE_NONE;
 8000dfa:	2300      	movs	r3, #0
 8000dfc:	623b      	str	r3, [r7, #32]
  EXTI_InitStruct.LineCommand = ENABLE;
 8000dfe:	2301      	movs	r3, #1
 8000e00:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 8000e04:	2300      	movs	r3, #0
 8000e06:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
  EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_RISING;
 8000e0a:	2301      	movs	r3, #1
 8000e0c:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  LL_EXTI_Init(&EXTI_InitStruct);
 8000e10:	f107 031c 	add.w	r3, r7, #28
 8000e14:	4618      	mov	r0, r3
 8000e16:	f005 febf 	bl	8006b98 <LL_EXTI_Init>

  /**/
  EXTI_InitStruct.Line_0_31 = LL_EXTI_LINE_12;
 8000e1a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000e1e:	61fb      	str	r3, [r7, #28]
  EXTI_InitStruct.Line_32_63 = LL_EXTI_LINE_NONE;
 8000e20:	2300      	movs	r3, #0
 8000e22:	623b      	str	r3, [r7, #32]
  EXTI_InitStruct.LineCommand = ENABLE;
 8000e24:	2301      	movs	r3, #1
 8000e26:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 8000e2a:	2300      	movs	r3, #0
 8000e2c:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
  EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_RISING;
 8000e30:	2301      	movs	r3, #1
 8000e32:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  LL_EXTI_Init(&EXTI_InitStruct);
 8000e36:	f107 031c 	add.w	r3, r7, #28
 8000e3a:	4618      	mov	r0, r3
 8000e3c:	f005 feac 	bl	8006b98 <LL_EXTI_Init>

  /**/
  EXTI_InitStruct.Line_0_31 = LL_EXTI_LINE_0;
 8000e40:	2301      	movs	r3, #1
 8000e42:	61fb      	str	r3, [r7, #28]
  EXTI_InitStruct.Line_32_63 = LL_EXTI_LINE_NONE;
 8000e44:	2300      	movs	r3, #0
 8000e46:	623b      	str	r3, [r7, #32]
  EXTI_InitStruct.LineCommand = ENABLE;
 8000e48:	2301      	movs	r3, #1
 8000e4a:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 8000e4e:	2300      	movs	r3, #0
 8000e50:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
  EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_RISING;
 8000e54:	2301      	movs	r3, #1
 8000e56:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  LL_EXTI_Init(&EXTI_InitStruct);
 8000e5a:	f107 031c 	add.w	r3, r7, #28
 8000e5e:	4618      	mov	r0, r3
 8000e60:	f005 fe9a 	bl	8006b98 <LL_EXTI_Init>

  /**/
  LL_GPIO_SetPinPull(IMU_INT1_GPIO_Port, IMU_INT1_Pin, LL_GPIO_PULL_NO);
 8000e64:	2200      	movs	r2, #0
 8000e66:	2108      	movs	r1, #8
 8000e68:	4815      	ldr	r0, [pc, #84]	; (8000ec0 <MX_GPIO_Init+0x2cc>)
 8000e6a:	f7ff fe78 	bl	8000b5e <LL_GPIO_SetPinPull>

  /**/
  LL_GPIO_SetPinPull(IMU_INT2_GPIO_Port, IMU_INT2_Pin, LL_GPIO_PULL_NO);
 8000e6e:	2200      	movs	r2, #0
 8000e70:	2110      	movs	r1, #16
 8000e72:	4819      	ldr	r0, [pc, #100]	; (8000ed8 <MX_GPIO_Init+0x2e4>)
 8000e74:	f7ff fe73 	bl	8000b5e <LL_GPIO_SetPinPull>

  /**/
  LL_GPIO_SetPinPull(SPI_EX_INT1_GPIO_Port, SPI_EX_INT1_Pin, LL_GPIO_PULL_NO);
 8000e78:	2200      	movs	r2, #0
 8000e7a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000e7e:	4810      	ldr	r0, [pc, #64]	; (8000ec0 <MX_GPIO_Init+0x2cc>)
 8000e80:	f7ff fe6d 	bl	8000b5e <LL_GPIO_SetPinPull>

  /**/
  LL_GPIO_SetPinPull(SPI_EX_INT2_GPIO_Port, SPI_EX_INT2_Pin, LL_GPIO_PULL_NO);
 8000e84:	2200      	movs	r2, #0
 8000e86:	2101      	movs	r1, #1
 8000e88:	4810      	ldr	r0, [pc, #64]	; (8000ecc <MX_GPIO_Init+0x2d8>)
 8000e8a:	f7ff fe68 	bl	8000b5e <LL_GPIO_SetPinPull>

  /**/
  LL_GPIO_SetPinMode(IMU_INT1_GPIO_Port, IMU_INT1_Pin, LL_GPIO_MODE_INPUT);
 8000e8e:	2200      	movs	r2, #0
 8000e90:	2108      	movs	r1, #8
 8000e92:	480b      	ldr	r0, [pc, #44]	; (8000ec0 <MX_GPIO_Init+0x2cc>)
 8000e94:	f7ff fe26 	bl	8000ae4 <LL_GPIO_SetPinMode>

  /**/
  LL_GPIO_SetPinMode(IMU_INT2_GPIO_Port, IMU_INT2_Pin, LL_GPIO_MODE_INPUT);
 8000e98:	2200      	movs	r2, #0
 8000e9a:	2110      	movs	r1, #16
 8000e9c:	480e      	ldr	r0, [pc, #56]	; (8000ed8 <MX_GPIO_Init+0x2e4>)
 8000e9e:	f7ff fe21 	bl	8000ae4 <LL_GPIO_SetPinMode>

  /**/
  LL_GPIO_SetPinMode(SPI_EX_INT1_GPIO_Port, SPI_EX_INT1_Pin, LL_GPIO_MODE_INPUT);
 8000ea2:	2200      	movs	r2, #0
 8000ea4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000ea8:	4805      	ldr	r0, [pc, #20]	; (8000ec0 <MX_GPIO_Init+0x2cc>)
 8000eaa:	f7ff fe1b 	bl	8000ae4 <LL_GPIO_SetPinMode>

  /**/
  LL_GPIO_SetPinMode(SPI_EX_INT2_GPIO_Port, SPI_EX_INT2_Pin, LL_GPIO_MODE_INPUT);
 8000eae:	2200      	movs	r2, #0
 8000eb0:	2101      	movs	r1, #1
 8000eb2:	4806      	ldr	r0, [pc, #24]	; (8000ecc <MX_GPIO_Init+0x2d8>)
 8000eb4:	f7ff fe16 	bl	8000ae4 <LL_GPIO_SetPinMode>

}
 8000eb8:	bf00      	nop
 8000eba:	3728      	adds	r7, #40	; 0x28
 8000ebc:	46bd      	mov	sp, r7
 8000ebe:	bd80      	pop	{r7, pc}
 8000ec0:	48000800 	.word	0x48000800
 8000ec4:	48000400 	.word	0x48000400
 8000ec8:	48001c00 	.word	0x48001c00
 8000ecc:	48000c00 	.word	0x48000c00
 8000ed0:	000f0001 	.word	0x000f0001
 8000ed4:	000f0003 	.word	0x000f0003
 8000ed8:	48001000 	.word	0x48001000

08000edc <LL_AHB2_GRP1_EnableClock>:
{
 8000edc:	b480      	push	{r7}
 8000ede:	b085      	sub	sp, #20
 8000ee0:	af00      	add	r7, sp, #0
 8000ee2:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 8000ee4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000ee8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000eea:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000eee:	687b      	ldr	r3, [r7, #4]
 8000ef0:	4313      	orrs	r3, r2
 8000ef2:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8000ef4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000ef8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000efa:	687b      	ldr	r3, [r7, #4]
 8000efc:	4013      	ands	r3, r2
 8000efe:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8000f00:	68fb      	ldr	r3, [r7, #12]
}
 8000f02:	bf00      	nop
 8000f04:	3714      	adds	r7, #20
 8000f06:	46bd      	mov	sp, r7
 8000f08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f0c:	4770      	bx	lr

08000f0e <LL_APB1_GRP1_EnableClock>:
  *         @arg @ref LL_APB1_GRP1_PERIPH_LPTIM1
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
 8000f0e:	b480      	push	{r7}
 8000f10:	b085      	sub	sp, #20
 8000f12:	af00      	add	r7, sp, #0
 8000f14:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR1, Periphs);
 8000f16:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000f1a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000f1c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000f20:	687b      	ldr	r3, [r7, #4]
 8000f22:	4313      	orrs	r3, r2
 8000f24:	658b      	str	r3, [r1, #88]	; 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8000f26:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000f2a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000f2c:	687b      	ldr	r3, [r7, #4]
 8000f2e:	4013      	ands	r3, r2
 8000f30:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8000f32:	68fb      	ldr	r3, [r7, #12]
}
 8000f34:	bf00      	nop
 8000f36:	3714      	adds	r7, #20
 8000f38:	46bd      	mov	sp, r7
 8000f3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f3e:	4770      	bx	lr

08000f40 <LL_APB1_GRP2_EnableClock>:
  *         @arg @ref LL_APB1_GRP2_PERIPH_LPTIM2
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
{
 8000f40:	b480      	push	{r7}
 8000f42:	b085      	sub	sp, #20
 8000f44:	af00      	add	r7, sp, #0
 8000f46:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR2, Periphs);
 8000f48:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000f4c:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8000f4e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8000f52:	687b      	ldr	r3, [r7, #4]
 8000f54:	4313      	orrs	r3, r2
 8000f56:	65cb      	str	r3, [r1, #92]	; 0x5c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR2, Periphs);
 8000f58:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000f5c:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8000f5e:	687b      	ldr	r3, [r7, #4]
 8000f60:	4013      	ands	r3, r2
 8000f62:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8000f64:	68fb      	ldr	r3, [r7, #12]
}
 8000f66:	bf00      	nop
 8000f68:	3714      	adds	r7, #20
 8000f6a:	46bd      	mov	sp, r7
 8000f6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f70:	4770      	bx	lr
	...

08000f74 <MX_LPTIM1_Init>:
LPTIM_HandleTypeDef hlptim1;
LPTIM_HandleTypeDef hlptim2;

/* LPTIM1 init function */
void MX_LPTIM1_Init(void)
{
 8000f74:	b580      	push	{r7, lr}
 8000f76:	af00      	add	r7, sp, #0
  /* USER CODE END LPTIM1_Init 0 */

  /* USER CODE BEGIN LPTIM1_Init 1 */

  /* USER CODE END LPTIM1_Init 1 */
  hlptim1.Instance = LPTIM1;
 8000f78:	4b16      	ldr	r3, [pc, #88]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000f7a:	4a17      	ldr	r2, [pc, #92]	; (8000fd8 <MX_LPTIM1_Init+0x64>)
 8000f7c:	601a      	str	r2, [r3, #0]
  hlptim1.Init.Clock.Source = LPTIM_CLOCKSOURCE_ULPTIM;
 8000f7e:	4b15      	ldr	r3, [pc, #84]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000f80:	2201      	movs	r2, #1
 8000f82:	605a      	str	r2, [r3, #4]
  hlptim1.Init.Clock.Prescaler = LPTIM_PRESCALER_DIV1;
 8000f84:	4b13      	ldr	r3, [pc, #76]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000f86:	2200      	movs	r2, #0
 8000f88:	609a      	str	r2, [r3, #8]
  hlptim1.Init.UltraLowPowerClock.Polarity = LPTIM_CLOCKPOLARITY_RISING;
 8000f8a:	4b12      	ldr	r3, [pc, #72]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000f8c:	2200      	movs	r2, #0
 8000f8e:	60da      	str	r2, [r3, #12]
  hlptim1.Init.UltraLowPowerClock.SampleTime = LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION;
 8000f90:	4b10      	ldr	r3, [pc, #64]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000f92:	2200      	movs	r2, #0
 8000f94:	611a      	str	r2, [r3, #16]
  hlptim1.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE;
 8000f96:	4b0f      	ldr	r3, [pc, #60]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000f98:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000f9c:	615a      	str	r2, [r3, #20]
  hlptim1.Init.OutputPolarity = LPTIM_OUTPUTPOLARITY_HIGH;
 8000f9e:	4b0d      	ldr	r3, [pc, #52]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000fa0:	2200      	movs	r2, #0
 8000fa2:	621a      	str	r2, [r3, #32]
  hlptim1.Init.UpdateMode = LPTIM_UPDATE_IMMEDIATE;
 8000fa4:	4b0b      	ldr	r3, [pc, #44]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000fa6:	2200      	movs	r2, #0
 8000fa8:	625a      	str	r2, [r3, #36]	; 0x24
  hlptim1.Init.CounterSource = LPTIM_COUNTERSOURCE_EXTERNAL;
 8000faa:	4b0a      	ldr	r3, [pc, #40]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000fac:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 8000fb0:	629a      	str	r2, [r3, #40]	; 0x28
  hlptim1.Init.Input1Source = LPTIM_INPUT1SOURCE_GPIO;
 8000fb2:	4b08      	ldr	r3, [pc, #32]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000fb4:	2200      	movs	r2, #0
 8000fb6:	62da      	str	r2, [r3, #44]	; 0x2c
  hlptim1.Init.Input2Source = LPTIM_INPUT2SOURCE_GPIO;
 8000fb8:	4b06      	ldr	r3, [pc, #24]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000fba:	2200      	movs	r2, #0
 8000fbc:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_LPTIM_Init(&hlptim1) != HAL_OK)
 8000fbe:	4805      	ldr	r0, [pc, #20]	; (8000fd4 <MX_LPTIM1_Init+0x60>)
 8000fc0:	f002 fb6e 	bl	80036a0 <HAL_LPTIM_Init>
 8000fc4:	4603      	mov	r3, r0
 8000fc6:	2b00      	cmp	r3, #0
 8000fc8:	d001      	beq.n	8000fce <MX_LPTIM1_Init+0x5a>
  {
    Error_Handler();
 8000fca:	f000 f98d 	bl	80012e8 <Error_Handler>
  }
  /* USER CODE BEGIN LPTIM1_Init 2 */

  /* USER CODE END LPTIM1_Init 2 */

}
 8000fce:	bf00      	nop
 8000fd0:	bd80      	pop	{r7, pc}
 8000fd2:	bf00      	nop
 8000fd4:	20003f48 	.word	0x20003f48
 8000fd8:	40007c00 	.word	0x40007c00

08000fdc <MX_LPTIM2_Init>:
/* LPTIM2 init function */
void MX_LPTIM2_Init(void)
{
 8000fdc:	b580      	push	{r7, lr}
 8000fde:	af00      	add	r7, sp, #0
  /* USER CODE END LPTIM2_Init 0 */

  /* USER CODE BEGIN LPTIM2_Init 1 */

  /* USER CODE END LPTIM2_Init 1 */
  hlptim2.Instance = LPTIM2;
 8000fe0:	4b16      	ldr	r3, [pc, #88]	; (800103c <MX_LPTIM2_Init+0x60>)
 8000fe2:	4a17      	ldr	r2, [pc, #92]	; (8001040 <MX_LPTIM2_Init+0x64>)
 8000fe4:	601a      	str	r2, [r3, #0]
  hlptim2.Init.Clock.Source = LPTIM_CLOCKSOURCE_ULPTIM;
 8000fe6:	4b15      	ldr	r3, [pc, #84]	; (800103c <MX_LPTIM2_Init+0x60>)
 8000fe8:	2201      	movs	r2, #1
 8000fea:	605a      	str	r2, [r3, #4]
  hlptim2.Init.Clock.Prescaler = LPTIM_PRESCALER_DIV1;
 8000fec:	4b13      	ldr	r3, [pc, #76]	; (800103c <MX_LPTIM2_Init+0x60>)
 8000fee:	2200      	movs	r2, #0
 8000ff0:	609a      	str	r2, [r3, #8]
  hlptim2.Init.UltraLowPowerClock.Polarity = LPTIM_CLOCKPOLARITY_RISING;
 8000ff2:	4b12      	ldr	r3, [pc, #72]	; (800103c <MX_LPTIM2_Init+0x60>)
 8000ff4:	2200      	movs	r2, #0
 8000ff6:	60da      	str	r2, [r3, #12]
  hlptim2.Init.UltraLowPowerClock.SampleTime = LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION;
 8000ff8:	4b10      	ldr	r3, [pc, #64]	; (800103c <MX_LPTIM2_Init+0x60>)
 8000ffa:	2200      	movs	r2, #0
 8000ffc:	611a      	str	r2, [r3, #16]
  hlptim2.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE;
 8000ffe:	4b0f      	ldr	r3, [pc, #60]	; (800103c <MX_LPTIM2_Init+0x60>)
 8001000:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001004:	615a      	str	r2, [r3, #20]
  hlptim2.Init.OutputPolarity = LPTIM_OUTPUTPOLARITY_HIGH;
 8001006:	4b0d      	ldr	r3, [pc, #52]	; (800103c <MX_LPTIM2_Init+0x60>)
 8001008:	2200      	movs	r2, #0
 800100a:	621a      	str	r2, [r3, #32]
  hlptim2.Init.UpdateMode = LPTIM_UPDATE_IMMEDIATE;
 800100c:	4b0b      	ldr	r3, [pc, #44]	; (800103c <MX_LPTIM2_Init+0x60>)
 800100e:	2200      	movs	r2, #0
 8001010:	625a      	str	r2, [r3, #36]	; 0x24
  hlptim2.Init.CounterSource = LPTIM_COUNTERSOURCE_EXTERNAL;
 8001012:	4b0a      	ldr	r3, [pc, #40]	; (800103c <MX_LPTIM2_Init+0x60>)
 8001014:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 8001018:	629a      	str	r2, [r3, #40]	; 0x28
  hlptim2.Init.Input1Source = LPTIM_INPUT1SOURCE_GPIO;
 800101a:	4b08      	ldr	r3, [pc, #32]	; (800103c <MX_LPTIM2_Init+0x60>)
 800101c:	2200      	movs	r2, #0
 800101e:	62da      	str	r2, [r3, #44]	; 0x2c
  hlptim2.Init.Input2Source = LPTIM_INPUT2SOURCE_GPIO;
 8001020:	4b06      	ldr	r3, [pc, #24]	; (800103c <MX_LPTIM2_Init+0x60>)
 8001022:	2200      	movs	r2, #0
 8001024:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_LPTIM_Init(&hlptim2) != HAL_OK)
 8001026:	4805      	ldr	r0, [pc, #20]	; (800103c <MX_LPTIM2_Init+0x60>)
 8001028:	f002 fb3a 	bl	80036a0 <HAL_LPTIM_Init>
 800102c:	4603      	mov	r3, r0
 800102e:	2b00      	cmp	r3, #0
 8001030:	d001      	beq.n	8001036 <MX_LPTIM2_Init+0x5a>
  {
    Error_Handler();
 8001032:	f000 f959 	bl	80012e8 <Error_Handler>
  }
  /* USER CODE BEGIN LPTIM2_Init 2 */

  /* USER CODE END LPTIM2_Init 2 */

}
 8001036:	bf00      	nop
 8001038:	bd80      	pop	{r7, pc}
 800103a:	bf00      	nop
 800103c:	20003f80 	.word	0x20003f80
 8001040:	40009400 	.word	0x40009400

08001044 <HAL_LPTIM_MspInit>:

void HAL_LPTIM_MspInit(LPTIM_HandleTypeDef* lptimHandle)
{
 8001044:	b580      	push	{r7, lr}
 8001046:	b09c      	sub	sp, #112	; 0x70
 8001048:	af00      	add	r7, sp, #0
 800104a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800104c:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8001050:	2200      	movs	r2, #0
 8001052:	601a      	str	r2, [r3, #0]
 8001054:	605a      	str	r2, [r3, #4]
 8001056:	609a      	str	r2, [r3, #8]
 8001058:	60da      	str	r2, [r3, #12]
 800105a:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800105c:	f107 030c 	add.w	r3, r7, #12
 8001060:	2250      	movs	r2, #80	; 0x50
 8001062:	2100      	movs	r1, #0
 8001064:	4618      	mov	r0, r3
 8001066:	f012 f8ff 	bl	8013268 <memset>
  if(lptimHandle->Instance==LPTIM1)
 800106a:	687b      	ldr	r3, [r7, #4]
 800106c:	681b      	ldr	r3, [r3, #0]
 800106e:	4a2c      	ldr	r2, [pc, #176]	; (8001120 <HAL_LPTIM_MspInit+0xdc>)
 8001070:	4293      	cmp	r3, r2
 8001072:	d126      	bne.n	80010c2 <HAL_LPTIM_MspInit+0x7e>

  /* USER CODE END LPTIM1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LPTIM1;
 8001074:	2310      	movs	r3, #16
 8001076:	60fb      	str	r3, [r7, #12]
    PeriphClkInitStruct.Lptim1ClockSelection = RCC_LPTIM1CLKSOURCE_PCLK1;
 8001078:	f44f 2340 	mov.w	r3, #786432	; 0xc0000
 800107c:	637b      	str	r3, [r7, #52]	; 0x34
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800107e:	f107 030c 	add.w	r3, r7, #12
 8001082:	4618      	mov	r0, r3
 8001084:	f004 f8f1 	bl	800526a <HAL_RCCEx_PeriphCLKConfig>
 8001088:	4603      	mov	r3, r0
 800108a:	2b00      	cmp	r3, #0
 800108c:	d001      	beq.n	8001092 <HAL_LPTIM_MspInit+0x4e>
    {
      Error_Handler();
 800108e:	f000 f92b 	bl	80012e8 <Error_Handler>
    }

    /* LPTIM1 clock enable */
    __HAL_RCC_LPTIM1_CLK_ENABLE();
 8001092:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 8001096:	f7ff ff3a 	bl	8000f0e <LL_APB1_GRP1_EnableClock>

    __HAL_RCC_GPIOC_CLK_ENABLE();
 800109a:	2004      	movs	r0, #4
 800109c:	f7ff ff1e 	bl	8000edc <LL_AHB2_GRP1_EnableClock>
    /**LPTIM1 GPIO Configuration
    PC0     ------> LPTIM1_IN1
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 80010a0:	2301      	movs	r3, #1
 80010a2:	65fb      	str	r3, [r7, #92]	; 0x5c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80010a4:	2302      	movs	r3, #2
 80010a6:	663b      	str	r3, [r7, #96]	; 0x60
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010a8:	2300      	movs	r3, #0
 80010aa:	667b      	str	r3, [r7, #100]	; 0x64
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80010ac:	2300      	movs	r3, #0
 80010ae:	66bb      	str	r3, [r7, #104]	; 0x68
    GPIO_InitStruct.Alternate = GPIO_AF1_LPTIM1;
 80010b0:	2301      	movs	r3, #1
 80010b2:	66fb      	str	r3, [r7, #108]	; 0x6c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80010b4:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 80010b8:	4619      	mov	r1, r3
 80010ba:	481a      	ldr	r0, [pc, #104]	; (8001124 <HAL_LPTIM_MspInit+0xe0>)
 80010bc:	f002 f980 	bl	80033c0 <HAL_GPIO_Init>

  /* USER CODE BEGIN LPTIM2_MspInit 1 */

  /* USER CODE END LPTIM2_MspInit 1 */
  }
}
 80010c0:	e029      	b.n	8001116 <HAL_LPTIM_MspInit+0xd2>
  else if(lptimHandle->Instance==LPTIM2)
 80010c2:	687b      	ldr	r3, [r7, #4]
 80010c4:	681b      	ldr	r3, [r3, #0]
 80010c6:	4a18      	ldr	r2, [pc, #96]	; (8001128 <HAL_LPTIM_MspInit+0xe4>)
 80010c8:	4293      	cmp	r3, r2
 80010ca:	d124      	bne.n	8001116 <HAL_LPTIM_MspInit+0xd2>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LPTIM2;
 80010cc:	2320      	movs	r3, #32
 80010ce:	60fb      	str	r3, [r7, #12]
    PeriphClkInitStruct.Lptim2ClockSelection = RCC_LPTIM2CLKSOURCE_PCLK;
 80010d0:	f44f 1340 	mov.w	r3, #3145728	; 0x300000
 80010d4:	63bb      	str	r3, [r7, #56]	; 0x38
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80010d6:	f107 030c 	add.w	r3, r7, #12
 80010da:	4618      	mov	r0, r3
 80010dc:	f004 f8c5 	bl	800526a <HAL_RCCEx_PeriphCLKConfig>
 80010e0:	4603      	mov	r3, r0
 80010e2:	2b00      	cmp	r3, #0
 80010e4:	d001      	beq.n	80010ea <HAL_LPTIM_MspInit+0xa6>
      Error_Handler();
 80010e6:	f000 f8ff 	bl	80012e8 <Error_Handler>
    __HAL_RCC_LPTIM2_CLK_ENABLE();
 80010ea:	2020      	movs	r0, #32
 80010ec:	f7ff ff28 	bl	8000f40 <LL_APB1_GRP2_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80010f0:	2002      	movs	r0, #2
 80010f2:	f7ff fef3 	bl	8000edc <LL_AHB2_GRP1_EnableClock>
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 80010f6:	2302      	movs	r3, #2
 80010f8:	65fb      	str	r3, [r7, #92]	; 0x5c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80010fa:	2302      	movs	r3, #2
 80010fc:	663b      	str	r3, [r7, #96]	; 0x60
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010fe:	2300      	movs	r3, #0
 8001100:	667b      	str	r3, [r7, #100]	; 0x64
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001102:	2300      	movs	r3, #0
 8001104:	66bb      	str	r3, [r7, #104]	; 0x68
    GPIO_InitStruct.Alternate = GPIO_AF14_LPTIM2;
 8001106:	230e      	movs	r3, #14
 8001108:	66fb      	str	r3, [r7, #108]	; 0x6c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800110a:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 800110e:	4619      	mov	r1, r3
 8001110:	4806      	ldr	r0, [pc, #24]	; (800112c <HAL_LPTIM_MspInit+0xe8>)
 8001112:	f002 f955 	bl	80033c0 <HAL_GPIO_Init>
}
 8001116:	bf00      	nop
 8001118:	3770      	adds	r7, #112	; 0x70
 800111a:	46bd      	mov	sp, r7
 800111c:	bd80      	pop	{r7, pc}
 800111e:	bf00      	nop
 8001120:	40007c00 	.word	0x40007c00
 8001124:	48000800 	.word	0x48000800
 8001128:	40009400 	.word	0x40009400
 800112c:	48000400 	.word	0x48000400

08001130 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8001130:	b580      	push	{r7, lr}
 8001132:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8001134:	f000 ffbe 	bl	80020b4 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8001138:	f000 f81c 	bl	8001174 <_Z18SystemClock_Configv>

/* Configure the peripherals common clocks */
  PeriphCommonClock_Config();
 800113c:	f000 f888 	bl	8001250 <_Z24PeriphCommonClock_Configv>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8001140:	f7ff fd58 	bl	8000bf4 <MX_GPIO_Init>
  MX_DMA_Init();
 8001144:	f7ff fc62 	bl	8000a0c <MX_DMA_Init>
  MX_TIM1_Init();
 8001148:	f000 fd60 	bl	8001c0c <MX_TIM1_Init>
  MX_USB_PCD_Init();
 800114c:	f000 ff20 	bl	8001f90 <MX_USB_PCD_Init>
  MX_LPTIM1_Init();
 8001150:	f7ff ff10 	bl	8000f74 <MX_LPTIM1_Init>
  MX_ADC1_Init();
 8001154:	f7ff fb9e 	bl	8000894 <MX_ADC1_Init>
  MX_LPTIM2_Init();
 8001158:	f7ff ff40 	bl	8000fdc <MX_LPTIM2_Init>
  MX_QUADSPI_Init();
 800115c:	f000 f93c 	bl	80013d8 <MX_QUADSPI_Init>
  MX_SPI1_Init();
 8001160:	f000 f9e0 	bl	8001524 <MX_SPI1_Init>
  MX_LPUART1_UART_Init();
 8001164:	f000 fe4e 	bl	8001e04 <MX_LPUART1_UART_Init>
  MX_RF_Init();
 8001168:	f000 f9a2 	bl	80014b0 <MX_RF_Init>
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  MX_ThreadX_Init();
 800116c:	f7ff fc2f 	bl	80009ce <MX_ThreadX_Init>

  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8001170:	e7fe      	b.n	8001170 <main+0x40>
	...

08001174 <_Z18SystemClock_Configv>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8001174:	b580      	push	{r7, lr}
 8001176:	b09a      	sub	sp, #104	; 0x68
 8001178:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800117a:	f107 0320 	add.w	r3, r7, #32
 800117e:	2248      	movs	r2, #72	; 0x48
 8001180:	2100      	movs	r1, #0
 8001182:	4618      	mov	r0, r3
 8001184:	f012 f870 	bl	8013268 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8001188:	1d3b      	adds	r3, r7, #4
 800118a:	2200      	movs	r2, #0
 800118c:	601a      	str	r2, [r3, #0]
 800118e:	605a      	str	r2, [r3, #4]
 8001190:	609a      	str	r2, [r3, #8]
 8001192:	60da      	str	r2, [r3, #12]
 8001194:	611a      	str	r2, [r3, #16]
 8001196:	615a      	str	r2, [r3, #20]
 8001198:	619a      	str	r2, [r3, #24]

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800119a:	4b2c      	ldr	r3, [pc, #176]	; (800124c <_Z18SystemClock_Configv+0xd8>)
 800119c:	681b      	ldr	r3, [r3, #0]
 800119e:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80011a2:	4a2a      	ldr	r2, [pc, #168]	; (800124c <_Z18SystemClock_Configv+0xd8>)
 80011a4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80011a8:	6013      	str	r3, [r2, #0]
 80011aa:	4b28      	ldr	r3, [pc, #160]	; (800124c <_Z18SystemClock_Configv+0xd8>)
 80011ac:	681b      	ldr	r3, [r3, #0]
 80011ae:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 80011b2:	603b      	str	r3, [r7, #0]
 80011b4:	683b      	ldr	r3, [r7, #0]

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
 80011b6:	2303      	movs	r3, #3
 80011b8:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80011ba:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80011be:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80011c0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80011c4:	62fb      	str	r3, [r7, #44]	; 0x2c
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 80011c6:	2340      	movs	r3, #64	; 0x40
 80011c8:	633b      	str	r3, [r7, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80011ca:	2302      	movs	r3, #2
 80011cc:	64fb      	str	r3, [r7, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80011ce:	2303      	movs	r3, #3
 80011d0:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV2;
 80011d2:	2310      	movs	r3, #16
 80011d4:	657b      	str	r3, [r7, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLN = 8;
 80011d6:	2308      	movs	r3, #8
 80011d8:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80011da:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80011de:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 80011e0:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 80011e4:	667b      	str	r3, [r7, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 80011e6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80011ea:	663b      	str	r3, [r7, #96]	; 0x60
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80011ec:	f107 0320 	add.w	r3, r7, #32
 80011f0:	4618      	mov	r0, r3
 80011f2:	f003 f857 	bl	80042a4 <HAL_RCC_OscConfig>
 80011f6:	4603      	mov	r3, r0
 80011f8:	2b00      	cmp	r3, #0
 80011fa:	bf14      	ite	ne
 80011fc:	2301      	movne	r3, #1
 80011fe:	2300      	moveq	r3, #0
 8001200:	b2db      	uxtb	r3, r3
 8001202:	2b00      	cmp	r3, #0
 8001204:	d001      	beq.n	800120a <_Z18SystemClock_Configv+0x96>
  {
    Error_Handler();
 8001206:	f000 f86f 	bl	80012e8 <Error_Handler>
  }

  /** Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK4|RCC_CLOCKTYPE_HCLK2
 800120a:	236f      	movs	r3, #111	; 0x6f
 800120c:	607b      	str	r3, [r7, #4]
                              |RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800120e:	2303      	movs	r3, #3
 8001210:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8001212:	2300      	movs	r3, #0
 8001214:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8001216:	2300      	movs	r3, #0
 8001218:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800121a:	2300      	movs	r3, #0
 800121c:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.AHBCLK2Divider = RCC_SYSCLK_DIV2;
 800121e:	2380      	movs	r3, #128	; 0x80
 8001220:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.AHBCLK4Divider = RCC_SYSCLK_DIV1;
 8001222:	2300      	movs	r3, #0
 8001224:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 8001226:	1d3b      	adds	r3, r7, #4
 8001228:	2103      	movs	r1, #3
 800122a:	4618      	mov	r0, r3
 800122c:	f003 fbae 	bl	800498c <HAL_RCC_ClockConfig>
 8001230:	4603      	mov	r3, r0
 8001232:	2b00      	cmp	r3, #0
 8001234:	bf14      	ite	ne
 8001236:	2301      	movne	r3, #1
 8001238:	2300      	moveq	r3, #0
 800123a:	b2db      	uxtb	r3, r3
 800123c:	2b00      	cmp	r3, #0
 800123e:	d001      	beq.n	8001244 <_Z18SystemClock_Configv+0xd0>
  {
    Error_Handler();
 8001240:	f000 f852 	bl	80012e8 <Error_Handler>
  }
}
 8001244:	bf00      	nop
 8001246:	3768      	adds	r7, #104	; 0x68
 8001248:	46bd      	mov	sp, r7
 800124a:	bd80      	pop	{r7, pc}
 800124c:	58000400 	.word	0x58000400

08001250 <_Z24PeriphCommonClock_Configv>:
/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
 8001250:	b580      	push	{r7, lr}
 8001252:	b094      	sub	sp, #80	; 0x50
 8001254:	af00      	add	r7, sp, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001256:	463b      	mov	r3, r7
 8001258:	2250      	movs	r2, #80	; 0x50
 800125a:	2100      	movs	r1, #0
 800125c:	4618      	mov	r0, r3
 800125e:	f012 f803 	bl	8013268 <memset>

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS|RCC_PERIPHCLK_RFWAKEUP
 8001262:	f44f 5354 	mov.w	r3, #13568	; 0x3500
 8001266:	603b      	str	r3, [r7, #0]
                              |RCC_PERIPHCLK_USB|RCC_PERIPHCLK_ADC;
  PeriphClkInitStruct.PLLSAI1.PLLN = 6;
 8001268:	2306      	movs	r3, #6
 800126a:	607b      	str	r3, [r7, #4]
  PeriphClkInitStruct.PLLSAI1.PLLP = RCC_PLLP_DIV2;
 800126c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001270:	60bb      	str	r3, [r7, #8]
  PeriphClkInitStruct.PLLSAI1.PLLQ = RCC_PLLQ_DIV2;
 8001272:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8001276:	60fb      	str	r3, [r7, #12]
  PeriphClkInitStruct.PLLSAI1.PLLR = RCC_PLLR_DIV2;
 8001278:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 800127c:	613b      	str	r3, [r7, #16]
  PeriphClkInitStruct.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_USBCLK|RCC_PLLSAI1_ADCCLK;
 800127e:	f04f 5388 	mov.w	r3, #285212672	; 0x11000000
 8001282:	617b      	str	r3, [r7, #20]
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 8001284:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 8001288:	637b      	str	r3, [r7, #52]	; 0x34
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 800128a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 800128e:	63fb      	str	r3, [r7, #60]	; 0x3c
  PeriphClkInitStruct.RFWakeUpClockSelection = RCC_RFWKPCLKSOURCE_HSE_DIV1024;
 8001290:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8001294:	647b      	str	r3, [r7, #68]	; 0x44
  PeriphClkInitStruct.SmpsClockSelection = RCC_SMPSCLKSOURCE_HSI;
 8001296:	2300      	movs	r3, #0
 8001298:	64bb      	str	r3, [r7, #72]	; 0x48
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLKDIV_RANGE1;
 800129a:	2310      	movs	r3, #16
 800129c:	64fb      	str	r3, [r7, #76]	; 0x4c

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800129e:	463b      	mov	r3, r7
 80012a0:	4618      	mov	r0, r3
 80012a2:	f003 ffe2 	bl	800526a <HAL_RCCEx_PeriphCLKConfig>
 80012a6:	4603      	mov	r3, r0
 80012a8:	2b00      	cmp	r3, #0
 80012aa:	bf14      	ite	ne
 80012ac:	2301      	movne	r3, #1
 80012ae:	2300      	moveq	r3, #0
 80012b0:	b2db      	uxtb	r3, r3
 80012b2:	2b00      	cmp	r3, #0
 80012b4:	d001      	beq.n	80012ba <_Z24PeriphCommonClock_Configv+0x6a>
  {
    Error_Handler();
 80012b6:	f000 f817 	bl	80012e8 <Error_Handler>
  }
  /* USER CODE BEGIN Smps */

  /* USER CODE END Smps */
}
 80012ba:	bf00      	nop
 80012bc:	3750      	adds	r7, #80	; 0x50
 80012be:	46bd      	mov	sp, r7
 80012c0:	bd80      	pop	{r7, pc}
	...

080012c4 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 80012c4:	b580      	push	{r7, lr}
 80012c6:	b082      	sub	sp, #8
 80012c8:	af00      	add	r7, sp, #0
 80012ca:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM17) {
 80012cc:	687b      	ldr	r3, [r7, #4]
 80012ce:	681b      	ldr	r3, [r3, #0]
 80012d0:	4a04      	ldr	r2, [pc, #16]	; (80012e4 <HAL_TIM_PeriodElapsedCallback+0x20>)
 80012d2:	4293      	cmp	r3, r2
 80012d4:	d101      	bne.n	80012da <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
 80012d6:	f000 ff0d 	bl	80020f4 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 80012da:	bf00      	nop
 80012dc:	3708      	adds	r7, #8
 80012de:	46bd      	mov	sp, r7
 80012e0:	bd80      	pop	{r7, pc}
 80012e2:	bf00      	nop
 80012e4:	40014800 	.word	0x40014800

080012e8 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80012e8:	b480      	push	{r7}
 80012ea:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 80012ec:	b672      	cpsid	i
}
 80012ee:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80012f0:	e7fe      	b.n	80012f0 <Error_Handler+0x8>
	...

080012f4 <_Z41__static_initialization_and_destruction_0ii>:
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
 80012f4:	b580      	push	{r7, lr}
 80012f6:	b082      	sub	sp, #8
 80012f8:	af00      	add	r7, sp, #0
 80012fa:	6078      	str	r0, [r7, #4]
 80012fc:	6039      	str	r1, [r7, #0]
 80012fe:	687b      	ldr	r3, [r7, #4]
 8001300:	2b01      	cmp	r3, #1
 8001302:	d11e      	bne.n	8001342 <_Z41__static_initialization_and_destruction_0ii+0x4e>
 8001304:	683b      	ldr	r3, [r7, #0]
 8001306:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800130a:	4293      	cmp	r3, r2
 800130c:	d119      	bne.n	8001342 <_Z41__static_initialization_and_destruction_0ii+0x4e>
GpioOut LED1 { LED1_GPIO_Port, LED1_Pin, true };
 800130e:	2301      	movs	r3, #1
 8001310:	2201      	movs	r2, #1
 8001312:	f04f 4190 	mov.w	r1, #1207959552	; 0x48000000
 8001316:	480d      	ldr	r0, [pc, #52]	; (800134c <_Z41__static_initialization_and_destruction_0ii+0x58>)
 8001318:	f7ff fa46 	bl	80007a8 <_ZN7GpioOutC1EP12GPIO_TypeDeftb>
GpioOut LED2 { LED2_GPIO_Port, LED2_Pin, true };
 800131c:	2301      	movs	r3, #1
 800131e:	2202      	movs	r2, #2
 8001320:	f04f 4190 	mov.w	r1, #1207959552	; 0x48000000
 8001324:	480a      	ldr	r0, [pc, #40]	; (8001350 <_Z41__static_initialization_and_destruction_0ii+0x5c>)
 8001326:	f7ff fa3f 	bl	80007a8 <_ZN7GpioOutC1EP12GPIO_TypeDeftb>
GpioOut LED3 { LED3_GPIO_Port, LED3_Pin, true };
 800132a:	2301      	movs	r3, #1
 800132c:	2220      	movs	r2, #32
 800132e:	4909      	ldr	r1, [pc, #36]	; (8001354 <_Z41__static_initialization_and_destruction_0ii+0x60>)
 8001330:	4809      	ldr	r0, [pc, #36]	; (8001358 <_Z41__static_initialization_and_destruction_0ii+0x64>)
 8001332:	f7ff fa39 	bl	80007a8 <_ZN7GpioOutC1EP12GPIO_TypeDeftb>
GpioOut LED4 { LED4_GPIO_Port, LED4_Pin, true };
 8001336:	2301      	movs	r3, #1
 8001338:	2204      	movs	r2, #4
 800133a:	4908      	ldr	r1, [pc, #32]	; (800135c <_Z41__static_initialization_and_destruction_0ii+0x68>)
 800133c:	4808      	ldr	r0, [pc, #32]	; (8001360 <_Z41__static_initialization_and_destruction_0ii+0x6c>)
 800133e:	f7ff fa33 	bl	80007a8 <_ZN7GpioOutC1EP12GPIO_TypeDeftb>
}
 8001342:	bf00      	nop
 8001344:	3708      	adds	r7, #8
 8001346:	46bd      	mov	sp, r7
 8001348:	bd80      	pop	{r7, pc}
 800134a:	bf00      	nop
 800134c:	20003fb8 	.word	0x20003fb8
 8001350:	20003fc0 	.word	0x20003fc0
 8001354:	48000800 	.word	0x48000800
 8001358:	20003fc8 	.word	0x20003fc8
 800135c:	48000400 	.word	0x48000400
 8001360:	20003fd0 	.word	0x20003fd0

08001364 <_GLOBAL__sub_I_LED1>:
 8001364:	b580      	push	{r7, lr}
 8001366:	af00      	add	r7, sp, #0
 8001368:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800136c:	2001      	movs	r0, #1
 800136e:	f7ff ffc1 	bl	80012f4 <_Z41__static_initialization_and_destruction_0ii>
 8001372:	bd80      	pop	{r7, pc}

08001374 <LL_AHB2_GRP1_EnableClock>:
{
 8001374:	b480      	push	{r7}
 8001376:	b085      	sub	sp, #20
 8001378:	af00      	add	r7, sp, #0
 800137a:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800137c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001380:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001382:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001386:	687b      	ldr	r3, [r7, #4]
 8001388:	4313      	orrs	r3, r2
 800138a:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800138c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001390:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001392:	687b      	ldr	r3, [r7, #4]
 8001394:	4013      	ands	r3, r2
 8001396:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8001398:	68fb      	ldr	r3, [r7, #12]
}
 800139a:	bf00      	nop
 800139c:	3714      	adds	r7, #20
 800139e:	46bd      	mov	sp, r7
 80013a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80013a4:	4770      	bx	lr

080013a6 <LL_AHB3_GRP1_EnableClock>:
{
 80013a6:	b480      	push	{r7}
 80013a8:	b085      	sub	sp, #20
 80013aa:	af00      	add	r7, sp, #0
 80013ac:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB3ENR, Periphs);
 80013ae:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80013b2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80013b4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80013b8:	687b      	ldr	r3, [r7, #4]
 80013ba:	4313      	orrs	r3, r2
 80013bc:	650b      	str	r3, [r1, #80]	; 0x50
  tmpreg = READ_BIT(RCC->AHB3ENR, Periphs);
 80013be:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80013c2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80013c4:	687b      	ldr	r3, [r7, #4]
 80013c6:	4013      	ands	r3, r2
 80013c8:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 80013ca:	68fb      	ldr	r3, [r7, #12]
}
 80013cc:	bf00      	nop
 80013ce:	3714      	adds	r7, #20
 80013d0:	46bd      	mov	sp, r7
 80013d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80013d6:	4770      	bx	lr

080013d8 <MX_QUADSPI_Init>:

QSPI_HandleTypeDef hqspi;

/* QUADSPI init function */
void MX_QUADSPI_Init(void)
{
 80013d8:	b580      	push	{r7, lr}
 80013da:	af00      	add	r7, sp, #0
  /* USER CODE END QUADSPI_Init 0 */

  /* USER CODE BEGIN QUADSPI_Init 1 */

  /* USER CODE END QUADSPI_Init 1 */
  hqspi.Instance = QUADSPI;
 80013dc:	4b0f      	ldr	r3, [pc, #60]	; (800141c <MX_QUADSPI_Init+0x44>)
 80013de:	4a10      	ldr	r2, [pc, #64]	; (8001420 <MX_QUADSPI_Init+0x48>)
 80013e0:	601a      	str	r2, [r3, #0]
  hqspi.Init.ClockPrescaler = 255;
 80013e2:	4b0e      	ldr	r3, [pc, #56]	; (800141c <MX_QUADSPI_Init+0x44>)
 80013e4:	22ff      	movs	r2, #255	; 0xff
 80013e6:	605a      	str	r2, [r3, #4]
  hqspi.Init.FifoThreshold = 1;
 80013e8:	4b0c      	ldr	r3, [pc, #48]	; (800141c <MX_QUADSPI_Init+0x44>)
 80013ea:	2201      	movs	r2, #1
 80013ec:	609a      	str	r2, [r3, #8]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
 80013ee:	4b0b      	ldr	r3, [pc, #44]	; (800141c <MX_QUADSPI_Init+0x44>)
 80013f0:	2200      	movs	r2, #0
 80013f2:	60da      	str	r2, [r3, #12]
  hqspi.Init.FlashSize = 1;
 80013f4:	4b09      	ldr	r3, [pc, #36]	; (800141c <MX_QUADSPI_Init+0x44>)
 80013f6:	2201      	movs	r2, #1
 80013f8:	611a      	str	r2, [r3, #16]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
 80013fa:	4b08      	ldr	r3, [pc, #32]	; (800141c <MX_QUADSPI_Init+0x44>)
 80013fc:	2200      	movs	r2, #0
 80013fe:	615a      	str	r2, [r3, #20]
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
 8001400:	4b06      	ldr	r3, [pc, #24]	; (800141c <MX_QUADSPI_Init+0x44>)
 8001402:	2200      	movs	r2, #0
 8001404:	619a      	str	r2, [r3, #24]
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
 8001406:	4805      	ldr	r0, [pc, #20]	; (800141c <MX_QUADSPI_Init+0x44>)
 8001408:	f002 fb0e 	bl	8003a28 <HAL_QSPI_Init>
 800140c:	4603      	mov	r3, r0
 800140e:	2b00      	cmp	r3, #0
 8001410:	d001      	beq.n	8001416 <MX_QUADSPI_Init+0x3e>
  {
    Error_Handler();
 8001412:	f7ff ff69 	bl	80012e8 <Error_Handler>
  }
  /* USER CODE BEGIN QUADSPI_Init 2 */

  /* USER CODE END QUADSPI_Init 2 */

}
 8001416:	bf00      	nop
 8001418:	bd80      	pop	{r7, pc}
 800141a:	bf00      	nop
 800141c:	20003fd8 	.word	0x20003fd8
 8001420:	a0001000 	.word	0xa0001000

08001424 <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
 8001424:	b580      	push	{r7, lr}
 8001426:	b088      	sub	sp, #32
 8001428:	af00      	add	r7, sp, #0
 800142a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800142c:	f107 030c 	add.w	r3, r7, #12
 8001430:	2200      	movs	r2, #0
 8001432:	601a      	str	r2, [r3, #0]
 8001434:	605a      	str	r2, [r3, #4]
 8001436:	609a      	str	r2, [r3, #8]
 8001438:	60da      	str	r2, [r3, #12]
 800143a:	611a      	str	r2, [r3, #16]
  if(qspiHandle->Instance==QUADSPI)
 800143c:	687b      	ldr	r3, [r7, #4]
 800143e:	681b      	ldr	r3, [r3, #0]
 8001440:	4a19      	ldr	r2, [pc, #100]	; (80014a8 <HAL_QSPI_MspInit+0x84>)
 8001442:	4293      	cmp	r3, r2
 8001444:	d12b      	bne.n	800149e <HAL_QSPI_MspInit+0x7a>
  {
  /* USER CODE BEGIN QUADSPI_MspInit 0 */

  /* USER CODE END QUADSPI_MspInit 0 */
    /* QUADSPI clock enable */
    __HAL_RCC_QSPI_CLK_ENABLE();
 8001446:	f44f 7080 	mov.w	r0, #256	; 0x100
 800144a:	f7ff ffac 	bl	80013a6 <LL_AHB3_GRP1_EnableClock>

    __HAL_RCC_GPIOB_CLK_ENABLE();
 800144e:	2002      	movs	r0, #2
 8001450:	f7ff ff90 	bl	8001374 <LL_AHB2_GRP1_EnableClock>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001454:	2001      	movs	r0, #1
 8001456:	f7ff ff8d 	bl	8001374 <LL_AHB2_GRP1_EnableClock>
    PA2     ------> QUADSPI_BK1_NCS
    PA3     ------> QUADSPI_CLK
    PA6     ------> QUADSPI_BK1_IO3
    PA7     ------> QUADSPI_BK1_IO2
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 800145a:	f44f 7340 	mov.w	r3, #768	; 0x300
 800145e:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001460:	2302      	movs	r3, #2
 8001462:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001464:	2300      	movs	r3, #0
 8001466:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001468:	2303      	movs	r3, #3
 800146a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 800146c:	230a      	movs	r3, #10
 800146e:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001470:	f107 030c 	add.w	r3, r7, #12
 8001474:	4619      	mov	r1, r3
 8001476:	480d      	ldr	r0, [pc, #52]	; (80014ac <HAL_QSPI_MspInit+0x88>)
 8001478:	f001 ffa2 	bl	80033c0 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_6|GPIO_PIN_7;
 800147c:	23cc      	movs	r3, #204	; 0xcc
 800147e:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001480:	2302      	movs	r3, #2
 8001482:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001484:	2300      	movs	r3, #0
 8001486:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001488:	2303      	movs	r3, #3
 800148a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 800148c:	230a      	movs	r3, #10
 800148e:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001490:	f107 030c 	add.w	r3, r7, #12
 8001494:	4619      	mov	r1, r3
 8001496:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800149a:	f001 ff91 	bl	80033c0 <HAL_GPIO_Init>

  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
 800149e:	bf00      	nop
 80014a0:	3720      	adds	r7, #32
 80014a2:	46bd      	mov	sp, r7
 80014a4:	bd80      	pop	{r7, pc}
 80014a6:	bf00      	nop
 80014a8:	a0001000 	.word	0xa0001000
 80014ac:	48000400 	.word	0x48000400

080014b0 <MX_RF_Init>:

/* USER CODE END 0 */

/* RF init function */
void MX_RF_Init(void)
{
 80014b0:	b480      	push	{r7}
 80014b2:	af00      	add	r7, sp, #0
  /* USER CODE END RF_Init 1 */
  /* USER CODE BEGIN RF_Init 2 */

  /* USER CODE END RF_Init 2 */

}
 80014b4:	bf00      	nop
 80014b6:	46bd      	mov	sp, r7
 80014b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014bc:	4770      	bx	lr

080014be <LL_AHB2_GRP1_EnableClock>:
{
 80014be:	b480      	push	{r7}
 80014c0:	b085      	sub	sp, #20
 80014c2:	af00      	add	r7, sp, #0
 80014c4:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 80014c6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80014ca:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80014cc:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80014d0:	687b      	ldr	r3, [r7, #4]
 80014d2:	4313      	orrs	r3, r2
 80014d4:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 80014d6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80014da:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80014dc:	687b      	ldr	r3, [r7, #4]
 80014de:	4013      	ands	r3, r2
 80014e0:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 80014e2:	68fb      	ldr	r3, [r7, #12]
}
 80014e4:	bf00      	nop
 80014e6:	3714      	adds	r7, #20
 80014e8:	46bd      	mov	sp, r7
 80014ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014ee:	4770      	bx	lr

080014f0 <LL_APB2_GRP1_EnableClock>:
  *         @arg @ref LL_APB2_GRP1_PERIPH_SAI1 (*)
  * @note  (*) Not supported by all the devices
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
 80014f0:	b480      	push	{r7}
 80014f2:	b085      	sub	sp, #20
 80014f4:	af00      	add	r7, sp, #0
 80014f6:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 80014f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80014fc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80014fe:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001502:	687b      	ldr	r3, [r7, #4]
 8001504:	4313      	orrs	r3, r2
 8001506:	660b      	str	r3, [r1, #96]	; 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 8001508:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800150c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800150e:	687b      	ldr	r3, [r7, #4]
 8001510:	4013      	ands	r3, r2
 8001512:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8001514:	68fb      	ldr	r3, [r7, #12]
}
 8001516:	bf00      	nop
 8001518:	3714      	adds	r7, #20
 800151a:	46bd      	mov	sp, r7
 800151c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001520:	4770      	bx	lr
	...

08001524 <MX_SPI1_Init>:
DMA_HandleTypeDef hdma_spi1_rx;
DMA_HandleTypeDef hdma_spi1_tx;

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 8001524:	b580      	push	{r7, lr}
 8001526:	af00      	add	r7, sp, #0
  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  hspi1.Instance = SPI1;
 8001528:	4b1b      	ldr	r3, [pc, #108]	; (8001598 <MX_SPI1_Init+0x74>)
 800152a:	4a1c      	ldr	r2, [pc, #112]	; (800159c <MX_SPI1_Init+0x78>)
 800152c:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 800152e:	4b1a      	ldr	r3, [pc, #104]	; (8001598 <MX_SPI1_Init+0x74>)
 8001530:	f44f 7282 	mov.w	r2, #260	; 0x104
 8001534:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8001536:	4b18      	ldr	r3, [pc, #96]	; (8001598 <MX_SPI1_Init+0x74>)
 8001538:	2200      	movs	r2, #0
 800153a:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 800153c:	4b16      	ldr	r3, [pc, #88]	; (8001598 <MX_SPI1_Init+0x74>)
 800153e:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 8001542:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8001544:	4b14      	ldr	r3, [pc, #80]	; (8001598 <MX_SPI1_Init+0x74>)
 8001546:	2200      	movs	r2, #0
 8001548:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 800154a:	4b13      	ldr	r3, [pc, #76]	; (8001598 <MX_SPI1_Init+0x74>)
 800154c:	2200      	movs	r2, #0
 800154e:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8001550:	4b11      	ldr	r3, [pc, #68]	; (8001598 <MX_SPI1_Init+0x74>)
 8001552:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001556:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 8001558:	4b0f      	ldr	r3, [pc, #60]	; (8001598 <MX_SPI1_Init+0x74>)
 800155a:	2210      	movs	r2, #16
 800155c:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800155e:	4b0e      	ldr	r3, [pc, #56]	; (8001598 <MX_SPI1_Init+0x74>)
 8001560:	2200      	movs	r2, #0
 8001562:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8001564:	4b0c      	ldr	r3, [pc, #48]	; (8001598 <MX_SPI1_Init+0x74>)
 8001566:	2200      	movs	r2, #0
 8001568:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800156a:	4b0b      	ldr	r3, [pc, #44]	; (8001598 <MX_SPI1_Init+0x74>)
 800156c:	2200      	movs	r2, #0
 800156e:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 8001570:	4b09      	ldr	r3, [pc, #36]	; (8001598 <MX_SPI1_Init+0x74>)
 8001572:	2207      	movs	r2, #7
 8001574:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8001576:	4b08      	ldr	r3, [pc, #32]	; (8001598 <MX_SPI1_Init+0x74>)
 8001578:	2200      	movs	r2, #0
 800157a:	631a      	str	r2, [r3, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 800157c:	4b06      	ldr	r3, [pc, #24]	; (8001598 <MX_SPI1_Init+0x74>)
 800157e:	2208      	movs	r2, #8
 8001580:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8001582:	4805      	ldr	r0, [pc, #20]	; (8001598 <MX_SPI1_Init+0x74>)
 8001584:	f004 f8f8 	bl	8005778 <HAL_SPI_Init>
 8001588:	4603      	mov	r3, r0
 800158a:	2b00      	cmp	r3, #0
 800158c:	d001      	beq.n	8001592 <MX_SPI1_Init+0x6e>
  {
    Error_Handler();
 800158e:	f7ff feab 	bl	80012e8 <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 8001592:	bf00      	nop
 8001594:	bd80      	pop	{r7, pc}
 8001596:	bf00      	nop
 8001598:	2000401c 	.word	0x2000401c
 800159c:	40013000 	.word	0x40013000

080015a0 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 80015a0:	b580      	push	{r7, lr}
 80015a2:	b088      	sub	sp, #32
 80015a4:	af00      	add	r7, sp, #0
 80015a6:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80015a8:	f107 030c 	add.w	r3, r7, #12
 80015ac:	2200      	movs	r2, #0
 80015ae:	601a      	str	r2, [r3, #0]
 80015b0:	605a      	str	r2, [r3, #4]
 80015b2:	609a      	str	r2, [r3, #8]
 80015b4:	60da      	str	r2, [r3, #12]
 80015b6:	611a      	str	r2, [r3, #16]
  if(spiHandle->Instance==SPI1)
 80015b8:	687b      	ldr	r3, [r7, #4]
 80015ba:	681b      	ldr	r3, [r3, #0]
 80015bc:	4a37      	ldr	r2, [pc, #220]	; (800169c <HAL_SPI_MspInit+0xfc>)
 80015be:	4293      	cmp	r3, r2
 80015c0:	d168      	bne.n	8001694 <HAL_SPI_MspInit+0xf4>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 80015c2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80015c6:	f7ff ff93 	bl	80014f0 <LL_APB2_GRP1_EnableClock>

    __HAL_RCC_GPIOB_CLK_ENABLE();
 80015ca:	2002      	movs	r0, #2
 80015cc:	f7ff ff77 	bl	80014be <LL_AHB2_GRP1_EnableClock>
    /**SPI1 GPIO Configuration
    PB3     ------> SPI1_SCK
    PB4     ------> SPI1_MISO
    PB5     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5;
 80015d0:	2338      	movs	r3, #56	; 0x38
 80015d2:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80015d4:	2302      	movs	r3, #2
 80015d6:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80015d8:	2300      	movs	r3, #0
 80015da:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80015dc:	2300      	movs	r3, #0
 80015de:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80015e0:	2305      	movs	r3, #5
 80015e2:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80015e4:	f107 030c 	add.w	r3, r7, #12
 80015e8:	4619      	mov	r1, r3
 80015ea:	482d      	ldr	r0, [pc, #180]	; (80016a0 <HAL_SPI_MspInit+0x100>)
 80015ec:	f001 fee8 	bl	80033c0 <HAL_GPIO_Init>

    /* SPI1 DMA Init */
    /* SPI1_RX Init */
    hdma_spi1_rx.Instance = DMA1_Channel1;
 80015f0:	4b2c      	ldr	r3, [pc, #176]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 80015f2:	4a2d      	ldr	r2, [pc, #180]	; (80016a8 <HAL_SPI_MspInit+0x108>)
 80015f4:	601a      	str	r2, [r3, #0]
    hdma_spi1_rx.Init.Request = DMA_REQUEST_SPI1_RX;
 80015f6:	4b2b      	ldr	r3, [pc, #172]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 80015f8:	2206      	movs	r2, #6
 80015fa:	605a      	str	r2, [r3, #4]
    hdma_spi1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 80015fc:	4b29      	ldr	r3, [pc, #164]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 80015fe:	2200      	movs	r2, #0
 8001600:	609a      	str	r2, [r3, #8]
    hdma_spi1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001602:	4b28      	ldr	r3, [pc, #160]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 8001604:	2200      	movs	r2, #0
 8001606:	60da      	str	r2, [r3, #12]
    hdma_spi1_rx.Init.MemInc = DMA_MINC_ENABLE;
 8001608:	4b26      	ldr	r3, [pc, #152]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 800160a:	2280      	movs	r2, #128	; 0x80
 800160c:	611a      	str	r2, [r3, #16]
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 800160e:	4b25      	ldr	r3, [pc, #148]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 8001610:	2200      	movs	r2, #0
 8001612:	615a      	str	r2, [r3, #20]
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001614:	4b23      	ldr	r3, [pc, #140]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 8001616:	2200      	movs	r2, #0
 8001618:	619a      	str	r2, [r3, #24]
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
 800161a:	4b22      	ldr	r3, [pc, #136]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 800161c:	2200      	movs	r2, #0
 800161e:	61da      	str	r2, [r3, #28]
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_LOW;
 8001620:	4b20      	ldr	r3, [pc, #128]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 8001622:	2200      	movs	r2, #0
 8001624:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_spi1_rx) != HAL_OK)
 8001626:	481f      	ldr	r0, [pc, #124]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 8001628:	f001 fd0e 	bl	8003048 <HAL_DMA_Init>
 800162c:	4603      	mov	r3, r0
 800162e:	2b00      	cmp	r3, #0
 8001630:	d001      	beq.n	8001636 <HAL_SPI_MspInit+0x96>
    {
      Error_Handler();
 8001632:	f7ff fe59 	bl	80012e8 <Error_Handler>
    }

    __HAL_LINKDMA(spiHandle,hdmarx,hdma_spi1_rx);
 8001636:	687b      	ldr	r3, [r7, #4]
 8001638:	4a1a      	ldr	r2, [pc, #104]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 800163a:	659a      	str	r2, [r3, #88]	; 0x58
 800163c:	4a19      	ldr	r2, [pc, #100]	; (80016a4 <HAL_SPI_MspInit+0x104>)
 800163e:	687b      	ldr	r3, [r7, #4]
 8001640:	6293      	str	r3, [r2, #40]	; 0x28

    /* SPI1_TX Init */
    hdma_spi1_tx.Instance = DMA1_Channel2;
 8001642:	4b1a      	ldr	r3, [pc, #104]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 8001644:	4a1a      	ldr	r2, [pc, #104]	; (80016b0 <HAL_SPI_MspInit+0x110>)
 8001646:	601a      	str	r2, [r3, #0]
    hdma_spi1_tx.Init.Request = DMA_REQUEST_SPI1_TX;
 8001648:	4b18      	ldr	r3, [pc, #96]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 800164a:	2207      	movs	r2, #7
 800164c:	605a      	str	r2, [r3, #4]
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800164e:	4b17      	ldr	r3, [pc, #92]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 8001650:	2210      	movs	r2, #16
 8001652:	609a      	str	r2, [r3, #8]
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001654:	4b15      	ldr	r3, [pc, #84]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 8001656:	2200      	movs	r2, #0
 8001658:	60da      	str	r2, [r3, #12]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 800165a:	4b14      	ldr	r3, [pc, #80]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 800165c:	2280      	movs	r2, #128	; 0x80
 800165e:	611a      	str	r2, [r3, #16]
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8001660:	4b12      	ldr	r3, [pc, #72]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 8001662:	2200      	movs	r2, #0
 8001664:	615a      	str	r2, [r3, #20]
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001666:	4b11      	ldr	r3, [pc, #68]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 8001668:	2200      	movs	r2, #0
 800166a:	619a      	str	r2, [r3, #24]
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
 800166c:	4b0f      	ldr	r3, [pc, #60]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 800166e:	2200      	movs	r2, #0
 8001670:	61da      	str	r2, [r3, #28]
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
 8001672:	4b0e      	ldr	r3, [pc, #56]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 8001674:	2200      	movs	r2, #0
 8001676:	621a      	str	r2, [r3, #32]
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 8001678:	480c      	ldr	r0, [pc, #48]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 800167a:	f001 fce5 	bl	8003048 <HAL_DMA_Init>
 800167e:	4603      	mov	r3, r0
 8001680:	2b00      	cmp	r3, #0
 8001682:	d001      	beq.n	8001688 <HAL_SPI_MspInit+0xe8>
    {
      Error_Handler();
 8001684:	f7ff fe30 	bl	80012e8 <Error_Handler>
    }

    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi1_tx);
 8001688:	687b      	ldr	r3, [r7, #4]
 800168a:	4a08      	ldr	r2, [pc, #32]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 800168c:	655a      	str	r2, [r3, #84]	; 0x54
 800168e:	4a07      	ldr	r2, [pc, #28]	; (80016ac <HAL_SPI_MspInit+0x10c>)
 8001690:	687b      	ldr	r3, [r7, #4]
 8001692:	6293      	str	r3, [r2, #40]	; 0x28

  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }
}
 8001694:	bf00      	nop
 8001696:	3720      	adds	r7, #32
 8001698:	46bd      	mov	sp, r7
 800169a:	bd80      	pop	{r7, pc}
 800169c:	40013000 	.word	0x40013000
 80016a0:	48000400 	.word	0x48000400
 80016a4:	20004080 	.word	0x20004080
 80016a8:	40020008 	.word	0x40020008
 80016ac:	200040e0 	.word	0x200040e0
 80016b0:	4002001c 	.word	0x4002001c

080016b4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80016b4:	b480      	push	{r7}
 80016b6:	af00      	add	r7, sp, #0
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80016b8:	bf00      	nop
 80016ba:	46bd      	mov	sp, r7
 80016bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016c0:	4770      	bx	lr

080016c2 <LL_APB2_GRP1_EnableClock>:
{
 80016c2:	b480      	push	{r7}
 80016c4:	b085      	sub	sp, #20
 80016c6:	af00      	add	r7, sp, #0
 80016c8:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB2ENR, Periphs);
 80016ca:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80016ce:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80016d0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80016d4:	687b      	ldr	r3, [r7, #4]
 80016d6:	4313      	orrs	r3, r2
 80016d8:	660b      	str	r3, [r1, #96]	; 0x60
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 80016da:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80016de:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80016e0:	687b      	ldr	r3, [r7, #4]
 80016e2:	4013      	ands	r3, r2
 80016e4:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 80016e6:	68fb      	ldr	r3, [r7, #12]
}
 80016e8:	bf00      	nop
 80016ea:	3714      	adds	r7, #20
 80016ec:	46bd      	mov	sp, r7
 80016ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016f2:	4770      	bx	lr

080016f4 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80016f4:	b580      	push	{r7, lr}
 80016f6:	b08c      	sub	sp, #48	; 0x30
 80016f8:	af00      	add	r7, sp, #0
 80016fa:	6078      	str	r0, [r7, #4]
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
 80016fc:	2300      	movs	r3, #0
 80016fe:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t              uwPrescalerValue = 0;
 8001700:	2300      	movs	r3, #0
 8001702:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t              pFLatency;
  /*Configure the TIM17 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_TRG_COM_TIM17_IRQn, TickPriority ,0);
 8001704:	2200      	movs	r2, #0
 8001706:	6879      	ldr	r1, [r7, #4]
 8001708:	201a      	movs	r0, #26
 800170a:	f001 fc75 	bl	8002ff8 <HAL_NVIC_SetPriority>
  /* Enable the TIM17 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_TRG_COM_TIM17_IRQn);
 800170e:	201a      	movs	r0, #26
 8001710:	f001 fc8c 	bl	800302c <HAL_NVIC_EnableIRQ>

  /* Enable TIM17 clock */
  __HAL_RCC_TIM17_CLK_ENABLE();
 8001714:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8001718:	f7ff ffd3 	bl	80016c2 <LL_APB2_GRP1_EnableClock>

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800171c:	f107 0208 	add.w	r2, r7, #8
 8001720:	f107 030c 	add.w	r3, r7, #12
 8001724:	4611      	mov	r1, r2
 8001726:	4618      	mov	r0, r3
 8001728:	f003 fb1c 	bl	8004d64 <HAL_RCC_GetClockConfig>

  /* Compute TIM17 clock */
  uwTimclock = HAL_RCC_GetPCLK2Freq();
 800172c:	f003 fb04 	bl	8004d38 <HAL_RCC_GetPCLK2Freq>
 8001730:	62f8      	str	r0, [r7, #44]	; 0x2c

  /* Compute the prescaler value to have TIM17 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8001732:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001734:	4a12      	ldr	r2, [pc, #72]	; (8001780 <HAL_InitTick+0x8c>)
 8001736:	fba2 2303 	umull	r2, r3, r2, r3
 800173a:	0c9b      	lsrs	r3, r3, #18
 800173c:	3b01      	subs	r3, #1
 800173e:	62bb      	str	r3, [r7, #40]	; 0x28

  /* Initialize TIM17 */
  htim17.Instance = TIM17;
 8001740:	4b10      	ldr	r3, [pc, #64]	; (8001784 <HAL_InitTick+0x90>)
 8001742:	4a11      	ldr	r2, [pc, #68]	; (8001788 <HAL_InitTick+0x94>)
 8001744:	601a      	str	r2, [r3, #0]
  + Period = [(TIM17CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim17.Init.Period = (1000000U / 1000U) - 1U;
 8001746:	4b0f      	ldr	r3, [pc, #60]	; (8001784 <HAL_InitTick+0x90>)
 8001748:	f240 32e7 	movw	r2, #999	; 0x3e7
 800174c:	60da      	str	r2, [r3, #12]
  htim17.Init.Prescaler = uwPrescalerValue;
 800174e:	4a0d      	ldr	r2, [pc, #52]	; (8001784 <HAL_InitTick+0x90>)
 8001750:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001752:	6053      	str	r3, [r2, #4]
  htim17.Init.ClockDivision = 0;
 8001754:	4b0b      	ldr	r3, [pc, #44]	; (8001784 <HAL_InitTick+0x90>)
 8001756:	2200      	movs	r2, #0
 8001758:	611a      	str	r2, [r3, #16]
  htim17.Init.CounterMode = TIM_COUNTERMODE_UP;
 800175a:	4b0a      	ldr	r3, [pc, #40]	; (8001784 <HAL_InitTick+0x90>)
 800175c:	2200      	movs	r2, #0
 800175e:	609a      	str	r2, [r3, #8]

  if(HAL_TIM_Base_Init(&htim17) == HAL_OK)
 8001760:	4808      	ldr	r0, [pc, #32]	; (8001784 <HAL_InitTick+0x90>)
 8001762:	f004 f8ac 	bl	80058be <HAL_TIM_Base_Init>
 8001766:	4603      	mov	r3, r0
 8001768:	2b00      	cmp	r3, #0
 800176a:	d104      	bne.n	8001776 <HAL_InitTick+0x82>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim17);
 800176c:	4805      	ldr	r0, [pc, #20]	; (8001784 <HAL_InitTick+0x90>)
 800176e:	f004 f907 	bl	8005980 <HAL_TIM_Base_Start_IT>
 8001772:	4603      	mov	r3, r0
 8001774:	e000      	b.n	8001778 <HAL_InitTick+0x84>
  }

  /* Return function status */
  return HAL_ERROR;
 8001776:	2301      	movs	r3, #1
}
 8001778:	4618      	mov	r0, r3
 800177a:	3730      	adds	r7, #48	; 0x30
 800177c:	46bd      	mov	sp, r7
 800177e:	bd80      	pop	{r7, pc}
 8001780:	431bde83 	.word	0x431bde83
 8001784:	20004140 	.word	0x20004140
 8001788:	40014800 	.word	0x40014800

0800178c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800178c:	b480      	push	{r7}
 800178e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8001790:	e7fe      	b.n	8001790 <NMI_Handler+0x4>

08001792 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8001792:	b480      	push	{r7}
 8001794:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001796:	e7fe      	b.n	8001796 <HardFault_Handler+0x4>

08001798 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8001798:	b480      	push	{r7}
 800179a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800179c:	e7fe      	b.n	800179c <MemManage_Handler+0x4>

0800179e <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800179e:	b480      	push	{r7}
 80017a0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 80017a2:	e7fe      	b.n	80017a2 <BusFault_Handler+0x4>

080017a4 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 80017a4:	b480      	push	{r7}
 80017a6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 80017a8:	e7fe      	b.n	80017a8 <UsageFault_Handler+0x4>

080017aa <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 80017aa:	b480      	push	{r7}
 80017ac:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 80017ae:	bf00      	nop
 80017b0:	46bd      	mov	sp, r7
 80017b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017b6:	4770      	bx	lr

080017b8 <DMA1_Channel1_IRQHandler>:

/**
  * @brief This function handles DMA1 channel1 global interrupt.
  */
void DMA1_Channel1_IRQHandler(void)
{
 80017b8:	b580      	push	{r7, lr}
 80017ba:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */

  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_rx);
 80017bc:	4802      	ldr	r0, [pc, #8]	; (80017c8 <DMA1_Channel1_IRQHandler+0x10>)
 80017be:	f001 fceb 	bl	8003198 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel1_IRQn 1 */

  /* USER CODE END DMA1_Channel1_IRQn 1 */
}
 80017c2:	bf00      	nop
 80017c4:	bd80      	pop	{r7, pc}
 80017c6:	bf00      	nop
 80017c8:	20004080 	.word	0x20004080

080017cc <DMA1_Channel2_IRQHandler>:

/**
  * @brief This function handles DMA1 channel2 global interrupt.
  */
void DMA1_Channel2_IRQHandler(void)
{
 80017cc:	b580      	push	{r7, lr}
 80017ce:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Channel2_IRQn 0 */

  /* USER CODE END DMA1_Channel2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
 80017d0:	4802      	ldr	r0, [pc, #8]	; (80017dc <DMA1_Channel2_IRQHandler+0x10>)
 80017d2:	f001 fce1 	bl	8003198 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel2_IRQn 1 */

  /* USER CODE END DMA1_Channel2_IRQn 1 */
}
 80017d6:	bf00      	nop
 80017d8:	bd80      	pop	{r7, pc}
 80017da:	bf00      	nop
 80017dc:	200040e0 	.word	0x200040e0

080017e0 <TIM1_TRG_COM_TIM17_IRQHandler>:

/**
  * @brief This function handles TIM1 trigger and commutation interrupts and TIM17 global interrupt.
  */
void TIM1_TRG_COM_TIM17_IRQHandler(void)
{
 80017e0:	b580      	push	{r7, lr}
 80017e2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM1_TRG_COM_TIM17_IRQn 0 */

  /* USER CODE END TIM1_TRG_COM_TIM17_IRQn 0 */
  HAL_TIM_IRQHandler(&htim17);
 80017e4:	4802      	ldr	r0, [pc, #8]	; (80017f0 <TIM1_TRG_COM_TIM17_IRQHandler+0x10>)
 80017e6:	f004 f919 	bl	8005a1c <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_TRG_COM_TIM17_IRQn 1 */

  /* USER CODE END TIM1_TRG_COM_TIM17_IRQn 1 */
}
 80017ea:	bf00      	nop
 80017ec:	bd80      	pop	{r7, pc}
 80017ee:	bf00      	nop
 80017f0:	20004140 	.word	0x20004140

080017f4 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80017f4:	b480      	push	{r7}
 80017f6:	af00      	add	r7, sp, #0
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif /* USER_VECT_TAB_ADDRESS */

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL * 2UL)) | (3UL << (11UL * 2UL))); /* set CP10 and CP11 Full Access */
 80017f8:	4b24      	ldr	r3, [pc, #144]	; (800188c <SystemInit+0x98>)
 80017fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80017fe:	4a23      	ldr	r2, [pc, #140]	; (800188c <SystemInit+0x98>)
 8001800:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001804:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
#endif /* FPU */

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8001808:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800180c:	681b      	ldr	r3, [r3, #0]
 800180e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001812:	f043 0301 	orr.w	r3, r3, #1
 8001816:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00070000U;
 8001818:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800181c:	f44f 22e0 	mov.w	r2, #458752	; 0x70000
 8001820:	609a      	str	r2, [r3, #8]

  /* Reset PLLSAI1ON, PLLON, HSECSSON, HSEON, HSION, and MSIPLLON bits */
  RCC->CR &= (uint32_t)0xFAF6FEFBU;
 8001822:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001826:	681a      	ldr	r2, [r3, #0]
 8001828:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800182c:	4b18      	ldr	r3, [pc, #96]	; (8001890 <SystemInit+0x9c>)
 800182e:	4013      	ands	r3, r2
 8001830:	600b      	str	r3, [r1, #0]

  /*!< Reset LSI1 and LSI2 bits */
  RCC->CSR &= (uint32_t)0xFFFFFFFAU;
 8001832:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001836:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800183a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800183e:	f023 0305 	bic.w	r3, r3, #5
 8001842:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94

  /*!< Reset HSI48ON  bit */
  RCC->CRRCR &= (uint32_t)0xFFFFFFFEU;
 8001846:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800184a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800184e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001852:	f023 0301 	bic.w	r3, r3, #1
 8001856:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x22041000U;
 800185a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800185e:	4a0d      	ldr	r2, [pc, #52]	; (8001894 <SystemInit+0xa0>)
 8001860:	60da      	str	r2, [r3, #12]

#if defined(STM32WB55xx) || defined(STM32WB5Mxx)
  /* Reset PLLSAI1CFGR register */
  RCC->PLLSAI1CFGR = 0x22041000U;
 8001862:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001866:	4a0b      	ldr	r2, [pc, #44]	; (8001894 <SystemInit+0xa0>)
 8001868:	611a      	str	r2, [r3, #16]
#endif /* STM32WB55xx || STM32WB5Mxx */

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 800186a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800186e:	681b      	ldr	r3, [r3, #0]
 8001870:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8001874:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001878:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 800187a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800187e:	2200      	movs	r2, #0
 8001880:	619a      	str	r2, [r3, #24]
}
 8001882:	bf00      	nop
 8001884:	46bd      	mov	sp, r7
 8001886:	f85d 7b04 	ldr.w	r7, [sp], #4
 800188a:	4770      	bx	lr
 800188c:	e000ed00 	.word	0xe000ed00
 8001890:	faf6fefb 	.word	0xfaf6fefb
 8001894:	22041000 	.word	0x22041000

08001898 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8001898:	b480      	push	{r7}
 800189a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800189c:	4b04      	ldr	r3, [pc, #16]	; (80018b0 <__NVIC_GetPriorityGrouping+0x18>)
 800189e:	68db      	ldr	r3, [r3, #12]
 80018a0:	0a1b      	lsrs	r3, r3, #8
 80018a2:	f003 0307 	and.w	r3, r3, #7
}
 80018a6:	4618      	mov	r0, r3
 80018a8:	46bd      	mov	sp, r7
 80018aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80018ae:	4770      	bx	lr
 80018b0:	e000ed00 	.word	0xe000ed00

080018b4 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80018b4:	b480      	push	{r7}
 80018b6:	b083      	sub	sp, #12
 80018b8:	af00      	add	r7, sp, #0
 80018ba:	4603      	mov	r3, r0
 80018bc:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80018be:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80018c2:	2b00      	cmp	r3, #0
 80018c4:	db0b      	blt.n	80018de <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80018c6:	79fb      	ldrb	r3, [r7, #7]
 80018c8:	f003 021f 	and.w	r2, r3, #31
 80018cc:	4907      	ldr	r1, [pc, #28]	; (80018ec <__NVIC_EnableIRQ+0x38>)
 80018ce:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80018d2:	095b      	lsrs	r3, r3, #5
 80018d4:	2001      	movs	r0, #1
 80018d6:	fa00 f202 	lsl.w	r2, r0, r2
 80018da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 80018de:	bf00      	nop
 80018e0:	370c      	adds	r7, #12
 80018e2:	46bd      	mov	sp, r7
 80018e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80018e8:	4770      	bx	lr
 80018ea:	bf00      	nop
 80018ec:	e000e100 	.word	0xe000e100

080018f0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80018f0:	b480      	push	{r7}
 80018f2:	b083      	sub	sp, #12
 80018f4:	af00      	add	r7, sp, #0
 80018f6:	4603      	mov	r3, r0
 80018f8:	6039      	str	r1, [r7, #0]
 80018fa:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80018fc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001900:	2b00      	cmp	r3, #0
 8001902:	db0a      	blt.n	800191a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001904:	683b      	ldr	r3, [r7, #0]
 8001906:	b2da      	uxtb	r2, r3
 8001908:	490c      	ldr	r1, [pc, #48]	; (800193c <__NVIC_SetPriority+0x4c>)
 800190a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800190e:	0112      	lsls	r2, r2, #4
 8001910:	b2d2      	uxtb	r2, r2
 8001912:	440b      	add	r3, r1
 8001914:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8001918:	e00a      	b.n	8001930 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800191a:	683b      	ldr	r3, [r7, #0]
 800191c:	b2da      	uxtb	r2, r3
 800191e:	4908      	ldr	r1, [pc, #32]	; (8001940 <__NVIC_SetPriority+0x50>)
 8001920:	79fb      	ldrb	r3, [r7, #7]
 8001922:	f003 030f 	and.w	r3, r3, #15
 8001926:	3b04      	subs	r3, #4
 8001928:	0112      	lsls	r2, r2, #4
 800192a:	b2d2      	uxtb	r2, r2
 800192c:	440b      	add	r3, r1
 800192e:	761a      	strb	r2, [r3, #24]
}
 8001930:	bf00      	nop
 8001932:	370c      	adds	r7, #12
 8001934:	46bd      	mov	sp, r7
 8001936:	f85d 7b04 	ldr.w	r7, [sp], #4
 800193a:	4770      	bx	lr
 800193c:	e000e100 	.word	0xe000e100
 8001940:	e000ed00 	.word	0xe000ed00

08001944 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001944:	b480      	push	{r7}
 8001946:	b089      	sub	sp, #36	; 0x24
 8001948:	af00      	add	r7, sp, #0
 800194a:	60f8      	str	r0, [r7, #12]
 800194c:	60b9      	str	r1, [r7, #8]
 800194e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001950:	68fb      	ldr	r3, [r7, #12]
 8001952:	f003 0307 	and.w	r3, r3, #7
 8001956:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001958:	69fb      	ldr	r3, [r7, #28]
 800195a:	f1c3 0307 	rsb	r3, r3, #7
 800195e:	2b04      	cmp	r3, #4
 8001960:	bf28      	it	cs
 8001962:	2304      	movcs	r3, #4
 8001964:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001966:	69fb      	ldr	r3, [r7, #28]
 8001968:	3304      	adds	r3, #4
 800196a:	2b06      	cmp	r3, #6
 800196c:	d902      	bls.n	8001974 <NVIC_EncodePriority+0x30>
 800196e:	69fb      	ldr	r3, [r7, #28]
 8001970:	3b03      	subs	r3, #3
 8001972:	e000      	b.n	8001976 <NVIC_EncodePriority+0x32>
 8001974:	2300      	movs	r3, #0
 8001976:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001978:	f04f 32ff 	mov.w	r2, #4294967295
 800197c:	69bb      	ldr	r3, [r7, #24]
 800197e:	fa02 f303 	lsl.w	r3, r2, r3
 8001982:	43da      	mvns	r2, r3
 8001984:	68bb      	ldr	r3, [r7, #8]
 8001986:	401a      	ands	r2, r3
 8001988:	697b      	ldr	r3, [r7, #20]
 800198a:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800198c:	f04f 31ff 	mov.w	r1, #4294967295
 8001990:	697b      	ldr	r3, [r7, #20]
 8001992:	fa01 f303 	lsl.w	r3, r1, r3
 8001996:	43d9      	mvns	r1, r3
 8001998:	687b      	ldr	r3, [r7, #4]
 800199a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800199c:	4313      	orrs	r3, r2
         );
}
 800199e:	4618      	mov	r0, r3
 80019a0:	3724      	adds	r7, #36	; 0x24
 80019a2:	46bd      	mov	sp, r7
 80019a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019a8:	4770      	bx	lr

080019aa <LL_AHB2_GRP1_EnableClock>:
{
 80019aa:	b480      	push	{r7}
 80019ac:	b085      	sub	sp, #20
 80019ae:	af00      	add	r7, sp, #0
 80019b0:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 80019b2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80019b6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80019b8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80019bc:	687b      	ldr	r3, [r7, #4]
 80019be:	4313      	orrs	r3, r2
 80019c0:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 80019c2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80019c6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80019c8:	687b      	ldr	r3, [r7, #4]
 80019ca:	4013      	ands	r3, r2
 80019cc:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 80019ce:	68fb      	ldr	r3, [r7, #12]
}
 80019d0:	bf00      	nop
 80019d2:	3714      	adds	r7, #20
 80019d4:	46bd      	mov	sp, r7
 80019d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019da:	4770      	bx	lr

080019dc <LL_APB2_GRP1_EnableClock>:
{
 80019dc:	b480      	push	{r7}
 80019de:	b085      	sub	sp, #20
 80019e0:	af00      	add	r7, sp, #0
 80019e2:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB2ENR, Periphs);
 80019e4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80019e8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80019ea:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80019ee:	687b      	ldr	r3, [r7, #4]
 80019f0:	4313      	orrs	r3, r2
 80019f2:	660b      	str	r3, [r1, #96]	; 0x60
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 80019f4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80019f8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80019fa:	687b      	ldr	r3, [r7, #4]
 80019fc:	4013      	ands	r3, r2
 80019fe:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8001a00:	68fb      	ldr	r3, [r7, #12]
}
 8001a02:	bf00      	nop
 8001a04:	3714      	adds	r7, #20
 8001a06:	46bd      	mov	sp, r7
 8001a08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a0c:	4770      	bx	lr

08001a0e <LL_TIM_DisableARRPreload>:
  * @rmtoll CR1          ARPE          LL_TIM_DisableARRPreload
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_DisableARRPreload(TIM_TypeDef *TIMx)
{
 8001a0e:	b480      	push	{r7}
 8001a10:	b083      	sub	sp, #12
 8001a12:	af00      	add	r7, sp, #0
 8001a14:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
 8001a16:	687b      	ldr	r3, [r7, #4]
 8001a18:	681b      	ldr	r3, [r3, #0]
 8001a1a:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8001a1e:	687b      	ldr	r3, [r7, #4]
 8001a20:	601a      	str	r2, [r3, #0]
}
 8001a22:	bf00      	nop
 8001a24:	370c      	adds	r7, #12
 8001a26:	46bd      	mov	sp, r7
 8001a28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a2c:	4770      	bx	lr
	...

08001a30 <LL_TIM_OC_DisableFast>:
  *         @arg @ref LL_TIM_CHANNEL_CH5
  *         @arg @ref LL_TIM_CHANNEL_CH6
  * @retval None
  */
__STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
{
 8001a30:	b480      	push	{r7}
 8001a32:	b085      	sub	sp, #20
 8001a34:	af00      	add	r7, sp, #0
 8001a36:	6078      	str	r0, [r7, #4]
 8001a38:	6039      	str	r1, [r7, #0]
  uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
 8001a3a:	683b      	ldr	r3, [r7, #0]
 8001a3c:	2b01      	cmp	r3, #1
 8001a3e:	d028      	beq.n	8001a92 <LL_TIM_OC_DisableFast+0x62>
 8001a40:	683b      	ldr	r3, [r7, #0]
 8001a42:	2b04      	cmp	r3, #4
 8001a44:	d023      	beq.n	8001a8e <LL_TIM_OC_DisableFast+0x5e>
 8001a46:	683b      	ldr	r3, [r7, #0]
 8001a48:	2b10      	cmp	r3, #16
 8001a4a:	d01e      	beq.n	8001a8a <LL_TIM_OC_DisableFast+0x5a>
 8001a4c:	683b      	ldr	r3, [r7, #0]
 8001a4e:	2b40      	cmp	r3, #64	; 0x40
 8001a50:	d019      	beq.n	8001a86 <LL_TIM_OC_DisableFast+0x56>
 8001a52:	683b      	ldr	r3, [r7, #0]
 8001a54:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8001a58:	d013      	beq.n	8001a82 <LL_TIM_OC_DisableFast+0x52>
 8001a5a:	683b      	ldr	r3, [r7, #0]
 8001a5c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8001a60:	d00d      	beq.n	8001a7e <LL_TIM_OC_DisableFast+0x4e>
 8001a62:	683b      	ldr	r3, [r7, #0]
 8001a64:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001a68:	d007      	beq.n	8001a7a <LL_TIM_OC_DisableFast+0x4a>
 8001a6a:	683b      	ldr	r3, [r7, #0]
 8001a6c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001a70:	d101      	bne.n	8001a76 <LL_TIM_OC_DisableFast+0x46>
 8001a72:	2307      	movs	r3, #7
 8001a74:	e00e      	b.n	8001a94 <LL_TIM_OC_DisableFast+0x64>
 8001a76:	2308      	movs	r3, #8
 8001a78:	e00c      	b.n	8001a94 <LL_TIM_OC_DisableFast+0x64>
 8001a7a:	2306      	movs	r3, #6
 8001a7c:	e00a      	b.n	8001a94 <LL_TIM_OC_DisableFast+0x64>
 8001a7e:	2305      	movs	r3, #5
 8001a80:	e008      	b.n	8001a94 <LL_TIM_OC_DisableFast+0x64>
 8001a82:	2304      	movs	r3, #4
 8001a84:	e006      	b.n	8001a94 <LL_TIM_OC_DisableFast+0x64>
 8001a86:	2303      	movs	r3, #3
 8001a88:	e004      	b.n	8001a94 <LL_TIM_OC_DisableFast+0x64>
 8001a8a:	2302      	movs	r3, #2
 8001a8c:	e002      	b.n	8001a94 <LL_TIM_OC_DisableFast+0x64>
 8001a8e:	2301      	movs	r3, #1
 8001a90:	e000      	b.n	8001a94 <LL_TIM_OC_DisableFast+0x64>
 8001a92:	2300      	movs	r3, #0
 8001a94:	73fb      	strb	r3, [r7, #15]
  __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 8001a96:	687b      	ldr	r3, [r7, #4]
 8001a98:	3318      	adds	r3, #24
 8001a9a:	4619      	mov	r1, r3
 8001a9c:	7bfb      	ldrb	r3, [r7, #15]
 8001a9e:	4a0b      	ldr	r2, [pc, #44]	; (8001acc <LL_TIM_OC_DisableFast+0x9c>)
 8001aa0:	5cd3      	ldrb	r3, [r2, r3]
 8001aa2:	440b      	add	r3, r1
 8001aa4:	60bb      	str	r3, [r7, #8]
  CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
 8001aa6:	68bb      	ldr	r3, [r7, #8]
 8001aa8:	681a      	ldr	r2, [r3, #0]
 8001aaa:	7bfb      	ldrb	r3, [r7, #15]
 8001aac:	4908      	ldr	r1, [pc, #32]	; (8001ad0 <LL_TIM_OC_DisableFast+0xa0>)
 8001aae:	5ccb      	ldrb	r3, [r1, r3]
 8001ab0:	4619      	mov	r1, r3
 8001ab2:	2304      	movs	r3, #4
 8001ab4:	408b      	lsls	r3, r1
 8001ab6:	43db      	mvns	r3, r3
 8001ab8:	401a      	ands	r2, r3
 8001aba:	68bb      	ldr	r3, [r7, #8]
 8001abc:	601a      	str	r2, [r3, #0]

}
 8001abe:	bf00      	nop
 8001ac0:	3714      	adds	r7, #20
 8001ac2:	46bd      	mov	sp, r7
 8001ac4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ac8:	4770      	bx	lr
 8001aca:	bf00      	nop
 8001acc:	08013584 	.word	0x08013584
 8001ad0:	08013590 	.word	0x08013590

08001ad4 <LL_TIM_OC_EnablePreload>:
  *         @arg @ref LL_TIM_CHANNEL_CH5
  *         @arg @ref LL_TIM_CHANNEL_CH6
  * @retval None
  */
__STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
{
 8001ad4:	b480      	push	{r7}
 8001ad6:	b085      	sub	sp, #20
 8001ad8:	af00      	add	r7, sp, #0
 8001ada:	6078      	str	r0, [r7, #4]
 8001adc:	6039      	str	r1, [r7, #0]
  uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
 8001ade:	683b      	ldr	r3, [r7, #0]
 8001ae0:	2b01      	cmp	r3, #1
 8001ae2:	d028      	beq.n	8001b36 <LL_TIM_OC_EnablePreload+0x62>
 8001ae4:	683b      	ldr	r3, [r7, #0]
 8001ae6:	2b04      	cmp	r3, #4
 8001ae8:	d023      	beq.n	8001b32 <LL_TIM_OC_EnablePreload+0x5e>
 8001aea:	683b      	ldr	r3, [r7, #0]
 8001aec:	2b10      	cmp	r3, #16
 8001aee:	d01e      	beq.n	8001b2e <LL_TIM_OC_EnablePreload+0x5a>
 8001af0:	683b      	ldr	r3, [r7, #0]
 8001af2:	2b40      	cmp	r3, #64	; 0x40
 8001af4:	d019      	beq.n	8001b2a <LL_TIM_OC_EnablePreload+0x56>
 8001af6:	683b      	ldr	r3, [r7, #0]
 8001af8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8001afc:	d013      	beq.n	8001b26 <LL_TIM_OC_EnablePreload+0x52>
 8001afe:	683b      	ldr	r3, [r7, #0]
 8001b00:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8001b04:	d00d      	beq.n	8001b22 <LL_TIM_OC_EnablePreload+0x4e>
 8001b06:	683b      	ldr	r3, [r7, #0]
 8001b08:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001b0c:	d007      	beq.n	8001b1e <LL_TIM_OC_EnablePreload+0x4a>
 8001b0e:	683b      	ldr	r3, [r7, #0]
 8001b10:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001b14:	d101      	bne.n	8001b1a <LL_TIM_OC_EnablePreload+0x46>
 8001b16:	2307      	movs	r3, #7
 8001b18:	e00e      	b.n	8001b38 <LL_TIM_OC_EnablePreload+0x64>
 8001b1a:	2308      	movs	r3, #8
 8001b1c:	e00c      	b.n	8001b38 <LL_TIM_OC_EnablePreload+0x64>
 8001b1e:	2306      	movs	r3, #6
 8001b20:	e00a      	b.n	8001b38 <LL_TIM_OC_EnablePreload+0x64>
 8001b22:	2305      	movs	r3, #5
 8001b24:	e008      	b.n	8001b38 <LL_TIM_OC_EnablePreload+0x64>
 8001b26:	2304      	movs	r3, #4
 8001b28:	e006      	b.n	8001b38 <LL_TIM_OC_EnablePreload+0x64>
 8001b2a:	2303      	movs	r3, #3
 8001b2c:	e004      	b.n	8001b38 <LL_TIM_OC_EnablePreload+0x64>
 8001b2e:	2302      	movs	r3, #2
 8001b30:	e002      	b.n	8001b38 <LL_TIM_OC_EnablePreload+0x64>
 8001b32:	2301      	movs	r3, #1
 8001b34:	e000      	b.n	8001b38 <LL_TIM_OC_EnablePreload+0x64>
 8001b36:	2300      	movs	r3, #0
 8001b38:	73fb      	strb	r3, [r7, #15]
  __IO uint32_t *pReg = (__IO uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 8001b3a:	687b      	ldr	r3, [r7, #4]
 8001b3c:	3318      	adds	r3, #24
 8001b3e:	4619      	mov	r1, r3
 8001b40:	7bfb      	ldrb	r3, [r7, #15]
 8001b42:	4a0a      	ldr	r2, [pc, #40]	; (8001b6c <LL_TIM_OC_EnablePreload+0x98>)
 8001b44:	5cd3      	ldrb	r3, [r2, r3]
 8001b46:	440b      	add	r3, r1
 8001b48:	60bb      	str	r3, [r7, #8]
  SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
 8001b4a:	68bb      	ldr	r3, [r7, #8]
 8001b4c:	681a      	ldr	r2, [r3, #0]
 8001b4e:	7bfb      	ldrb	r3, [r7, #15]
 8001b50:	4907      	ldr	r1, [pc, #28]	; (8001b70 <LL_TIM_OC_EnablePreload+0x9c>)
 8001b52:	5ccb      	ldrb	r3, [r1, r3]
 8001b54:	4619      	mov	r1, r3
 8001b56:	2308      	movs	r3, #8
 8001b58:	408b      	lsls	r3, r1
 8001b5a:	431a      	orrs	r2, r3
 8001b5c:	68bb      	ldr	r3, [r7, #8]
 8001b5e:	601a      	str	r2, [r3, #0]
}
 8001b60:	bf00      	nop
 8001b62:	3714      	adds	r7, #20
 8001b64:	46bd      	mov	sp, r7
 8001b66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b6a:	4770      	bx	lr
 8001b6c:	08013584 	.word	0x08013584
 8001b70:	08013590 	.word	0x08013590

08001b74 <LL_TIM_SetClockSource>:
  *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE1
  *         @arg @ref LL_TIM_CLOCKSOURCE_EXT_MODE2
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
{
 8001b74:	b480      	push	{r7}
 8001b76:	b083      	sub	sp, #12
 8001b78:	af00      	add	r7, sp, #0
 8001b7a:	6078      	str	r0, [r7, #4]
 8001b7c:	6039      	str	r1, [r7, #0]
  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
 8001b7e:	687b      	ldr	r3, [r7, #4]
 8001b80:	689b      	ldr	r3, [r3, #8]
 8001b82:	f423 33a0 	bic.w	r3, r3, #81920	; 0x14000
 8001b86:	f023 0307 	bic.w	r3, r3, #7
 8001b8a:	683a      	ldr	r2, [r7, #0]
 8001b8c:	431a      	orrs	r2, r3
 8001b8e:	687b      	ldr	r3, [r7, #4]
 8001b90:	609a      	str	r2, [r3, #8]
}
 8001b92:	bf00      	nop
 8001b94:	370c      	adds	r7, #12
 8001b96:	46bd      	mov	sp, r7
 8001b98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b9c:	4770      	bx	lr

08001b9e <LL_TIM_SetTriggerOutput>:
  *         @arg @ref LL_TIM_TRGO_OC3REF
  *         @arg @ref LL_TIM_TRGO_OC4REF
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
{
 8001b9e:	b480      	push	{r7}
 8001ba0:	b083      	sub	sp, #12
 8001ba2:	af00      	add	r7, sp, #0
 8001ba4:	6078      	str	r0, [r7, #4]
 8001ba6:	6039      	str	r1, [r7, #0]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8001ba8:	687b      	ldr	r3, [r7, #4]
 8001baa:	685b      	ldr	r3, [r3, #4]
 8001bac:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8001bb0:	683b      	ldr	r3, [r7, #0]
 8001bb2:	431a      	orrs	r2, r3
 8001bb4:	687b      	ldr	r3, [r7, #4]
 8001bb6:	605a      	str	r2, [r3, #4]
}
 8001bb8:	bf00      	nop
 8001bba:	370c      	adds	r7, #12
 8001bbc:	46bd      	mov	sp, r7
 8001bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001bc2:	4770      	bx	lr

08001bc4 <LL_TIM_SetTriggerOutput2>:
  *         @arg @ref LL_TIM_TRGO2_OC5_RISING_OC6_RISING
  *         @arg @ref LL_TIM_TRGO2_OC5_RISING_OC6_FALLING
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetTriggerOutput2(TIM_TypeDef *TIMx, uint32_t ADCSynchronization)
{
 8001bc4:	b480      	push	{r7}
 8001bc6:	b083      	sub	sp, #12
 8001bc8:	af00      	add	r7, sp, #0
 8001bca:	6078      	str	r0, [r7, #4]
 8001bcc:	6039      	str	r1, [r7, #0]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS2, ADCSynchronization);
 8001bce:	687b      	ldr	r3, [r7, #4]
 8001bd0:	685b      	ldr	r3, [r3, #4]
 8001bd2:	f423 0270 	bic.w	r2, r3, #15728640	; 0xf00000
 8001bd6:	683b      	ldr	r3, [r7, #0]
 8001bd8:	431a      	orrs	r2, r3
 8001bda:	687b      	ldr	r3, [r7, #4]
 8001bdc:	605a      	str	r2, [r3, #4]
}
 8001bde:	bf00      	nop
 8001be0:	370c      	adds	r7, #12
 8001be2:	46bd      	mov	sp, r7
 8001be4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001be8:	4770      	bx	lr

08001bea <LL_TIM_DisableMasterSlaveMode>:
  * @rmtoll SMCR         MSM           LL_TIM_DisableMasterSlaveMode
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
{
 8001bea:	b480      	push	{r7}
 8001bec:	b083      	sub	sp, #12
 8001bee:	af00      	add	r7, sp, #0
 8001bf0:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
 8001bf2:	687b      	ldr	r3, [r7, #4]
 8001bf4:	689b      	ldr	r3, [r3, #8]
 8001bf6:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8001bfa:	687b      	ldr	r3, [r7, #4]
 8001bfc:	609a      	str	r2, [r3, #8]
}
 8001bfe:	bf00      	nop
 8001c00:	370c      	adds	r7, #12
 8001c02:	46bd      	mov	sp, r7
 8001c04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001c08:	4770      	bx	lr
	...

08001c0c <MX_TIM1_Init>:

/* USER CODE END 0 */

/* TIM1 init function */
void MX_TIM1_Init(void)
{
 8001c0c:	b580      	push	{r7, lr}
 8001c0e:	b0a0      	sub	sp, #128	; 0x80
 8001c10:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  LL_TIM_InitTypeDef TIM_InitStruct = {0};
 8001c12:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8001c16:	2200      	movs	r2, #0
 8001c18:	601a      	str	r2, [r3, #0]
 8001c1a:	605a      	str	r2, [r3, #4]
 8001c1c:	609a      	str	r2, [r3, #8]
 8001c1e:	60da      	str	r2, [r3, #12]
 8001c20:	611a      	str	r2, [r3, #16]
  LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
 8001c22:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8001c26:	2220      	movs	r2, #32
 8001c28:	2100      	movs	r1, #0
 8001c2a:	4618      	mov	r0, r3
 8001c2c:	f011 fb1c 	bl	8013268 <memset>
  LL_TIM_BDTR_InitTypeDef TIM_BDTRInitStruct = {0};
 8001c30:	f107 031c 	add.w	r3, r7, #28
 8001c34:	2230      	movs	r2, #48	; 0x30
 8001c36:	2100      	movs	r1, #0
 8001c38:	4618      	mov	r0, r3
 8001c3a:	f011 fb15 	bl	8013268 <memset>

  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001c3e:	1d3b      	adds	r3, r7, #4
 8001c40:	2200      	movs	r2, #0
 8001c42:	601a      	str	r2, [r3, #0]
 8001c44:	605a      	str	r2, [r3, #4]
 8001c46:	609a      	str	r2, [r3, #8]
 8001c48:	60da      	str	r2, [r3, #12]
 8001c4a:	611a      	str	r2, [r3, #16]
 8001c4c:	615a      	str	r2, [r3, #20]
  /* Peripheral clock enable */
  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM1);
 8001c4e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8001c52:	f7ff fec3 	bl	80019dc <LL_APB2_GRP1_EnableClock>

  /* TIM1 interrupt Init */
  NVIC_SetPriority(TIM1_TRG_COM_TIM17_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),15, 0));
 8001c56:	f7ff fe1f 	bl	8001898 <__NVIC_GetPriorityGrouping>
 8001c5a:	4603      	mov	r3, r0
 8001c5c:	2200      	movs	r2, #0
 8001c5e:	210f      	movs	r1, #15
 8001c60:	4618      	mov	r0, r3
 8001c62:	f7ff fe6f 	bl	8001944 <NVIC_EncodePriority>
 8001c66:	4603      	mov	r3, r0
 8001c68:	4619      	mov	r1, r3
 8001c6a:	201a      	movs	r0, #26
 8001c6c:	f7ff fe40 	bl	80018f0 <__NVIC_SetPriority>
  NVIC_EnableIRQ(TIM1_TRG_COM_TIM17_IRQn);
 8001c70:	201a      	movs	r0, #26
 8001c72:	f7ff fe1f 	bl	80018b4 <__NVIC_EnableIRQ>

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  TIM_InitStruct.Prescaler = 0;
 8001c76:	2300      	movs	r3, #0
 8001c78:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
  TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
 8001c7c:	2300      	movs	r3, #0
 8001c7e:	673b      	str	r3, [r7, #112]	; 0x70
  TIM_InitStruct.Autoreload = 65535;
 8001c80:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001c84:	677b      	str	r3, [r7, #116]	; 0x74
  TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
 8001c86:	2300      	movs	r3, #0
 8001c88:	67bb      	str	r3, [r7, #120]	; 0x78
  TIM_InitStruct.RepetitionCounter = 0;
 8001c8a:	2300      	movs	r3, #0
 8001c8c:	67fb      	str	r3, [r7, #124]	; 0x7c
  LL_TIM_Init(TIM1, &TIM_InitStruct);
 8001c8e:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8001c92:	4619      	mov	r1, r3
 8001c94:	4841      	ldr	r0, [pc, #260]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001c96:	f005 fac7 	bl	8007228 <LL_TIM_Init>
  LL_TIM_SetClockSource(TIM1, LL_TIM_CLOCKSOURCE_INTERNAL);
 8001c9a:	2100      	movs	r1, #0
 8001c9c:	483f      	ldr	r0, [pc, #252]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001c9e:	f7ff ff69 	bl	8001b74 <LL_TIM_SetClockSource>
  LL_TIM_DisableARRPreload(TIM1);
 8001ca2:	483e      	ldr	r0, [pc, #248]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001ca4:	f7ff feb3 	bl	8001a0e <LL_TIM_DisableARRPreload>
  LL_TIM_OC_EnablePreload(TIM1, LL_TIM_CHANNEL_CH1);
 8001ca8:	2101      	movs	r1, #1
 8001caa:	483c      	ldr	r0, [pc, #240]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001cac:	f7ff ff12 	bl	8001ad4 <LL_TIM_OC_EnablePreload>
  TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM1;
 8001cb0:	2360      	movs	r3, #96	; 0x60
 8001cb2:	64fb      	str	r3, [r7, #76]	; 0x4c
  TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_DISABLE;
 8001cb4:	2300      	movs	r3, #0
 8001cb6:	653b      	str	r3, [r7, #80]	; 0x50
  TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_DISABLE;
 8001cb8:	2300      	movs	r3, #0
 8001cba:	657b      	str	r3, [r7, #84]	; 0x54
  TIM_OC_InitStruct.CompareValue = 0;
 8001cbc:	2300      	movs	r3, #0
 8001cbe:	65bb      	str	r3, [r7, #88]	; 0x58
  TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_HIGH;
 8001cc0:	2300      	movs	r3, #0
 8001cc2:	65fb      	str	r3, [r7, #92]	; 0x5c
  TIM_OC_InitStruct.OCNPolarity = LL_TIM_OCPOLARITY_HIGH;
 8001cc4:	2300      	movs	r3, #0
 8001cc6:	663b      	str	r3, [r7, #96]	; 0x60
  TIM_OC_InitStruct.OCIdleState = LL_TIM_OCIDLESTATE_LOW;
 8001cc8:	2300      	movs	r3, #0
 8001cca:	667b      	str	r3, [r7, #100]	; 0x64
  TIM_OC_InitStruct.OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
 8001ccc:	2300      	movs	r3, #0
 8001cce:	66bb      	str	r3, [r7, #104]	; 0x68
  LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
 8001cd0:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8001cd4:	461a      	mov	r2, r3
 8001cd6:	2101      	movs	r1, #1
 8001cd8:	4830      	ldr	r0, [pc, #192]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001cda:	f005 fb03 	bl	80072e4 <LL_TIM_OC_Init>
  LL_TIM_OC_DisableFast(TIM1, LL_TIM_CHANNEL_CH1);
 8001cde:	2101      	movs	r1, #1
 8001ce0:	482e      	ldr	r0, [pc, #184]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001ce2:	f7ff fea5 	bl	8001a30 <LL_TIM_OC_DisableFast>
  LL_TIM_OC_EnablePreload(TIM1, LL_TIM_CHANNEL_CH3);
 8001ce6:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001cea:	482c      	ldr	r0, [pc, #176]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001cec:	f7ff fef2 	bl	8001ad4 <LL_TIM_OC_EnablePreload>
  LL_TIM_OC_Init(TIM1, LL_TIM_CHANNEL_CH3, &TIM_OC_InitStruct);
 8001cf0:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8001cf4:	461a      	mov	r2, r3
 8001cf6:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001cfa:	4828      	ldr	r0, [pc, #160]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001cfc:	f005 faf2 	bl	80072e4 <LL_TIM_OC_Init>
  LL_TIM_OC_DisableFast(TIM1, LL_TIM_CHANNEL_CH3);
 8001d00:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001d04:	4825      	ldr	r0, [pc, #148]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001d06:	f7ff fe93 	bl	8001a30 <LL_TIM_OC_DisableFast>
  LL_TIM_SetTriggerOutput(TIM1, LL_TIM_TRGO_RESET);
 8001d0a:	2100      	movs	r1, #0
 8001d0c:	4823      	ldr	r0, [pc, #140]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001d0e:	f7ff ff46 	bl	8001b9e <LL_TIM_SetTriggerOutput>
  LL_TIM_SetTriggerOutput2(TIM1, LL_TIM_TRGO2_RESET);
 8001d12:	2100      	movs	r1, #0
 8001d14:	4821      	ldr	r0, [pc, #132]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001d16:	f7ff ff55 	bl	8001bc4 <LL_TIM_SetTriggerOutput2>
  LL_TIM_DisableMasterSlaveMode(TIM1);
 8001d1a:	4820      	ldr	r0, [pc, #128]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001d1c:	f7ff ff65 	bl	8001bea <LL_TIM_DisableMasterSlaveMode>
  TIM_BDTRInitStruct.OSSRState = LL_TIM_OSSR_DISABLE;
 8001d20:	2300      	movs	r3, #0
 8001d22:	61fb      	str	r3, [r7, #28]
  TIM_BDTRInitStruct.OSSIState = LL_TIM_OSSI_DISABLE;
 8001d24:	2300      	movs	r3, #0
 8001d26:	623b      	str	r3, [r7, #32]
  TIM_BDTRInitStruct.LockLevel = LL_TIM_LOCKLEVEL_OFF;
 8001d28:	2300      	movs	r3, #0
 8001d2a:	627b      	str	r3, [r7, #36]	; 0x24
  TIM_BDTRInitStruct.DeadTime = 0;
 8001d2c:	2300      	movs	r3, #0
 8001d2e:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
  TIM_BDTRInitStruct.BreakState = LL_TIM_BREAK_DISABLE;
 8001d32:	2300      	movs	r3, #0
 8001d34:	857b      	strh	r3, [r7, #42]	; 0x2a
  TIM_BDTRInitStruct.BreakPolarity = LL_TIM_BREAK_POLARITY_HIGH;
 8001d36:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001d3a:	62fb      	str	r3, [r7, #44]	; 0x2c
  TIM_BDTRInitStruct.BreakFilter = LL_TIM_BREAK_FILTER_FDIV1;
 8001d3c:	2300      	movs	r3, #0
 8001d3e:	633b      	str	r3, [r7, #48]	; 0x30
  TIM_BDTRInitStruct.BreakAFMode = LL_TIM_BREAK_AFMODE_INPUT;
 8001d40:	2300      	movs	r3, #0
 8001d42:	637b      	str	r3, [r7, #52]	; 0x34
  TIM_BDTRInitStruct.Break2State = LL_TIM_BREAK2_DISABLE;
 8001d44:	2300      	movs	r3, #0
 8001d46:	63bb      	str	r3, [r7, #56]	; 0x38
  TIM_BDTRInitStruct.Break2Polarity = LL_TIM_BREAK2_POLARITY_HIGH;
 8001d48:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8001d4c:	63fb      	str	r3, [r7, #60]	; 0x3c
  TIM_BDTRInitStruct.Break2Filter = LL_TIM_BREAK2_FILTER_FDIV1;
 8001d4e:	2300      	movs	r3, #0
 8001d50:	643b      	str	r3, [r7, #64]	; 0x40
  TIM_BDTRInitStruct.Break2AFMode = LL_TIM_BREAK_AFMODE_INPUT;
 8001d52:	2300      	movs	r3, #0
 8001d54:	647b      	str	r3, [r7, #68]	; 0x44
  TIM_BDTRInitStruct.AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
 8001d56:	2300      	movs	r3, #0
 8001d58:	64bb      	str	r3, [r7, #72]	; 0x48
  LL_TIM_BDTR_Init(TIM1, &TIM_BDTRInitStruct);
 8001d5a:	f107 031c 	add.w	r3, r7, #28
 8001d5e:	4619      	mov	r1, r3
 8001d60:	480e      	ldr	r0, [pc, #56]	; (8001d9c <MX_TIM1_Init+0x190>)
 8001d62:	f005 fb1f 	bl	80073a4 <LL_TIM_BDTR_Init>
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */
  LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOA);
 8001d66:	2001      	movs	r0, #1
 8001d68:	f7ff fe1f 	bl	80019aa <LL_AHB2_GRP1_EnableClock>
    /**TIM1 GPIO Configuration
    PA8     ------> TIM1_CH1
    PA10     ------> TIM1_CH3
    */
  GPIO_InitStruct.Pin = M_LEFT_PWM_Pin|M_RIGHT_PWM_Pin;
 8001d6c:	f44f 63a0 	mov.w	r3, #1280	; 0x500
 8001d70:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8001d72:	2302      	movs	r3, #2
 8001d74:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
 8001d76:	2300      	movs	r3, #0
 8001d78:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8001d7a:	2300      	movs	r3, #0
 8001d7c:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 8001d7e:	2300      	movs	r3, #0
 8001d80:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
 8001d82:	2301      	movs	r3, #1
 8001d84:	61bb      	str	r3, [r7, #24]
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001d86:	1d3b      	adds	r3, r7, #4
 8001d88:	4619      	mov	r1, r3
 8001d8a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001d8e:	f005 f93e 	bl	800700e <LL_GPIO_Init>

}
 8001d92:	bf00      	nop
 8001d94:	3780      	adds	r7, #128	; 0x80
 8001d96:	46bd      	mov	sp, r7
 8001d98:	bd80      	pop	{r7, pc}
 8001d9a:	bf00      	nop
 8001d9c:	40012c00 	.word	0x40012c00

08001da0 <LL_AHB2_GRP1_EnableClock>:
{
 8001da0:	b480      	push	{r7}
 8001da2:	b085      	sub	sp, #20
 8001da4:	af00      	add	r7, sp, #0
 8001da6:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 8001da8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001dac:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001dae:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001db2:	687b      	ldr	r3, [r7, #4]
 8001db4:	4313      	orrs	r3, r2
 8001db6:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8001db8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001dbc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001dbe:	687b      	ldr	r3, [r7, #4]
 8001dc0:	4013      	ands	r3, r2
 8001dc2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8001dc4:	68fb      	ldr	r3, [r7, #12]
}
 8001dc6:	bf00      	nop
 8001dc8:	3714      	adds	r7, #20
 8001dca:	46bd      	mov	sp, r7
 8001dcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001dd0:	4770      	bx	lr

08001dd2 <LL_APB1_GRP2_EnableClock>:
{
 8001dd2:	b480      	push	{r7}
 8001dd4:	b085      	sub	sp, #20
 8001dd6:	af00      	add	r7, sp, #0
 8001dd8:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1ENR2, Periphs);
 8001dda:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001dde:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8001de0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001de4:	687b      	ldr	r3, [r7, #4]
 8001de6:	4313      	orrs	r3, r2
 8001de8:	65cb      	str	r3, [r1, #92]	; 0x5c
  tmpreg = READ_BIT(RCC->APB1ENR2, Periphs);
 8001dea:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001dee:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8001df0:	687b      	ldr	r3, [r7, #4]
 8001df2:	4013      	ands	r3, r2
 8001df4:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8001df6:	68fb      	ldr	r3, [r7, #12]
}
 8001df8:	bf00      	nop
 8001dfa:	3714      	adds	r7, #20
 8001dfc:	46bd      	mov	sp, r7
 8001dfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e02:	4770      	bx	lr

08001e04 <MX_LPUART1_UART_Init>:
UART_HandleTypeDef hlpuart1;

/* LPUART1 init function */

void MX_LPUART1_UART_Init(void)
{
 8001e04:	b580      	push	{r7, lr}
 8001e06:	af00      	add	r7, sp, #0
  /* USER CODE END LPUART1_Init 0 */

  /* USER CODE BEGIN LPUART1_Init 1 */

  /* USER CODE END LPUART1_Init 1 */
  hlpuart1.Instance = LPUART1;
 8001e08:	4b22      	ldr	r3, [pc, #136]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e0a:	4a23      	ldr	r2, [pc, #140]	; (8001e98 <MX_LPUART1_UART_Init+0x94>)
 8001e0c:	601a      	str	r2, [r3, #0]
  hlpuart1.Init.BaudRate = 209700;
 8001e0e:	4b21      	ldr	r3, [pc, #132]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e10:	4a22      	ldr	r2, [pc, #136]	; (8001e9c <MX_LPUART1_UART_Init+0x98>)
 8001e12:	605a      	str	r2, [r3, #4]
  hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
 8001e14:	4b1f      	ldr	r3, [pc, #124]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e16:	2200      	movs	r2, #0
 8001e18:	609a      	str	r2, [r3, #8]
  hlpuart1.Init.StopBits = UART_STOPBITS_1;
 8001e1a:	4b1e      	ldr	r3, [pc, #120]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e1c:	2200      	movs	r2, #0
 8001e1e:	60da      	str	r2, [r3, #12]
  hlpuart1.Init.Parity = UART_PARITY_NONE;
 8001e20:	4b1c      	ldr	r3, [pc, #112]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e22:	2200      	movs	r2, #0
 8001e24:	611a      	str	r2, [r3, #16]
  hlpuart1.Init.Mode = UART_MODE_TX_RX;
 8001e26:	4b1b      	ldr	r3, [pc, #108]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e28:	220c      	movs	r2, #12
 8001e2a:	615a      	str	r2, [r3, #20]
  hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001e2c:	4b19      	ldr	r3, [pc, #100]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e2e:	2200      	movs	r2, #0
 8001e30:	619a      	str	r2, [r3, #24]
  hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001e32:	4b18      	ldr	r3, [pc, #96]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e34:	2200      	movs	r2, #0
 8001e36:	621a      	str	r2, [r3, #32]
  hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8001e38:	4b16      	ldr	r3, [pc, #88]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e3a:	2200      	movs	r2, #0
 8001e3c:	625a      	str	r2, [r3, #36]	; 0x24
  hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001e3e:	4b15      	ldr	r3, [pc, #84]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e40:	2200      	movs	r2, #0
 8001e42:	629a      	str	r2, [r3, #40]	; 0x28
  hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
 8001e44:	4b13      	ldr	r3, [pc, #76]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e46:	2200      	movs	r2, #0
 8001e48:	665a      	str	r2, [r3, #100]	; 0x64
  if (HAL_UART_Init(&hlpuart1) != HAL_OK)
 8001e4a:	4812      	ldr	r0, [pc, #72]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e4c:	f003 ffd0 	bl	8005df0 <HAL_UART_Init>
 8001e50:	4603      	mov	r3, r0
 8001e52:	2b00      	cmp	r3, #0
 8001e54:	d001      	beq.n	8001e5a <MX_LPUART1_UART_Init+0x56>
  {
    Error_Handler();
 8001e56:	f7ff fa47 	bl	80012e8 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001e5a:	2100      	movs	r1, #0
 8001e5c:	480d      	ldr	r0, [pc, #52]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e5e:	f004 fc91 	bl	8006784 <HAL_UARTEx_SetTxFifoThreshold>
 8001e62:	4603      	mov	r3, r0
 8001e64:	2b00      	cmp	r3, #0
 8001e66:	d001      	beq.n	8001e6c <MX_LPUART1_UART_Init+0x68>
  {
    Error_Handler();
 8001e68:	f7ff fa3e 	bl	80012e8 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001e6c:	2100      	movs	r1, #0
 8001e6e:	4809      	ldr	r0, [pc, #36]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e70:	f004 fcc6 	bl	8006800 <HAL_UARTEx_SetRxFifoThreshold>
 8001e74:	4603      	mov	r3, r0
 8001e76:	2b00      	cmp	r3, #0
 8001e78:	d001      	beq.n	8001e7e <MX_LPUART1_UART_Init+0x7a>
  {
    Error_Handler();
 8001e7a:	f7ff fa35 	bl	80012e8 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
 8001e7e:	4805      	ldr	r0, [pc, #20]	; (8001e94 <MX_LPUART1_UART_Init+0x90>)
 8001e80:	f004 fc47 	bl	8006712 <HAL_UARTEx_DisableFifoMode>
 8001e84:	4603      	mov	r3, r0
 8001e86:	2b00      	cmp	r3, #0
 8001e88:	d001      	beq.n	8001e8e <MX_LPUART1_UART_Init+0x8a>
  {
    Error_Handler();
 8001e8a:	f7ff fa2d 	bl	80012e8 <Error_Handler>
  }
  /* USER CODE BEGIN LPUART1_Init 2 */

  /* USER CODE END LPUART1_Init 2 */

}
 8001e8e:	bf00      	nop
 8001e90:	bd80      	pop	{r7, pc}
 8001e92:	bf00      	nop
 8001e94:	2000418c 	.word	0x2000418c
 8001e98:	40008000 	.word	0x40008000
 8001e9c:	00033324 	.word	0x00033324

08001ea0 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8001ea0:	b580      	push	{r7, lr}
 8001ea2:	b09c      	sub	sp, #112	; 0x70
 8001ea4:	af00      	add	r7, sp, #0
 8001ea6:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001ea8:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8001eac:	2200      	movs	r2, #0
 8001eae:	601a      	str	r2, [r3, #0]
 8001eb0:	605a      	str	r2, [r3, #4]
 8001eb2:	609a      	str	r2, [r3, #8]
 8001eb4:	60da      	str	r2, [r3, #12]
 8001eb6:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001eb8:	f107 030c 	add.w	r3, r7, #12
 8001ebc:	2250      	movs	r2, #80	; 0x50
 8001ebe:	2100      	movs	r1, #0
 8001ec0:	4618      	mov	r0, r3
 8001ec2:	f011 f9d1 	bl	8013268 <memset>
  if(uartHandle->Instance==LPUART1)
 8001ec6:	687b      	ldr	r3, [r7, #4]
 8001ec8:	681b      	ldr	r3, [r3, #0]
 8001eca:	4a16      	ldr	r2, [pc, #88]	; (8001f24 <HAL_UART_MspInit+0x84>)
 8001ecc:	4293      	cmp	r3, r2
 8001ece:	d124      	bne.n	8001f1a <HAL_UART_MspInit+0x7a>

  /* USER CODE END LPUART1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LPUART1;
 8001ed0:	2302      	movs	r3, #2
 8001ed2:	60fb      	str	r3, [r7, #12]
    PeriphClkInitStruct.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1;
 8001ed4:	2300      	movs	r3, #0
 8001ed6:	62bb      	str	r3, [r7, #40]	; 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001ed8:	f107 030c 	add.w	r3, r7, #12
 8001edc:	4618      	mov	r0, r3
 8001ede:	f003 f9c4 	bl	800526a <HAL_RCCEx_PeriphCLKConfig>
 8001ee2:	4603      	mov	r3, r0
 8001ee4:	2b00      	cmp	r3, #0
 8001ee6:	d001      	beq.n	8001eec <HAL_UART_MspInit+0x4c>
    {
      Error_Handler();
 8001ee8:	f7ff f9fe 	bl	80012e8 <Error_Handler>
    }

    /* LPUART1 clock enable */
    __HAL_RCC_LPUART1_CLK_ENABLE();
 8001eec:	2001      	movs	r0, #1
 8001eee:	f7ff ff70 	bl	8001dd2 <LL_APB1_GRP2_EnableClock>

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8001ef2:	2002      	movs	r0, #2
 8001ef4:	f7ff ff54 	bl	8001da0 <LL_AHB2_GRP1_EnableClock>
    /**LPUART1 GPIO Configuration
    PB10     ------> LPUART1_RX
    PB11     ------> LPUART1_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 8001ef8:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8001efc:	65fb      	str	r3, [r7, #92]	; 0x5c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001efe:	2302      	movs	r3, #2
 8001f00:	663b      	str	r3, [r7, #96]	; 0x60
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001f02:	2300      	movs	r3, #0
 8001f04:	667b      	str	r3, [r7, #100]	; 0x64
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001f06:	2303      	movs	r3, #3
 8001f08:	66bb      	str	r3, [r7, #104]	; 0x68
    GPIO_InitStruct.Alternate = GPIO_AF8_LPUART1;
 8001f0a:	2308      	movs	r3, #8
 8001f0c:	66fb      	str	r3, [r7, #108]	; 0x6c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001f0e:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8001f12:	4619      	mov	r1, r3
 8001f14:	4804      	ldr	r0, [pc, #16]	; (8001f28 <HAL_UART_MspInit+0x88>)
 8001f16:	f001 fa53 	bl	80033c0 <HAL_GPIO_Init>

  /* USER CODE BEGIN LPUART1_MspInit 1 */

  /* USER CODE END LPUART1_MspInit 1 */
  }
}
 8001f1a:	bf00      	nop
 8001f1c:	3770      	adds	r7, #112	; 0x70
 8001f1e:	46bd      	mov	sp, r7
 8001f20:	bd80      	pop	{r7, pc}
 8001f22:	bf00      	nop
 8001f24:	40008000 	.word	0x40008000
 8001f28:	48000400 	.word	0x48000400

08001f2c <LL_AHB2_GRP1_EnableClock>:
{
 8001f2c:	b480      	push	{r7}
 8001f2e:	b085      	sub	sp, #20
 8001f30:	af00      	add	r7, sp, #0
 8001f32:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHB2ENR, Periphs);
 8001f34:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001f38:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001f3a:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001f3e:	687b      	ldr	r3, [r7, #4]
 8001f40:	4313      	orrs	r3, r2
 8001f42:	64cb      	str	r3, [r1, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8001f44:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001f48:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001f4a:	687b      	ldr	r3, [r7, #4]
 8001f4c:	4013      	ands	r3, r2
 8001f4e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8001f50:	68fb      	ldr	r3, [r7, #12]
}
 8001f52:	bf00      	nop
 8001f54:	3714      	adds	r7, #20
 8001f56:	46bd      	mov	sp, r7
 8001f58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f5c:	4770      	bx	lr

08001f5e <LL_APB1_GRP1_EnableClock>:
{
 8001f5e:	b480      	push	{r7}
 8001f60:	b085      	sub	sp, #20
 8001f62:	af00      	add	r7, sp, #0
 8001f64:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->APB1ENR1, Periphs);
 8001f66:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001f6a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001f6c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8001f70:	687b      	ldr	r3, [r7, #4]
 8001f72:	4313      	orrs	r3, r2
 8001f74:	658b      	str	r3, [r1, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8001f76:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001f7a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001f7c:	687b      	ldr	r3, [r7, #4]
 8001f7e:	4013      	ands	r3, r2
 8001f80:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
 8001f82:	68fb      	ldr	r3, [r7, #12]
}
 8001f84:	bf00      	nop
 8001f86:	3714      	adds	r7, #20
 8001f88:	46bd      	mov	sp, r7
 8001f8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f8e:	4770      	bx	lr

08001f90 <MX_USB_PCD_Init>:
PCD_HandleTypeDef hpcd_USB_FS;

/* USB init function */

void MX_USB_PCD_Init(void)
{
 8001f90:	b580      	push	{r7, lr}
 8001f92:	af00      	add	r7, sp, #0
  /* USER CODE END USB_Init 0 */

  /* USER CODE BEGIN USB_Init 1 */

  /* USER CODE END USB_Init 1 */
  hpcd_USB_FS.Instance = USB;
 8001f94:	4b10      	ldr	r3, [pc, #64]	; (8001fd8 <MX_USB_PCD_Init+0x48>)
 8001f96:	4a11      	ldr	r2, [pc, #68]	; (8001fdc <MX_USB_PCD_Init+0x4c>)
 8001f98:	601a      	str	r2, [r3, #0]
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8001f9a:	4b0f      	ldr	r3, [pc, #60]	; (8001fd8 <MX_USB_PCD_Init+0x48>)
 8001f9c:	2208      	movs	r2, #8
 8001f9e:	605a      	str	r2, [r3, #4]
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8001fa0:	4b0d      	ldr	r3, [pc, #52]	; (8001fd8 <MX_USB_PCD_Init+0x48>)
 8001fa2:	2202      	movs	r2, #2
 8001fa4:	609a      	str	r2, [r3, #8]
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8001fa6:	4b0c      	ldr	r3, [pc, #48]	; (8001fd8 <MX_USB_PCD_Init+0x48>)
 8001fa8:	2202      	movs	r2, #2
 8001faa:	611a      	str	r2, [r3, #16]
  hpcd_USB_FS.Init.Sof_enable = DISABLE;
 8001fac:	4b0a      	ldr	r3, [pc, #40]	; (8001fd8 <MX_USB_PCD_Init+0x48>)
 8001fae:	2200      	movs	r2, #0
 8001fb0:	615a      	str	r2, [r3, #20]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 8001fb2:	4b09      	ldr	r3, [pc, #36]	; (8001fd8 <MX_USB_PCD_Init+0x48>)
 8001fb4:	2200      	movs	r2, #0
 8001fb6:	619a      	str	r2, [r3, #24]
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
 8001fb8:	4b07      	ldr	r3, [pc, #28]	; (8001fd8 <MX_USB_PCD_Init+0x48>)
 8001fba:	2200      	movs	r2, #0
 8001fbc:	61da      	str	r2, [r3, #28]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 8001fbe:	4b06      	ldr	r3, [pc, #24]	; (8001fd8 <MX_USB_PCD_Init+0x48>)
 8001fc0:	2200      	movs	r2, #0
 8001fc2:	621a      	str	r2, [r3, #32]
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 8001fc4:	4804      	ldr	r0, [pc, #16]	; (8001fd8 <MX_USB_PCD_Init+0x48>)
 8001fc6:	f001 fc0d 	bl	80037e4 <HAL_PCD_Init>
 8001fca:	4603      	mov	r3, r0
 8001fcc:	2b00      	cmp	r3, #0
 8001fce:	d001      	beq.n	8001fd4 <MX_USB_PCD_Init+0x44>
  {
    Error_Handler();
 8001fd0:	f7ff f98a 	bl	80012e8 <Error_Handler>
  }
  /* USER CODE BEGIN USB_Init 2 */

  /* USER CODE END USB_Init 2 */

}
 8001fd4:	bf00      	nop
 8001fd6:	bd80      	pop	{r7, pc}
 8001fd8:	20004220 	.word	0x20004220
 8001fdc:	40006800 	.word	0x40006800

08001fe0 <HAL_PCD_MspInit>:

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8001fe0:	b580      	push	{r7, lr}
 8001fe2:	b088      	sub	sp, #32
 8001fe4:	af00      	add	r7, sp, #0
 8001fe6:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001fe8:	f107 030c 	add.w	r3, r7, #12
 8001fec:	2200      	movs	r2, #0
 8001fee:	601a      	str	r2, [r3, #0]
 8001ff0:	605a      	str	r2, [r3, #4]
 8001ff2:	609a      	str	r2, [r3, #8]
 8001ff4:	60da      	str	r2, [r3, #12]
 8001ff6:	611a      	str	r2, [r3, #16]
  if(pcdHandle->Instance==USB)
 8001ff8:	687b      	ldr	r3, [r7, #4]
 8001ffa:	681b      	ldr	r3, [r3, #0]
 8001ffc:	4a0f      	ldr	r2, [pc, #60]	; (800203c <HAL_PCD_MspInit+0x5c>)
 8001ffe:	4293      	cmp	r3, r2
 8002000:	d118      	bne.n	8002034 <HAL_PCD_MspInit+0x54>
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8002002:	2001      	movs	r0, #1
 8002004:	f7ff ff92 	bl	8001f2c <LL_AHB2_GRP1_EnableClock>
    /**USB GPIO Configuration
    PA11     ------> USB_DM
    PA12     ------> USB_DP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8002008:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 800200c:	60fb      	str	r3, [r7, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800200e:	2302      	movs	r3, #2
 8002010:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002012:	2300      	movs	r3, #0
 8002014:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8002016:	2300      	movs	r3, #0
 8002018:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Alternate = GPIO_AF10_USB;
 800201a:	230a      	movs	r3, #10
 800201c:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800201e:	f107 030c 	add.w	r3, r7, #12
 8002022:	4619      	mov	r1, r3
 8002024:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8002028:	f001 f9ca 	bl	80033c0 <HAL_GPIO_Init>

    /* USB clock enable */
    __HAL_RCC_USB_CLK_ENABLE();
 800202c:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 8002030:	f7ff ff95 	bl	8001f5e <LL_APB1_GRP1_EnableClock>
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 8002034:	bf00      	nop
 8002036:	3720      	adds	r7, #32
 8002038:	46bd      	mov	sp, r7
 800203a:	bd80      	pop	{r7, pc}
 800203c:	40006800 	.word	0x40006800

08002040 <CopyDataInit>:
  bl LoopCopyDataInit
.endm

.section  .text.data_initializers
CopyDataInit:
  ldr r4, [r2, r3]
 8002040:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8002042:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8002044:	3304      	adds	r3, #4

08002046 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8002046:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8002048:	428c      	cmp	r4, r1
  bcc  CopyDataInit
 800204a:	d3f9      	bcc.n	8002040 <CopyDataInit>
  bx lr
 800204c:	4770      	bx	lr

0800204e <FillZerobss>:

FillZerobss:
  str  r3, [r0]
 800204e:	6003      	str	r3, [r0, #0]
  adds r0, r0, #4
 8002050:	3004      	adds	r0, #4

08002052 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r0, r1
 8002052:	4288      	cmp	r0, r1
  bcc FillZerobss
 8002054:	d3fb      	bcc.n	800204e <FillZerobss>
  bx lr
 8002056:	4770      	bx	lr

08002058 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8002058:	480c      	ldr	r0, [pc, #48]	; (800208c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800205a:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 800205c:	f7ff fbca 	bl	80017f4 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  INIT_DATA _sdata, _edata, _sidata
 8002060:	480b      	ldr	r0, [pc, #44]	; (8002090 <LoopForever+0x6>)
 8002062:	490c      	ldr	r1, [pc, #48]	; (8002094 <LoopForever+0xa>)
 8002064:	4a0c      	ldr	r2, [pc, #48]	; (8002098 <LoopForever+0xe>)
 8002066:	2300      	movs	r3, #0
 8002068:	f7ff ffed 	bl	8002046 <LoopCopyDataInit>
  INIT_DATA _sMB_MEM2, _eMB_MEM2, _siMB_MEM2
 800206c:	480b      	ldr	r0, [pc, #44]	; (800209c <LoopForever+0x12>)
 800206e:	490c      	ldr	r1, [pc, #48]	; (80020a0 <LoopForever+0x16>)
 8002070:	4a0c      	ldr	r2, [pc, #48]	; (80020a4 <LoopForever+0x1a>)
 8002072:	2300      	movs	r3, #0
 8002074:	f7ff ffe7 	bl	8002046 <LoopCopyDataInit>

/* Zero fill the bss segments. */
  INIT_BSS _sbss, _ebss
 8002078:	480b      	ldr	r0, [pc, #44]	; (80020a8 <LoopForever+0x1e>)
 800207a:	490c      	ldr	r1, [pc, #48]	; (80020ac <LoopForever+0x22>)
 800207c:	2300      	movs	r3, #0
 800207e:	f7ff ffe8 	bl	8002052 <LoopFillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8002082:	f011 f8f9 	bl	8013278 <__libc_init_array>
/* Call the application s entry point.*/
  bl main
 8002086:	f7ff f853 	bl	8001130 <main>

0800208a <LoopForever>:

LoopForever:
  b LoopForever
 800208a:	e7fe      	b.n	800208a <LoopForever>
  ldr   r0, =_estack
 800208c:	20030000 	.word	0x20030000
  INIT_DATA _sdata, _edata, _sidata
 8002090:	20000008 	.word	0x20000008
 8002094:	20000118 	.word	0x20000118
 8002098:	080135dc 	.word	0x080135dc
  INIT_DATA _sMB_MEM2, _eMB_MEM2, _siMB_MEM2
 800209c:	20030000 	.word	0x20030000
 80020a0:	20030000 	.word	0x20030000
 80020a4:	080136ec 	.word	0x080136ec
  INIT_BSS _sbss, _ebss
 80020a8:	20000118 	.word	0x20000118
 80020ac:	20007954 	.word	0x20007954

080020b0 <ADC1_IRQHandler>:
 * @retval None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80020b0:	e7fe      	b.n	80020b0 <ADC1_IRQHandler>
	...

080020b4 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80020b4:	b580      	push	{r7, lr}
 80020b6:	b082      	sub	sp, #8
 80020b8:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 80020ba:	2300      	movs	r3, #0
 80020bc:	71fb      	strb	r3, [r7, #7]
#if (DATA_CACHE_ENABLE == 0U)
  __HAL_FLASH_DATA_CACHE_DISABLE();
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80020be:	4b0c      	ldr	r3, [pc, #48]	; (80020f0 <HAL_Init+0x3c>)
 80020c0:	681b      	ldr	r3, [r3, #0]
 80020c2:	4a0b      	ldr	r2, [pc, #44]	; (80020f0 <HAL_Init+0x3c>)
 80020c4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80020c8:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80020ca:	2003      	movs	r0, #3
 80020cc:	f000 ff89 	bl	8002fe2 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80020d0:	200f      	movs	r0, #15
 80020d2:	f7ff fb0f 	bl	80016f4 <HAL_InitTick>
 80020d6:	4603      	mov	r3, r0
 80020d8:	2b00      	cmp	r3, #0
 80020da:	d002      	beq.n	80020e2 <HAL_Init+0x2e>
  {
    status = HAL_ERROR;
 80020dc:	2301      	movs	r3, #1
 80020de:	71fb      	strb	r3, [r7, #7]
 80020e0:	e001      	b.n	80020e6 <HAL_Init+0x32>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 80020e2:	f7ff fae7 	bl	80016b4 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 80020e6:	79fb      	ldrb	r3, [r7, #7]
}
 80020e8:	4618      	mov	r0, r3
 80020ea:	3708      	adds	r7, #8
 80020ec:	46bd      	mov	sp, r7
 80020ee:	bd80      	pop	{r7, pc}
 80020f0:	58004000 	.word	0x58004000

080020f4 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 80020f4:	b480      	push	{r7}
 80020f6:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 80020f8:	4b06      	ldr	r3, [pc, #24]	; (8002114 <HAL_IncTick+0x20>)
 80020fa:	781b      	ldrb	r3, [r3, #0]
 80020fc:	461a      	mov	r2, r3
 80020fe:	4b06      	ldr	r3, [pc, #24]	; (8002118 <HAL_IncTick+0x24>)
 8002100:	681b      	ldr	r3, [r3, #0]
 8002102:	4413      	add	r3, r2
 8002104:	4a04      	ldr	r2, [pc, #16]	; (8002118 <HAL_IncTick+0x24>)
 8002106:	6013      	str	r3, [r2, #0]
}
 8002108:	bf00      	nop
 800210a:	46bd      	mov	sp, r7
 800210c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002110:	4770      	bx	lr
 8002112:	bf00      	nop
 8002114:	20000020 	.word	0x20000020
 8002118:	20004514 	.word	0x20004514

0800211c <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 800211c:	b480      	push	{r7}
 800211e:	af00      	add	r7, sp, #0
  return uwTick;
 8002120:	4b03      	ldr	r3, [pc, #12]	; (8002130 <HAL_GetTick+0x14>)
 8002122:	681b      	ldr	r3, [r3, #0]
}
 8002124:	4618      	mov	r0, r3
 8002126:	46bd      	mov	sp, r7
 8002128:	f85d 7b04 	ldr.w	r7, [sp], #4
 800212c:	4770      	bx	lr
 800212e:	bf00      	nop
 8002130:	20004514 	.word	0x20004514

08002134 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
 8002134:	b480      	push	{r7}
 8002136:	af00      	add	r7, sp, #0
  return uwTickPrio;
 8002138:	4b03      	ldr	r3, [pc, #12]	; (8002148 <HAL_GetTickPrio+0x14>)
 800213a:	681b      	ldr	r3, [r3, #0]
}
 800213c:	4618      	mov	r0, r3
 800213e:	46bd      	mov	sp, r7
 8002140:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002144:	4770      	bx	lr
 8002146:	bf00      	nop
 8002148:	2000001c 	.word	0x2000001c

0800214c <LL_ADC_SetCommonClock>:
  *
  *         (*) Value available on all STM32 devices except: STM32W10xxx, STM32W15xxx.
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
{
 800214c:	b480      	push	{r7}
 800214e:	b083      	sub	sp, #12
 8002150:	af00      	add	r7, sp, #0
 8002152:	6078      	str	r0, [r7, #4]
 8002154:	6039      	str	r1, [r7, #0]
#if defined(ADC_SUPPORT_2_5_MSPS)
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_PRESC, CommonClock);
#else
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8002156:	687b      	ldr	r3, [r7, #4]
 8002158:	689b      	ldr	r3, [r3, #8]
 800215a:	f423 127c 	bic.w	r2, r3, #4128768	; 0x3f0000
 800215e:	683b      	ldr	r3, [r7, #0]
 8002160:	431a      	orrs	r2, r3
 8002162:	687b      	ldr	r3, [r7, #4]
 8002164:	609a      	str	r2, [r3, #8]
#endif /* ADC_SUPPORT_2_5_MSPS */
}
 8002166:	bf00      	nop
 8002168:	370c      	adds	r7, #12
 800216a:	46bd      	mov	sp, r7
 800216c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002170:	4770      	bx	lr

08002172 <LL_ADC_SetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
 8002172:	b480      	push	{r7}
 8002174:	b083      	sub	sp, #12
 8002176:	af00      	add	r7, sp, #0
 8002178:	6078      	str	r0, [r7, #4]
 800217a:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 800217c:	687b      	ldr	r3, [r7, #4]
 800217e:	689b      	ldr	r3, [r3, #8]
 8002180:	f023 72e0 	bic.w	r2, r3, #29360128	; 0x1c00000
 8002184:	683b      	ldr	r3, [r7, #0]
 8002186:	431a      	orrs	r2, r3
 8002188:	687b      	ldr	r3, [r7, #4]
 800218a:	609a      	str	r2, [r3, #8]
}
 800218c:	bf00      	nop
 800218e:	370c      	adds	r7, #12
 8002190:	46bd      	mov	sp, r7
 8002192:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002196:	4770      	bx	lr

08002198 <LL_ADC_GetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(const ADC_Common_TypeDef *ADCxy_COMMON)
{
 8002198:	b480      	push	{r7}
 800219a:	b083      	sub	sp, #12
 800219c:	af00      	add	r7, sp, #0
 800219e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80021a0:	687b      	ldr	r3, [r7, #4]
 80021a2:	689b      	ldr	r3, [r3, #8]
 80021a4:	f003 73e0 	and.w	r3, r3, #29360128	; 0x1c00000
}
 80021a8:	4618      	mov	r0, r3
 80021aa:	370c      	adds	r7, #12
 80021ac:	46bd      	mov	sp, r7
 80021ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80021b2:	4770      	bx	lr

080021b4 <LL_ADC_SetOffset>:
  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
{
 80021b4:	b480      	push	{r7}
 80021b6:	b087      	sub	sp, #28
 80021b8:	af00      	add	r7, sp, #0
 80021ba:	60f8      	str	r0, [r7, #12]
 80021bc:	60b9      	str	r1, [r7, #8]
 80021be:	607a      	str	r2, [r7, #4]
 80021c0:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80021c2:	68fb      	ldr	r3, [r7, #12]
 80021c4:	3360      	adds	r3, #96	; 0x60
 80021c6:	461a      	mov	r2, r3
 80021c8:	68bb      	ldr	r3, [r7, #8]
 80021ca:	009b      	lsls	r3, r3, #2
 80021cc:	4413      	add	r3, r2
 80021ce:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 80021d0:	697b      	ldr	r3, [r7, #20]
 80021d2:	681a      	ldr	r2, [r3, #0]
 80021d4:	4b08      	ldr	r3, [pc, #32]	; (80021f8 <LL_ADC_SetOffset+0x44>)
 80021d6:	4013      	ands	r3, r2
 80021d8:	687a      	ldr	r2, [r7, #4]
 80021da:	f002 41f8 	and.w	r1, r2, #2080374784	; 0x7c000000
 80021de:	683a      	ldr	r2, [r7, #0]
 80021e0:	430a      	orrs	r2, r1
 80021e2:	4313      	orrs	r3, r2
 80021e4:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 80021e8:	697b      	ldr	r3, [r7, #20]
 80021ea:	601a      	str	r2, [r3, #0]
             ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,
             ADC_OFR1_OFFSET1_EN | (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
}
 80021ec:	bf00      	nop
 80021ee:	371c      	adds	r7, #28
 80021f0:	46bd      	mov	sp, r7
 80021f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80021f6:	4770      	bx	lr
 80021f8:	03fff000 	.word	0x03fff000

080021fc <LL_ADC_GetOffsetChannel>:
  *         (4) For ADC channel read back from ADC register,
  *             comparison with internal channel parameter to be done
  *             using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(const ADC_TypeDef *ADCx, uint32_t Offsety)
{
 80021fc:	b480      	push	{r7}
 80021fe:	b085      	sub	sp, #20
 8002200:	af00      	add	r7, sp, #0
 8002202:	6078      	str	r0, [r7, #4]
 8002204:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8002206:	687b      	ldr	r3, [r7, #4]
 8002208:	3360      	adds	r3, #96	; 0x60
 800220a:	461a      	mov	r2, r3
 800220c:	683b      	ldr	r3, [r7, #0]
 800220e:	009b      	lsls	r3, r3, #2
 8002210:	4413      	add	r3, r2
 8002212:	60fb      	str	r3, [r7, #12]

  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8002214:	68fb      	ldr	r3, [r7, #12]
 8002216:	681b      	ldr	r3, [r3, #0]
 8002218:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
}
 800221c:	4618      	mov	r0, r3
 800221e:	3714      	adds	r7, #20
 8002220:	46bd      	mov	sp, r7
 8002222:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002226:	4770      	bx	lr

08002228 <LL_ADC_SetOffsetState>:
  *         @arg @ref LL_ADC_OFFSET_DISABLE
  *         @arg @ref LL_ADC_OFFSET_ENABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetState(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)
{
 8002228:	b480      	push	{r7}
 800222a:	b087      	sub	sp, #28
 800222c:	af00      	add	r7, sp, #0
 800222e:	60f8      	str	r0, [r7, #12]
 8002230:	60b9      	str	r1, [r7, #8]
 8002232:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8002234:	68fb      	ldr	r3, [r7, #12]
 8002236:	3360      	adds	r3, #96	; 0x60
 8002238:	461a      	mov	r2, r3
 800223a:	68bb      	ldr	r3, [r7, #8]
 800223c:	009b      	lsls	r3, r3, #2
 800223e:	4413      	add	r3, r2
 8002240:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 8002242:	697b      	ldr	r3, [r7, #20]
 8002244:	681b      	ldr	r3, [r3, #0]
 8002246:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 800224a:	687b      	ldr	r3, [r7, #4]
 800224c:	431a      	orrs	r2, r3
 800224e:	697b      	ldr	r3, [r7, #20]
 8002250:	601a      	str	r2, [r3, #0]
             ADC_OFR1_OFFSET1_EN,
             OffsetState);
}
 8002252:	bf00      	nop
 8002254:	371c      	adds	r7, #28
 8002256:	46bd      	mov	sp, r7
 8002258:	f85d 7b04 	ldr.w	r7, [sp], #4
 800225c:	4770      	bx	lr

0800225e <LL_ADC_REG_SetSequencerRanks>:
  *         (7) On STM32WB devices (except devices: STM32WB10xx, STM32WB15xx, STM32WB1Mxx) fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)).
  *             Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
 800225e:	b480      	push	{r7}
 8002260:	b087      	sub	sp, #28
 8002262:	af00      	add	r7, sp, #0
 8002264:	60f8      	str	r0, [r7, #12]
 8002266:	60b9      	str	r1, [r7, #8]
 8002268:	607a      	str	r2, [r7, #4]
#else
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 800226a:	68fb      	ldr	r3, [r7, #12]
 800226c:	3330      	adds	r3, #48	; 0x30
 800226e:	461a      	mov	r2, r3
 8002270:	68bb      	ldr	r3, [r7, #8]
 8002272:	0a1b      	lsrs	r3, r3, #8
 8002274:	009b      	lsls	r3, r3, #2
 8002276:	f003 030c 	and.w	r3, r3, #12
 800227a:	4413      	add	r3, r2
 800227c:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 800227e:	697b      	ldr	r3, [r7, #20]
 8002280:	681a      	ldr	r2, [r3, #0]
 8002282:	68bb      	ldr	r3, [r7, #8]
 8002284:	f003 031f 	and.w	r3, r3, #31
 8002288:	211f      	movs	r1, #31
 800228a:	fa01 f303 	lsl.w	r3, r1, r3
 800228e:	43db      	mvns	r3, r3
 8002290:	401a      	ands	r2, r3
 8002292:	687b      	ldr	r3, [r7, #4]
 8002294:	0e9b      	lsrs	r3, r3, #26
 8002296:	f003 011f 	and.w	r1, r3, #31
 800229a:	68bb      	ldr	r3, [r7, #8]
 800229c:	f003 031f 	and.w	r3, r3, #31
 80022a0:	fa01 f303 	lsl.w	r3, r1, r3
 80022a4:	431a      	orrs	r2, r3
 80022a6:	697b      	ldr	r3, [r7, #20]
 80022a8:	601a      	str	r2, [r3, #0]
             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
#endif /* ADC_SUPPORT_2_5_MSPS */
}
 80022aa:	bf00      	nop
 80022ac:	371c      	adds	r7, #28
 80022ae:	46bd      	mov	sp, r7
 80022b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80022b4:	4770      	bx	lr

080022b6 <LL_ADC_SetChannelSamplingTime>:
  *         @arg @ref LL_ADC_SAMPLINGTIME_247CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_640CYCLES_5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 80022b6:	b480      	push	{r7}
 80022b8:	b087      	sub	sp, #28
 80022ba:	af00      	add	r7, sp, #0
 80022bc:	60f8      	str	r0, [r7, #12]
 80022be:	60b9      	str	r1, [r7, #8]
 80022c0:	607a      	str	r2, [r7, #4]
#else
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80022c2:	68fb      	ldr	r3, [r7, #12]
 80022c4:	3314      	adds	r3, #20
 80022c6:	461a      	mov	r2, r3
 80022c8:	68bb      	ldr	r3, [r7, #8]
 80022ca:	0e5b      	lsrs	r3, r3, #25
 80022cc:	009b      	lsls	r3, r3, #2
 80022ce:	f003 0304 	and.w	r3, r3, #4
 80022d2:	4413      	add	r3, r2
 80022d4:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 80022d6:	697b      	ldr	r3, [r7, #20]
 80022d8:	681a      	ldr	r2, [r3, #0]
 80022da:	68bb      	ldr	r3, [r7, #8]
 80022dc:	0d1b      	lsrs	r3, r3, #20
 80022de:	f003 031f 	and.w	r3, r3, #31
 80022e2:	2107      	movs	r1, #7
 80022e4:	fa01 f303 	lsl.w	r3, r1, r3
 80022e8:	43db      	mvns	r3, r3
 80022ea:	401a      	ands	r2, r3
 80022ec:	68bb      	ldr	r3, [r7, #8]
 80022ee:	0d1b      	lsrs	r3, r3, #20
 80022f0:	f003 031f 	and.w	r3, r3, #31
 80022f4:	6879      	ldr	r1, [r7, #4]
 80022f6:	fa01 f303 	lsl.w	r3, r1, r3
 80022fa:	431a      	orrs	r2, r3
 80022fc:	697b      	ldr	r3, [r7, #20]
 80022fe:	601a      	str	r2, [r3, #0]
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
#endif /* ADC_SUPPORT_2_5_MSPS */
}
 8002300:	bf00      	nop
 8002302:	371c      	adds	r7, #28
 8002304:	46bd      	mov	sp, r7
 8002306:	f85d 7b04 	ldr.w	r7, [sp], #4
 800230a:	4770      	bx	lr

0800230c <LL_ADC_SetChannelSingleDiff>:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
 800230c:	b480      	push	{r7}
 800230e:	b085      	sub	sp, #20
 8002310:	af00      	add	r7, sp, #0
 8002312:	60f8      	str	r0, [r7, #12]
 8002314:	60b9      	str	r1, [r7, #8]
 8002316:	607a      	str	r2, [r7, #4]
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  MODIFY_REG(ADCx->DIFSEL,
 8002318:	68fb      	ldr	r3, [r7, #12]
 800231a:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 800231e:	68bb      	ldr	r3, [r7, #8]
 8002320:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002324:	43db      	mvns	r3, r3
 8002326:	401a      	ands	r2, r3
 8002328:	687b      	ldr	r3, [r7, #4]
 800232a:	f003 0318 	and.w	r3, r3, #24
 800232e:	4908      	ldr	r1, [pc, #32]	; (8002350 <LL_ADC_SetChannelSingleDiff+0x44>)
 8002330:	40d9      	lsrs	r1, r3
 8002332:	68bb      	ldr	r3, [r7, #8]
 8002334:	400b      	ands	r3, r1
 8002336:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800233a:	431a      	orrs	r2, r3
 800233c:	68fb      	ldr	r3, [r7, #12]
 800233e:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
             Channel & ADC_SINGLEDIFF_CHANNEL_MASK,
             (Channel & ADC_SINGLEDIFF_CHANNEL_MASK) & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
}
 8002342:	bf00      	nop
 8002344:	3714      	adds	r7, #20
 8002346:	46bd      	mov	sp, r7
 8002348:	f85d 7b04 	ldr.w	r7, [sp], #4
 800234c:	4770      	bx	lr
 800234e:	bf00      	nop
 8002350:	0007ffff 	.word	0x0007ffff

08002354 <LL_ADC_DisableDeepPowerDown>:
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
 8002354:	b480      	push	{r7}
 8002356:	b083      	sub	sp, #12
 8002358:	af00      	add	r7, sp, #0
 800235a:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 800235c:	687b      	ldr	r3, [r7, #4]
 800235e:	689b      	ldr	r3, [r3, #8]
 8002360:	f023 4320 	bic.w	r3, r3, #2684354560	; 0xa0000000
 8002364:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8002368:	687a      	ldr	r2, [r7, #4]
 800236a:	6093      	str	r3, [r2, #8]
}
 800236c:	bf00      	nop
 800236e:	370c      	adds	r7, #12
 8002370:	46bd      	mov	sp, r7
 8002372:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002376:	4770      	bx	lr

08002378 <LL_ADC_IsDeepPowerDownEnabled>:
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(const ADC_TypeDef *ADCx)
{
 8002378:	b480      	push	{r7}
 800237a:	b083      	sub	sp, #12
 800237c:	af00      	add	r7, sp, #0
 800237e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 8002380:	687b      	ldr	r3, [r7, #4]
 8002382:	689b      	ldr	r3, [r3, #8]
 8002384:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8002388:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800238c:	d101      	bne.n	8002392 <LL_ADC_IsDeepPowerDownEnabled+0x1a>
 800238e:	2301      	movs	r3, #1
 8002390:	e000      	b.n	8002394 <LL_ADC_IsDeepPowerDownEnabled+0x1c>
 8002392:	2300      	movs	r3, #0
}
 8002394:	4618      	mov	r0, r3
 8002396:	370c      	adds	r7, #12
 8002398:	46bd      	mov	sp, r7
 800239a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800239e:	4770      	bx	lr

080023a0 <LL_ADC_EnableInternalRegulator>:
  * @rmtoll CR       ADVREGEN       LL_ADC_EnableInternalRegulator
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
{
 80023a0:	b480      	push	{r7}
 80023a2:	b083      	sub	sp, #12
 80023a4:	af00      	add	r7, sp, #0
 80023a6:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 80023a8:	687b      	ldr	r3, [r7, #4]
 80023aa:	689b      	ldr	r3, [r3, #8]
 80023ac:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 80023b0:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80023b4:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
 80023b8:	687b      	ldr	r3, [r7, #4]
 80023ba:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADVREGEN);
}
 80023bc:	bf00      	nop
 80023be:	370c      	adds	r7, #12
 80023c0:	46bd      	mov	sp, r7
 80023c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023c6:	4770      	bx	lr

080023c8 <LL_ADC_IsInternalRegulatorEnabled>:
  * @rmtoll CR       ADVREGEN       LL_ADC_IsInternalRegulatorEnabled
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(const ADC_TypeDef *ADCx)
{
 80023c8:	b480      	push	{r7}
 80023ca:	b083      	sub	sp, #12
 80023cc:	af00      	add	r7, sp, #0
 80023ce:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 80023d0:	687b      	ldr	r3, [r7, #4]
 80023d2:	689b      	ldr	r3, [r3, #8]
 80023d4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80023d8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80023dc:	d101      	bne.n	80023e2 <LL_ADC_IsInternalRegulatorEnabled+0x1a>
 80023de:	2301      	movs	r3, #1
 80023e0:	e000      	b.n	80023e4 <LL_ADC_IsInternalRegulatorEnabled+0x1c>
 80023e2:	2300      	movs	r3, #0
}
 80023e4:	4618      	mov	r0, r3
 80023e6:	370c      	adds	r7, #12
 80023e8:	46bd      	mov	sp, r7
 80023ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023ee:	4770      	bx	lr

080023f0 <LL_ADC_IsEnabled>:
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(const ADC_TypeDef *ADCx)
{
 80023f0:	b480      	push	{r7}
 80023f2:	b083      	sub	sp, #12
 80023f4:	af00      	add	r7, sp, #0
 80023f6:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80023f8:	687b      	ldr	r3, [r7, #4]
 80023fa:	689b      	ldr	r3, [r3, #8]
 80023fc:	f003 0301 	and.w	r3, r3, #1
 8002400:	2b01      	cmp	r3, #1
 8002402:	d101      	bne.n	8002408 <LL_ADC_IsEnabled+0x18>
 8002404:	2301      	movs	r3, #1
 8002406:	e000      	b.n	800240a <LL_ADC_IsEnabled+0x1a>
 8002408:	2300      	movs	r3, #0
}
 800240a:	4618      	mov	r0, r3
 800240c:	370c      	adds	r7, #12
 800240e:	46bd      	mov	sp, r7
 8002410:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002414:	4770      	bx	lr

08002416 <LL_ADC_REG_IsConversionOngoing>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
 8002416:	b480      	push	{r7}
 8002418:	b083      	sub	sp, #12
 800241a:	af00      	add	r7, sp, #0
 800241c:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800241e:	687b      	ldr	r3, [r7, #4]
 8002420:	689b      	ldr	r3, [r3, #8]
 8002422:	f003 0304 	and.w	r3, r3, #4
 8002426:	2b04      	cmp	r3, #4
 8002428:	d101      	bne.n	800242e <LL_ADC_REG_IsConversionOngoing+0x18>
 800242a:	2301      	movs	r3, #1
 800242c:	e000      	b.n	8002430 <LL_ADC_REG_IsConversionOngoing+0x1a>
 800242e:	2300      	movs	r3, #0
}
 8002430:	4618      	mov	r0, r3
 8002432:	370c      	adds	r7, #12
 8002434:	46bd      	mov	sp, r7
 8002436:	f85d 7b04 	ldr.w	r7, [sp], #4
 800243a:	4770      	bx	lr

0800243c <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
 800243c:	b480      	push	{r7}
 800243e:	b083      	sub	sp, #12
 8002440:	af00      	add	r7, sp, #0
 8002442:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8002444:	687b      	ldr	r3, [r7, #4]
 8002446:	689b      	ldr	r3, [r3, #8]
 8002448:	f003 0308 	and.w	r3, r3, #8
 800244c:	2b08      	cmp	r3, #8
 800244e:	d101      	bne.n	8002454 <LL_ADC_INJ_IsConversionOngoing+0x18>
 8002450:	2301      	movs	r3, #1
 8002452:	e000      	b.n	8002456 <LL_ADC_INJ_IsConversionOngoing+0x1a>
 8002454:	2300      	movs	r3, #0
}
 8002456:	4618      	mov	r0, r3
 8002458:	370c      	adds	r7, #12
 800245a:	46bd      	mov	sp, r7
 800245c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002460:	4770      	bx	lr
	...

08002464 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8002464:	b580      	push	{r7, lr}
 8002466:	b088      	sub	sp, #32
 8002468:	af00      	add	r7, sp, #0
 800246a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800246c:	2300      	movs	r3, #0
 800246e:	77fb      	strb	r3, [r7, #31]
  uint32_t tmpCFGR = 0UL;
 8002470:	2300      	movs	r3, #0
 8002472:	61bb      	str	r3, [r7, #24]
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8002474:	2300      	movs	r3, #0
 8002476:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;
#endif /* ADC_SUPPORT_2_5_MSPS */

  /* Check ADC handle */
  if (hadc == NULL)
 8002478:	687b      	ldr	r3, [r7, #4]
 800247a:	2b00      	cmp	r3, #0
 800247c:	d101      	bne.n	8002482 <HAL_ADC_Init+0x1e>
  {
    return HAL_ERROR;
 800247e:	2301      	movs	r3, #1
 8002480:	e12e      	b.n	80026e0 <HAL_ADC_Init+0x27c>
    }
  }
#else
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8002482:	687b      	ldr	r3, [r7, #4]
 8002484:	691b      	ldr	r3, [r3, #16]
 8002486:	2b00      	cmp	r3, #0
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
#endif /* ADC_SUPPORT_2_5_MSPS */

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8002488:	687b      	ldr	r3, [r7, #4]
 800248a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800248c:	2b00      	cmp	r3, #0
 800248e:	d109      	bne.n	80024a4 <HAL_ADC_Init+0x40>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8002490:	6878      	ldr	r0, [r7, #4]
 8002492:	f7fe fa63 	bl	800095c <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8002496:	687b      	ldr	r3, [r7, #4]
 8002498:	2200      	movs	r2, #0
 800249a:	659a      	str	r2, [r3, #88]	; 0x58

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 800249c:	687b      	ldr	r3, [r7, #4]
 800249e:	2200      	movs	r2, #0
 80024a0:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* - Exit from deep power-down mode and ADC voltage regulator enable        */
#if defined(ADC_SUPPORT_2_5_MSPS)
  /* Feature "deep power-down" not available on ADC peripheral of this STM32WB device */
#else
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 80024a4:	687b      	ldr	r3, [r7, #4]
 80024a6:	681b      	ldr	r3, [r3, #0]
 80024a8:	4618      	mov	r0, r3
 80024aa:	f7ff ff65 	bl	8002378 <LL_ADC_IsDeepPowerDownEnabled>
 80024ae:	4603      	mov	r3, r0
 80024b0:	2b00      	cmp	r3, #0
 80024b2:	d004      	beq.n	80024be <HAL_ADC_Init+0x5a>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
 80024b4:	687b      	ldr	r3, [r7, #4]
 80024b6:	681b      	ldr	r3, [r3, #0]
 80024b8:	4618      	mov	r0, r3
 80024ba:	f7ff ff4b 	bl	8002354 <LL_ADC_DisableDeepPowerDown>
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }
#endif /* ADC_SUPPORT_2_5_MSPS */

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 80024be:	687b      	ldr	r3, [r7, #4]
 80024c0:	681b      	ldr	r3, [r3, #0]
 80024c2:	4618      	mov	r0, r3
 80024c4:	f7ff ff80 	bl	80023c8 <LL_ADC_IsInternalRegulatorEnabled>
 80024c8:	4603      	mov	r3, r0
 80024ca:	2b00      	cmp	r3, #0
 80024cc:	d115      	bne.n	80024fa <HAL_ADC_Init+0x96>
  {
    /* Enable ADC internal voltage regulator */
    LL_ADC_EnableInternalRegulator(hadc->Instance);
 80024ce:	687b      	ldr	r3, [r7, #4]
 80024d0:	681b      	ldr	r3, [r3, #0]
 80024d2:	4618      	mov	r0, r3
 80024d4:	f7ff ff64 	bl	80023a0 <LL_ADC_EnableInternalRegulator>

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 80024d8:	4b83      	ldr	r3, [pc, #524]	; (80026e8 <HAL_ADC_Init+0x284>)
 80024da:	681b      	ldr	r3, [r3, #0]
 80024dc:	099b      	lsrs	r3, r3, #6
 80024de:	4a83      	ldr	r2, [pc, #524]	; (80026ec <HAL_ADC_Init+0x288>)
 80024e0:	fba2 2303 	umull	r2, r3, r2, r3
 80024e4:	099b      	lsrs	r3, r3, #6
 80024e6:	3301      	adds	r3, #1
 80024e8:	005b      	lsls	r3, r3, #1
 80024ea:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 80024ec:	e002      	b.n	80024f4 <HAL_ADC_Init+0x90>
    {
      wait_loop_index--;
 80024ee:	68bb      	ldr	r3, [r7, #8]
 80024f0:	3b01      	subs	r3, #1
 80024f2:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 80024f4:	68bb      	ldr	r3, [r7, #8]
 80024f6:	2b00      	cmp	r3, #0
 80024f8:	d1f9      	bne.n	80024ee <HAL_ADC_Init+0x8a>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 80024fa:	687b      	ldr	r3, [r7, #4]
 80024fc:	681b      	ldr	r3, [r3, #0]
 80024fe:	4618      	mov	r0, r3
 8002500:	f7ff ff62 	bl	80023c8 <LL_ADC_IsInternalRegulatorEnabled>
 8002504:	4603      	mov	r3, r0
 8002506:	2b00      	cmp	r3, #0
 8002508:	d10d      	bne.n	8002526 <HAL_ADC_Init+0xc2>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800250a:	687b      	ldr	r3, [r7, #4]
 800250c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800250e:	f043 0210 	orr.w	r2, r3, #16
 8002512:	687b      	ldr	r3, [r7, #4]
 8002514:	655a      	str	r2, [r3, #84]	; 0x54

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002516:	687b      	ldr	r3, [r7, #4]
 8002518:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800251a:	f043 0201 	orr.w	r2, r3, #1
 800251e:	687b      	ldr	r3, [r7, #4]
 8002520:	659a      	str	r2, [r3, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 8002522:	2301      	movs	r3, #1
 8002524:	77fb      	strb	r3, [r7, #31]

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8002526:	687b      	ldr	r3, [r7, #4]
 8002528:	681b      	ldr	r3, [r3, #0]
 800252a:	4618      	mov	r0, r3
 800252c:	f7ff ff73 	bl	8002416 <LL_ADC_REG_IsConversionOngoing>
 8002530:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8002532:	687b      	ldr	r3, [r7, #4]
 8002534:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002536:	f003 0310 	and.w	r3, r3, #16
 800253a:	2b00      	cmp	r3, #0
 800253c:	f040 80c7 	bne.w	80026ce <HAL_ADC_Init+0x26a>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 8002540:	697b      	ldr	r3, [r7, #20]
 8002542:	2b00      	cmp	r3, #0
 8002544:	f040 80c3 	bne.w	80026ce <HAL_ADC_Init+0x26a>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8002548:	687b      	ldr	r3, [r7, #4]
 800254a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800254c:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 8002550:	f043 0202 	orr.w	r2, r3, #2
 8002554:	687b      	ldr	r3, [r7, #4]
 8002556:	655a      	str	r2, [r3, #84]	; 0x54
    /* Configuration of common ADC parameters                                 */

    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8002558:	687b      	ldr	r3, [r7, #4]
 800255a:	681b      	ldr	r3, [r3, #0]
 800255c:	4618      	mov	r0, r3
 800255e:	f7ff ff47 	bl	80023f0 <LL_ADC_IsEnabled>
 8002562:	4603      	mov	r3, r0
 8002564:	2b00      	cmp	r3, #0
 8002566:	d10b      	bne.n	8002580 <HAL_ADC_Init+0x11c>
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8002568:	4861      	ldr	r0, [pc, #388]	; (80026f0 <HAL_ADC_Init+0x28c>)
 800256a:	f7ff ff41 	bl	80023f0 <LL_ADC_IsEnabled>
 800256e:	4603      	mov	r3, r0
 8002570:	2b00      	cmp	r3, #0
 8002572:	d105      	bne.n	8002580 <HAL_ADC_Init+0x11c>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8002574:	687b      	ldr	r3, [r7, #4]
 8002576:	685b      	ldr	r3, [r3, #4]
 8002578:	4619      	mov	r1, r3
 800257a:	485e      	ldr	r0, [pc, #376]	; (80026f4 <HAL_ADC_Init+0x290>)
 800257c:	f7ff fde6 	bl	800214c <LL_ADC_SetCommonClock>
    /*  - external trigger polarity                Init.ExternalTrigConvEdge  */
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR |= (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8002580:	687b      	ldr	r3, [r7, #4]
 8002582:	7e5b      	ldrb	r3, [r3, #25]
 8002584:	035a      	lsls	r2, r3, #13
                hadc->Init.Overrun                                                     |
 8002586:	687b      	ldr	r3, [r7, #4]
 8002588:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    tmpCFGR |= (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800258a:	431a      	orrs	r2, r3
                hadc->Init.DataAlign                                                   |
 800258c:	687b      	ldr	r3, [r7, #4]
 800258e:	68db      	ldr	r3, [r3, #12]
                hadc->Init.Overrun                                                     |
 8002590:	431a      	orrs	r2, r3
                hadc->Init.Resolution                                                  |
 8002592:	687b      	ldr	r3, [r7, #4]
 8002594:	689b      	ldr	r3, [r3, #8]
                hadc->Init.DataAlign                                                   |
 8002596:	431a      	orrs	r2, r3
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 8002598:	687b      	ldr	r3, [r7, #4]
 800259a:	f893 3020 	ldrb.w	r3, [r3, #32]
 800259e:	041b      	lsls	r3, r3, #16
                hadc->Init.Resolution                                                  |
 80025a0:	4313      	orrs	r3, r2
    tmpCFGR |= (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 80025a2:	69ba      	ldr	r2, [r7, #24]
 80025a4:	4313      	orrs	r3, r2
 80025a6:	61bb      	str	r3, [r7, #24]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80025a8:	687b      	ldr	r3, [r7, #4]
 80025aa:	f893 3020 	ldrb.w	r3, [r3, #32]
 80025ae:	2b01      	cmp	r3, #1
 80025b0:	d106      	bne.n	80025c0 <HAL_ADC_Init+0x15c>
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 80025b2:	687b      	ldr	r3, [r7, #4]
 80025b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80025b6:	3b01      	subs	r3, #1
 80025b8:	045b      	lsls	r3, r3, #17
 80025ba:	69ba      	ldr	r2, [r7, #24]
 80025bc:	4313      	orrs	r3, r2
 80025be:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80025c0:	687b      	ldr	r3, [r7, #4]
 80025c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80025c4:	2b00      	cmp	r3, #0
 80025c6:	d009      	beq.n	80025dc <HAL_ADC_Init+0x178>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 80025c8:	687b      	ldr	r3, [r7, #4]
 80025ca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80025cc:	f403 7270 	and.w	r2, r3, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 80025d0:	687b      	ldr	r3, [r7, #4]
 80025d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80025d4:	4313      	orrs	r3, r2
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 80025d6:	69ba      	ldr	r2, [r7, #24]
 80025d8:	4313      	orrs	r3, r2
 80025da:	61bb      	str	r3, [r7, #24]
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 80025dc:	687b      	ldr	r3, [r7, #4]
 80025de:	681b      	ldr	r3, [r3, #0]
 80025e0:	68da      	ldr	r2, [r3, #12]
 80025e2:	4b45      	ldr	r3, [pc, #276]	; (80026f8 <HAL_ADC_Init+0x294>)
 80025e4:	4013      	ands	r3, r2
 80025e6:	687a      	ldr	r2, [r7, #4]
 80025e8:	6812      	ldr	r2, [r2, #0]
 80025ea:	69b9      	ldr	r1, [r7, #24]
 80025ec:	430b      	orrs	r3, r1
 80025ee:	60d3      	str	r3, [r2, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 80025f0:	687b      	ldr	r3, [r7, #4]
 80025f2:	681b      	ldr	r3, [r3, #0]
 80025f4:	4618      	mov	r0, r3
 80025f6:	f7ff ff0e 	bl	8002416 <LL_ADC_REG_IsConversionOngoing>
 80025fa:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 80025fc:	687b      	ldr	r3, [r7, #4]
 80025fe:	681b      	ldr	r3, [r3, #0]
 8002600:	4618      	mov	r0, r3
 8002602:	f7ff ff1b 	bl	800243c <LL_ADC_INJ_IsConversionOngoing>
 8002606:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8002608:	693b      	ldr	r3, [r7, #16]
 800260a:	2b00      	cmp	r3, #0
 800260c:	d13d      	bne.n	800268a <HAL_ADC_Init+0x226>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 800260e:	68fb      	ldr	r3, [r7, #12]
 8002610:	2b00      	cmp	r3, #0
 8002612:	d13a      	bne.n	800268a <HAL_ADC_Init+0x226>
       )
    {
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8002614:	687b      	ldr	r3, [r7, #4]
 8002616:	7e1b      	ldrb	r3, [r3, #24]
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8002618:	039a      	lsls	r2, r3, #14
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 800261a:	687b      	ldr	r3, [r7, #4]
 800261c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8002620:	005b      	lsls	r3, r3, #1
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 8002622:	4313      	orrs	r3, r2
 8002624:	61bb      	str	r3, [r7, #24]

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8002626:	687b      	ldr	r3, [r7, #4]
 8002628:	681b      	ldr	r3, [r3, #0]
 800262a:	68db      	ldr	r3, [r3, #12]
 800262c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002630:	f023 0302 	bic.w	r3, r3, #2
 8002634:	687a      	ldr	r2, [r7, #4]
 8002636:	6812      	ldr	r2, [r2, #0]
 8002638:	69b9      	ldr	r1, [r7, #24]
 800263a:	430b      	orrs	r3, r1
 800263c:	60d3      	str	r3, [r2, #12]

      if (hadc->Init.OversamplingMode == ENABLE)
 800263e:	687b      	ldr	r3, [r7, #4]
 8002640:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8002644:	2b01      	cmp	r3, #1
 8002646:	d118      	bne.n	800267a <HAL_ADC_Init+0x216>
        /* Configuration of Oversampler:                                      */
        /*  - Oversampling Ratio                                              */
        /*  - Right bit shift                                                 */
        /*  - Triggered mode                                                  */
        /*  - Oversampling mode (continued/resumed)                           */
        MODIFY_REG(hadc->Instance->CFGR2,
 8002648:	687b      	ldr	r3, [r7, #4]
 800264a:	681b      	ldr	r3, [r3, #0]
 800264c:	691b      	ldr	r3, [r3, #16]
 800264e:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8002652:	f023 0304 	bic.w	r3, r3, #4
 8002656:	687a      	ldr	r2, [r7, #4]
 8002658:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 800265a:	687a      	ldr	r2, [r7, #4]
 800265c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800265e:	4311      	orrs	r1, r2
 8002660:	687a      	ldr	r2, [r7, #4]
 8002662:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8002664:	4311      	orrs	r1, r2
 8002666:	687a      	ldr	r2, [r7, #4]
 8002668:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800266a:	430a      	orrs	r2, r1
 800266c:	431a      	orrs	r2, r3
 800266e:	687b      	ldr	r3, [r7, #4]
 8002670:	681b      	ldr	r3, [r3, #0]
 8002672:	f042 0201 	orr.w	r2, r2, #1
 8002676:	611a      	str	r2, [r3, #16]
 8002678:	e007      	b.n	800268a <HAL_ADC_Init+0x226>
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 800267a:	687b      	ldr	r3, [r7, #4]
 800267c:	681b      	ldr	r3, [r3, #0]
 800267e:	691a      	ldr	r2, [r3, #16]
 8002680:	687b      	ldr	r3, [r7, #4]
 8002682:	681b      	ldr	r3, [r3, #0]
 8002684:	f022 0201 	bic.w	r2, r2, #1
 8002688:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 800268a:	687b      	ldr	r3, [r7, #4]
 800268c:	691b      	ldr	r3, [r3, #16]
 800268e:	2b01      	cmp	r3, #1
 8002690:	d10c      	bne.n	80026ac <HAL_ADC_Init+0x248>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8002692:	687b      	ldr	r3, [r7, #4]
 8002694:	681b      	ldr	r3, [r3, #0]
 8002696:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002698:	f023 010f 	bic.w	r1, r3, #15
 800269c:	687b      	ldr	r3, [r7, #4]
 800269e:	69db      	ldr	r3, [r3, #28]
 80026a0:	1e5a      	subs	r2, r3, #1
 80026a2:	687b      	ldr	r3, [r7, #4]
 80026a4:	681b      	ldr	r3, [r3, #0]
 80026a6:	430a      	orrs	r2, r1
 80026a8:	631a      	str	r2, [r3, #48]	; 0x30
 80026aa:	e007      	b.n	80026bc <HAL_ADC_Init+0x258>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 80026ac:	687b      	ldr	r3, [r7, #4]
 80026ae:	681b      	ldr	r3, [r3, #0]
 80026b0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80026b2:	687b      	ldr	r3, [r7, #4]
 80026b4:	681b      	ldr	r3, [r3, #0]
 80026b6:	f022 020f 	bic.w	r2, r2, #15
 80026ba:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 80026bc:	687b      	ldr	r3, [r7, #4]
 80026be:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80026c0:	f023 0303 	bic.w	r3, r3, #3
 80026c4:	f043 0201 	orr.w	r2, r3, #1
 80026c8:	687b      	ldr	r3, [r7, #4]
 80026ca:	655a      	str	r2, [r3, #84]	; 0x54
 80026cc:	e007      	b.n	80026de <HAL_ADC_Init+0x27a>
#endif /* ADC_SUPPORT_2_5_MSPS */
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80026ce:	687b      	ldr	r3, [r7, #4]
 80026d0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80026d2:	f043 0210 	orr.w	r2, r3, #16
 80026d6:	687b      	ldr	r3, [r7, #4]
 80026d8:	655a      	str	r2, [r3, #84]	; 0x54

    tmp_hal_status = HAL_ERROR;
 80026da:	2301      	movs	r3, #1
 80026dc:	77fb      	strb	r3, [r7, #31]
  }

  /* Return function status */
  return tmp_hal_status;
 80026de:	7ffb      	ldrb	r3, [r7, #31]
}
 80026e0:	4618      	mov	r0, r3
 80026e2:	3720      	adds	r7, #32
 80026e4:	46bd      	mov	sp, r7
 80026e6:	bd80      	pop	{r7, pc}
 80026e8:	20000018 	.word	0x20000018
 80026ec:	053e2d63 	.word	0x053e2d63
 80026f0:	50040000 	.word	0x50040000
 80026f4:	50040300 	.word	0x50040300
 80026f8:	fff0c007 	.word	0xfff0c007

080026fc <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, const ADC_ChannelConfTypeDef *sConfig)
{
 80026fc:	b580      	push	{r7, lr}
 80026fe:	b0b6      	sub	sp, #216	; 0xd8
 8002700:	af00      	add	r7, sp, #0
 8002702:	6078      	str	r0, [r7, #4]
 8002704:	6039      	str	r1, [r7, #0]
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
  
#else
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8002706:	2300      	movs	r3, #0
 8002708:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0;
 800270c:	2300      	movs	r3, #0
 800270e:	60fb      	str	r3, [r7, #12]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8002710:	687b      	ldr	r3, [r7, #4]
 8002712:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8002716:	2b01      	cmp	r3, #1
 8002718:	d101      	bne.n	800271e <HAL_ADC_ConfigChannel+0x22>
 800271a:	2302      	movs	r3, #2
 800271c:	e39f      	b.n	8002e5e <HAL_ADC_ConfigChannel+0x762>
 800271e:	687b      	ldr	r3, [r7, #4]
 8002720:	2201      	movs	r2, #1
 8002722:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8002726:	687b      	ldr	r3, [r7, #4]
 8002728:	681b      	ldr	r3, [r3, #0]
 800272a:	4618      	mov	r0, r3
 800272c:	f7ff fe73 	bl	8002416 <LL_ADC_REG_IsConversionOngoing>
 8002730:	4603      	mov	r3, r0
 8002732:	2b00      	cmp	r3, #0
 8002734:	f040 8384 	bne.w	8002e40 <HAL_ADC_ConfigChannel+0x744>
  {
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8002738:	687b      	ldr	r3, [r7, #4]
 800273a:	6818      	ldr	r0, [r3, #0]
 800273c:	683b      	ldr	r3, [r7, #0]
 800273e:	6859      	ldr	r1, [r3, #4]
 8002740:	683b      	ldr	r3, [r7, #0]
 8002742:	681b      	ldr	r3, [r3, #0]
 8002744:	461a      	mov	r2, r3
 8002746:	f7ff fd8a 	bl	800225e <LL_ADC_REG_SetSequencerRanks>
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
#if defined(ADC_SUPPORT_2_5_MSPS)
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
#else
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800274a:	687b      	ldr	r3, [r7, #4]
 800274c:	681b      	ldr	r3, [r3, #0]
 800274e:	4618      	mov	r0, r3
 8002750:	f7ff fe61 	bl	8002416 <LL_ADC_REG_IsConversionOngoing>
 8002754:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8002758:	687b      	ldr	r3, [r7, #4]
 800275a:	681b      	ldr	r3, [r3, #0]
 800275c:	4618      	mov	r0, r3
 800275e:	f7ff fe6d 	bl	800243c <LL_ADC_INJ_IsConversionOngoing>
 8002762:	f8c7 00cc 	str.w	r0, [r7, #204]	; 0xcc
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8002766:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 800276a:	2b00      	cmp	r3, #0
 800276c:	f040 81a6 	bne.w	8002abc <HAL_ADC_ConfigChannel+0x3c0>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8002770:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8002774:	2b00      	cmp	r3, #0
 8002776:	f040 81a1 	bne.w	8002abc <HAL_ADC_ConfigChannel+0x3c0>
       )
#endif /* ADC_SUPPORT_2_5_MSPS */
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 800277a:	687b      	ldr	r3, [r7, #4]
 800277c:	6818      	ldr	r0, [r3, #0]
 800277e:	683b      	ldr	r3, [r7, #0]
 8002780:	6819      	ldr	r1, [r3, #0]
 8002782:	683b      	ldr	r3, [r7, #0]
 8002784:	689b      	ldr	r3, [r3, #8]
 8002786:	461a      	mov	r2, r3
 8002788:	f7ff fd95 	bl	80022b6 <LL_ADC_SetChannelSamplingTime>

      /* Configure the offset: offset enable/disable, channel, offset value */

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 800278c:	683b      	ldr	r3, [r7, #0]
 800278e:	695a      	ldr	r2, [r3, #20]
 8002790:	687b      	ldr	r3, [r7, #4]
 8002792:	681b      	ldr	r3, [r3, #0]
 8002794:	68db      	ldr	r3, [r3, #12]
 8002796:	08db      	lsrs	r3, r3, #3
 8002798:	f003 0303 	and.w	r3, r3, #3
 800279c:	005b      	lsls	r3, r3, #1
 800279e:	fa02 f303 	lsl.w	r3, r2, r3
 80027a2:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 80027a6:	683b      	ldr	r3, [r7, #0]
 80027a8:	691b      	ldr	r3, [r3, #16]
 80027aa:	2b04      	cmp	r3, #4
 80027ac:	d00a      	beq.n	80027c4 <HAL_ADC_ConfigChannel+0xc8>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 80027ae:	687b      	ldr	r3, [r7, #4]
 80027b0:	6818      	ldr	r0, [r3, #0]
 80027b2:	683b      	ldr	r3, [r7, #0]
 80027b4:	6919      	ldr	r1, [r3, #16]
 80027b6:	683b      	ldr	r3, [r7, #0]
 80027b8:	681a      	ldr	r2, [r3, #0]
 80027ba:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80027be:	f7ff fcf9 	bl	80021b4 <LL_ADC_SetOffset>
 80027c2:	e17b      	b.n	8002abc <HAL_ADC_ConfigChannel+0x3c0>
      }
      else
      {
        /* Scan each offset register to check if the selected channel is targeted. */
        /* If this is the case, the corresponding offset number is disabled.       */
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80027c4:	687b      	ldr	r3, [r7, #4]
 80027c6:	681b      	ldr	r3, [r3, #0]
 80027c8:	2100      	movs	r1, #0
 80027ca:	4618      	mov	r0, r3
 80027cc:	f7ff fd16 	bl	80021fc <LL_ADC_GetOffsetChannel>
 80027d0:	4603      	mov	r3, r0
 80027d2:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80027d6:	2b00      	cmp	r3, #0
 80027d8:	d10a      	bne.n	80027f0 <HAL_ADC_ConfigChannel+0xf4>
 80027da:	687b      	ldr	r3, [r7, #4]
 80027dc:	681b      	ldr	r3, [r3, #0]
 80027de:	2100      	movs	r1, #0
 80027e0:	4618      	mov	r0, r3
 80027e2:	f7ff fd0b 	bl	80021fc <LL_ADC_GetOffsetChannel>
 80027e6:	4603      	mov	r3, r0
 80027e8:	0e9b      	lsrs	r3, r3, #26
 80027ea:	f003 021f 	and.w	r2, r3, #31
 80027ee:	e01e      	b.n	800282e <HAL_ADC_ConfigChannel+0x132>
 80027f0:	687b      	ldr	r3, [r7, #4]
 80027f2:	681b      	ldr	r3, [r3, #0]
 80027f4:	2100      	movs	r1, #0
 80027f6:	4618      	mov	r0, r3
 80027f8:	f7ff fd00 	bl	80021fc <LL_ADC_GetOffsetChannel>
 80027fc:	4603      	mov	r3, r0
 80027fe:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002802:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8002806:	fa93 f3a3 	rbit	r3, r3
 800280a:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  return result;
 800280e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8002812:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  if (value == 0U)
 8002816:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800281a:	2b00      	cmp	r3, #0
 800281c:	d101      	bne.n	8002822 <HAL_ADC_ConfigChannel+0x126>
    return 32U;
 800281e:	2320      	movs	r3, #32
 8002820:	e004      	b.n	800282c <HAL_ADC_ConfigChannel+0x130>
  return __builtin_clz(value);
 8002822:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8002826:	fab3 f383 	clz	r3, r3
 800282a:	b2db      	uxtb	r3, r3
 800282c:	461a      	mov	r2, r3
 800282e:	683b      	ldr	r3, [r7, #0]
 8002830:	681b      	ldr	r3, [r3, #0]
 8002832:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002836:	2b00      	cmp	r3, #0
 8002838:	d105      	bne.n	8002846 <HAL_ADC_ConfigChannel+0x14a>
 800283a:	683b      	ldr	r3, [r7, #0]
 800283c:	681b      	ldr	r3, [r3, #0]
 800283e:	0e9b      	lsrs	r3, r3, #26
 8002840:	f003 031f 	and.w	r3, r3, #31
 8002844:	e018      	b.n	8002878 <HAL_ADC_ConfigChannel+0x17c>
 8002846:	683b      	ldr	r3, [r7, #0]
 8002848:	681b      	ldr	r3, [r3, #0]
 800284a:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800284e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8002852:	fa93 f3a3 	rbit	r3, r3
 8002856:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  return result;
 800285a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800285e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  if (value == 0U)
 8002862:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8002866:	2b00      	cmp	r3, #0
 8002868:	d101      	bne.n	800286e <HAL_ADC_ConfigChannel+0x172>
    return 32U;
 800286a:	2320      	movs	r3, #32
 800286c:	e004      	b.n	8002878 <HAL_ADC_ConfigChannel+0x17c>
  return __builtin_clz(value);
 800286e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8002872:	fab3 f383 	clz	r3, r3
 8002876:	b2db      	uxtb	r3, r3
 8002878:	429a      	cmp	r2, r3
 800287a:	d106      	bne.n	800288a <HAL_ADC_ConfigChannel+0x18e>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_1, LL_ADC_OFFSET_DISABLE);
 800287c:	687b      	ldr	r3, [r7, #4]
 800287e:	681b      	ldr	r3, [r3, #0]
 8002880:	2200      	movs	r2, #0
 8002882:	2100      	movs	r1, #0
 8002884:	4618      	mov	r0, r3
 8002886:	f7ff fccf 	bl	8002228 <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800288a:	687b      	ldr	r3, [r7, #4]
 800288c:	681b      	ldr	r3, [r3, #0]
 800288e:	2101      	movs	r1, #1
 8002890:	4618      	mov	r0, r3
 8002892:	f7ff fcb3 	bl	80021fc <LL_ADC_GetOffsetChannel>
 8002896:	4603      	mov	r3, r0
 8002898:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800289c:	2b00      	cmp	r3, #0
 800289e:	d10a      	bne.n	80028b6 <HAL_ADC_ConfigChannel+0x1ba>
 80028a0:	687b      	ldr	r3, [r7, #4]
 80028a2:	681b      	ldr	r3, [r3, #0]
 80028a4:	2101      	movs	r1, #1
 80028a6:	4618      	mov	r0, r3
 80028a8:	f7ff fca8 	bl	80021fc <LL_ADC_GetOffsetChannel>
 80028ac:	4603      	mov	r3, r0
 80028ae:	0e9b      	lsrs	r3, r3, #26
 80028b0:	f003 021f 	and.w	r2, r3, #31
 80028b4:	e01e      	b.n	80028f4 <HAL_ADC_ConfigChannel+0x1f8>
 80028b6:	687b      	ldr	r3, [r7, #4]
 80028b8:	681b      	ldr	r3, [r3, #0]
 80028ba:	2101      	movs	r1, #1
 80028bc:	4618      	mov	r0, r3
 80028be:	f7ff fc9d 	bl	80021fc <LL_ADC_GetOffsetChannel>
 80028c2:	4603      	mov	r3, r0
 80028c4:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80028c8:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80028cc:	fa93 f3a3 	rbit	r3, r3
 80028d0:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  return result;
 80028d4:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80028d8:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  if (value == 0U)
 80028dc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80028e0:	2b00      	cmp	r3, #0
 80028e2:	d101      	bne.n	80028e8 <HAL_ADC_ConfigChannel+0x1ec>
    return 32U;
 80028e4:	2320      	movs	r3, #32
 80028e6:	e004      	b.n	80028f2 <HAL_ADC_ConfigChannel+0x1f6>
  return __builtin_clz(value);
 80028e8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 80028ec:	fab3 f383 	clz	r3, r3
 80028f0:	b2db      	uxtb	r3, r3
 80028f2:	461a      	mov	r2, r3
 80028f4:	683b      	ldr	r3, [r7, #0]
 80028f6:	681b      	ldr	r3, [r3, #0]
 80028f8:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80028fc:	2b00      	cmp	r3, #0
 80028fe:	d105      	bne.n	800290c <HAL_ADC_ConfigChannel+0x210>
 8002900:	683b      	ldr	r3, [r7, #0]
 8002902:	681b      	ldr	r3, [r3, #0]
 8002904:	0e9b      	lsrs	r3, r3, #26
 8002906:	f003 031f 	and.w	r3, r3, #31
 800290a:	e018      	b.n	800293e <HAL_ADC_ConfigChannel+0x242>
 800290c:	683b      	ldr	r3, [r7, #0]
 800290e:	681b      	ldr	r3, [r3, #0]
 8002910:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002914:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8002918:	fa93 f3a3 	rbit	r3, r3
 800291c:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  return result;
 8002920:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8002924:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  if (value == 0U)
 8002928:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800292c:	2b00      	cmp	r3, #0
 800292e:	d101      	bne.n	8002934 <HAL_ADC_ConfigChannel+0x238>
    return 32U;
 8002930:	2320      	movs	r3, #32
 8002932:	e004      	b.n	800293e <HAL_ADC_ConfigChannel+0x242>
  return __builtin_clz(value);
 8002934:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8002938:	fab3 f383 	clz	r3, r3
 800293c:	b2db      	uxtb	r3, r3
 800293e:	429a      	cmp	r2, r3
 8002940:	d106      	bne.n	8002950 <HAL_ADC_ConfigChannel+0x254>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_2, LL_ADC_OFFSET_DISABLE);
 8002942:	687b      	ldr	r3, [r7, #4]
 8002944:	681b      	ldr	r3, [r3, #0]
 8002946:	2200      	movs	r2, #0
 8002948:	2101      	movs	r1, #1
 800294a:	4618      	mov	r0, r3
 800294c:	f7ff fc6c 	bl	8002228 <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8002950:	687b      	ldr	r3, [r7, #4]
 8002952:	681b      	ldr	r3, [r3, #0]
 8002954:	2102      	movs	r1, #2
 8002956:	4618      	mov	r0, r3
 8002958:	f7ff fc50 	bl	80021fc <LL_ADC_GetOffsetChannel>
 800295c:	4603      	mov	r3, r0
 800295e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002962:	2b00      	cmp	r3, #0
 8002964:	d10a      	bne.n	800297c <HAL_ADC_ConfigChannel+0x280>
 8002966:	687b      	ldr	r3, [r7, #4]
 8002968:	681b      	ldr	r3, [r3, #0]
 800296a:	2102      	movs	r1, #2
 800296c:	4618      	mov	r0, r3
 800296e:	f7ff fc45 	bl	80021fc <LL_ADC_GetOffsetChannel>
 8002972:	4603      	mov	r3, r0
 8002974:	0e9b      	lsrs	r3, r3, #26
 8002976:	f003 021f 	and.w	r2, r3, #31
 800297a:	e01e      	b.n	80029ba <HAL_ADC_ConfigChannel+0x2be>
 800297c:	687b      	ldr	r3, [r7, #4]
 800297e:	681b      	ldr	r3, [r3, #0]
 8002980:	2102      	movs	r1, #2
 8002982:	4618      	mov	r0, r3
 8002984:	f7ff fc3a 	bl	80021fc <LL_ADC_GetOffsetChannel>
 8002988:	4603      	mov	r3, r0
 800298a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800298e:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8002992:	fa93 f3a3 	rbit	r3, r3
 8002996:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  return result;
 800299a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800299e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  if (value == 0U)
 80029a2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80029a6:	2b00      	cmp	r3, #0
 80029a8:	d101      	bne.n	80029ae <HAL_ADC_ConfigChannel+0x2b2>
    return 32U;
 80029aa:	2320      	movs	r3, #32
 80029ac:	e004      	b.n	80029b8 <HAL_ADC_ConfigChannel+0x2bc>
  return __builtin_clz(value);
 80029ae:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80029b2:	fab3 f383 	clz	r3, r3
 80029b6:	b2db      	uxtb	r3, r3
 80029b8:	461a      	mov	r2, r3
 80029ba:	683b      	ldr	r3, [r7, #0]
 80029bc:	681b      	ldr	r3, [r3, #0]
 80029be:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80029c2:	2b00      	cmp	r3, #0
 80029c4:	d105      	bne.n	80029d2 <HAL_ADC_ConfigChannel+0x2d6>
 80029c6:	683b      	ldr	r3, [r7, #0]
 80029c8:	681b      	ldr	r3, [r3, #0]
 80029ca:	0e9b      	lsrs	r3, r3, #26
 80029cc:	f003 031f 	and.w	r3, r3, #31
 80029d0:	e016      	b.n	8002a00 <HAL_ADC_ConfigChannel+0x304>
 80029d2:	683b      	ldr	r3, [r7, #0]
 80029d4:	681b      	ldr	r3, [r3, #0]
 80029d6:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80029da:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80029de:	fa93 f3a3 	rbit	r3, r3
 80029e2:	67fb      	str	r3, [r7, #124]	; 0x7c
  return result;
 80029e4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80029e6:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if (value == 0U)
 80029ea:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80029ee:	2b00      	cmp	r3, #0
 80029f0:	d101      	bne.n	80029f6 <HAL_ADC_ConfigChannel+0x2fa>
    return 32U;
 80029f2:	2320      	movs	r3, #32
 80029f4:	e004      	b.n	8002a00 <HAL_ADC_ConfigChannel+0x304>
  return __builtin_clz(value);
 80029f6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80029fa:	fab3 f383 	clz	r3, r3
 80029fe:	b2db      	uxtb	r3, r3
 8002a00:	429a      	cmp	r2, r3
 8002a02:	d106      	bne.n	8002a12 <HAL_ADC_ConfigChannel+0x316>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_3, LL_ADC_OFFSET_DISABLE);
 8002a04:	687b      	ldr	r3, [r7, #4]
 8002a06:	681b      	ldr	r3, [r3, #0]
 8002a08:	2200      	movs	r2, #0
 8002a0a:	2102      	movs	r1, #2
 8002a0c:	4618      	mov	r0, r3
 8002a0e:	f7ff fc0b 	bl	8002228 <LL_ADC_SetOffsetState>
        }
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8002a12:	687b      	ldr	r3, [r7, #4]
 8002a14:	681b      	ldr	r3, [r3, #0]
 8002a16:	2103      	movs	r1, #3
 8002a18:	4618      	mov	r0, r3
 8002a1a:	f7ff fbef 	bl	80021fc <LL_ADC_GetOffsetChannel>
 8002a1e:	4603      	mov	r3, r0
 8002a20:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002a24:	2b00      	cmp	r3, #0
 8002a26:	d10a      	bne.n	8002a3e <HAL_ADC_ConfigChannel+0x342>
 8002a28:	687b      	ldr	r3, [r7, #4]
 8002a2a:	681b      	ldr	r3, [r3, #0]
 8002a2c:	2103      	movs	r1, #3
 8002a2e:	4618      	mov	r0, r3
 8002a30:	f7ff fbe4 	bl	80021fc <LL_ADC_GetOffsetChannel>
 8002a34:	4603      	mov	r3, r0
 8002a36:	0e9b      	lsrs	r3, r3, #26
 8002a38:	f003 021f 	and.w	r2, r3, #31
 8002a3c:	e017      	b.n	8002a6e <HAL_ADC_ConfigChannel+0x372>
 8002a3e:	687b      	ldr	r3, [r7, #4]
 8002a40:	681b      	ldr	r3, [r3, #0]
 8002a42:	2103      	movs	r1, #3
 8002a44:	4618      	mov	r0, r3
 8002a46:	f7ff fbd9 	bl	80021fc <LL_ADC_GetOffsetChannel>
 8002a4a:	4603      	mov	r3, r0
 8002a4c:	677b      	str	r3, [r7, #116]	; 0x74
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002a4e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8002a50:	fa93 f3a3 	rbit	r3, r3
 8002a54:	673b      	str	r3, [r7, #112]	; 0x70
  return result;
 8002a56:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8002a58:	67bb      	str	r3, [r7, #120]	; 0x78
  if (value == 0U)
 8002a5a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8002a5c:	2b00      	cmp	r3, #0
 8002a5e:	d101      	bne.n	8002a64 <HAL_ADC_ConfigChannel+0x368>
    return 32U;
 8002a60:	2320      	movs	r3, #32
 8002a62:	e003      	b.n	8002a6c <HAL_ADC_ConfigChannel+0x370>
  return __builtin_clz(value);
 8002a64:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8002a66:	fab3 f383 	clz	r3, r3
 8002a6a:	b2db      	uxtb	r3, r3
 8002a6c:	461a      	mov	r2, r3
 8002a6e:	683b      	ldr	r3, [r7, #0]
 8002a70:	681b      	ldr	r3, [r3, #0]
 8002a72:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002a76:	2b00      	cmp	r3, #0
 8002a78:	d105      	bne.n	8002a86 <HAL_ADC_ConfigChannel+0x38a>
 8002a7a:	683b      	ldr	r3, [r7, #0]
 8002a7c:	681b      	ldr	r3, [r3, #0]
 8002a7e:	0e9b      	lsrs	r3, r3, #26
 8002a80:	f003 031f 	and.w	r3, r3, #31
 8002a84:	e011      	b.n	8002aaa <HAL_ADC_ConfigChannel+0x3ae>
 8002a86:	683b      	ldr	r3, [r7, #0]
 8002a88:	681b      	ldr	r3, [r3, #0]
 8002a8a:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002a8c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002a8e:	fa93 f3a3 	rbit	r3, r3
 8002a92:	667b      	str	r3, [r7, #100]	; 0x64
  return result;
 8002a94:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8002a96:	66fb      	str	r3, [r7, #108]	; 0x6c
  if (value == 0U)
 8002a98:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002a9a:	2b00      	cmp	r3, #0
 8002a9c:	d101      	bne.n	8002aa2 <HAL_ADC_ConfigChannel+0x3a6>
    return 32U;
 8002a9e:	2320      	movs	r3, #32
 8002aa0:	e003      	b.n	8002aaa <HAL_ADC_ConfigChannel+0x3ae>
  return __builtin_clz(value);
 8002aa2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002aa4:	fab3 f383 	clz	r3, r3
 8002aa8:	b2db      	uxtb	r3, r3
 8002aaa:	429a      	cmp	r2, r3
 8002aac:	d106      	bne.n	8002abc <HAL_ADC_ConfigChannel+0x3c0>
        {
          LL_ADC_SetOffsetState(hadc->Instance, LL_ADC_OFFSET_4, LL_ADC_OFFSET_DISABLE);
 8002aae:	687b      	ldr	r3, [r7, #4]
 8002ab0:	681b      	ldr	r3, [r3, #0]
 8002ab2:	2200      	movs	r2, #0
 8002ab4:	2103      	movs	r1, #3
 8002ab6:	4618      	mov	r0, r3
 8002ab8:	f7ff fbb6 	bl	8002228 <LL_ADC_SetOffsetState>

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8002abc:	687b      	ldr	r3, [r7, #4]
 8002abe:	681b      	ldr	r3, [r3, #0]
 8002ac0:	4618      	mov	r0, r3
 8002ac2:	f7ff fc95 	bl	80023f0 <LL_ADC_IsEnabled>
 8002ac6:	4603      	mov	r3, r0
 8002ac8:	2b00      	cmp	r3, #0
 8002aca:	f040 81c2 	bne.w	8002e52 <HAL_ADC_ConfigChannel+0x756>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 8002ace:	687b      	ldr	r3, [r7, #4]
 8002ad0:	6818      	ldr	r0, [r3, #0]
 8002ad2:	683b      	ldr	r3, [r7, #0]
 8002ad4:	6819      	ldr	r1, [r3, #0]
 8002ad6:	683b      	ldr	r3, [r7, #0]
 8002ad8:	68db      	ldr	r3, [r3, #12]
 8002ada:	461a      	mov	r2, r3
 8002adc:	f7ff fc16 	bl	800230c <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 8002ae0:	683b      	ldr	r3, [r7, #0]
 8002ae2:	68db      	ldr	r3, [r3, #12]
 8002ae4:	4a8e      	ldr	r2, [pc, #568]	; (8002d20 <HAL_ADC_ConfigChannel+0x624>)
 8002ae6:	4293      	cmp	r3, r2
 8002ae8:	f040 8130 	bne.w	8002d4c <HAL_ADC_ConfigChannel+0x650>
      {
        /* Set sampling time of the selected ADC channel */
        /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8002aec:	687b      	ldr	r3, [r7, #4]
 8002aee:	6818      	ldr	r0, [r3, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8002af0:	683b      	ldr	r3, [r7, #0]
 8002af2:	681b      	ldr	r3, [r3, #0]
 8002af4:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002af8:	2b00      	cmp	r3, #0
 8002afa:	d10b      	bne.n	8002b14 <HAL_ADC_ConfigChannel+0x418>
 8002afc:	683b      	ldr	r3, [r7, #0]
 8002afe:	681b      	ldr	r3, [r3, #0]
 8002b00:	0e9b      	lsrs	r3, r3, #26
 8002b02:	3301      	adds	r3, #1
 8002b04:	f003 031f 	and.w	r3, r3, #31
 8002b08:	2b09      	cmp	r3, #9
 8002b0a:	bf94      	ite	ls
 8002b0c:	2301      	movls	r3, #1
 8002b0e:	2300      	movhi	r3, #0
 8002b10:	b2db      	uxtb	r3, r3
 8002b12:	e019      	b.n	8002b48 <HAL_ADC_ConfigChannel+0x44c>
 8002b14:	683b      	ldr	r3, [r7, #0]
 8002b16:	681b      	ldr	r3, [r3, #0]
 8002b18:	65fb      	str	r3, [r7, #92]	; 0x5c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002b1a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8002b1c:	fa93 f3a3 	rbit	r3, r3
 8002b20:	65bb      	str	r3, [r7, #88]	; 0x58
  return result;
 8002b22:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002b24:	663b      	str	r3, [r7, #96]	; 0x60
  if (value == 0U)
 8002b26:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8002b28:	2b00      	cmp	r3, #0
 8002b2a:	d101      	bne.n	8002b30 <HAL_ADC_ConfigChannel+0x434>
    return 32U;
 8002b2c:	2320      	movs	r3, #32
 8002b2e:	e003      	b.n	8002b38 <HAL_ADC_ConfigChannel+0x43c>
  return __builtin_clz(value);
 8002b30:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8002b32:	fab3 f383 	clz	r3, r3
 8002b36:	b2db      	uxtb	r3, r3
 8002b38:	3301      	adds	r3, #1
 8002b3a:	f003 031f 	and.w	r3, r3, #31
 8002b3e:	2b09      	cmp	r3, #9
 8002b40:	bf94      	ite	ls
 8002b42:	2301      	movls	r3, #1
 8002b44:	2300      	movhi	r3, #0
 8002b46:	b2db      	uxtb	r3, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8002b48:	2b00      	cmp	r3, #0
 8002b4a:	d079      	beq.n	8002c40 <HAL_ADC_ConfigChannel+0x544>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8002b4c:	683b      	ldr	r3, [r7, #0]
 8002b4e:	681b      	ldr	r3, [r3, #0]
 8002b50:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002b54:	2b00      	cmp	r3, #0
 8002b56:	d107      	bne.n	8002b68 <HAL_ADC_ConfigChannel+0x46c>
 8002b58:	683b      	ldr	r3, [r7, #0]
 8002b5a:	681b      	ldr	r3, [r3, #0]
 8002b5c:	0e9b      	lsrs	r3, r3, #26
 8002b5e:	3301      	adds	r3, #1
 8002b60:	069b      	lsls	r3, r3, #26
 8002b62:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8002b66:	e015      	b.n	8002b94 <HAL_ADC_ConfigChannel+0x498>
 8002b68:	683b      	ldr	r3, [r7, #0]
 8002b6a:	681b      	ldr	r3, [r3, #0]
 8002b6c:	653b      	str	r3, [r7, #80]	; 0x50
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002b6e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8002b70:	fa93 f3a3 	rbit	r3, r3
 8002b74:	64fb      	str	r3, [r7, #76]	; 0x4c
  return result;
 8002b76:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8002b78:	657b      	str	r3, [r7, #84]	; 0x54
  if (value == 0U)
 8002b7a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8002b7c:	2b00      	cmp	r3, #0
 8002b7e:	d101      	bne.n	8002b84 <HAL_ADC_ConfigChannel+0x488>
    return 32U;
 8002b80:	2320      	movs	r3, #32
 8002b82:	e003      	b.n	8002b8c <HAL_ADC_ConfigChannel+0x490>
  return __builtin_clz(value);
 8002b84:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8002b86:	fab3 f383 	clz	r3, r3
 8002b8a:	b2db      	uxtb	r3, r3
 8002b8c:	3301      	adds	r3, #1
 8002b8e:	069b      	lsls	r3, r3, #26
 8002b90:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8002b94:	683b      	ldr	r3, [r7, #0]
 8002b96:	681b      	ldr	r3, [r3, #0]
 8002b98:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002b9c:	2b00      	cmp	r3, #0
 8002b9e:	d109      	bne.n	8002bb4 <HAL_ADC_ConfigChannel+0x4b8>
 8002ba0:	683b      	ldr	r3, [r7, #0]
 8002ba2:	681b      	ldr	r3, [r3, #0]
 8002ba4:	0e9b      	lsrs	r3, r3, #26
 8002ba6:	3301      	adds	r3, #1
 8002ba8:	f003 031f 	and.w	r3, r3, #31
 8002bac:	2101      	movs	r1, #1
 8002bae:	fa01 f303 	lsl.w	r3, r1, r3
 8002bb2:	e017      	b.n	8002be4 <HAL_ADC_ConfigChannel+0x4e8>
 8002bb4:	683b      	ldr	r3, [r7, #0]
 8002bb6:	681b      	ldr	r3, [r3, #0]
 8002bb8:	647b      	str	r3, [r7, #68]	; 0x44
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002bba:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8002bbc:	fa93 f3a3 	rbit	r3, r3
 8002bc0:	643b      	str	r3, [r7, #64]	; 0x40
  return result;
 8002bc2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8002bc4:	64bb      	str	r3, [r7, #72]	; 0x48
  if (value == 0U)
 8002bc6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002bc8:	2b00      	cmp	r3, #0
 8002bca:	d101      	bne.n	8002bd0 <HAL_ADC_ConfigChannel+0x4d4>
    return 32U;
 8002bcc:	2320      	movs	r3, #32
 8002bce:	e003      	b.n	8002bd8 <HAL_ADC_ConfigChannel+0x4dc>
  return __builtin_clz(value);
 8002bd0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8002bd2:	fab3 f383 	clz	r3, r3
 8002bd6:	b2db      	uxtb	r3, r3
 8002bd8:	3301      	adds	r3, #1
 8002bda:	f003 031f 	and.w	r3, r3, #31
 8002bde:	2101      	movs	r1, #1
 8002be0:	fa01 f303 	lsl.w	r3, r1, r3
 8002be4:	ea42 0103 	orr.w	r1, r2, r3
 8002be8:	683b      	ldr	r3, [r7, #0]
 8002bea:	681b      	ldr	r3, [r3, #0]
 8002bec:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002bf0:	2b00      	cmp	r3, #0
 8002bf2:	d10a      	bne.n	8002c0a <HAL_ADC_ConfigChannel+0x50e>
 8002bf4:	683b      	ldr	r3, [r7, #0]
 8002bf6:	681b      	ldr	r3, [r3, #0]
 8002bf8:	0e9b      	lsrs	r3, r3, #26
 8002bfa:	3301      	adds	r3, #1
 8002bfc:	f003 021f 	and.w	r2, r3, #31
 8002c00:	4613      	mov	r3, r2
 8002c02:	005b      	lsls	r3, r3, #1
 8002c04:	4413      	add	r3, r2
 8002c06:	051b      	lsls	r3, r3, #20
 8002c08:	e018      	b.n	8002c3c <HAL_ADC_ConfigChannel+0x540>
 8002c0a:	683b      	ldr	r3, [r7, #0]
 8002c0c:	681b      	ldr	r3, [r3, #0]
 8002c0e:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002c10:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8002c12:	fa93 f3a3 	rbit	r3, r3
 8002c16:	637b      	str	r3, [r7, #52]	; 0x34
  return result;
 8002c18:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8002c1a:	63fb      	str	r3, [r7, #60]	; 0x3c
  if (value == 0U)
 8002c1c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002c1e:	2b00      	cmp	r3, #0
 8002c20:	d101      	bne.n	8002c26 <HAL_ADC_ConfigChannel+0x52a>
    return 32U;
 8002c22:	2320      	movs	r3, #32
 8002c24:	e003      	b.n	8002c2e <HAL_ADC_ConfigChannel+0x532>
  return __builtin_clz(value);
 8002c26:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8002c28:	fab3 f383 	clz	r3, r3
 8002c2c:	b2db      	uxtb	r3, r3
 8002c2e:	3301      	adds	r3, #1
 8002c30:	f003 021f 	and.w	r2, r3, #31
 8002c34:	4613      	mov	r3, r2
 8002c36:	005b      	lsls	r3, r3, #1
 8002c38:	4413      	add	r3, r2
 8002c3a:	051b      	lsls	r3, r3, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8002c3c:	430b      	orrs	r3, r1
 8002c3e:	e080      	b.n	8002d42 <HAL_ADC_ConfigChannel+0x646>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8002c40:	683b      	ldr	r3, [r7, #0]
 8002c42:	681b      	ldr	r3, [r3, #0]
 8002c44:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002c48:	2b00      	cmp	r3, #0
 8002c4a:	d107      	bne.n	8002c5c <HAL_ADC_ConfigChannel+0x560>
 8002c4c:	683b      	ldr	r3, [r7, #0]
 8002c4e:	681b      	ldr	r3, [r3, #0]
 8002c50:	0e9b      	lsrs	r3, r3, #26
 8002c52:	3301      	adds	r3, #1
 8002c54:	069b      	lsls	r3, r3, #26
 8002c56:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8002c5a:	e015      	b.n	8002c88 <HAL_ADC_ConfigChannel+0x58c>
 8002c5c:	683b      	ldr	r3, [r7, #0]
 8002c5e:	681b      	ldr	r3, [r3, #0]
 8002c60:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002c62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002c64:	fa93 f3a3 	rbit	r3, r3
 8002c68:	62bb      	str	r3, [r7, #40]	; 0x28
  return result;
 8002c6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002c6c:	633b      	str	r3, [r7, #48]	; 0x30
  if (value == 0U)
 8002c6e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002c70:	2b00      	cmp	r3, #0
 8002c72:	d101      	bne.n	8002c78 <HAL_ADC_ConfigChannel+0x57c>
    return 32U;
 8002c74:	2320      	movs	r3, #32
 8002c76:	e003      	b.n	8002c80 <HAL_ADC_ConfigChannel+0x584>
  return __builtin_clz(value);
 8002c78:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8002c7a:	fab3 f383 	clz	r3, r3
 8002c7e:	b2db      	uxtb	r3, r3
 8002c80:	3301      	adds	r3, #1
 8002c82:	069b      	lsls	r3, r3, #26
 8002c84:	f003 42f8 	and.w	r2, r3, #2080374784	; 0x7c000000
 8002c88:	683b      	ldr	r3, [r7, #0]
 8002c8a:	681b      	ldr	r3, [r3, #0]
 8002c8c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002c90:	2b00      	cmp	r3, #0
 8002c92:	d109      	bne.n	8002ca8 <HAL_ADC_ConfigChannel+0x5ac>
 8002c94:	683b      	ldr	r3, [r7, #0]
 8002c96:	681b      	ldr	r3, [r3, #0]
 8002c98:	0e9b      	lsrs	r3, r3, #26
 8002c9a:	3301      	adds	r3, #1
 8002c9c:	f003 031f 	and.w	r3, r3, #31
 8002ca0:	2101      	movs	r1, #1
 8002ca2:	fa01 f303 	lsl.w	r3, r1, r3
 8002ca6:	e017      	b.n	8002cd8 <HAL_ADC_ConfigChannel+0x5dc>
 8002ca8:	683b      	ldr	r3, [r7, #0]
 8002caa:	681b      	ldr	r3, [r3, #0]
 8002cac:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002cae:	6a3b      	ldr	r3, [r7, #32]
 8002cb0:	fa93 f3a3 	rbit	r3, r3
 8002cb4:	61fb      	str	r3, [r7, #28]
  return result;
 8002cb6:	69fb      	ldr	r3, [r7, #28]
 8002cb8:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 8002cba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002cbc:	2b00      	cmp	r3, #0
 8002cbe:	d101      	bne.n	8002cc4 <HAL_ADC_ConfigChannel+0x5c8>
    return 32U;
 8002cc0:	2320      	movs	r3, #32
 8002cc2:	e003      	b.n	8002ccc <HAL_ADC_ConfigChannel+0x5d0>
  return __builtin_clz(value);
 8002cc4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002cc6:	fab3 f383 	clz	r3, r3
 8002cca:	b2db      	uxtb	r3, r3
 8002ccc:	3301      	adds	r3, #1
 8002cce:	f003 031f 	and.w	r3, r3, #31
 8002cd2:	2101      	movs	r1, #1
 8002cd4:	fa01 f303 	lsl.w	r3, r1, r3
 8002cd8:	ea42 0103 	orr.w	r1, r2, r3
 8002cdc:	683b      	ldr	r3, [r7, #0]
 8002cde:	681b      	ldr	r3, [r3, #0]
 8002ce0:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8002ce4:	2b00      	cmp	r3, #0
 8002ce6:	d10d      	bne.n	8002d04 <HAL_ADC_ConfigChannel+0x608>
 8002ce8:	683b      	ldr	r3, [r7, #0]
 8002cea:	681b      	ldr	r3, [r3, #0]
 8002cec:	0e9b      	lsrs	r3, r3, #26
 8002cee:	3301      	adds	r3, #1
 8002cf0:	f003 021f 	and.w	r2, r3, #31
 8002cf4:	4613      	mov	r3, r2
 8002cf6:	005b      	lsls	r3, r3, #1
 8002cf8:	4413      	add	r3, r2
 8002cfa:	3b1e      	subs	r3, #30
 8002cfc:	051b      	lsls	r3, r3, #20
 8002cfe:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8002d02:	e01d      	b.n	8002d40 <HAL_ADC_ConfigChannel+0x644>
 8002d04:	683b      	ldr	r3, [r7, #0]
 8002d06:	681b      	ldr	r3, [r3, #0]
 8002d08:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002d0a:	697b      	ldr	r3, [r7, #20]
 8002d0c:	fa93 f3a3 	rbit	r3, r3
 8002d10:	613b      	str	r3, [r7, #16]
  return result;
 8002d12:	693b      	ldr	r3, [r7, #16]
 8002d14:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8002d16:	69bb      	ldr	r3, [r7, #24]
 8002d18:	2b00      	cmp	r3, #0
 8002d1a:	d103      	bne.n	8002d24 <HAL_ADC_ConfigChannel+0x628>
    return 32U;
 8002d1c:	2320      	movs	r3, #32
 8002d1e:	e005      	b.n	8002d2c <HAL_ADC_ConfigChannel+0x630>
 8002d20:	407f0000 	.word	0x407f0000
  return __builtin_clz(value);
 8002d24:	69bb      	ldr	r3, [r7, #24]
 8002d26:	fab3 f383 	clz	r3, r3
 8002d2a:	b2db      	uxtb	r3, r3
 8002d2c:	3301      	adds	r3, #1
 8002d2e:	f003 021f 	and.w	r2, r3, #31
 8002d32:	4613      	mov	r3, r2
 8002d34:	005b      	lsls	r3, r3, #1
 8002d36:	4413      	add	r3, r2
 8002d38:	3b1e      	subs	r3, #30
 8002d3a:	051b      	lsls	r3, r3, #20
 8002d3c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8002d40:	430b      	orrs	r3, r1
                                      sConfig->SamplingTime);
 8002d42:	683a      	ldr	r2, [r7, #0]
 8002d44:	6892      	ldr	r2, [r2, #8]
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8002d46:	4619      	mov	r1, r3
 8002d48:	f7ff fab5 	bl	80022b6 <LL_ADC_SetChannelSamplingTime>
      /* If internal channel selected, enable dedicated internal buffers and    */
      /* paths.                                                                 */
      /* Note: these internal measurement paths can be disabled using           */
      /* HAL_ADC_DeInit().                                                      */

      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8002d4c:	683b      	ldr	r3, [r7, #0]
 8002d4e:	681a      	ldr	r2, [r3, #0]
 8002d50:	4b45      	ldr	r3, [pc, #276]	; (8002e68 <HAL_ADC_ConfigChannel+0x76c>)
 8002d52:	4013      	ands	r3, r2
 8002d54:	2b00      	cmp	r3, #0
 8002d56:	d07c      	beq.n	8002e52 <HAL_ADC_ConfigChannel+0x756>
      {
        /* Configuration of common ADC parameters                                 */

        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8002d58:	4844      	ldr	r0, [pc, #272]	; (8002e6c <HAL_ADC_ConfigChannel+0x770>)
 8002d5a:	f7ff fa1d 	bl	8002198 <LL_ADC_GetCommonPathInternalCh>
 8002d5e:	f8c7 00c4 	str.w	r0, [r7, #196]	; 0xc4

        /* Software is allowed to change common parameters only when all ADCs   */
        /* of the common group are disabled.                                    */
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8002d62:	4843      	ldr	r0, [pc, #268]	; (8002e70 <HAL_ADC_ConfigChannel+0x774>)
 8002d64:	f7ff fb44 	bl	80023f0 <LL_ADC_IsEnabled>
 8002d68:	4603      	mov	r3, r0
 8002d6a:	2b00      	cmp	r3, #0
 8002d6c:	d15e      	bne.n	8002e2c <HAL_ADC_ConfigChannel+0x730>
        {
          /* If the requested internal measurement path has already been enabled, */
          /* bypass the configuration processing.                                 */
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8002d6e:	683b      	ldr	r3, [r7, #0]
 8002d70:	681b      	ldr	r3, [r3, #0]
 8002d72:	4a40      	ldr	r2, [pc, #256]	; (8002e74 <HAL_ADC_ConfigChannel+0x778>)
 8002d74:	4293      	cmp	r3, r2
 8002d76:	d127      	bne.n	8002dc8 <HAL_ADC_ConfigChannel+0x6cc>
 8002d78:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8002d7c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8002d80:	2b00      	cmp	r3, #0
 8002d82:	d121      	bne.n	8002dc8 <HAL_ADC_ConfigChannel+0x6cc>
          {
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8002d84:	687b      	ldr	r3, [r7, #4]
 8002d86:	681b      	ldr	r3, [r3, #0]
 8002d88:	4a39      	ldr	r2, [pc, #228]	; (8002e70 <HAL_ADC_ConfigChannel+0x774>)
 8002d8a:	4293      	cmp	r3, r2
 8002d8c:	d161      	bne.n	8002e52 <HAL_ADC_ConfigChannel+0x756>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 8002d8e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8002d92:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8002d96:	4619      	mov	r1, r3
 8002d98:	4834      	ldr	r0, [pc, #208]	; (8002e6c <HAL_ADC_ConfigChannel+0x770>)
 8002d9a:	f7ff f9ea 	bl	8002172 <LL_ADC_SetCommonPathInternalCh>
              /* Delay for temperature sensor stabilization time */
              /* Wait loop initialization and execution */
              /* Note: Variable divided by 2 to compensate partially              */
              /*       CPU processing cycles, scaling in us split to not          */
              /*       exceed 32 bits register capacity and handle low frequency. */
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8002d9e:	4b36      	ldr	r3, [pc, #216]	; (8002e78 <HAL_ADC_ConfigChannel+0x77c>)
 8002da0:	681b      	ldr	r3, [r3, #0]
 8002da2:	099b      	lsrs	r3, r3, #6
 8002da4:	4a35      	ldr	r2, [pc, #212]	; (8002e7c <HAL_ADC_ConfigChannel+0x780>)
 8002da6:	fba2 2303 	umull	r2, r3, r2, r3
 8002daa:	099b      	lsrs	r3, r3, #6
 8002dac:	1c5a      	adds	r2, r3, #1
 8002dae:	4613      	mov	r3, r2
 8002db0:	005b      	lsls	r3, r3, #1
 8002db2:	4413      	add	r3, r2
 8002db4:	009b      	lsls	r3, r3, #2
 8002db6:	60fb      	str	r3, [r7, #12]
              while(wait_loop_index != 0UL)
 8002db8:	e002      	b.n	8002dc0 <HAL_ADC_ConfigChannel+0x6c4>
              {
                wait_loop_index--;
 8002dba:	68fb      	ldr	r3, [r7, #12]
 8002dbc:	3b01      	subs	r3, #1
 8002dbe:	60fb      	str	r3, [r7, #12]
              while(wait_loop_index != 0UL)
 8002dc0:	68fb      	ldr	r3, [r7, #12]
 8002dc2:	2b00      	cmp	r3, #0
 8002dc4:	d1f9      	bne.n	8002dba <HAL_ADC_ConfigChannel+0x6be>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8002dc6:	e044      	b.n	8002e52 <HAL_ADC_ConfigChannel+0x756>
              }
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8002dc8:	683b      	ldr	r3, [r7, #0]
 8002dca:	681b      	ldr	r3, [r3, #0]
 8002dcc:	4a2c      	ldr	r2, [pc, #176]	; (8002e80 <HAL_ADC_ConfigChannel+0x784>)
 8002dce:	4293      	cmp	r3, r2
 8002dd0:	d113      	bne.n	8002dfa <HAL_ADC_ConfigChannel+0x6fe>
 8002dd2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8002dd6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8002dda:	2b00      	cmp	r3, #0
 8002ddc:	d10d      	bne.n	8002dfa <HAL_ADC_ConfigChannel+0x6fe>
          {
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8002dde:	687b      	ldr	r3, [r7, #4]
 8002de0:	681b      	ldr	r3, [r3, #0]
 8002de2:	4a23      	ldr	r2, [pc, #140]	; (8002e70 <HAL_ADC_ConfigChannel+0x774>)
 8002de4:	4293      	cmp	r3, r2
 8002de6:	d134      	bne.n	8002e52 <HAL_ADC_ConfigChannel+0x756>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 8002de8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8002dec:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002df0:	4619      	mov	r1, r3
 8002df2:	481e      	ldr	r0, [pc, #120]	; (8002e6c <HAL_ADC_ConfigChannel+0x770>)
 8002df4:	f7ff f9bd 	bl	8002172 <LL_ADC_SetCommonPathInternalCh>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8002df8:	e02b      	b.n	8002e52 <HAL_ADC_ConfigChannel+0x756>
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8002dfa:	683b      	ldr	r3, [r7, #0]
 8002dfc:	681b      	ldr	r3, [r3, #0]
 8002dfe:	4a21      	ldr	r2, [pc, #132]	; (8002e84 <HAL_ADC_ConfigChannel+0x788>)
 8002e00:	4293      	cmp	r3, r2
 8002e02:	d126      	bne.n	8002e52 <HAL_ADC_ConfigChannel+0x756>
 8002e04:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8002e08:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8002e0c:	2b00      	cmp	r3, #0
 8002e0e:	d120      	bne.n	8002e52 <HAL_ADC_ConfigChannel+0x756>
          {
            if (ADC_VREFINT_INSTANCE(hadc))
 8002e10:	687b      	ldr	r3, [r7, #4]
 8002e12:	681b      	ldr	r3, [r3, #0]
 8002e14:	4a16      	ldr	r2, [pc, #88]	; (8002e70 <HAL_ADC_ConfigChannel+0x774>)
 8002e16:	4293      	cmp	r3, r2
 8002e18:	d11b      	bne.n	8002e52 <HAL_ADC_ConfigChannel+0x756>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 8002e1a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8002e1e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8002e22:	4619      	mov	r1, r3
 8002e24:	4811      	ldr	r0, [pc, #68]	; (8002e6c <HAL_ADC_ConfigChannel+0x770>)
 8002e26:	f7ff f9a4 	bl	8002172 <LL_ADC_SetCommonPathInternalCh>
 8002e2a:	e012      	b.n	8002e52 <HAL_ADC_ConfigChannel+0x756>
        /* enabled and other ADC of the common group are enabled, internal      */
        /* measurement paths cannot be enabled.                                 */
        else
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002e2c:	687b      	ldr	r3, [r7, #4]
 8002e2e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002e30:	f043 0220 	orr.w	r2, r3, #32
 8002e34:	687b      	ldr	r3, [r7, #4]
 8002e36:	655a      	str	r2, [r3, #84]	; 0x54

          tmp_hal_status = HAL_ERROR;
 8002e38:	2301      	movs	r3, #1
 8002e3a:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
 8002e3e:	e008      	b.n	8002e52 <HAL_ADC_ConfigChannel+0x756>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002e40:	687b      	ldr	r3, [r7, #4]
 8002e42:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002e44:	f043 0220 	orr.w	r2, r3, #32
 8002e48:	687b      	ldr	r3, [r7, #4]
 8002e4a:	655a      	str	r2, [r3, #84]	; 0x54

    tmp_hal_status = HAL_ERROR;
 8002e4c:	2301      	movs	r3, #1
 8002e4e:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8002e52:	687b      	ldr	r3, [r7, #4]
 8002e54:	2200      	movs	r2, #0
 8002e56:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
#endif /* ADC_SUPPORT_2_5_MSPS */

  /* Return function status */
  return tmp_hal_status;
 8002e5a:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
}
 8002e5e:	4618      	mov	r0, r3
 8002e60:	37d8      	adds	r7, #216	; 0xd8
 8002e62:	46bd      	mov	sp, r7
 8002e64:	bd80      	pop	{r7, pc}
 8002e66:	bf00      	nop
 8002e68:	80080000 	.word	0x80080000
 8002e6c:	50040300 	.word	0x50040300
 8002e70:	50040000 	.word	0x50040000
 8002e74:	c7520000 	.word	0xc7520000
 8002e78:	20000018 	.word	0x20000018
 8002e7c:	053e2d63 	.word	0x053e2d63
 8002e80:	cb840000 	.word	0xcb840000
 8002e84:	80000001 	.word	0x80000001

08002e88 <__NVIC_SetPriorityGrouping>:
{
 8002e88:	b480      	push	{r7}
 8002e8a:	b085      	sub	sp, #20
 8002e8c:	af00      	add	r7, sp, #0
 8002e8e:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8002e90:	687b      	ldr	r3, [r7, #4]
 8002e92:	f003 0307 	and.w	r3, r3, #7
 8002e96:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8002e98:	4b0c      	ldr	r3, [pc, #48]	; (8002ecc <__NVIC_SetPriorityGrouping+0x44>)
 8002e9a:	68db      	ldr	r3, [r3, #12]
 8002e9c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002e9e:	68ba      	ldr	r2, [r7, #8]
 8002ea0:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8002ea4:	4013      	ands	r3, r2
 8002ea6:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8002ea8:	68fb      	ldr	r3, [r7, #12]
 8002eaa:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8002eac:	68bb      	ldr	r3, [r7, #8]
 8002eae:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8002eb0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8002eb4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002eb8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8002eba:	4a04      	ldr	r2, [pc, #16]	; (8002ecc <__NVIC_SetPriorityGrouping+0x44>)
 8002ebc:	68bb      	ldr	r3, [r7, #8]
 8002ebe:	60d3      	str	r3, [r2, #12]
}
 8002ec0:	bf00      	nop
 8002ec2:	3714      	adds	r7, #20
 8002ec4:	46bd      	mov	sp, r7
 8002ec6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002eca:	4770      	bx	lr
 8002ecc:	e000ed00 	.word	0xe000ed00

08002ed0 <__NVIC_GetPriorityGrouping>:
{
 8002ed0:	b480      	push	{r7}
 8002ed2:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8002ed4:	4b04      	ldr	r3, [pc, #16]	; (8002ee8 <__NVIC_GetPriorityGrouping+0x18>)
 8002ed6:	68db      	ldr	r3, [r3, #12]
 8002ed8:	0a1b      	lsrs	r3, r3, #8
 8002eda:	f003 0307 	and.w	r3, r3, #7
}
 8002ede:	4618      	mov	r0, r3
 8002ee0:	46bd      	mov	sp, r7
 8002ee2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ee6:	4770      	bx	lr
 8002ee8:	e000ed00 	.word	0xe000ed00

08002eec <__NVIC_EnableIRQ>:
{
 8002eec:	b480      	push	{r7}
 8002eee:	b083      	sub	sp, #12
 8002ef0:	af00      	add	r7, sp, #0
 8002ef2:	4603      	mov	r3, r0
 8002ef4:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8002ef6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002efa:	2b00      	cmp	r3, #0
 8002efc:	db0b      	blt.n	8002f16 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002efe:	79fb      	ldrb	r3, [r7, #7]
 8002f00:	f003 021f 	and.w	r2, r3, #31
 8002f04:	4907      	ldr	r1, [pc, #28]	; (8002f24 <__NVIC_EnableIRQ+0x38>)
 8002f06:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002f0a:	095b      	lsrs	r3, r3, #5
 8002f0c:	2001      	movs	r0, #1
 8002f0e:	fa00 f202 	lsl.w	r2, r0, r2
 8002f12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8002f16:	bf00      	nop
 8002f18:	370c      	adds	r7, #12
 8002f1a:	46bd      	mov	sp, r7
 8002f1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f20:	4770      	bx	lr
 8002f22:	bf00      	nop
 8002f24:	e000e100 	.word	0xe000e100

08002f28 <__NVIC_SetPriority>:
{
 8002f28:	b480      	push	{r7}
 8002f2a:	b083      	sub	sp, #12
 8002f2c:	af00      	add	r7, sp, #0
 8002f2e:	4603      	mov	r3, r0
 8002f30:	6039      	str	r1, [r7, #0]
 8002f32:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8002f34:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002f38:	2b00      	cmp	r3, #0
 8002f3a:	db0a      	blt.n	8002f52 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002f3c:	683b      	ldr	r3, [r7, #0]
 8002f3e:	b2da      	uxtb	r2, r3
 8002f40:	490c      	ldr	r1, [pc, #48]	; (8002f74 <__NVIC_SetPriority+0x4c>)
 8002f42:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002f46:	0112      	lsls	r2, r2, #4
 8002f48:	b2d2      	uxtb	r2, r2
 8002f4a:	440b      	add	r3, r1
 8002f4c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 8002f50:	e00a      	b.n	8002f68 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002f52:	683b      	ldr	r3, [r7, #0]
 8002f54:	b2da      	uxtb	r2, r3
 8002f56:	4908      	ldr	r1, [pc, #32]	; (8002f78 <__NVIC_SetPriority+0x50>)
 8002f58:	79fb      	ldrb	r3, [r7, #7]
 8002f5a:	f003 030f 	and.w	r3, r3, #15
 8002f5e:	3b04      	subs	r3, #4
 8002f60:	0112      	lsls	r2, r2, #4
 8002f62:	b2d2      	uxtb	r2, r2
 8002f64:	440b      	add	r3, r1
 8002f66:	761a      	strb	r2, [r3, #24]
}
 8002f68:	bf00      	nop
 8002f6a:	370c      	adds	r7, #12
 8002f6c:	46bd      	mov	sp, r7
 8002f6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f72:	4770      	bx	lr
 8002f74:	e000e100 	.word	0xe000e100
 8002f78:	e000ed00 	.word	0xe000ed00

08002f7c <NVIC_EncodePriority>:
{
 8002f7c:	b480      	push	{r7}
 8002f7e:	b089      	sub	sp, #36	; 0x24
 8002f80:	af00      	add	r7, sp, #0
 8002f82:	60f8      	str	r0, [r7, #12]
 8002f84:	60b9      	str	r1, [r7, #8]
 8002f86:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8002f88:	68fb      	ldr	r3, [r7, #12]
 8002f8a:	f003 0307 	and.w	r3, r3, #7
 8002f8e:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8002f90:	69fb      	ldr	r3, [r7, #28]
 8002f92:	f1c3 0307 	rsb	r3, r3, #7
 8002f96:	2b04      	cmp	r3, #4
 8002f98:	bf28      	it	cs
 8002f9a:	2304      	movcs	r3, #4
 8002f9c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002f9e:	69fb      	ldr	r3, [r7, #28]
 8002fa0:	3304      	adds	r3, #4
 8002fa2:	2b06      	cmp	r3, #6
 8002fa4:	d902      	bls.n	8002fac <NVIC_EncodePriority+0x30>
 8002fa6:	69fb      	ldr	r3, [r7, #28]
 8002fa8:	3b03      	subs	r3, #3
 8002faa:	e000      	b.n	8002fae <NVIC_EncodePriority+0x32>
 8002fac:	2300      	movs	r3, #0
 8002fae:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002fb0:	f04f 32ff 	mov.w	r2, #4294967295
 8002fb4:	69bb      	ldr	r3, [r7, #24]
 8002fb6:	fa02 f303 	lsl.w	r3, r2, r3
 8002fba:	43da      	mvns	r2, r3
 8002fbc:	68bb      	ldr	r3, [r7, #8]
 8002fbe:	401a      	ands	r2, r3
 8002fc0:	697b      	ldr	r3, [r7, #20]
 8002fc2:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8002fc4:	f04f 31ff 	mov.w	r1, #4294967295
 8002fc8:	697b      	ldr	r3, [r7, #20]
 8002fca:	fa01 f303 	lsl.w	r3, r1, r3
 8002fce:	43d9      	mvns	r1, r3
 8002fd0:	687b      	ldr	r3, [r7, #4]
 8002fd2:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002fd4:	4313      	orrs	r3, r2
}
 8002fd6:	4618      	mov	r0, r3
 8002fd8:	3724      	adds	r7, #36	; 0x24
 8002fda:	46bd      	mov	sp, r7
 8002fdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002fe0:	4770      	bx	lr

08002fe2 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8002fe2:	b580      	push	{r7, lr}
 8002fe4:	b082      	sub	sp, #8
 8002fe6:	af00      	add	r7, sp, #0
 8002fe8:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8002fea:	6878      	ldr	r0, [r7, #4]
 8002fec:	f7ff ff4c 	bl	8002e88 <__NVIC_SetPriorityGrouping>
}
 8002ff0:	bf00      	nop
 8002ff2:	3708      	adds	r7, #8
 8002ff4:	46bd      	mov	sp, r7
 8002ff6:	bd80      	pop	{r7, pc}

08002ff8 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8002ff8:	b580      	push	{r7, lr}
 8002ffa:	b086      	sub	sp, #24
 8002ffc:	af00      	add	r7, sp, #0
 8002ffe:	4603      	mov	r3, r0
 8003000:	60b9      	str	r1, [r7, #8]
 8003002:	607a      	str	r2, [r7, #4]
 8003004:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 8003006:	f7ff ff63 	bl	8002ed0 <__NVIC_GetPriorityGrouping>
 800300a:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 800300c:	687a      	ldr	r2, [r7, #4]
 800300e:	68b9      	ldr	r1, [r7, #8]
 8003010:	6978      	ldr	r0, [r7, #20]
 8003012:	f7ff ffb3 	bl	8002f7c <NVIC_EncodePriority>
 8003016:	4602      	mov	r2, r0
 8003018:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800301c:	4611      	mov	r1, r2
 800301e:	4618      	mov	r0, r3
 8003020:	f7ff ff82 	bl	8002f28 <__NVIC_SetPriority>
}
 8003024:	bf00      	nop
 8003026:	3718      	adds	r7, #24
 8003028:	46bd      	mov	sp, r7
 800302a:	bd80      	pop	{r7, pc}

0800302c <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32wbxxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800302c:	b580      	push	{r7, lr}
 800302e:	b082      	sub	sp, #8
 8003030:	af00      	add	r7, sp, #0
 8003032:	4603      	mov	r3, r0
 8003034:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8003036:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800303a:	4618      	mov	r0, r3
 800303c:	f7ff ff56 	bl	8002eec <__NVIC_EnableIRQ>
}
 8003040:	bf00      	nop
 8003042:	3708      	adds	r7, #8
 8003044:	46bd      	mov	sp, r7
 8003046:	bd80      	pop	{r7, pc}

08003048 <HAL_DMA_Init>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8003048:	b580      	push	{r7, lr}
 800304a:	b084      	sub	sp, #16
 800304c:	af00      	add	r7, sp, #0
 800304e:	6078      	str	r0, [r7, #4]
  uint32_t tmp;

  /* Check the DMA handle allocation */
  if (hdma == NULL)
 8003050:	687b      	ldr	r3, [r7, #4]
 8003052:	2b00      	cmp	r3, #0
 8003054:	d101      	bne.n	800305a <HAL_DMA_Init+0x12>
  {
    return HAL_ERROR;
 8003056:	2301      	movs	r3, #1
 8003058:	e08e      	b.n	8003178 <HAL_DMA_Init+0x130>

  assert_param(IS_DMA_ALL_REQUEST(hdma->Init.Request));

#if defined(DMA2)
  /* Compute the channel index */
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 800305a:	687b      	ldr	r3, [r7, #4]
 800305c:	681b      	ldr	r3, [r3, #0]
 800305e:	461a      	mov	r2, r3
 8003060:	4b47      	ldr	r3, [pc, #284]	; (8003180 <HAL_DMA_Init+0x138>)
 8003062:	429a      	cmp	r2, r3
 8003064:	d80f      	bhi.n	8003086 <HAL_DMA_Init+0x3e>
  {
    /* DMA1 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8003066:	687b      	ldr	r3, [r7, #4]
 8003068:	681b      	ldr	r3, [r3, #0]
 800306a:	461a      	mov	r2, r3
 800306c:	4b45      	ldr	r3, [pc, #276]	; (8003184 <HAL_DMA_Init+0x13c>)
 800306e:	4413      	add	r3, r2
 8003070:	4a45      	ldr	r2, [pc, #276]	; (8003188 <HAL_DMA_Init+0x140>)
 8003072:	fba2 2303 	umull	r2, r3, r2, r3
 8003076:	091b      	lsrs	r3, r3, #4
 8003078:	009a      	lsls	r2, r3, #2
 800307a:	687b      	ldr	r3, [r7, #4]
 800307c:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 800307e:	687b      	ldr	r3, [r7, #4]
 8003080:	4a42      	ldr	r2, [pc, #264]	; (800318c <HAL_DMA_Init+0x144>)
 8003082:	641a      	str	r2, [r3, #64]	; 0x40
 8003084:	e00e      	b.n	80030a4 <HAL_DMA_Init+0x5c>
  }
  else
  {
    /* DMA2 */
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 8003086:	687b      	ldr	r3, [r7, #4]
 8003088:	681b      	ldr	r3, [r3, #0]
 800308a:	461a      	mov	r2, r3
 800308c:	4b40      	ldr	r3, [pc, #256]	; (8003190 <HAL_DMA_Init+0x148>)
 800308e:	4413      	add	r3, r2
 8003090:	4a3d      	ldr	r2, [pc, #244]	; (8003188 <HAL_DMA_Init+0x140>)
 8003092:	fba2 2303 	umull	r2, r3, r2, r3
 8003096:	091b      	lsrs	r3, r3, #4
 8003098:	009a      	lsls	r2, r3, #2
 800309a:	687b      	ldr	r3, [r7, #4]
 800309c:	645a      	str	r2, [r3, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 800309e:	687b      	ldr	r3, [r7, #4]
 80030a0:	4a3c      	ldr	r2, [pc, #240]	; (8003194 <HAL_DMA_Init+0x14c>)
 80030a2:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
  hdma->DmaBaseAddress = DMA1;
#endif /* DMA2 */

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80030a4:	687b      	ldr	r3, [r7, #4]
 80030a6:	2202      	movs	r2, #2
 80030a8:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 80030ac:	687b      	ldr	r3, [r7, #4]
 80030ae:	681b      	ldr	r3, [r3, #0]
 80030b0:	681b      	ldr	r3, [r3, #0]
 80030b2:	60fb      	str	r3, [r7, #12]

  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR and MEM2MEM bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  |
 80030b4:	68fb      	ldr	r3, [r7, #12]
 80030b6:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 80030ba:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80030be:	60fb      	str	r3, [r7, #12]
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   |
                      DMA_CCR_DIR   | DMA_CCR_MEM2MEM));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 80030c0:	687b      	ldr	r3, [r7, #4]
 80030c2:	689a      	ldr	r2, [r3, #8]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80030c4:	687b      	ldr	r3, [r7, #4]
 80030c6:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Direction        |
 80030c8:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80030ca:	687b      	ldr	r3, [r7, #4]
 80030cc:	691b      	ldr	r3, [r3, #16]
 80030ce:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80030d0:	687b      	ldr	r3, [r7, #4]
 80030d2:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80030d4:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80030d6:	687b      	ldr	r3, [r7, #4]
 80030d8:	699b      	ldr	r3, [r3, #24]
 80030da:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 80030dc:	687b      	ldr	r3, [r7, #4]
 80030de:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80030e0:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 80030e2:	687b      	ldr	r3, [r7, #4]
 80030e4:	6a1b      	ldr	r3, [r3, #32]
 80030e6:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Direction        |
 80030e8:	68fa      	ldr	r2, [r7, #12]
 80030ea:	4313      	orrs	r3, r2
 80030ec:	60fb      	str	r3, [r7, #12]

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;
 80030ee:	687b      	ldr	r3, [r7, #4]
 80030f0:	681b      	ldr	r3, [r3, #0]
 80030f2:	68fa      	ldr	r2, [r7, #12]
 80030f4:	601a      	str	r2, [r3, #0]

  /* Initialize parameters for DMAMUX channel :
     DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
  */
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 80030f6:	6878      	ldr	r0, [r7, #4]
 80030f8:	f000 f8fe 	bl	80032f8 <DMA_CalcDMAMUXChannelBaseAndMask>

  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 80030fc:	687b      	ldr	r3, [r7, #4]
 80030fe:	689b      	ldr	r3, [r3, #8]
 8003100:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8003104:	d102      	bne.n	800310c <HAL_DMA_Init+0xc4>
  {
    /* if memory to memory force the request to 0*/
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 8003106:	687b      	ldr	r3, [r7, #4]
 8003108:	2200      	movs	r2, #0
 800310a:	605a      	str	r2, [r3, #4]
  }

  /* Set peripheral request  to DMAMUX channel */
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800310c:	687b      	ldr	r3, [r7, #4]
 800310e:	685a      	ldr	r2, [r3, #4]
 8003110:	687b      	ldr	r3, [r7, #4]
 8003112:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8003114:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8003118:	601a      	str	r2, [r3, #0]

  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800311a:	687b      	ldr	r3, [r7, #4]
 800311c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800311e:	687a      	ldr	r2, [r7, #4]
 8003120:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8003122:	605a      	str	r2, [r3, #4]

  if (((hdma->Init.Request >  0U) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8003124:	687b      	ldr	r3, [r7, #4]
 8003126:	685b      	ldr	r3, [r3, #4]
 8003128:	2b00      	cmp	r3, #0
 800312a:	d010      	beq.n	800314e <HAL_DMA_Init+0x106>
 800312c:	687b      	ldr	r3, [r7, #4]
 800312e:	685b      	ldr	r3, [r3, #4]
 8003130:	2b04      	cmp	r3, #4
 8003132:	d80c      	bhi.n	800314e <HAL_DMA_Init+0x106>
  {
    /* Initialize parameters for DMAMUX request generator :
       DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask
    */
    DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
 8003134:	6878      	ldr	r0, [r7, #4]
 8003136:	f000 f91d 	bl	8003374 <DMA_CalcDMAMUXRequestGenBaseAndMask>

    /* Reset the DMAMUX request generator register*/
    hdma->DMAmuxRequestGen->RGCR = 0U;
 800313a:	687b      	ldr	r3, [r7, #4]
 800313c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800313e:	2200      	movs	r2, #0
 8003140:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8003142:	687b      	ldr	r3, [r7, #4]
 8003144:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8003146:	687a      	ldr	r2, [r7, #4]
 8003148:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 800314a:	605a      	str	r2, [r3, #4]
 800314c:	e008      	b.n	8003160 <HAL_DMA_Init+0x118>
  }
  else
  {
    hdma->DMAmuxRequestGen = 0U;
 800314e:	687b      	ldr	r3, [r7, #4]
 8003150:	2200      	movs	r2, #0
 8003152:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->DMAmuxRequestGenStatus = 0U;
 8003154:	687b      	ldr	r3, [r7, #4]
 8003156:	2200      	movs	r2, #0
 8003158:	659a      	str	r2, [r3, #88]	; 0x58
    hdma->DMAmuxRequestGenStatusMask = 0U;
 800315a:	687b      	ldr	r3, [r7, #4]
 800315c:	2200      	movs	r2, #0
 800315e:	65da      	str	r2, [r3, #92]	; 0x5c
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003160:	687b      	ldr	r3, [r7, #4]
 8003162:	2200      	movs	r2, #0
 8003164:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Initialize the DMA state*/
  hdma->State  = HAL_DMA_STATE_READY;
 8003166:	687b      	ldr	r3, [r7, #4]
 8003168:	2201      	movs	r2, #1
 800316a:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;
 800316e:	687b      	ldr	r3, [r7, #4]
 8003170:	2200      	movs	r2, #0
 8003172:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  return HAL_OK;
 8003176:	2300      	movs	r3, #0
}
 8003178:	4618      	mov	r0, r3
 800317a:	3710      	adds	r7, #16
 800317c:	46bd      	mov	sp, r7
 800317e:	bd80      	pop	{r7, pc}
 8003180:	40020407 	.word	0x40020407
 8003184:	bffdfff8 	.word	0xbffdfff8
 8003188:	cccccccd 	.word	0xcccccccd
 800318c:	40020000 	.word	0x40020000
 8003190:	bffdfbf8 	.word	0xbffdfbf8
 8003194:	40020400 	.word	0x40020400

08003198 <HAL_DMA_IRQHandler>:
  * @param hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8003198:	b580      	push	{r7, lr}
 800319a:	b084      	sub	sp, #16
 800319c:	af00      	add	r7, sp, #0
 800319e:	6078      	str	r0, [r7, #4]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 80031a0:	687b      	ldr	r3, [r7, #4]
 80031a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80031a4:	681b      	ldr	r3, [r3, #0]
 80031a6:	60fb      	str	r3, [r7, #12]
  uint32_t source_it = hdma->Instance->CCR;
 80031a8:	687b      	ldr	r3, [r7, #4]
 80031aa:	681b      	ldr	r3, [r3, #0]
 80031ac:	681b      	ldr	r3, [r3, #0]
 80031ae:	60bb      	str	r3, [r7, #8]

  /* Half Transfer Complete Interrupt management ******************************/
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 80031b0:	687b      	ldr	r3, [r7, #4]
 80031b2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80031b4:	f003 031c 	and.w	r3, r3, #28
 80031b8:	2204      	movs	r2, #4
 80031ba:	409a      	lsls	r2, r3
 80031bc:	68fb      	ldr	r3, [r7, #12]
 80031be:	4013      	ands	r3, r2
 80031c0:	2b00      	cmp	r3, #0
 80031c2:	d026      	beq.n	8003212 <HAL_DMA_IRQHandler+0x7a>
 80031c4:	68bb      	ldr	r3, [r7, #8]
 80031c6:	f003 0304 	and.w	r3, r3, #4
 80031ca:	2b00      	cmp	r3, #0
 80031cc:	d021      	beq.n	8003212 <HAL_DMA_IRQHandler+0x7a>
  {
    /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 80031ce:	687b      	ldr	r3, [r7, #4]
 80031d0:	681b      	ldr	r3, [r3, #0]
 80031d2:	681b      	ldr	r3, [r3, #0]
 80031d4:	f003 0320 	and.w	r3, r3, #32
 80031d8:	2b00      	cmp	r3, #0
 80031da:	d107      	bne.n	80031ec <HAL_DMA_IRQHandler+0x54>
    {
      /* Disable the half transfer interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 80031dc:	687b      	ldr	r3, [r7, #4]
 80031de:	681b      	ldr	r3, [r3, #0]
 80031e0:	681a      	ldr	r2, [r3, #0]
 80031e2:	687b      	ldr	r3, [r7, #4]
 80031e4:	681b      	ldr	r3, [r3, #0]
 80031e6:	f022 0204 	bic.w	r2, r2, #4
 80031ea:	601a      	str	r2, [r3, #0]
    }
    /* Clear the half transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU));
 80031ec:	687b      	ldr	r3, [r7, #4]
 80031ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80031f0:	f003 021c 	and.w	r2, r3, #28
 80031f4:	687b      	ldr	r3, [r7, #4]
 80031f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80031f8:	2104      	movs	r1, #4
 80031fa:	fa01 f202 	lsl.w	r2, r1, r2
 80031fe:	605a      	str	r2, [r3, #4]

    /* DMA peripheral state is not updated in Half Transfer */
    /* but in Transfer Complete case */

    if (hdma->XferHalfCpltCallback != NULL)
 8003200:	687b      	ldr	r3, [r7, #4]
 8003202:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8003204:	2b00      	cmp	r3, #0
 8003206:	d071      	beq.n	80032ec <HAL_DMA_IRQHandler+0x154>
    {
      /* Half transfer callback */
      hdma->XferHalfCpltCallback(hdma);
 8003208:	687b      	ldr	r3, [r7, #4]
 800320a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800320c:	6878      	ldr	r0, [r7, #4]
 800320e:	4798      	blx	r3
    if (hdma->XferHalfCpltCallback != NULL)
 8003210:	e06c      	b.n	80032ec <HAL_DMA_IRQHandler+0x154>
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  else if (((flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_TC) != 0U))
 8003212:	687b      	ldr	r3, [r7, #4]
 8003214:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003216:	f003 031c 	and.w	r3, r3, #28
 800321a:	2202      	movs	r2, #2
 800321c:	409a      	lsls	r2, r3
 800321e:	68fb      	ldr	r3, [r7, #12]
 8003220:	4013      	ands	r3, r2
 8003222:	2b00      	cmp	r3, #0
 8003224:	d02e      	beq.n	8003284 <HAL_DMA_IRQHandler+0xec>
 8003226:	68bb      	ldr	r3, [r7, #8]
 8003228:	f003 0302 	and.w	r3, r3, #2
 800322c:	2b00      	cmp	r3, #0
 800322e:	d029      	beq.n	8003284 <HAL_DMA_IRQHandler+0xec>
  {
    if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8003230:	687b      	ldr	r3, [r7, #4]
 8003232:	681b      	ldr	r3, [r3, #0]
 8003234:	681b      	ldr	r3, [r3, #0]
 8003236:	f003 0320 	and.w	r3, r3, #32
 800323a:	2b00      	cmp	r3, #0
 800323c:	d10b      	bne.n	8003256 <HAL_DMA_IRQHandler+0xbe>
    {
      /* Disable the transfer complete and error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 800323e:	687b      	ldr	r3, [r7, #4]
 8003240:	681b      	ldr	r3, [r3, #0]
 8003242:	681a      	ldr	r2, [r3, #0]
 8003244:	687b      	ldr	r3, [r7, #4]
 8003246:	681b      	ldr	r3, [r3, #0]
 8003248:	f022 020a 	bic.w	r2, r2, #10
 800324c:	601a      	str	r2, [r3, #0]

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 800324e:	687b      	ldr	r3, [r7, #4]
 8003250:	2201      	movs	r2, #1
 8003252:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
    }
    /* Clear the transfer complete flag */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_TCIF1 << (hdma->ChannelIndex & 0x1cU));
 8003256:	687b      	ldr	r3, [r7, #4]
 8003258:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800325a:	f003 021c 	and.w	r2, r3, #28
 800325e:	687b      	ldr	r3, [r7, #4]
 8003260:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003262:	2102      	movs	r1, #2
 8003264:	fa01 f202 	lsl.w	r2, r1, r2
 8003268:	605a      	str	r2, [r3, #4]

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800326a:	687b      	ldr	r3, [r7, #4]
 800326c:	2200      	movs	r2, #0
 800326e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferCpltCallback != NULL)
 8003272:	687b      	ldr	r3, [r7, #4]
 8003274:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003276:	2b00      	cmp	r3, #0
 8003278:	d038      	beq.n	80032ec <HAL_DMA_IRQHandler+0x154>
    {
      /* Transfer complete callback */
      hdma->XferCpltCallback(hdma);
 800327a:	687b      	ldr	r3, [r7, #4]
 800327c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800327e:	6878      	ldr	r0, [r7, #4]
 8003280:	4798      	blx	r3
    if (hdma->XferCpltCallback != NULL)
 8003282:	e033      	b.n	80032ec <HAL_DMA_IRQHandler+0x154>
    }
  }

  /* Transfer Error Interrupt management **************************************/
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1cU))) != 0U) && ((source_it & DMA_IT_TE) != 0U))
 8003284:	687b      	ldr	r3, [r7, #4]
 8003286:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003288:	f003 031c 	and.w	r3, r3, #28
 800328c:	2208      	movs	r2, #8
 800328e:	409a      	lsls	r2, r3
 8003290:	68fb      	ldr	r3, [r7, #12]
 8003292:	4013      	ands	r3, r2
 8003294:	2b00      	cmp	r3, #0
 8003296:	d02a      	beq.n	80032ee <HAL_DMA_IRQHandler+0x156>
 8003298:	68bb      	ldr	r3, [r7, #8]
 800329a:	f003 0308 	and.w	r3, r3, #8
 800329e:	2b00      	cmp	r3, #0
 80032a0:	d025      	beq.n	80032ee <HAL_DMA_IRQHandler+0x156>
  {
    /* When a DMA transfer error occurs */
    /* A hardware clear of its EN bits is performed */
    /* Disable ALL DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80032a2:	687b      	ldr	r3, [r7, #4]
 80032a4:	681b      	ldr	r3, [r3, #0]
 80032a6:	681a      	ldr	r2, [r3, #0]
 80032a8:	687b      	ldr	r3, [r7, #4]
 80032aa:	681b      	ldr	r3, [r3, #0]
 80032ac:	f022 020e 	bic.w	r2, r2, #14
 80032b0:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1cU));
 80032b2:	687b      	ldr	r3, [r7, #4]
 80032b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80032b6:	f003 021c 	and.w	r2, r3, #28
 80032ba:	687b      	ldr	r3, [r7, #4]
 80032bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80032be:	2101      	movs	r1, #1
 80032c0:	fa01 f202 	lsl.w	r2, r1, r2
 80032c4:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 80032c6:	687b      	ldr	r3, [r7, #4]
 80032c8:	2201      	movs	r2, #1
 80032ca:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 80032cc:	687b      	ldr	r3, [r7, #4]
 80032ce:	2201      	movs	r2, #1
 80032d0:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80032d4:	687b      	ldr	r3, [r7, #4]
 80032d6:	2200      	movs	r2, #0
 80032d8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    if (hdma->XferErrorCallback != NULL)
 80032dc:	687b      	ldr	r3, [r7, #4]
 80032de:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80032e0:	2b00      	cmp	r3, #0
 80032e2:	d004      	beq.n	80032ee <HAL_DMA_IRQHandler+0x156>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 80032e4:	687b      	ldr	r3, [r7, #4]
 80032e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80032e8:	6878      	ldr	r0, [r7, #4]
 80032ea:	4798      	blx	r3
  }
  else
  {
    /* Nothing To Do */
  }
  return;
 80032ec:	bf00      	nop
 80032ee:	bf00      	nop
}
 80032f0:	3710      	adds	r7, #16
 80032f2:	46bd      	mov	sp, r7
 80032f4:	bd80      	pop	{r7, pc}
	...

080032f8 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Channel.
  * @retval None
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
 80032f8:	b480      	push	{r7}
 80032fa:	b085      	sub	sp, #20
 80032fc:	af00      	add	r7, sp, #0
 80032fe:	6078      	str	r0, [r7, #4]
  uint32_t channel_number;

  /* check if instance is not outside the DMA channel range */
#if defined(DMA2)
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 8003300:	687b      	ldr	r3, [r7, #4]
 8003302:	681b      	ldr	r3, [r3, #0]
 8003304:	461a      	mov	r2, r3
 8003306:	4b17      	ldr	r3, [pc, #92]	; (8003364 <DMA_CalcDMAMUXChannelBaseAndMask+0x6c>)
 8003308:	429a      	cmp	r2, r3
 800330a:	d80a      	bhi.n	8003322 <DMA_CalcDMAMUXChannelBaseAndMask+0x2a>
  {
    /* DMA1 */
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 800330c:	687b      	ldr	r3, [r7, #4]
 800330e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003310:	089b      	lsrs	r3, r3, #2
 8003312:	009b      	lsls	r3, r3, #2
 8003314:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8003318:	f503 3302 	add.w	r3, r3, #133120	; 0x20800
 800331c:	687a      	ldr	r2, [r7, #4]
 800331e:	6493      	str	r3, [r2, #72]	; 0x48
 8003320:	e007      	b.n	8003332 <DMA_CalcDMAMUXChannelBaseAndMask+0x3a>
  }
  else
  {
    /* DMA2 */
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 8003322:	687b      	ldr	r3, [r7, #4]
 8003324:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003326:	089b      	lsrs	r3, r3, #2
 8003328:	009a      	lsls	r2, r3, #2
 800332a:	4b0f      	ldr	r3, [pc, #60]	; (8003368 <DMA_CalcDMAMUXChannelBaseAndMask+0x70>)
 800332c:	4413      	add	r3, r2
 800332e:	687a      	ldr	r2, [r7, #4]
 8003330:	6493      	str	r3, [r2, #72]	; 0x48
  }
#else
  /* DMA1 */
  hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
#endif /* DMA2 */
  channel_number = (((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U;
 8003332:	687b      	ldr	r3, [r7, #4]
 8003334:	681b      	ldr	r3, [r3, #0]
 8003336:	b2db      	uxtb	r3, r3
 8003338:	3b08      	subs	r3, #8
 800333a:	4a0c      	ldr	r2, [pc, #48]	; (800336c <DMA_CalcDMAMUXChannelBaseAndMask+0x74>)
 800333c:	fba2 2303 	umull	r2, r3, r2, r3
 8003340:	091b      	lsrs	r3, r3, #4
 8003342:	60fb      	str	r3, [r7, #12]
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8003344:	687b      	ldr	r3, [r7, #4]
 8003346:	4a0a      	ldr	r2, [pc, #40]	; (8003370 <DMA_CalcDMAMUXChannelBaseAndMask+0x78>)
 8003348:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Initialize the field DMAmuxChannelStatusMask with the corresponding index of the DMAMUX channel selected for the current ChannelIndex */
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 800334a:	68fb      	ldr	r3, [r7, #12]
 800334c:	f003 031f 	and.w	r3, r3, #31
 8003350:	2201      	movs	r2, #1
 8003352:	409a      	lsls	r2, r3
 8003354:	687b      	ldr	r3, [r7, #4]
 8003356:	651a      	str	r2, [r3, #80]	; 0x50
}
 8003358:	bf00      	nop
 800335a:	3714      	adds	r7, #20
 800335c:	46bd      	mov	sp, r7
 800335e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003362:	4770      	bx	lr
 8003364:	40020407 	.word	0x40020407
 8003368:	4002081c 	.word	0x4002081c
 800336c:	cccccccd 	.word	0xcccccccd
 8003370:	40020880 	.word	0x40020880

08003374 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  *                     the configuration information for the specified DMA Channel.
  * @retval None
  */

static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
 8003374:	b480      	push	{r7}
 8003376:	b085      	sub	sp, #20
 8003378:	af00      	add	r7, sp, #0
 800337a:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
 800337c:	687b      	ldr	r3, [r7, #4]
 800337e:	685b      	ldr	r3, [r3, #4]
 8003380:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8003384:	60fb      	str	r3, [r7, #12]

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8003386:	68fa      	ldr	r2, [r7, #12]
 8003388:	4b0b      	ldr	r3, [pc, #44]	; (80033b8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x44>)
 800338a:	4413      	add	r3, r2
 800338c:	009b      	lsls	r3, r3, #2
 800338e:	461a      	mov	r2, r3
 8003390:	687b      	ldr	r3, [r7, #4]
 8003392:	655a      	str	r2, [r3, #84]	; 0x54

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8003394:	687b      	ldr	r3, [r7, #4]
 8003396:	4a09      	ldr	r2, [pc, #36]	; (80033bc <DMA_CalcDMAMUXRequestGenBaseAndMask+0x48>)
 8003398:	659a      	str	r2, [r3, #88]	; 0x58

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 800339a:	68fb      	ldr	r3, [r7, #12]
 800339c:	3b01      	subs	r3, #1
 800339e:	f003 0303 	and.w	r3, r3, #3
 80033a2:	2201      	movs	r2, #1
 80033a4:	409a      	lsls	r2, r3
 80033a6:	687b      	ldr	r3, [r7, #4]
 80033a8:	65da      	str	r2, [r3, #92]	; 0x5c
}
 80033aa:	bf00      	nop
 80033ac:	3714      	adds	r7, #20
 80033ae:	46bd      	mov	sp, r7
 80033b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80033b4:	4770      	bx	lr
 80033b6:	bf00      	nop
 80033b8:	1000823f 	.word	0x1000823f
 80033bc:	40020940 	.word	0x40020940

080033c0 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80033c0:	b480      	push	{r7}
 80033c2:	b087      	sub	sp, #28
 80033c4:	af00      	add	r7, sp, #0
 80033c6:	6078      	str	r0, [r7, #4]
 80033c8:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 80033ca:	2300      	movs	r3, #0
 80033cc:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80033ce:	e14c      	b.n	800366a <HAL_GPIO_Init+0x2aa>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 80033d0:	683b      	ldr	r3, [r7, #0]
 80033d2:	681a      	ldr	r2, [r3, #0]
 80033d4:	2101      	movs	r1, #1
 80033d6:	697b      	ldr	r3, [r7, #20]
 80033d8:	fa01 f303 	lsl.w	r3, r1, r3
 80033dc:	4013      	ands	r3, r2
 80033de:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
 80033e0:	68fb      	ldr	r3, [r7, #12]
 80033e2:	2b00      	cmp	r3, #0
 80033e4:	f000 813e 	beq.w	8003664 <HAL_GPIO_Init+0x2a4>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 80033e8:	683b      	ldr	r3, [r7, #0]
 80033ea:	685b      	ldr	r3, [r3, #4]
 80033ec:	f003 0303 	and.w	r3, r3, #3
 80033f0:	2b01      	cmp	r3, #1
 80033f2:	d005      	beq.n	8003400 <HAL_GPIO_Init+0x40>
 80033f4:	683b      	ldr	r3, [r7, #0]
 80033f6:	685b      	ldr	r3, [r3, #4]
 80033f8:	f003 0303 	and.w	r3, r3, #3
 80033fc:	2b02      	cmp	r3, #2
 80033fe:	d130      	bne.n	8003462 <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8003400:	687b      	ldr	r3, [r7, #4]
 8003402:	689b      	ldr	r3, [r3, #8]
 8003404:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8003406:	697b      	ldr	r3, [r7, #20]
 8003408:	005b      	lsls	r3, r3, #1
 800340a:	2203      	movs	r2, #3
 800340c:	fa02 f303 	lsl.w	r3, r2, r3
 8003410:	43db      	mvns	r3, r3
 8003412:	693a      	ldr	r2, [r7, #16]
 8003414:	4013      	ands	r3, r2
 8003416:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
 8003418:	683b      	ldr	r3, [r7, #0]
 800341a:	68da      	ldr	r2, [r3, #12]
 800341c:	697b      	ldr	r3, [r7, #20]
 800341e:	005b      	lsls	r3, r3, #1
 8003420:	fa02 f303 	lsl.w	r3, r2, r3
 8003424:	693a      	ldr	r2, [r7, #16]
 8003426:	4313      	orrs	r3, r2
 8003428:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
 800342a:	687b      	ldr	r3, [r7, #4]
 800342c:	693a      	ldr	r2, [r7, #16]
 800342e:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8003430:	687b      	ldr	r3, [r7, #4]
 8003432:	685b      	ldr	r3, [r3, #4]
 8003434:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8003436:	2201      	movs	r2, #1
 8003438:	697b      	ldr	r3, [r7, #20]
 800343a:	fa02 f303 	lsl.w	r3, r2, r3
 800343e:	43db      	mvns	r3, r3
 8003440:	693a      	ldr	r2, [r7, #16]
 8003442:	4013      	ands	r3, r2
 8003444:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8003446:	683b      	ldr	r3, [r7, #0]
 8003448:	685b      	ldr	r3, [r3, #4]
 800344a:	091b      	lsrs	r3, r3, #4
 800344c:	f003 0201 	and.w	r2, r3, #1
 8003450:	697b      	ldr	r3, [r7, #20]
 8003452:	fa02 f303 	lsl.w	r3, r2, r3
 8003456:	693a      	ldr	r2, [r7, #16]
 8003458:	4313      	orrs	r3, r2
 800345a:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
 800345c:	687b      	ldr	r3, [r7, #4]
 800345e:	693a      	ldr	r2, [r7, #16]
 8003460:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8003462:	683b      	ldr	r3, [r7, #0]
 8003464:	685b      	ldr	r3, [r3, #4]
 8003466:	f003 0303 	and.w	r3, r3, #3
 800346a:	2b03      	cmp	r3, #3
 800346c:	d017      	beq.n	800349e <HAL_GPIO_Init+0xde>
      {
        temp = GPIOx->PUPDR;
 800346e:	687b      	ldr	r3, [r7, #4]
 8003470:	68db      	ldr	r3, [r3, #12]
 8003472:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8003474:	697b      	ldr	r3, [r7, #20]
 8003476:	005b      	lsls	r3, r3, #1
 8003478:	2203      	movs	r2, #3
 800347a:	fa02 f303 	lsl.w	r3, r2, r3
 800347e:	43db      	mvns	r3, r3
 8003480:	693a      	ldr	r2, [r7, #16]
 8003482:	4013      	ands	r3, r2
 8003484:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8003486:	683b      	ldr	r3, [r7, #0]
 8003488:	689a      	ldr	r2, [r3, #8]
 800348a:	697b      	ldr	r3, [r7, #20]
 800348c:	005b      	lsls	r3, r3, #1
 800348e:	fa02 f303 	lsl.w	r3, r2, r3
 8003492:	693a      	ldr	r2, [r7, #16]
 8003494:	4313      	orrs	r3, r2
 8003496:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
 8003498:	687b      	ldr	r3, [r7, #4]
 800349a:	693a      	ldr	r2, [r7, #16]
 800349c:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 800349e:	683b      	ldr	r3, [r7, #0]
 80034a0:	685b      	ldr	r3, [r3, #4]
 80034a2:	f003 0303 	and.w	r3, r3, #3
 80034a6:	2b02      	cmp	r3, #2
 80034a8:	d123      	bne.n	80034f2 <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
 80034aa:	697b      	ldr	r3, [r7, #20]
 80034ac:	08da      	lsrs	r2, r3, #3
 80034ae:	687b      	ldr	r3, [r7, #4]
 80034b0:	3208      	adds	r2, #8
 80034b2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80034b6:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80034b8:	697b      	ldr	r3, [r7, #20]
 80034ba:	f003 0307 	and.w	r3, r3, #7
 80034be:	009b      	lsls	r3, r3, #2
 80034c0:	220f      	movs	r2, #15
 80034c2:	fa02 f303 	lsl.w	r3, r2, r3
 80034c6:	43db      	mvns	r3, r3
 80034c8:	693a      	ldr	r2, [r7, #16]
 80034ca:	4013      	ands	r3, r2
 80034cc:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80034ce:	683b      	ldr	r3, [r7, #0]
 80034d0:	691a      	ldr	r2, [r3, #16]
 80034d2:	697b      	ldr	r3, [r7, #20]
 80034d4:	f003 0307 	and.w	r3, r3, #7
 80034d8:	009b      	lsls	r3, r3, #2
 80034da:	fa02 f303 	lsl.w	r3, r2, r3
 80034de:	693a      	ldr	r2, [r7, #16]
 80034e0:	4313      	orrs	r3, r2
 80034e2:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
 80034e4:	697b      	ldr	r3, [r7, #20]
 80034e6:	08da      	lsrs	r2, r3, #3
 80034e8:	687b      	ldr	r3, [r7, #4]
 80034ea:	3208      	adds	r2, #8
 80034ec:	6939      	ldr	r1, [r7, #16]
 80034ee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 80034f2:	687b      	ldr	r3, [r7, #4]
 80034f4:	681b      	ldr	r3, [r3, #0]
 80034f6:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80034f8:	697b      	ldr	r3, [r7, #20]
 80034fa:	005b      	lsls	r3, r3, #1
 80034fc:	2203      	movs	r2, #3
 80034fe:	fa02 f303 	lsl.w	r3, r2, r3
 8003502:	43db      	mvns	r3, r3
 8003504:	693a      	ldr	r2, [r7, #16]
 8003506:	4013      	ands	r3, r2
 8003508:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 800350a:	683b      	ldr	r3, [r7, #0]
 800350c:	685b      	ldr	r3, [r3, #4]
 800350e:	f003 0203 	and.w	r2, r3, #3
 8003512:	697b      	ldr	r3, [r7, #20]
 8003514:	005b      	lsls	r3, r3, #1
 8003516:	fa02 f303 	lsl.w	r3, r2, r3
 800351a:	693a      	ldr	r2, [r7, #16]
 800351c:	4313      	orrs	r3, r2
 800351e:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
 8003520:	687b      	ldr	r3, [r7, #4]
 8003522:	693a      	ldr	r2, [r7, #16]
 8003524:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8003526:	683b      	ldr	r3, [r7, #0]
 8003528:	685b      	ldr	r3, [r3, #4]
 800352a:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800352e:	2b00      	cmp	r3, #0
 8003530:	f000 8098 	beq.w	8003664 <HAL_GPIO_Init+0x2a4>
      {
        temp = SYSCFG->EXTICR[position >> 2u];
 8003534:	4a54      	ldr	r2, [pc, #336]	; (8003688 <HAL_GPIO_Init+0x2c8>)
 8003536:	697b      	ldr	r3, [r7, #20]
 8003538:	089b      	lsrs	r3, r3, #2
 800353a:	3302      	adds	r3, #2
 800353c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003540:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8003542:	697b      	ldr	r3, [r7, #20]
 8003544:	f003 0303 	and.w	r3, r3, #3
 8003548:	009b      	lsls	r3, r3, #2
 800354a:	220f      	movs	r2, #15
 800354c:	fa02 f303 	lsl.w	r3, r2, r3
 8003550:	43db      	mvns	r3, r3
 8003552:	693a      	ldr	r2, [r7, #16]
 8003554:	4013      	ands	r3, r2
 8003556:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8003558:	687b      	ldr	r3, [r7, #4]
 800355a:	f1b3 4f90 	cmp.w	r3, #1207959552	; 0x48000000
 800355e:	d019      	beq.n	8003594 <HAL_GPIO_Init+0x1d4>
 8003560:	687b      	ldr	r3, [r7, #4]
 8003562:	4a4a      	ldr	r2, [pc, #296]	; (800368c <HAL_GPIO_Init+0x2cc>)
 8003564:	4293      	cmp	r3, r2
 8003566:	d013      	beq.n	8003590 <HAL_GPIO_Init+0x1d0>
 8003568:	687b      	ldr	r3, [r7, #4]
 800356a:	4a49      	ldr	r2, [pc, #292]	; (8003690 <HAL_GPIO_Init+0x2d0>)
 800356c:	4293      	cmp	r3, r2
 800356e:	d00d      	beq.n	800358c <HAL_GPIO_Init+0x1cc>
 8003570:	687b      	ldr	r3, [r7, #4]
 8003572:	4a48      	ldr	r2, [pc, #288]	; (8003694 <HAL_GPIO_Init+0x2d4>)
 8003574:	4293      	cmp	r3, r2
 8003576:	d007      	beq.n	8003588 <HAL_GPIO_Init+0x1c8>
 8003578:	687b      	ldr	r3, [r7, #4]
 800357a:	4a47      	ldr	r2, [pc, #284]	; (8003698 <HAL_GPIO_Init+0x2d8>)
 800357c:	4293      	cmp	r3, r2
 800357e:	d101      	bne.n	8003584 <HAL_GPIO_Init+0x1c4>
 8003580:	2304      	movs	r3, #4
 8003582:	e008      	b.n	8003596 <HAL_GPIO_Init+0x1d6>
 8003584:	2307      	movs	r3, #7
 8003586:	e006      	b.n	8003596 <HAL_GPIO_Init+0x1d6>
 8003588:	2303      	movs	r3, #3
 800358a:	e004      	b.n	8003596 <HAL_GPIO_Init+0x1d6>
 800358c:	2302      	movs	r3, #2
 800358e:	e002      	b.n	8003596 <HAL_GPIO_Init+0x1d6>
 8003590:	2301      	movs	r3, #1
 8003592:	e000      	b.n	8003596 <HAL_GPIO_Init+0x1d6>
 8003594:	2300      	movs	r3, #0
 8003596:	697a      	ldr	r2, [r7, #20]
 8003598:	f002 0203 	and.w	r2, r2, #3
 800359c:	0092      	lsls	r2, r2, #2
 800359e:	4093      	lsls	r3, r2
 80035a0:	693a      	ldr	r2, [r7, #16]
 80035a2:	4313      	orrs	r3, r2
 80035a4:	613b      	str	r3, [r7, #16]
        SYSCFG->EXTICR[position >> 2u] = temp;
 80035a6:	4938      	ldr	r1, [pc, #224]	; (8003688 <HAL_GPIO_Init+0x2c8>)
 80035a8:	697b      	ldr	r3, [r7, #20]
 80035aa:	089b      	lsrs	r3, r3, #2
 80035ac:	3302      	adds	r3, #2
 80035ae:	693a      	ldr	r2, [r7, #16]
 80035b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 80035b4:	4b39      	ldr	r3, [pc, #228]	; (800369c <HAL_GPIO_Init+0x2dc>)
 80035b6:	681b      	ldr	r3, [r3, #0]
 80035b8:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 80035ba:	68fb      	ldr	r3, [r7, #12]
 80035bc:	43db      	mvns	r3, r3
 80035be:	693a      	ldr	r2, [r7, #16]
 80035c0:	4013      	ands	r3, r2
 80035c2:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 80035c4:	683b      	ldr	r3, [r7, #0]
 80035c6:	685b      	ldr	r3, [r3, #4]
 80035c8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 80035cc:	2b00      	cmp	r3, #0
 80035ce:	d003      	beq.n	80035d8 <HAL_GPIO_Init+0x218>
        {
          temp |= iocurrent;
 80035d0:	693a      	ldr	r2, [r7, #16]
 80035d2:	68fb      	ldr	r3, [r7, #12]
 80035d4:	4313      	orrs	r3, r2
 80035d6:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
 80035d8:	4a30      	ldr	r2, [pc, #192]	; (800369c <HAL_GPIO_Init+0x2dc>)
 80035da:	693b      	ldr	r3, [r7, #16]
 80035dc:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 80035de:	4b2f      	ldr	r3, [pc, #188]	; (800369c <HAL_GPIO_Init+0x2dc>)
 80035e0:	685b      	ldr	r3, [r3, #4]
 80035e2:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 80035e4:	68fb      	ldr	r3, [r7, #12]
 80035e6:	43db      	mvns	r3, r3
 80035e8:	693a      	ldr	r2, [r7, #16]
 80035ea:	4013      	ands	r3, r2
 80035ec:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 80035ee:	683b      	ldr	r3, [r7, #0]
 80035f0:	685b      	ldr	r3, [r3, #4]
 80035f2:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80035f6:	2b00      	cmp	r3, #0
 80035f8:	d003      	beq.n	8003602 <HAL_GPIO_Init+0x242>
        {
          temp |= iocurrent;
 80035fa:	693a      	ldr	r2, [r7, #16]
 80035fc:	68fb      	ldr	r3, [r7, #12]
 80035fe:	4313      	orrs	r3, r2
 8003600:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
 8003602:	4a26      	ldr	r2, [pc, #152]	; (800369c <HAL_GPIO_Init+0x2dc>)
 8003604:	693b      	ldr	r3, [r7, #16]
 8003606:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8003608:	4b24      	ldr	r3, [pc, #144]	; (800369c <HAL_GPIO_Init+0x2dc>)
 800360a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800360e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 8003610:	68fb      	ldr	r3, [r7, #12]
 8003612:	43db      	mvns	r3, r3
 8003614:	693a      	ldr	r2, [r7, #16]
 8003616:	4013      	ands	r3, r2
 8003618:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 800361a:	683b      	ldr	r3, [r7, #0]
 800361c:	685b      	ldr	r3, [r3, #4]
 800361e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8003622:	2b00      	cmp	r3, #0
 8003624:	d003      	beq.n	800362e <HAL_GPIO_Init+0x26e>
        {
          temp |= iocurrent;
 8003626:	693a      	ldr	r2, [r7, #16]
 8003628:	68fb      	ldr	r3, [r7, #12]
 800362a:	4313      	orrs	r3, r2
 800362c:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
 800362e:	4a1b      	ldr	r2, [pc, #108]	; (800369c <HAL_GPIO_Init+0x2dc>)
 8003630:	693b      	ldr	r3, [r7, #16]
 8003632:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

        temp = EXTI->EMR1;
 8003636:	4b19      	ldr	r3, [pc, #100]	; (800369c <HAL_GPIO_Init+0x2dc>)
 8003638:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800363c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
 800363e:	68fb      	ldr	r3, [r7, #12]
 8003640:	43db      	mvns	r3, r3
 8003642:	693a      	ldr	r2, [r7, #16]
 8003644:	4013      	ands	r3, r2
 8003646:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8003648:	683b      	ldr	r3, [r7, #0]
 800364a:	685b      	ldr	r3, [r3, #4]
 800364c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003650:	2b00      	cmp	r3, #0
 8003652:	d003      	beq.n	800365c <HAL_GPIO_Init+0x29c>
        {
          temp |= iocurrent;
 8003654:	693a      	ldr	r2, [r7, #16]
 8003656:	68fb      	ldr	r3, [r7, #12]
 8003658:	4313      	orrs	r3, r2
 800365a:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
 800365c:	4a0f      	ldr	r2, [pc, #60]	; (800369c <HAL_GPIO_Init+0x2dc>)
 800365e:	693b      	ldr	r3, [r7, #16]
 8003660:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
      }
    }

    position++;
 8003664:	697b      	ldr	r3, [r7, #20]
 8003666:	3301      	adds	r3, #1
 8003668:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800366a:	683b      	ldr	r3, [r7, #0]
 800366c:	681a      	ldr	r2, [r3, #0]
 800366e:	697b      	ldr	r3, [r7, #20]
 8003670:	fa22 f303 	lsr.w	r3, r2, r3
 8003674:	2b00      	cmp	r3, #0
 8003676:	f47f aeab 	bne.w	80033d0 <HAL_GPIO_Init+0x10>
  }
}
 800367a:	bf00      	nop
 800367c:	bf00      	nop
 800367e:	371c      	adds	r7, #28
 8003680:	46bd      	mov	sp, r7
 8003682:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003686:	4770      	bx	lr
 8003688:	40010000 	.word	0x40010000
 800368c:	48000400 	.word	0x48000400
 8003690:	48000800 	.word	0x48000800
 8003694:	48000c00 	.word	0x48000c00
 8003698:	48001000 	.word	0x48001000
 800369c:	58000800 	.word	0x58000800

080036a0 <HAL_LPTIM_Init>:
  *         LPTIM_InitTypeDef and initialize the associated handle.
  * @param  hlptim LPTIM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LPTIM_Init(LPTIM_HandleTypeDef *hlptim)
{
 80036a0:	b580      	push	{r7, lr}
 80036a2:	b084      	sub	sp, #16
 80036a4:	af00      	add	r7, sp, #0
 80036a6:	6078      	str	r0, [r7, #4]
  uint32_t tmpcfgr;

  /* Check the LPTIM handle allocation */
  if (hlptim == NULL)
 80036a8:	687b      	ldr	r3, [r7, #4]
 80036aa:	2b00      	cmp	r3, #0
 80036ac:	d101      	bne.n	80036b2 <HAL_LPTIM_Init+0x12>
  {
    return HAL_ERROR;
 80036ae:	2301      	movs	r3, #1
 80036b0:	e08f      	b.n	80037d2 <HAL_LPTIM_Init+0x132>
  /* Check the parameters */
  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));

  assert_param(IS_LPTIM_CLOCK_SOURCE(hlptim->Init.Clock.Source));
  assert_param(IS_LPTIM_CLOCK_PRESCALER(hlptim->Init.Clock.Prescaler));
  if ((hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_ULPTIM)
 80036b2:	687b      	ldr	r3, [r7, #4]
 80036b4:	685b      	ldr	r3, [r3, #4]
 80036b6:	2b01      	cmp	r3, #1
  }
  assert_param(IS_LPTIM_OUTPUT_POLARITY(hlptim->Init.OutputPolarity));
  assert_param(IS_LPTIM_UPDATE_MODE(hlptim->Init.UpdateMode));
  assert_param(IS_LPTIM_COUNTER_SOURCE(hlptim->Init.CounterSource));

  if (hlptim->State == HAL_LPTIM_STATE_RESET)
 80036b8:	687b      	ldr	r3, [r7, #4]
 80036ba:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 80036be:	b2db      	uxtb	r3, r3
 80036c0:	2b00      	cmp	r3, #0
 80036c2:	d106      	bne.n	80036d2 <HAL_LPTIM_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hlptim->Lock = HAL_UNLOCKED;
 80036c4:	687b      	ldr	r3, [r7, #4]
 80036c6:	2200      	movs	r2, #0
 80036c8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    hlptim->MspInitCallback(hlptim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_LPTIM_MspInit(hlptim);
 80036cc:	6878      	ldr	r0, [r7, #4]
 80036ce:	f7fd fcb9 	bl	8001044 <HAL_LPTIM_MspInit>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
  }

  /* Change the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_BUSY;
 80036d2:	687b      	ldr	r3, [r7, #4]
 80036d4:	2202      	movs	r2, #2
 80036d6:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36

  /* Get the LPTIMx CFGR value */
  tmpcfgr = hlptim->Instance->CFGR;
 80036da:	687b      	ldr	r3, [r7, #4]
 80036dc:	681b      	ldr	r3, [r3, #0]
 80036de:	68db      	ldr	r3, [r3, #12]
 80036e0:	60fb      	str	r3, [r7, #12]

  if ((hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_ULPTIM)
 80036e2:	687b      	ldr	r3, [r7, #4]
 80036e4:	685b      	ldr	r3, [r3, #4]
 80036e6:	2b01      	cmp	r3, #1
 80036e8:	d004      	beq.n	80036f4 <HAL_LPTIM_Init+0x54>
      || (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))
 80036ea:	687b      	ldr	r3, [r7, #4]
 80036ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80036ee:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80036f2:	d103      	bne.n	80036fc <HAL_LPTIM_Init+0x5c>
  {
    tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKPOL | LPTIM_CFGR_CKFLT));
 80036f4:	68fb      	ldr	r3, [r7, #12]
 80036f6:	f023 031e 	bic.w	r3, r3, #30
 80036fa:	60fb      	str	r3, [r7, #12]
  }
  if (hlptim->Init.Trigger.Source != LPTIM_TRIGSOURCE_SOFTWARE)
 80036fc:	687b      	ldr	r3, [r7, #4]
 80036fe:	695b      	ldr	r3, [r3, #20]
 8003700:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8003704:	4293      	cmp	r3, r2
 8003706:	d005      	beq.n	8003714 <HAL_LPTIM_Init+0x74>
  {
    tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_TRGFLT | LPTIM_CFGR_TRIGSEL));
 8003708:	68fb      	ldr	r3, [r7, #12]
 800370a:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800370e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8003712:	60fb      	str	r3, [r7, #12]
  }

  /* Clear CKSEL, PRESC, TRIGEN, TRGFLT, WAVPOL, PRELOAD & COUNTMODE bits */
  tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKSEL | LPTIM_CFGR_TRIGEN | LPTIM_CFGR_PRELOAD |
 8003714:	68fa      	ldr	r2, [r7, #12]
 8003716:	4b31      	ldr	r3, [pc, #196]	; (80037dc <HAL_LPTIM_Init+0x13c>)
 8003718:	4013      	ands	r3, r2
 800371a:	60fb      	str	r3, [r7, #12]
                          LPTIM_CFGR_WAVPOL | LPTIM_CFGR_PRESC | LPTIM_CFGR_COUNTMODE));

  /* Set initialization parameters */
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 800371c:	687b      	ldr	r3, [r7, #4]
 800371e:	685a      	ldr	r2, [r3, #4]
              hlptim->Init.Clock.Prescaler |
 8003720:	687b      	ldr	r3, [r7, #4]
 8003722:	689b      	ldr	r3, [r3, #8]
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 8003724:	431a      	orrs	r2, r3
              hlptim->Init.OutputPolarity  |
 8003726:	687b      	ldr	r3, [r7, #4]
 8003728:	6a1b      	ldr	r3, [r3, #32]
              hlptim->Init.Clock.Prescaler |
 800372a:	431a      	orrs	r2, r3
              hlptim->Init.UpdateMode      |
 800372c:	687b      	ldr	r3, [r7, #4]
 800372e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
              hlptim->Init.OutputPolarity  |
 8003730:	431a      	orrs	r2, r3
              hlptim->Init.CounterSource);
 8003732:	687b      	ldr	r3, [r7, #4]
 8003734:	6a9b      	ldr	r3, [r3, #40]	; 0x28
              hlptim->Init.UpdateMode      |
 8003736:	4313      	orrs	r3, r2
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 8003738:	68fa      	ldr	r2, [r7, #12]
 800373a:	4313      	orrs	r3, r2
 800373c:	60fb      	str	r3, [r7, #12]

  /* Glitch filters for internal triggers and  external inputs are configured
   * only if an internal clock source is provided to the LPTIM
   */
  if (hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC)
 800373e:	687b      	ldr	r3, [r7, #4]
 8003740:	685b      	ldr	r3, [r3, #4]
 8003742:	2b00      	cmp	r3, #0
 8003744:	d107      	bne.n	8003756 <HAL_LPTIM_Init+0xb6>
  {
    tmpcfgr |= (hlptim->Init.Trigger.SampleTime |
 8003746:	687b      	ldr	r3, [r7, #4]
 8003748:	69da      	ldr	r2, [r3, #28]
                hlptim->Init.UltraLowPowerClock.SampleTime);
 800374a:	687b      	ldr	r3, [r7, #4]
 800374c:	691b      	ldr	r3, [r3, #16]
    tmpcfgr |= (hlptim->Init.Trigger.SampleTime |
 800374e:	4313      	orrs	r3, r2
 8003750:	68fa      	ldr	r2, [r7, #12]
 8003752:	4313      	orrs	r3, r2
 8003754:	60fb      	str	r3, [r7, #12]
  }

  /* Configure LPTIM external clock polarity and digital filter */
  if ((hlptim->Init.Clock.Source == LPTIM_CLOCKSOURCE_ULPTIM)
 8003756:	687b      	ldr	r3, [r7, #4]
 8003758:	685b      	ldr	r3, [r3, #4]
 800375a:	2b01      	cmp	r3, #1
 800375c:	d004      	beq.n	8003768 <HAL_LPTIM_Init+0xc8>
      || (hlptim->Init.CounterSource == LPTIM_COUNTERSOURCE_EXTERNAL))
 800375e:	687b      	ldr	r3, [r7, #4]
 8003760:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003762:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8003766:	d107      	bne.n	8003778 <HAL_LPTIM_Init+0xd8>
  {
    tmpcfgr |= (hlptim->Init.UltraLowPowerClock.Polarity |
 8003768:	687b      	ldr	r3, [r7, #4]
 800376a:	68da      	ldr	r2, [r3, #12]
                hlptim->Init.UltraLowPowerClock.SampleTime);
 800376c:	687b      	ldr	r3, [r7, #4]
 800376e:	691b      	ldr	r3, [r3, #16]
    tmpcfgr |= (hlptim->Init.UltraLowPowerClock.Polarity |
 8003770:	4313      	orrs	r3, r2
 8003772:	68fa      	ldr	r2, [r7, #12]
 8003774:	4313      	orrs	r3, r2
 8003776:	60fb      	str	r3, [r7, #12]
  }

  /* Configure LPTIM external trigger */
  if (hlptim->Init.Trigger.Source != LPTIM_TRIGSOURCE_SOFTWARE)
 8003778:	687b      	ldr	r3, [r7, #4]
 800377a:	695b      	ldr	r3, [r3, #20]
 800377c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8003780:	4293      	cmp	r3, r2
 8003782:	d00a      	beq.n	800379a <HAL_LPTIM_Init+0xfa>
  {
    /* Enable External trigger and set the trigger source */
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 8003784:	687b      	ldr	r3, [r7, #4]
 8003786:	695a      	ldr	r2, [r3, #20]
                hlptim->Init.Trigger.ActiveEdge |
 8003788:	687b      	ldr	r3, [r7, #4]
 800378a:	699b      	ldr	r3, [r3, #24]
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 800378c:	431a      	orrs	r2, r3
                hlptim->Init.Trigger.SampleTime);
 800378e:	687b      	ldr	r3, [r7, #4]
 8003790:	69db      	ldr	r3, [r3, #28]
                hlptim->Init.Trigger.ActiveEdge |
 8003792:	4313      	orrs	r3, r2
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 8003794:	68fa      	ldr	r2, [r7, #12]
 8003796:	4313      	orrs	r3, r2
 8003798:	60fb      	str	r3, [r7, #12]
  }

  /* Write to LPTIMx CFGR */
  hlptim->Instance->CFGR = tmpcfgr;
 800379a:	687b      	ldr	r3, [r7, #4]
 800379c:	681b      	ldr	r3, [r3, #0]
 800379e:	68fa      	ldr	r2, [r7, #12]
 80037a0:	60da      	str	r2, [r3, #12]
#if defined(LPTIM_OR_OR)

  /* Configure LPTIM input sources */
  if (hlptim->Instance == LPTIM1)
 80037a2:	687b      	ldr	r3, [r7, #4]
 80037a4:	681b      	ldr	r3, [r3, #0]
 80037a6:	4a0e      	ldr	r2, [pc, #56]	; (80037e0 <HAL_LPTIM_Init+0x140>)
 80037a8:	4293      	cmp	r3, r2
 80037aa:	d108      	bne.n	80037be <HAL_LPTIM_Init+0x11e>
    /* Check LPTIM Input1 and Input2 sources */
    assert_param(IS_LPTIM_INPUT1_SOURCE(hlptim->Instance, hlptim->Init.Input1Source));
    assert_param(IS_LPTIM_INPUT2_SOURCE(hlptim->Instance, hlptim->Init.Input2Source));

    /* Configure LPTIM Input1 and Input2 sources */
    hlptim->Instance->OR = (hlptim->Init.Input1Source | hlptim->Init.Input2Source);
 80037ac:	687b      	ldr	r3, [r7, #4]
 80037ae:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80037b0:	687b      	ldr	r3, [r7, #4]
 80037b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80037b4:	687b      	ldr	r3, [r7, #4]
 80037b6:	681b      	ldr	r3, [r3, #0]
 80037b8:	430a      	orrs	r2, r1
 80037ba:	621a      	str	r2, [r3, #32]
 80037bc:	e004      	b.n	80037c8 <HAL_LPTIM_Init+0x128>
  {
    /* Check LPTIM2 Input1 source */
    assert_param(IS_LPTIM_INPUT1_SOURCE(hlptim->Instance, hlptim->Init.Input1Source));

    /* Configure LPTIM2 Input1 source */
    hlptim->Instance->OR = hlptim->Init.Input1Source;
 80037be:	687b      	ldr	r3, [r7, #4]
 80037c0:	681b      	ldr	r3, [r3, #0]
 80037c2:	687a      	ldr	r2, [r7, #4]
 80037c4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80037c6:	621a      	str	r2, [r3, #32]
  }
#endif /* LPTIM_OR_OR */

  /* Change the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_READY;
 80037c8:	687b      	ldr	r3, [r7, #4]
 80037ca:	2201      	movs	r2, #1
 80037cc:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36

  /* Return function status */
  return HAL_OK;
 80037d0:	2300      	movs	r3, #0
}
 80037d2:	4618      	mov	r0, r3
 80037d4:	3710      	adds	r7, #16
 80037d6:	46bd      	mov	sp, r7
 80037d8:	bd80      	pop	{r7, pc}
 80037da:	bf00      	nop
 80037dc:	ff19f1fe 	.word	0xff19f1fe
 80037e0:	40007c00 	.word	0x40007c00

080037e4 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 80037e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80037e6:	b08b      	sub	sp, #44	; 0x2c
 80037e8:	af06      	add	r7, sp, #24
 80037ea:	6078      	str	r0, [r7, #4]
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 80037ec:	687b      	ldr	r3, [r7, #4]
 80037ee:	2b00      	cmp	r3, #0
 80037f0:	d101      	bne.n	80037f6 <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 80037f2:	2301      	movs	r3, #1
 80037f4:	e0cb      	b.n	800398e <HAL_PCD_Init+0x1aa>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 80037f6:	687b      	ldr	r3, [r7, #4]
 80037f8:	f893 32a9 	ldrb.w	r3, [r3, #681]	; 0x2a9
 80037fc:	b2db      	uxtb	r3, r3
 80037fe:	2b00      	cmp	r3, #0
 8003800:	d106      	bne.n	8003810 <HAL_PCD_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 8003802:	687b      	ldr	r3, [r7, #4]
 8003804:	2200      	movs	r2, #0
 8003806:	f883 22a8 	strb.w	r2, [r3, #680]	; 0x2a8

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 800380a:	6878      	ldr	r0, [r7, #4]
 800380c:	f7fe fbe8 	bl	8001fe0 <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 8003810:	687b      	ldr	r3, [r7, #4]
 8003812:	2203      	movs	r2, #3
 8003814:	f883 22a9 	strb.w	r2, [r3, #681]	; 0x2a9

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 8003818:	687b      	ldr	r3, [r7, #4]
 800381a:	681b      	ldr	r3, [r3, #0]
 800381c:	4618      	mov	r0, r3
 800381e:	f004 f8af 	bl	8007980 <USB_DisableGlobalInt>

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8003822:	2300      	movs	r3, #0
 8003824:	73fb      	strb	r3, [r7, #15]
 8003826:	e040      	b.n	80038aa <HAL_PCD_Init+0xc6>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 8003828:	7bfb      	ldrb	r3, [r7, #15]
 800382a:	6879      	ldr	r1, [r7, #4]
 800382c:	1c5a      	adds	r2, r3, #1
 800382e:	4613      	mov	r3, r2
 8003830:	009b      	lsls	r3, r3, #2
 8003832:	4413      	add	r3, r2
 8003834:	00db      	lsls	r3, r3, #3
 8003836:	440b      	add	r3, r1
 8003838:	3301      	adds	r3, #1
 800383a:	2201      	movs	r2, #1
 800383c:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 800383e:	7bfb      	ldrb	r3, [r7, #15]
 8003840:	6879      	ldr	r1, [r7, #4]
 8003842:	1c5a      	adds	r2, r3, #1
 8003844:	4613      	mov	r3, r2
 8003846:	009b      	lsls	r3, r3, #2
 8003848:	4413      	add	r3, r2
 800384a:	00db      	lsls	r3, r3, #3
 800384c:	440b      	add	r3, r1
 800384e:	7bfa      	ldrb	r2, [r7, #15]
 8003850:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8003852:	7bfb      	ldrb	r3, [r7, #15]
 8003854:	6879      	ldr	r1, [r7, #4]
 8003856:	1c5a      	adds	r2, r3, #1
 8003858:	4613      	mov	r3, r2
 800385a:	009b      	lsls	r3, r3, #2
 800385c:	4413      	add	r3, r2
 800385e:	00db      	lsls	r3, r3, #3
 8003860:	440b      	add	r3, r1
 8003862:	3303      	adds	r3, #3
 8003864:	2200      	movs	r2, #0
 8003866:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 8003868:	7bfa      	ldrb	r2, [r7, #15]
 800386a:	6879      	ldr	r1, [r7, #4]
 800386c:	4613      	mov	r3, r2
 800386e:	009b      	lsls	r3, r3, #2
 8003870:	4413      	add	r3, r2
 8003872:	00db      	lsls	r3, r3, #3
 8003874:	440b      	add	r3, r1
 8003876:	3338      	adds	r3, #56	; 0x38
 8003878:	2200      	movs	r2, #0
 800387a:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 800387c:	7bfa      	ldrb	r2, [r7, #15]
 800387e:	6879      	ldr	r1, [r7, #4]
 8003880:	4613      	mov	r3, r2
 8003882:	009b      	lsls	r3, r3, #2
 8003884:	4413      	add	r3, r2
 8003886:	00db      	lsls	r3, r3, #3
 8003888:	440b      	add	r3, r1
 800388a:	333c      	adds	r3, #60	; 0x3c
 800388c:	2200      	movs	r2, #0
 800388e:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 8003890:	7bfa      	ldrb	r2, [r7, #15]
 8003892:	6879      	ldr	r1, [r7, #4]
 8003894:	4613      	mov	r3, r2
 8003896:	009b      	lsls	r3, r3, #2
 8003898:	4413      	add	r3, r2
 800389a:	00db      	lsls	r3, r3, #3
 800389c:	440b      	add	r3, r1
 800389e:	3340      	adds	r3, #64	; 0x40
 80038a0:	2200      	movs	r2, #0
 80038a2:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80038a4:	7bfb      	ldrb	r3, [r7, #15]
 80038a6:	3301      	adds	r3, #1
 80038a8:	73fb      	strb	r3, [r7, #15]
 80038aa:	7bfa      	ldrb	r2, [r7, #15]
 80038ac:	687b      	ldr	r3, [r7, #4]
 80038ae:	685b      	ldr	r3, [r3, #4]
 80038b0:	429a      	cmp	r2, r3
 80038b2:	d3b9      	bcc.n	8003828 <HAL_PCD_Init+0x44>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80038b4:	2300      	movs	r3, #0
 80038b6:	73fb      	strb	r3, [r7, #15]
 80038b8:	e044      	b.n	8003944 <HAL_PCD_Init+0x160>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 80038ba:	7bfa      	ldrb	r2, [r7, #15]
 80038bc:	6879      	ldr	r1, [r7, #4]
 80038be:	4613      	mov	r3, r2
 80038c0:	009b      	lsls	r3, r3, #2
 80038c2:	4413      	add	r3, r2
 80038c4:	00db      	lsls	r3, r3, #3
 80038c6:	440b      	add	r3, r1
 80038c8:	f203 1369 	addw	r3, r3, #361	; 0x169
 80038cc:	2200      	movs	r2, #0
 80038ce:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 80038d0:	7bfa      	ldrb	r2, [r7, #15]
 80038d2:	6879      	ldr	r1, [r7, #4]
 80038d4:	4613      	mov	r3, r2
 80038d6:	009b      	lsls	r3, r3, #2
 80038d8:	4413      	add	r3, r2
 80038da:	00db      	lsls	r3, r3, #3
 80038dc:	440b      	add	r3, r1
 80038de:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 80038e2:	7bfa      	ldrb	r2, [r7, #15]
 80038e4:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80038e6:	7bfa      	ldrb	r2, [r7, #15]
 80038e8:	6879      	ldr	r1, [r7, #4]
 80038ea:	4613      	mov	r3, r2
 80038ec:	009b      	lsls	r3, r3, #2
 80038ee:	4413      	add	r3, r2
 80038f0:	00db      	lsls	r3, r3, #3
 80038f2:	440b      	add	r3, r1
 80038f4:	f203 136b 	addw	r3, r3, #363	; 0x16b
 80038f8:	2200      	movs	r2, #0
 80038fa:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 80038fc:	7bfa      	ldrb	r2, [r7, #15]
 80038fe:	6879      	ldr	r1, [r7, #4]
 8003900:	4613      	mov	r3, r2
 8003902:	009b      	lsls	r3, r3, #2
 8003904:	4413      	add	r3, r2
 8003906:	00db      	lsls	r3, r3, #3
 8003908:	440b      	add	r3, r1
 800390a:	f503 73bc 	add.w	r3, r3, #376	; 0x178
 800390e:	2200      	movs	r2, #0
 8003910:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8003912:	7bfa      	ldrb	r2, [r7, #15]
 8003914:	6879      	ldr	r1, [r7, #4]
 8003916:	4613      	mov	r3, r2
 8003918:	009b      	lsls	r3, r3, #2
 800391a:	4413      	add	r3, r2
 800391c:	00db      	lsls	r3, r3, #3
 800391e:	440b      	add	r3, r1
 8003920:	f503 73be 	add.w	r3, r3, #380	; 0x17c
 8003924:	2200      	movs	r2, #0
 8003926:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 8003928:	7bfa      	ldrb	r2, [r7, #15]
 800392a:	6879      	ldr	r1, [r7, #4]
 800392c:	4613      	mov	r3, r2
 800392e:	009b      	lsls	r3, r3, #2
 8003930:	4413      	add	r3, r2
 8003932:	00db      	lsls	r3, r3, #3
 8003934:	440b      	add	r3, r1
 8003936:	f503 73c0 	add.w	r3, r3, #384	; 0x180
 800393a:	2200      	movs	r2, #0
 800393c:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800393e:	7bfb      	ldrb	r3, [r7, #15]
 8003940:	3301      	adds	r3, #1
 8003942:	73fb      	strb	r3, [r7, #15]
 8003944:	7bfa      	ldrb	r2, [r7, #15]
 8003946:	687b      	ldr	r3, [r7, #4]
 8003948:	685b      	ldr	r3, [r3, #4]
 800394a:	429a      	cmp	r2, r3
 800394c:	d3b5      	bcc.n	80038ba <HAL_PCD_Init+0xd6>
  }

  /* Init Device */
  (void)USB_DevInit(hpcd->Instance, hpcd->Init);
 800394e:	687b      	ldr	r3, [r7, #4]
 8003950:	681b      	ldr	r3, [r3, #0]
 8003952:	603b      	str	r3, [r7, #0]
 8003954:	687e      	ldr	r6, [r7, #4]
 8003956:	466d      	mov	r5, sp
 8003958:	f106 0410 	add.w	r4, r6, #16
 800395c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800395e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8003960:	6823      	ldr	r3, [r4, #0]
 8003962:	602b      	str	r3, [r5, #0]
 8003964:	1d33      	adds	r3, r6, #4
 8003966:	cb0e      	ldmia	r3, {r1, r2, r3}
 8003968:	6838      	ldr	r0, [r7, #0]
 800396a:	f004 f824 	bl	80079b6 <USB_DevInit>

  hpcd->USB_Address = 0U;
 800396e:	687b      	ldr	r3, [r7, #4]
 8003970:	2200      	movs	r2, #0
 8003972:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  hpcd->State = HAL_PCD_STATE_READY;
 8003976:	687b      	ldr	r3, [r7, #4]
 8003978:	2201      	movs	r2, #1
 800397a:	f883 22a9 	strb.w	r2, [r3, #681]	; 0x2a9

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
 800397e:	687b      	ldr	r3, [r7, #4]
 8003980:	69db      	ldr	r3, [r3, #28]
 8003982:	2b01      	cmp	r3, #1
 8003984:	d102      	bne.n	800398c <HAL_PCD_Init+0x1a8>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 8003986:	6878      	ldr	r0, [r7, #4]
 8003988:	f000 f805 	bl	8003996 <HAL_PCDEx_ActivateLPM>
  }

  return HAL_OK;
 800398c:	2300      	movs	r3, #0
}
 800398e:	4618      	mov	r0, r3
 8003990:	3714      	adds	r7, #20
 8003992:	46bd      	mov	sp, r7
 8003994:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003996 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 8003996:	b480      	push	{r7}
 8003998:	b085      	sub	sp, #20
 800399a:	af00      	add	r7, sp, #0
 800399c:	6078      	str	r0, [r7, #4]

  USB_TypeDef *USBx = hpcd->Instance;
 800399e:	687b      	ldr	r3, [r7, #4]
 80039a0:	681b      	ldr	r3, [r3, #0]
 80039a2:	60fb      	str	r3, [r7, #12]
  hpcd->lpm_active = 1U;
 80039a4:	687b      	ldr	r3, [r7, #4]
 80039a6:	2201      	movs	r2, #1
 80039a8:	f8c3 22e8 	str.w	r2, [r3, #744]	; 0x2e8
  hpcd->LPM_State = LPM_L0;
 80039ac:	687b      	ldr	r3, [r7, #4]
 80039ae:	2200      	movs	r2, #0
 80039b0:	f883 22e0 	strb.w	r2, [r3, #736]	; 0x2e0

  USBx->LPMCSR |= USB_LPMCSR_LMPEN;
 80039b4:	68fb      	ldr	r3, [r7, #12]
 80039b6:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 80039ba:	b29b      	uxth	r3, r3
 80039bc:	f043 0301 	orr.w	r3, r3, #1
 80039c0:	b29a      	uxth	r2, r3
 80039c2:	68fb      	ldr	r3, [r7, #12]
 80039c4:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
  USBx->LPMCSR |= USB_LPMCSR_LPMACK;
 80039c8:	68fb      	ldr	r3, [r7, #12]
 80039ca:	f8b3 3054 	ldrh.w	r3, [r3, #84]	; 0x54
 80039ce:	b29b      	uxth	r3, r3
 80039d0:	f043 0302 	orr.w	r3, r3, #2
 80039d4:	b29a      	uxth	r2, r3
 80039d6:	68fb      	ldr	r3, [r7, #12]
 80039d8:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54

  return HAL_OK;
 80039dc:	2300      	movs	r3, #0
}
 80039de:	4618      	mov	r0, r3
 80039e0:	3714      	adds	r7, #20
 80039e2:	46bd      	mov	sp, r7
 80039e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039e8:	4770      	bx	lr
	...

080039ec <HAL_PWR_EnableBkUpAccess>:
  * @note   LSEON bit that switches on and off the LSE crystal belongs as well to the
  *         back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 80039ec:	b480      	push	{r7}
 80039ee:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80039f0:	4b05      	ldr	r3, [pc, #20]	; (8003a08 <HAL_PWR_EnableBkUpAccess+0x1c>)
 80039f2:	681b      	ldr	r3, [r3, #0]
 80039f4:	4a04      	ldr	r2, [pc, #16]	; (8003a08 <HAL_PWR_EnableBkUpAccess+0x1c>)
 80039f6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80039fa:	6013      	str	r3, [r2, #0]
}
 80039fc:	bf00      	nop
 80039fe:	46bd      	mov	sp, r7
 8003a00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a04:	4770      	bx	lr
 8003a06:	bf00      	nop
 8003a08:	58000400 	.word	0x58000400

08003a0c <HAL_PWREx_GetVoltageRange>:
/**
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_RANGE1 or PWR_REGULATOR_VOLTAGE_RANGE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
 8003a0c:	b480      	push	{r7}
 8003a0e:	af00      	add	r7, sp, #0
  return (PWR->CR1 & PWR_CR1_VOS);
 8003a10:	4b04      	ldr	r3, [pc, #16]	; (8003a24 <HAL_PWREx_GetVoltageRange+0x18>)
 8003a12:	681b      	ldr	r3, [r3, #0]
 8003a14:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
}
 8003a18:	4618      	mov	r0, r3
 8003a1a:	46bd      	mov	sp, r7
 8003a1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a20:	4770      	bx	lr
 8003a22:	bf00      	nop
 8003a24:	58000400 	.word	0x58000400

08003a28 <HAL_QSPI_Init>:
  *        in the QSPI_InitTypeDef and initialize the associated handle.
  * @param hqspi QSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_QSPI_Init(QSPI_HandleTypeDef *hqspi)
{
 8003a28:	b580      	push	{r7, lr}
 8003a2a:	b086      	sub	sp, #24
 8003a2c:	af02      	add	r7, sp, #8
 8003a2e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
 8003a30:	f7fe fb74 	bl	800211c <HAL_GetTick>
 8003a34:	60f8      	str	r0, [r7, #12]

  /* Check the QSPI handle allocation */
  if(hqspi == NULL)
 8003a36:	687b      	ldr	r3, [r7, #4]
 8003a38:	2b00      	cmp	r3, #0
 8003a3a:	d101      	bne.n	8003a40 <HAL_QSPI_Init+0x18>
  {
    return HAL_ERROR;
 8003a3c:	2301      	movs	r3, #1
 8003a3e:	e063      	b.n	8003b08 <HAL_QSPI_Init+0xe0>
  assert_param(IS_QSPI_SSHIFT(hqspi->Init.SampleShifting));
  assert_param(IS_QSPI_FLASH_SIZE(hqspi->Init.FlashSize));
  assert_param(IS_QSPI_CS_HIGH_TIME(hqspi->Init.ChipSelectHighTime));
  assert_param(IS_QSPI_CLOCK_MODE(hqspi->Init.ClockMode));

  if(hqspi->State == HAL_QSPI_STATE_RESET)
 8003a40:	687b      	ldr	r3, [r7, #4]
 8003a42:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8003a46:	b2db      	uxtb	r3, r3
 8003a48:	2b00      	cmp	r3, #0
 8003a4a:	d10b      	bne.n	8003a64 <HAL_QSPI_Init+0x3c>
  {
    /* Allocate lock resource and initialize it */
    hqspi->Lock = HAL_UNLOCKED;
 8003a4c:	687b      	ldr	r3, [r7, #4]
 8003a4e:	2200      	movs	r2, #0
 8003a50:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Init the low level hardware */
    hqspi->MspInitCallback(hqspi);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_QSPI_MspInit(hqspi);
 8003a54:	6878      	ldr	r0, [r7, #4]
 8003a56:	f7fd fce5 	bl	8001424 <HAL_QSPI_MspInit>
#endif

    /* Configure the default timeout for the QSPI memory access */
    HAL_QSPI_SetTimeout(hqspi, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);
 8003a5a:	f241 3188 	movw	r1, #5000	; 0x1388
 8003a5e:	6878      	ldr	r0, [r7, #4]
 8003a60:	f000 f858 	bl	8003b14 <HAL_QSPI_SetTimeout>
  }

  /* Configure QSPI FIFO Threshold */
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
 8003a64:	687b      	ldr	r3, [r7, #4]
 8003a66:	681b      	ldr	r3, [r3, #0]
 8003a68:	681b      	ldr	r3, [r3, #0]
 8003a6a:	f423 6170 	bic.w	r1, r3, #3840	; 0xf00
 8003a6e:	687b      	ldr	r3, [r7, #4]
 8003a70:	689b      	ldr	r3, [r3, #8]
 8003a72:	3b01      	subs	r3, #1
 8003a74:	021a      	lsls	r2, r3, #8
 8003a76:	687b      	ldr	r3, [r7, #4]
 8003a78:	681b      	ldr	r3, [r3, #0]
 8003a7a:	430a      	orrs	r2, r1
 8003a7c:	601a      	str	r2, [r3, #0]
             ((hqspi->Init.FifoThreshold - 1U) << QUADSPI_CR_FTHRES_Pos));

  /* Wait till BUSY flag reset */
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 8003a7e:	687b      	ldr	r3, [r7, #4]
 8003a80:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003a82:	9300      	str	r3, [sp, #0]
 8003a84:	68fb      	ldr	r3, [r7, #12]
 8003a86:	2200      	movs	r2, #0
 8003a88:	2120      	movs	r1, #32
 8003a8a:	6878      	ldr	r0, [r7, #4]
 8003a8c:	f000 f850 	bl	8003b30 <QSPI_WaitFlagStateUntilTimeout>
 8003a90:	4603      	mov	r3, r0
 8003a92:	72fb      	strb	r3, [r7, #11]

  if(status == HAL_OK)
 8003a94:	7afb      	ldrb	r3, [r7, #11]
 8003a96:	2b00      	cmp	r3, #0
 8003a98:	d131      	bne.n	8003afe <HAL_QSPI_Init+0xd6>
  {
    /* Configure QSPI Clock Prescaler and Sample Shift */
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT),
 8003a9a:	687b      	ldr	r3, [r7, #4]
 8003a9c:	681b      	ldr	r3, [r3, #0]
 8003a9e:	681b      	ldr	r3, [r3, #0]
 8003aa0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8003aa4:	f023 0310 	bic.w	r3, r3, #16
 8003aa8:	687a      	ldr	r2, [r7, #4]
 8003aaa:	6852      	ldr	r2, [r2, #4]
 8003aac:	0611      	lsls	r1, r2, #24
 8003aae:	687a      	ldr	r2, [r7, #4]
 8003ab0:	68d2      	ldr	r2, [r2, #12]
 8003ab2:	4311      	orrs	r1, r2
 8003ab4:	687a      	ldr	r2, [r7, #4]
 8003ab6:	6812      	ldr	r2, [r2, #0]
 8003ab8:	430b      	orrs	r3, r1
 8003aba:	6013      	str	r3, [r2, #0]
               ((hqspi->Init.ClockPrescaler << QUADSPI_CR_PRESCALER_Pos) |
                hqspi->Init.SampleShifting));

    /* Configure QSPI Flash Size, CS High Time and Clock Mode */
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 8003abc:	687b      	ldr	r3, [r7, #4]
 8003abe:	681b      	ldr	r3, [r3, #0]
 8003ac0:	685a      	ldr	r2, [r3, #4]
 8003ac2:	4b13      	ldr	r3, [pc, #76]	; (8003b10 <HAL_QSPI_Init+0xe8>)
 8003ac4:	4013      	ands	r3, r2
 8003ac6:	687a      	ldr	r2, [r7, #4]
 8003ac8:	6912      	ldr	r2, [r2, #16]
 8003aca:	0411      	lsls	r1, r2, #16
 8003acc:	687a      	ldr	r2, [r7, #4]
 8003ace:	6952      	ldr	r2, [r2, #20]
 8003ad0:	4311      	orrs	r1, r2
 8003ad2:	687a      	ldr	r2, [r7, #4]
 8003ad4:	6992      	ldr	r2, [r2, #24]
 8003ad6:	4311      	orrs	r1, r2
 8003ad8:	687a      	ldr	r2, [r7, #4]
 8003ada:	6812      	ldr	r2, [r2, #0]
 8003adc:	430b      	orrs	r3, r1
 8003ade:	6053      	str	r3, [r2, #4]
               ((hqspi->Init.FlashSize << QUADSPI_DCR_FSIZE_Pos) |
                hqspi->Init.ChipSelectHighTime | hqspi->Init.ClockMode));

    /* Enable the QSPI peripheral */
    __HAL_QSPI_ENABLE(hqspi);
 8003ae0:	687b      	ldr	r3, [r7, #4]
 8003ae2:	681b      	ldr	r3, [r3, #0]
 8003ae4:	681a      	ldr	r2, [r3, #0]
 8003ae6:	687b      	ldr	r3, [r7, #4]
 8003ae8:	681b      	ldr	r3, [r3, #0]
 8003aea:	f042 0201 	orr.w	r2, r2, #1
 8003aee:	601a      	str	r2, [r3, #0]

    /* Set QSPI error code to none */
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8003af0:	687b      	ldr	r3, [r7, #4]
 8003af2:	2200      	movs	r2, #0
 8003af4:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Initialize the QSPI state */
    hqspi->State = HAL_QSPI_STATE_READY;
 8003af6:	687b      	ldr	r3, [r7, #4]
 8003af8:	2201      	movs	r2, #1
 8003afa:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  }

  /* Release Lock */
  __HAL_UNLOCK(hqspi);
 8003afe:	687b      	ldr	r3, [r7, #4]
 8003b00:	2200      	movs	r2, #0
 8003b02:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  /* Return function status */
  return status;
 8003b06:	7afb      	ldrb	r3, [r7, #11]
}
 8003b08:	4618      	mov	r0, r3
 8003b0a:	3710      	adds	r7, #16
 8003b0c:	46bd      	mov	sp, r7
 8003b0e:	bd80      	pop	{r7, pc}
 8003b10:	ffe0f8fe 	.word	0xffe0f8fe

08003b14 <HAL_QSPI_SetTimeout>:
  * @param  hqspi QSPI handle.
  * @param  Timeout Timeout for the QSPI memory access.
  * @retval None
  */
void HAL_QSPI_SetTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
{
 8003b14:	b480      	push	{r7}
 8003b16:	b083      	sub	sp, #12
 8003b18:	af00      	add	r7, sp, #0
 8003b1a:	6078      	str	r0, [r7, #4]
 8003b1c:	6039      	str	r1, [r7, #0]
  hqspi->Timeout = Timeout;
 8003b1e:	687b      	ldr	r3, [r7, #4]
 8003b20:	683a      	ldr	r2, [r7, #0]
 8003b22:	641a      	str	r2, [r3, #64]	; 0x40
}
 8003b24:	bf00      	nop
 8003b26:	370c      	adds	r7, #12
 8003b28:	46bd      	mov	sp, r7
 8003b2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b2e:	4770      	bx	lr

08003b30 <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout Duration of the timeout
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
 8003b30:	b580      	push	{r7, lr}
 8003b32:	b084      	sub	sp, #16
 8003b34:	af00      	add	r7, sp, #0
 8003b36:	60f8      	str	r0, [r7, #12]
 8003b38:	60b9      	str	r1, [r7, #8]
 8003b3a:	603b      	str	r3, [r7, #0]
 8003b3c:	4613      	mov	r3, r2
 8003b3e:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8003b40:	e01a      	b.n	8003b78 <QSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8003b42:	69bb      	ldr	r3, [r7, #24]
 8003b44:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003b48:	d016      	beq.n	8003b78 <QSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003b4a:	f7fe fae7 	bl	800211c <HAL_GetTick>
 8003b4e:	4602      	mov	r2, r0
 8003b50:	683b      	ldr	r3, [r7, #0]
 8003b52:	1ad3      	subs	r3, r2, r3
 8003b54:	69ba      	ldr	r2, [r7, #24]
 8003b56:	429a      	cmp	r2, r3
 8003b58:	d302      	bcc.n	8003b60 <QSPI_WaitFlagStateUntilTimeout+0x30>
 8003b5a:	69bb      	ldr	r3, [r7, #24]
 8003b5c:	2b00      	cmp	r3, #0
 8003b5e:	d10b      	bne.n	8003b78 <QSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 8003b60:	68fb      	ldr	r3, [r7, #12]
 8003b62:	2204      	movs	r2, #4
 8003b64:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 8003b68:	68fb      	ldr	r3, [r7, #12]
 8003b6a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003b6c:	f043 0201 	orr.w	r2, r3, #1
 8003b70:	68fb      	ldr	r3, [r7, #12]
 8003b72:	63da      	str	r2, [r3, #60]	; 0x3c

        return HAL_ERROR;
 8003b74:	2301      	movs	r3, #1
 8003b76:	e00e      	b.n	8003b96 <QSPI_WaitFlagStateUntilTimeout+0x66>
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8003b78:	68fb      	ldr	r3, [r7, #12]
 8003b7a:	681b      	ldr	r3, [r3, #0]
 8003b7c:	689a      	ldr	r2, [r3, #8]
 8003b7e:	68bb      	ldr	r3, [r7, #8]
 8003b80:	4013      	ands	r3, r2
 8003b82:	2b00      	cmp	r3, #0
 8003b84:	bf14      	ite	ne
 8003b86:	2301      	movne	r3, #1
 8003b88:	2300      	moveq	r3, #0
 8003b8a:	b2db      	uxtb	r3, r3
 8003b8c:	461a      	mov	r2, r3
 8003b8e:	79fb      	ldrb	r3, [r7, #7]
 8003b90:	429a      	cmp	r2, r3
 8003b92:	d1d6      	bne.n	8003b42 <QSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 8003b94:	2300      	movs	r3, #0
}
 8003b96:	4618      	mov	r0, r3
 8003b98:	3710      	adds	r7, #16
 8003b9a:	46bd      	mov	sp, r7
 8003b9c:	bd80      	pop	{r7, pc}

08003b9e <LL_RCC_HSE_IsEnabledDiv2>:
  * @brief  Get HSE sysclk and pll prescaler
  * @rmtoll CR           HSEPRE        LL_RCC_HSE_IsEnabledDiv2
  * @retval None
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsEnabledDiv2(void)
{
 8003b9e:	b480      	push	{r7}
 8003ba0:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8003ba2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003ba6:	681b      	ldr	r3, [r3, #0]
 8003ba8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8003bac:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8003bb0:	d101      	bne.n	8003bb6 <LL_RCC_HSE_IsEnabledDiv2+0x18>
 8003bb2:	2301      	movs	r3, #1
 8003bb4:	e000      	b.n	8003bb8 <LL_RCC_HSE_IsEnabledDiv2+0x1a>
 8003bb6:	2300      	movs	r3, #0
}
 8003bb8:	4618      	mov	r0, r3
 8003bba:	46bd      	mov	sp, r7
 8003bbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003bc0:	4770      	bx	lr

08003bc2 <LL_RCC_HSE_Enable>:
  * @brief  Enable HSE crystal oscillator (HSE ON)
  * @rmtoll CR           HSEON         LL_RCC_HSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_Enable(void)
{
 8003bc2:	b480      	push	{r7}
 8003bc4:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 8003bc6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003bca:	681b      	ldr	r3, [r3, #0]
 8003bcc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003bd0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003bd4:	6013      	str	r3, [r2, #0]
}
 8003bd6:	bf00      	nop
 8003bd8:	46bd      	mov	sp, r7
 8003bda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003bde:	4770      	bx	lr

08003be0 <LL_RCC_HSE_Disable>:
  * @brief  Disable HSE crystal oscillator (HSE ON)
  * @rmtoll CR           HSEON         LL_RCC_HSE_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_Disable(void)
{
 8003be0:	b480      	push	{r7}
 8003be2:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 8003be4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003be8:	681b      	ldr	r3, [r3, #0]
 8003bea:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003bee:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003bf2:	6013      	str	r3, [r2, #0]
}
 8003bf4:	bf00      	nop
 8003bf6:	46bd      	mov	sp, r7
 8003bf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003bfc:	4770      	bx	lr

08003bfe <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
 8003bfe:	b480      	push	{r7}
 8003c00:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8003c02:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003c06:	681b      	ldr	r3, [r3, #0]
 8003c08:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003c0c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8003c10:	d101      	bne.n	8003c16 <LL_RCC_HSE_IsReady+0x18>
 8003c12:	2301      	movs	r3, #1
 8003c14:	e000      	b.n	8003c18 <LL_RCC_HSE_IsReady+0x1a>
 8003c16:	2300      	movs	r3, #0
}
 8003c18:	4618      	mov	r0, r3
 8003c1a:	46bd      	mov	sp, r7
 8003c1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c20:	4770      	bx	lr

08003c22 <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI oscillator
  * @rmtoll CR           HSION         LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
 8003c22:	b480      	push	{r7}
 8003c24:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSION);
 8003c26:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003c2a:	681b      	ldr	r3, [r3, #0]
 8003c2c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003c30:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003c34:	6013      	str	r3, [r2, #0]
}
 8003c36:	bf00      	nop
 8003c38:	46bd      	mov	sp, r7
 8003c3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c3e:	4770      	bx	lr

08003c40 <LL_RCC_HSI_Disable>:
  * @brief  Disable HSI oscillator
  * @rmtoll CR           HSION         LL_RCC_HSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Disable(void)
{
 8003c40:	b480      	push	{r7}
 8003c42:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 8003c44:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003c48:	681b      	ldr	r3, [r3, #0]
 8003c4a:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003c4e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003c52:	6013      	str	r3, [r2, #0]
}
 8003c54:	bf00      	nop
 8003c56:	46bd      	mov	sp, r7
 8003c58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c5c:	4770      	bx	lr

08003c5e <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
 8003c5e:	b480      	push	{r7}
 8003c60:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8003c62:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003c66:	681b      	ldr	r3, [r3, #0]
 8003c68:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8003c6c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8003c70:	d101      	bne.n	8003c76 <LL_RCC_HSI_IsReady+0x18>
 8003c72:	2301      	movs	r3, #1
 8003c74:	e000      	b.n	8003c78 <LL_RCC_HSI_IsReady+0x1a>
 8003c76:	2300      	movs	r3, #0
}
 8003c78:	4618      	mov	r0, r3
 8003c7a:	46bd      	mov	sp, r7
 8003c7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c80:	4770      	bx	lr

08003c82 <LL_RCC_HSI_SetCalibTrimming>:
  * @rmtoll ICSCR        HSITRIM       LL_RCC_HSI_SetCalibTrimming
  * @param  Value Between Min_Data = 0 and Max_Data = 127
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
{
 8003c82:	b480      	push	{r7}
 8003c84:	b083      	sub	sp, #12
 8003c86:	af00      	add	r7, sp, #0
 8003c88:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 8003c8a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003c8e:	685b      	ldr	r3, [r3, #4]
 8003c90:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 8003c94:	687b      	ldr	r3, [r7, #4]
 8003c96:	061b      	lsls	r3, r3, #24
 8003c98:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8003c9c:	4313      	orrs	r3, r2
 8003c9e:	604b      	str	r3, [r1, #4]
}
 8003ca0:	bf00      	nop
 8003ca2:	370c      	adds	r7, #12
 8003ca4:	46bd      	mov	sp, r7
 8003ca6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003caa:	4770      	bx	lr

08003cac <LL_RCC_HSI48_Enable>:
  * @brief  Enable HSI48
  * @rmtoll CRRCR          HSI48ON       LL_RCC_HSI48_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI48_Enable(void)
{
 8003cac:	b480      	push	{r7}
 8003cae:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 8003cb0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003cb4:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8003cb8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003cbc:	f043 0301 	orr.w	r3, r3, #1
 8003cc0:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 8003cc4:	bf00      	nop
 8003cc6:	46bd      	mov	sp, r7
 8003cc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ccc:	4770      	bx	lr

08003cce <LL_RCC_HSI48_Disable>:
  * @brief  Disable HSI48
  * @rmtoll CRRCR          HSI48ON       LL_RCC_HSI48_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI48_Disable(void)
{
 8003cce:	b480      	push	{r7}
 8003cd0:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CRRCR, RCC_CRRCR_HSI48ON);
 8003cd2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003cd6:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8003cda:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003cde:	f023 0301 	bic.w	r3, r3, #1
 8003ce2:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
}
 8003ce6:	bf00      	nop
 8003ce8:	46bd      	mov	sp, r7
 8003cea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003cee:	4770      	bx	lr

08003cf0 <LL_RCC_HSI48_IsReady>:
  * @brief  Check if HSI48 oscillator Ready
  * @rmtoll CRRCR          HSI48RDY      LL_RCC_HSI48_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI48_IsReady(void)
{
 8003cf0:	b480      	push	{r7}
 8003cf2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == (RCC_CRRCR_HSI48RDY)) ? 1UL : 0UL);
 8003cf4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003cf8:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8003cfc:	f003 0302 	and.w	r3, r3, #2
 8003d00:	2b02      	cmp	r3, #2
 8003d02:	d101      	bne.n	8003d08 <LL_RCC_HSI48_IsReady+0x18>
 8003d04:	2301      	movs	r3, #1
 8003d06:	e000      	b.n	8003d0a <LL_RCC_HSI48_IsReady+0x1a>
 8003d08:	2300      	movs	r3, #0
}
 8003d0a:	4618      	mov	r0, r3
 8003d0c:	46bd      	mov	sp, r7
 8003d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d12:	4770      	bx	lr

08003d14 <LL_RCC_LSE_Enable>:
  * @brief  Enable  Low Speed External (LSE) crystal.
  * @rmtoll BDCR         LSEON         LL_RCC_LSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_Enable(void)
{
 8003d14:	b480      	push	{r7}
 8003d16:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8003d18:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003d1c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003d20:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003d24:	f043 0301 	orr.w	r3, r3, #1
 8003d28:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8003d2c:	bf00      	nop
 8003d2e:	46bd      	mov	sp, r7
 8003d30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d34:	4770      	bx	lr

08003d36 <LL_RCC_LSE_Disable>:
  * @brief  Disable  Low Speed External (LSE) crystal.
  * @rmtoll BDCR         LSEON         LL_RCC_LSE_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_Disable(void)
{
 8003d36:	b480      	push	{r7}
 8003d38:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8003d3a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003d3e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003d42:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003d46:	f023 0301 	bic.w	r3, r3, #1
 8003d4a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8003d4e:	bf00      	nop
 8003d50:	46bd      	mov	sp, r7
 8003d52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d56:	4770      	bx	lr

08003d58 <LL_RCC_LSE_EnableBypass>:
  * @brief  Enable external clock source (LSE bypass).
  * @rmtoll BDCR         LSEBYP        LL_RCC_LSE_EnableBypass
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_EnableBypass(void)
{
 8003d58:	b480      	push	{r7}
 8003d5a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8003d5c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003d60:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003d64:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003d68:	f043 0304 	orr.w	r3, r3, #4
 8003d6c:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8003d70:	bf00      	nop
 8003d72:	46bd      	mov	sp, r7
 8003d74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d78:	4770      	bx	lr

08003d7a <LL_RCC_LSE_DisableBypass>:
  * @brief  Disable external clock source (LSE bypass).
  * @rmtoll BDCR         LSEBYP        LL_RCC_LSE_DisableBypass
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_DisableBypass(void)
{
 8003d7a:	b480      	push	{r7}
 8003d7c:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8003d7e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003d82:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003d86:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003d8a:	f023 0304 	bic.w	r3, r3, #4
 8003d8e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8003d92:	bf00      	nop
 8003d94:	46bd      	mov	sp, r7
 8003d96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d9a:	4770      	bx	lr

08003d9c <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll BDCR         LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
 8003d9c:	b480      	push	{r7}
 8003d9e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8003da0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003da4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003da8:	f003 0302 	and.w	r3, r3, #2
 8003dac:	2b02      	cmp	r3, #2
 8003dae:	d101      	bne.n	8003db4 <LL_RCC_LSE_IsReady+0x18>
 8003db0:	2301      	movs	r3, #1
 8003db2:	e000      	b.n	8003db6 <LL_RCC_LSE_IsReady+0x1a>
 8003db4:	2300      	movs	r3, #0
}
 8003db6:	4618      	mov	r0, r3
 8003db8:	46bd      	mov	sp, r7
 8003dba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003dbe:	4770      	bx	lr

08003dc0 <LL_RCC_LSI1_Enable>:
  * @brief  Enable LSI1 Oscillator
  * @rmtoll CSR          LSI1ON         LL_RCC_LSI1_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI1_Enable(void)
{
 8003dc0:	b480      	push	{r7}
 8003dc2:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 8003dc4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003dc8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003dcc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003dd0:	f043 0301 	orr.w	r3, r3, #1
 8003dd4:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 8003dd8:	bf00      	nop
 8003dda:	46bd      	mov	sp, r7
 8003ddc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003de0:	4770      	bx	lr

08003de2 <LL_RCC_LSI1_Disable>:
  * @brief  Disable LSI1 Oscillator
  * @rmtoll CSR          LSI1ON         LL_RCC_LSI1_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI1_Disable(void)
{
 8003de2:	b480      	push	{r7}
 8003de4:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI1ON);
 8003de6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003dea:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003dee:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003df2:	f023 0301 	bic.w	r3, r3, #1
 8003df6:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 8003dfa:	bf00      	nop
 8003dfc:	46bd      	mov	sp, r7
 8003dfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e02:	4770      	bx	lr

08003e04 <LL_RCC_LSI1_IsReady>:
  * @brief  Check if LSI1 is Ready
  * @rmtoll CSR          LSI1RDY        LL_RCC_LSI1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI1_IsReady(void)
{
 8003e04:	b480      	push	{r7}
 8003e06:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI1RDY) == (RCC_CSR_LSI1RDY)) ? 1UL : 0UL);
 8003e08:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003e0c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003e10:	f003 0302 	and.w	r3, r3, #2
 8003e14:	2b02      	cmp	r3, #2
 8003e16:	d101      	bne.n	8003e1c <LL_RCC_LSI1_IsReady+0x18>
 8003e18:	2301      	movs	r3, #1
 8003e1a:	e000      	b.n	8003e1e <LL_RCC_LSI1_IsReady+0x1a>
 8003e1c:	2300      	movs	r3, #0
}
 8003e1e:	4618      	mov	r0, r3
 8003e20:	46bd      	mov	sp, r7
 8003e22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e26:	4770      	bx	lr

08003e28 <LL_RCC_LSI2_Enable>:
  * @brief  Enable LSI2 Oscillator
  * @rmtoll CSR          LSI2ON         LL_RCC_LSI2_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI2_Enable(void)
{
 8003e28:	b480      	push	{r7}
 8003e2a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 8003e2c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003e30:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003e34:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003e38:	f043 0304 	orr.w	r3, r3, #4
 8003e3c:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 8003e40:	bf00      	nop
 8003e42:	46bd      	mov	sp, r7
 8003e44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e48:	4770      	bx	lr

08003e4a <LL_RCC_LSI2_Disable>:
  * @brief  Disable LSI2 Oscillator
  * @rmtoll CSR          LSI2ON         LL_RCC_LSI2_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI2_Disable(void)
{
 8003e4a:	b480      	push	{r7}
 8003e4c:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSI2ON);
 8003e4e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003e52:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003e56:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003e5a:	f023 0304 	bic.w	r3, r3, #4
 8003e5e:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
}
 8003e62:	bf00      	nop
 8003e64:	46bd      	mov	sp, r7
 8003e66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e6a:	4770      	bx	lr

08003e6c <LL_RCC_LSI2_IsReady>:
  * @brief  Check if LSI2 is Ready
  * @rmtoll CSR          LSI2RDY        LL_RCC_LSI2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI2_IsReady(void)
{
 8003e6c:	b480      	push	{r7}
 8003e6e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSI2RDY) == (RCC_CSR_LSI2RDY)) ? 1UL : 0UL);
 8003e70:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003e74:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003e78:	f003 0308 	and.w	r3, r3, #8
 8003e7c:	2b08      	cmp	r3, #8
 8003e7e:	d101      	bne.n	8003e84 <LL_RCC_LSI2_IsReady+0x18>
 8003e80:	2301      	movs	r3, #1
 8003e82:	e000      	b.n	8003e86 <LL_RCC_LSI2_IsReady+0x1a>
 8003e84:	2300      	movs	r3, #0
}
 8003e86:	4618      	mov	r0, r3
 8003e88:	46bd      	mov	sp, r7
 8003e8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e8e:	4770      	bx	lr

08003e90 <LL_RCC_LSI2_SetTrimming>:
  * @rmtoll CSR        LSI2TRIM       LL_RCC_LSI2_SetTrimming
  * @param  Value Between Min_Data = 0 and Max_Data = 15
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI2_SetTrimming(uint32_t Value)
{
 8003e90:	b480      	push	{r7}
 8003e92:	b083      	sub	sp, #12
 8003e94:	af00      	add	r7, sp, #0
 8003e96:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CSR, RCC_CSR_LSI2TRIM, Value << RCC_CSR_LSI2TRIM_Pos);
 8003e98:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003e9c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8003ea0:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
 8003ea4:	687b      	ldr	r3, [r7, #4]
 8003ea6:	021b      	lsls	r3, r3, #8
 8003ea8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8003eac:	4313      	orrs	r3, r2
 8003eae:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
}
 8003eb2:	bf00      	nop
 8003eb4:	370c      	adds	r7, #12
 8003eb6:	46bd      	mov	sp, r7
 8003eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ebc:	4770      	bx	lr

08003ebe <LL_RCC_MSI_Enable>:
  * @brief  Enable MSI oscillator
  * @rmtoll CR           MSION         LL_RCC_MSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Enable(void)
{
 8003ebe:	b480      	push	{r7}
 8003ec0:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_MSION);
 8003ec2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003ec6:	681b      	ldr	r3, [r3, #0]
 8003ec8:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003ecc:	f043 0301 	orr.w	r3, r3, #1
 8003ed0:	6013      	str	r3, [r2, #0]
}
 8003ed2:	bf00      	nop
 8003ed4:	46bd      	mov	sp, r7
 8003ed6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003eda:	4770      	bx	lr

08003edc <LL_RCC_MSI_Disable>:
  * @brief  Disable MSI oscillator
  * @rmtoll CR           MSION         LL_RCC_MSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Disable(void)
{
 8003edc:	b480      	push	{r7}
 8003ede:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 8003ee0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003ee4:	681b      	ldr	r3, [r3, #0]
 8003ee6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003eea:	f023 0301 	bic.w	r3, r3, #1
 8003eee:	6013      	str	r3, [r2, #0]
}
 8003ef0:	bf00      	nop
 8003ef2:	46bd      	mov	sp, r7
 8003ef4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ef8:	4770      	bx	lr

08003efa <LL_RCC_MSI_IsReady>:
  * @brief  Check if MSI oscillator Ready
  * @rmtoll CR           MSIRDY        LL_RCC_MSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsReady(void)
{
 8003efa:	b480      	push	{r7}
 8003efc:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 8003efe:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003f02:	681b      	ldr	r3, [r3, #0]
 8003f04:	f003 0302 	and.w	r3, r3, #2
 8003f08:	2b02      	cmp	r3, #2
 8003f0a:	d101      	bne.n	8003f10 <LL_RCC_MSI_IsReady+0x16>
 8003f0c:	2301      	movs	r3, #1
 8003f0e:	e000      	b.n	8003f12 <LL_RCC_MSI_IsReady+0x18>
 8003f10:	2300      	movs	r3, #0
}
 8003f12:	4618      	mov	r0, r3
 8003f14:	46bd      	mov	sp, r7
 8003f16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f1a:	4770      	bx	lr

08003f1c <LL_RCC_MSI_SetRange>:
  *         @arg @ref LL_RCC_MSIRANGE_10
  *         @arg @ref LL_RCC_MSIRANGE_11
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_SetRange(uint32_t Range)
{
 8003f1c:	b480      	push	{r7}
 8003f1e:	b083      	sub	sp, #12
 8003f20:	af00      	add	r7, sp, #0
 8003f22:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, Range);
 8003f24:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003f28:	681b      	ldr	r3, [r3, #0]
 8003f2a:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8003f2e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8003f32:	687b      	ldr	r3, [r7, #4]
 8003f34:	4313      	orrs	r3, r2
 8003f36:	600b      	str	r3, [r1, #0]
}
 8003f38:	bf00      	nop
 8003f3a:	370c      	adds	r7, #12
 8003f3c:	46bd      	mov	sp, r7
 8003f3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f42:	4770      	bx	lr

08003f44 <LL_RCC_MSI_GetRange>:
  *         @arg @ref LL_RCC_MSIRANGE_9
  *         @arg @ref LL_RCC_MSIRANGE_10
  *         @arg @ref LL_RCC_MSIRANGE_11
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_GetRange(void)
{
 8003f44:	b480      	push	{r7}
 8003f46:	b083      	sub	sp, #12
 8003f48:	af00      	add	r7, sp, #0
  uint32_t msiRange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE);
 8003f4a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003f4e:	681b      	ldr	r3, [r3, #0]
 8003f50:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8003f54:	607b      	str	r3, [r7, #4]
  if (msiRange > LL_RCC_MSIRANGE_11)
 8003f56:	687b      	ldr	r3, [r7, #4]
 8003f58:	2bb0      	cmp	r3, #176	; 0xb0
 8003f5a:	d901      	bls.n	8003f60 <LL_RCC_MSI_GetRange+0x1c>
  {
    msiRange = LL_RCC_MSIRANGE_11;
 8003f5c:	23b0      	movs	r3, #176	; 0xb0
 8003f5e:	607b      	str	r3, [r7, #4]
  }
  return msiRange;
 8003f60:	687b      	ldr	r3, [r7, #4]
}
 8003f62:	4618      	mov	r0, r3
 8003f64:	370c      	adds	r7, #12
 8003f66:	46bd      	mov	sp, r7
 8003f68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f6c:	4770      	bx	lr

08003f6e <LL_RCC_MSI_SetCalibTrimming>:
  * @rmtoll ICSCR        MSITRIM       LL_RCC_MSI_SetCalibTrimming
  * @param  Value Between Min_Data = 0 and Max_Data = 255
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_SetCalibTrimming(uint32_t Value)
{
 8003f6e:	b480      	push	{r7}
 8003f70:	b083      	sub	sp, #12
 8003f72:	af00      	add	r7, sp, #0
 8003f74:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 8003f76:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003f7a:	685b      	ldr	r3, [r3, #4]
 8003f7c:	f423 427f 	bic.w	r2, r3, #65280	; 0xff00
 8003f80:	687b      	ldr	r3, [r7, #4]
 8003f82:	021b      	lsls	r3, r3, #8
 8003f84:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8003f88:	4313      	orrs	r3, r2
 8003f8a:	604b      	str	r3, [r1, #4]
}
 8003f8c:	bf00      	nop
 8003f8e:	370c      	adds	r7, #12
 8003f90:	46bd      	mov	sp, r7
 8003f92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f96:	4770      	bx	lr

08003f98 <LL_RCC_SetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_PLL
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
{
 8003f98:	b480      	push	{r7}
 8003f9a:	b083      	sub	sp, #12
 8003f9c:	af00      	add	r7, sp, #0
 8003f9e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8003fa0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003fa4:	689b      	ldr	r3, [r3, #8]
 8003fa6:	f023 0203 	bic.w	r2, r3, #3
 8003faa:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8003fae:	687b      	ldr	r3, [r7, #4]
 8003fb0:	4313      	orrs	r3, r2
 8003fb2:	608b      	str	r3, [r1, #8]
}
 8003fb4:	bf00      	nop
 8003fb6:	370c      	adds	r7, #12
 8003fb8:	46bd      	mov	sp, r7
 8003fba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003fbe:	4770      	bx	lr

08003fc0 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_PLL
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
 8003fc0:	b480      	push	{r7}
 8003fc2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8003fc4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003fc8:	689b      	ldr	r3, [r3, #8]
 8003fca:	f003 030c 	and.w	r3, r3, #12
}
 8003fce:	4618      	mov	r0, r3
 8003fd0:	46bd      	mov	sp, r7
 8003fd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003fd6:	4770      	bx	lr

08003fd8 <LL_RCC_SetAHBPrescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAHBPrescaler(uint32_t Prescaler)
{
 8003fd8:	b480      	push	{r7}
 8003fda:	b083      	sub	sp, #12
 8003fdc:	af00      	add	r7, sp, #0
 8003fde:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8003fe0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003fe4:	689b      	ldr	r3, [r3, #8]
 8003fe6:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8003fea:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8003fee:	687b      	ldr	r3, [r7, #4]
 8003ff0:	4313      	orrs	r3, r2
 8003ff2:	608b      	str	r3, [r1, #8]
}
 8003ff4:	bf00      	nop
 8003ff6:	370c      	adds	r7, #12
 8003ff8:	46bd      	mov	sp, r7
 8003ffa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ffe:	4770      	bx	lr

08004000 <LL_C2_RCC_SetAHBPrescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  * @retval None
  */
__STATIC_INLINE void LL_C2_RCC_SetAHBPrescaler(uint32_t Prescaler)
{
 8004000:	b480      	push	{r7}
 8004002:	b083      	sub	sp, #12
 8004004:	af00      	add	r7, sp, #0
 8004006:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 8004008:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800400c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8004010:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8004014:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004018:	687b      	ldr	r3, [r7, #4]
 800401a:	4313      	orrs	r3, r2
 800401c:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
}
 8004020:	bf00      	nop
 8004022:	370c      	adds	r7, #12
 8004024:	46bd      	mov	sp, r7
 8004026:	f85d 7b04 	ldr.w	r7, [sp], #4
 800402a:	4770      	bx	lr

0800402c <LL_RCC_SetAHB4Prescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAHB4Prescaler(uint32_t Prescaler)
{
 800402c:	b480      	push	{r7}
 800402e:	b083      	sub	sp, #12
 8004030:	af00      	add	r7, sp, #0
 8004032:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 8004034:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004038:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800403c:	f023 020f 	bic.w	r2, r3, #15
 8004040:	687b      	ldr	r3, [r7, #4]
 8004042:	091b      	lsrs	r3, r3, #4
 8004044:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004048:	4313      	orrs	r3, r2
 800404a:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
}
 800404e:	bf00      	nop
 8004050:	370c      	adds	r7, #12
 8004052:	46bd      	mov	sp, r7
 8004054:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004058:	4770      	bx	lr

0800405a <LL_RCC_SetAPB1Prescaler>:
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAPB1Prescaler(uint32_t Prescaler)
{
 800405a:	b480      	push	{r7}
 800405c:	b083      	sub	sp, #12
 800405e:	af00      	add	r7, sp, #0
 8004060:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 8004062:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004066:	689b      	ldr	r3, [r3, #8]
 8004068:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 800406c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004070:	687b      	ldr	r3, [r7, #4]
 8004072:	4313      	orrs	r3, r2
 8004074:	608b      	str	r3, [r1, #8]
}
 8004076:	bf00      	nop
 8004078:	370c      	adds	r7, #12
 800407a:	46bd      	mov	sp, r7
 800407c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004080:	4770      	bx	lr

08004082 <LL_RCC_SetAPB2Prescaler>:
  *         @arg @ref LL_RCC_APB2_DIV_8
  *         @arg @ref LL_RCC_APB2_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAPB2Prescaler(uint32_t Prescaler)
{
 8004082:	b480      	push	{r7}
 8004084:	b083      	sub	sp, #12
 8004086:	af00      	add	r7, sp, #0
 8004088:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 800408a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800408e:	689b      	ldr	r3, [r3, #8]
 8004090:	f423 5260 	bic.w	r2, r3, #14336	; 0x3800
 8004094:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004098:	687b      	ldr	r3, [r7, #4]
 800409a:	4313      	orrs	r3, r2
 800409c:	608b      	str	r3, [r1, #8]
}
 800409e:	bf00      	nop
 80040a0:	370c      	adds	r7, #12
 80040a2:	46bd      	mov	sp, r7
 80040a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040a8:	4770      	bx	lr

080040aa <LL_RCC_GetAHBPrescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_128
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
 80040aa:	b480      	push	{r7}
 80040ac:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 80040ae:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80040b2:	689b      	ldr	r3, [r3, #8]
 80040b4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 80040b8:	4618      	mov	r0, r3
 80040ba:	46bd      	mov	sp, r7
 80040bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040c0:	4770      	bx	lr

080040c2 <LL_C2_RCC_GetAHBPrescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_128
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_C2_RCC_GetAHBPrescaler(void)
{
 80040c2:	b480      	push	{r7}
 80040c4:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE));
 80040c6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80040ca:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 80040ce:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 80040d2:	4618      	mov	r0, r3
 80040d4:	46bd      	mov	sp, r7
 80040d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040da:	4770      	bx	lr

080040dc <LL_RCC_GetAHB4Prescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_128
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHB4Prescaler(void)
{
 80040dc:	b480      	push	{r7}
 80040de:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 80040e0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80040e4:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 80040e8:	011b      	lsls	r3, r3, #4
 80040ea:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
}
 80040ee:	4618      	mov	r0, r3
 80040f0:	46bd      	mov	sp, r7
 80040f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80040f6:	4770      	bx	lr

080040f8 <LL_RCC_GetAPB1Prescaler>:
  *         @arg @ref LL_RCC_APB1_DIV_4
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
 80040f8:	b480      	push	{r7}
 80040fa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 80040fc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004100:	689b      	ldr	r3, [r3, #8]
 8004102:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
}
 8004106:	4618      	mov	r0, r3
 8004108:	46bd      	mov	sp, r7
 800410a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800410e:	4770      	bx	lr

08004110 <LL_RCC_GetAPB2Prescaler>:
  *         @arg @ref LL_RCC_APB2_DIV_4
  *         @arg @ref LL_RCC_APB2_DIV_8
  *         @arg @ref LL_RCC_APB2_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB2Prescaler(void)
{
 8004110:	b480      	push	{r7}
 8004112:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 8004114:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004118:	689b      	ldr	r3, [r3, #8]
 800411a:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
}
 800411e:	4618      	mov	r0, r3
 8004120:	46bd      	mov	sp, r7
 8004122:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004126:	4770      	bx	lr

08004128 <LL_RCC_PLL_Enable>:
  * @brief  Enable PLL
  * @rmtoll CR           PLLON         LL_RCC_PLL_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_Enable(void)
{
 8004128:	b480      	push	{r7}
 800412a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 800412c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004130:	681b      	ldr	r3, [r3, #0]
 8004132:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8004136:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800413a:	6013      	str	r3, [r2, #0]
}
 800413c:	bf00      	nop
 800413e:	46bd      	mov	sp, r7
 8004140:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004144:	4770      	bx	lr

08004146 <LL_RCC_PLL_Disable>:
  * @note Cannot be disabled if the PLL clock is used as the system clock
  * @rmtoll CR           PLLON         LL_RCC_PLL_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_Disable(void)
{
 8004146:	b480      	push	{r7}
 8004148:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 800414a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800414e:	681b      	ldr	r3, [r3, #0]
 8004150:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8004154:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004158:	6013      	str	r3, [r2, #0]
}
 800415a:	bf00      	nop
 800415c:	46bd      	mov	sp, r7
 800415e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004162:	4770      	bx	lr

08004164 <LL_RCC_PLL_IsReady>:
  * @brief  Check if PLL Ready
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
 8004164:	b480      	push	{r7}
 8004166:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 8004168:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800416c:	681b      	ldr	r3, [r3, #0]
 800416e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004172:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8004176:	d101      	bne.n	800417c <LL_RCC_PLL_IsReady+0x18>
 8004178:	2301      	movs	r3, #1
 800417a:	e000      	b.n	800417e <LL_RCC_PLL_IsReady+0x1a>
 800417c:	2300      	movs	r3, #0
}
 800417e:	4618      	mov	r0, r3
 8004180:	46bd      	mov	sp, r7
 8004182:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004186:	4770      	bx	lr

08004188 <LL_RCC_PLL_GetN>:
  * @brief  Get Main PLL multiplication factor for VCO
  * @rmtoll PLLCFGR      PLLN          LL_RCC_PLL_GetN
  * @retval Between 6 and 127
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetN(void)
{
 8004188:	b480      	push	{r7}
 800418a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 800418c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004190:	68db      	ldr	r3, [r3, #12]
 8004192:	0a1b      	lsrs	r3, r3, #8
 8004194:	f003 037f 	and.w	r3, r3, #127	; 0x7f
}
 8004198:	4618      	mov	r0, r3
 800419a:	46bd      	mov	sp, r7
 800419c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041a0:	4770      	bx	lr

080041a2 <LL_RCC_PLL_GetR>:
  *         @arg @ref LL_RCC_PLLR_DIV_6
  *         @arg @ref LL_RCC_PLLR_DIV_7
  *         @arg @ref LL_RCC_PLLR_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetR(void)
{
 80041a2:	b480      	push	{r7}
 80041a4:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 80041a6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80041aa:	68db      	ldr	r3, [r3, #12]
 80041ac:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
}
 80041b0:	4618      	mov	r0, r3
 80041b2:	46bd      	mov	sp, r7
 80041b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041b8:	4770      	bx	lr

080041ba <LL_RCC_PLL_GetDivider>:
  *         @arg @ref LL_RCC_PLLM_DIV_6
  *         @arg @ref LL_RCC_PLLM_DIV_7
  *         @arg @ref LL_RCC_PLLM_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
{
 80041ba:	b480      	push	{r7}
 80041bc:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 80041be:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80041c2:	68db      	ldr	r3, [r3, #12]
 80041c4:	f003 0370 	and.w	r3, r3, #112	; 0x70
}
 80041c8:	4618      	mov	r0, r3
 80041ca:	46bd      	mov	sp, r7
 80041cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041d0:	4770      	bx	lr

080041d2 <LL_RCC_PLL_GetMainSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
 80041d2:	b480      	push	{r7}
 80041d4:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80041d6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80041da:	68db      	ldr	r3, [r3, #12]
 80041dc:	f003 0303 	and.w	r3, r3, #3
}
 80041e0:	4618      	mov	r0, r3
 80041e2:	46bd      	mov	sp, r7
 80041e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041e8:	4770      	bx	lr

080041ea <LL_RCC_IsActiveFlag_HPRE>:
  * @brief  Check if HCLK1 prescaler flag value has been applied or not
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
 80041ea:	b480      	push	{r7}
 80041ec:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 80041ee:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80041f2:	689b      	ldr	r3, [r3, #8]
 80041f4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80041f8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80041fc:	d101      	bne.n	8004202 <LL_RCC_IsActiveFlag_HPRE+0x18>
 80041fe:	2301      	movs	r3, #1
 8004200:	e000      	b.n	8004204 <LL_RCC_IsActiveFlag_HPRE+0x1a>
 8004202:	2300      	movs	r3, #0
}
 8004204:	4618      	mov	r0, r3
 8004206:	46bd      	mov	sp, r7
 8004208:	f85d 7b04 	ldr.w	r7, [sp], #4
 800420c:	4770      	bx	lr

0800420e <LL_RCC_IsActiveFlag_C2HPRE>:
  * @brief  Check if HCLK2 prescaler flag value has been applied or not
  * @rmtoll EXTCFGR         C2HPREF       LL_RCC_IsActiveFlag_C2HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_C2HPRE(void)
{
 800420e:	b480      	push	{r7}
 8004210:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 8004212:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004216:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800421a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800421e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8004222:	d101      	bne.n	8004228 <LL_RCC_IsActiveFlag_C2HPRE+0x1a>
 8004224:	2301      	movs	r3, #1
 8004226:	e000      	b.n	800422a <LL_RCC_IsActiveFlag_C2HPRE+0x1c>
 8004228:	2300      	movs	r3, #0
}
 800422a:	4618      	mov	r0, r3
 800422c:	46bd      	mov	sp, r7
 800422e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004232:	4770      	bx	lr

08004234 <LL_RCC_IsActiveFlag_SHDHPRE>:
  * @brief  Check if HCLK4 prescaler flag value has been applied or not
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
 8004234:	b480      	push	{r7}
 8004236:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 8004238:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800423c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8004240:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004244:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8004248:	d101      	bne.n	800424e <LL_RCC_IsActiveFlag_SHDHPRE+0x1a>
 800424a:	2301      	movs	r3, #1
 800424c:	e000      	b.n	8004250 <LL_RCC_IsActiveFlag_SHDHPRE+0x1c>
 800424e:	2300      	movs	r3, #0
}
 8004250:	4618      	mov	r0, r3
 8004252:	46bd      	mov	sp, r7
 8004254:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004258:	4770      	bx	lr

0800425a <LL_RCC_IsActiveFlag_PPRE1>:
  * @brief  Check if PLCK1 prescaler flag value has been applied or not
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
 800425a:	b480      	push	{r7}
 800425c:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 800425e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004262:	689b      	ldr	r3, [r3, #8]
 8004264:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004268:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800426c:	d101      	bne.n	8004272 <LL_RCC_IsActiveFlag_PPRE1+0x18>
 800426e:	2301      	movs	r3, #1
 8004270:	e000      	b.n	8004274 <LL_RCC_IsActiveFlag_PPRE1+0x1a>
 8004272:	2300      	movs	r3, #0
}
 8004274:	4618      	mov	r0, r3
 8004276:	46bd      	mov	sp, r7
 8004278:	f85d 7b04 	ldr.w	r7, [sp], #4
 800427c:	4770      	bx	lr

0800427e <LL_RCC_IsActiveFlag_PPRE2>:
  * @brief  Check if PLCK2 prescaler flag value has been applied or not
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
 800427e:	b480      	push	{r7}
 8004280:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 8004282:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004286:	689b      	ldr	r3, [r3, #8]
 8004288:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800428c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8004290:	d101      	bne.n	8004296 <LL_RCC_IsActiveFlag_PPRE2+0x18>
 8004292:	2301      	movs	r3, #1
 8004294:	e000      	b.n	8004298 <LL_RCC_IsActiveFlag_PPRE2+0x1a>
 8004296:	2300      	movs	r3, #0
}
 8004298:	4618      	mov	r0, r3
 800429a:	46bd      	mov	sp, r7
 800429c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80042a0:	4770      	bx	lr
	...

080042a4 <HAL_RCC_OscConfig>:
  * @note   The PLL is not disabled when used as system clock.
  * @note   The PLL source is not updated when used as PLLSAI1 clock source.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80042a4:	b590      	push	{r4, r7, lr}
 80042a6:	b08d      	sub	sp, #52	; 0x34
 80042a8:	af00      	add	r7, sp, #0
 80042aa:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 80042ac:	687b      	ldr	r3, [r7, #4]
 80042ae:	2b00      	cmp	r3, #0
 80042b0:	d101      	bne.n	80042b6 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 80042b2:	2301      	movs	r3, #1
 80042b4:	e363      	b.n	800497e <HAL_RCC_OscConfig+0x6da>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*----------------------------- MSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80042b6:	687b      	ldr	r3, [r7, #4]
 80042b8:	681b      	ldr	r3, [r3, #0]
 80042ba:	f003 0320 	and.w	r3, r3, #32
 80042be:	2b00      	cmp	r3, #0
 80042c0:	f000 808d 	beq.w	80043de <HAL_RCC_OscConfig+0x13a>
    assert_param(IS_RCC_MSI(RCC_OscInitStruct->MSIState));
    assert_param(IS_RCC_MSICALIBRATION_VALUE(RCC_OscInitStruct->MSICalibrationValue));
    assert_param(IS_RCC_MSI_CLOCK_RANGE(RCC_OscInitStruct->MSIClockRange));

    /* When the MSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80042c4:	f7ff fe7c 	bl	8003fc0 <LL_RCC_GetSysClkSource>
 80042c8:	62f8      	str	r0, [r7, #44]	; 0x2c
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 80042ca:	f7ff ff82 	bl	80041d2 <LL_RCC_PLL_GetMainSource>
 80042ce:	62b8      	str	r0, [r7, #40]	; 0x28
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80042d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80042d2:	2b00      	cmp	r3, #0
 80042d4:	d005      	beq.n	80042e2 <HAL_RCC_OscConfig+0x3e>
 80042d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80042d8:	2b0c      	cmp	r3, #12
 80042da:	d147      	bne.n	800436c <HAL_RCC_OscConfig+0xc8>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_MSI)))
 80042dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80042de:	2b01      	cmp	r3, #1
 80042e0:	d144      	bne.n	800436c <HAL_RCC_OscConfig+0xc8>
    {
      if (RCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 80042e2:	687b      	ldr	r3, [r7, #4]
 80042e4:	69db      	ldr	r3, [r3, #28]
 80042e6:	2b00      	cmp	r3, #0
 80042e8:	d101      	bne.n	80042ee <HAL_RCC_OscConfig+0x4a>
      {
        return HAL_ERROR;
 80042ea:	2301      	movs	r3, #1
 80042ec:	e347      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      else
      {
        /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
           must be correctly programmed according to the frequency of the AHB4 clock
           and the supply voltage of the device. */
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80042ee:	687b      	ldr	r3, [r7, #4]
 80042f0:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80042f2:	f7ff fe27 	bl	8003f44 <LL_RCC_MSI_GetRange>
 80042f6:	4603      	mov	r3, r0
 80042f8:	429c      	cmp	r4, r3
 80042fa:	d914      	bls.n	8004326 <HAL_RCC_OscConfig+0x82>
        {
          /* First increase number of wait states update if necessary */
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80042fc:	687b      	ldr	r3, [r7, #4]
 80042fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004300:	4618      	mov	r0, r3
 8004302:	f000 fd61 	bl	8004dc8 <RCC_SetFlashLatencyFromMSIRange>
 8004306:	4603      	mov	r3, r0
 8004308:	2b00      	cmp	r3, #0
 800430a:	d001      	beq.n	8004310 <HAL_RCC_OscConfig+0x6c>
          {
            return HAL_ERROR;
 800430c:	2301      	movs	r3, #1
 800430e:	e336      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
          }

          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8004310:	687b      	ldr	r3, [r7, #4]
 8004312:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004314:	4618      	mov	r0, r3
 8004316:	f7ff fe01 	bl	8003f1c <LL_RCC_MSI_SetRange>
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800431a:	687b      	ldr	r3, [r7, #4]
 800431c:	6a1b      	ldr	r3, [r3, #32]
 800431e:	4618      	mov	r0, r3
 8004320:	f7ff fe25 	bl	8003f6e <LL_RCC_MSI_SetCalibTrimming>
 8004324:	e013      	b.n	800434e <HAL_RCC_OscConfig+0xaa>
        }
        else
        {
          /* Else, keep current flash latency while decreasing applies */
          /* Selects the Multiple Speed oscillator (MSI) clock range .*/
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8004326:	687b      	ldr	r3, [r7, #4]
 8004328:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800432a:	4618      	mov	r0, r3
 800432c:	f7ff fdf6 	bl	8003f1c <LL_RCC_MSI_SetRange>
          /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8004330:	687b      	ldr	r3, [r7, #4]
 8004332:	6a1b      	ldr	r3, [r3, #32]
 8004334:	4618      	mov	r0, r3
 8004336:	f7ff fe1a 	bl	8003f6e <LL_RCC_MSI_SetCalibTrimming>

          /* Decrease number of wait states update if necessary */
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800433a:	687b      	ldr	r3, [r7, #4]
 800433c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800433e:	4618      	mov	r0, r3
 8004340:	f000 fd42 	bl	8004dc8 <RCC_SetFlashLatencyFromMSIRange>
 8004344:	4603      	mov	r3, r0
 8004346:	2b00      	cmp	r3, #0
 8004348:	d001      	beq.n	800434e <HAL_RCC_OscConfig+0xaa>
          {
            return HAL_ERROR;
 800434a:	2301      	movs	r3, #1
 800434c:	e317      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
          }
        }

        /* Update the SystemCoreClock global variable */
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 800434e:	f000 fcc9 	bl	8004ce4 <HAL_RCC_GetHCLKFreq>
 8004352:	4603      	mov	r3, r0
 8004354:	4aa4      	ldr	r2, [pc, #656]	; (80045e8 <HAL_RCC_OscConfig+0x344>)
 8004356:	6013      	str	r3, [r2, #0]

        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8004358:	4ba4      	ldr	r3, [pc, #656]	; (80045ec <HAL_RCC_OscConfig+0x348>)
 800435a:	681b      	ldr	r3, [r3, #0]
 800435c:	4618      	mov	r0, r3
 800435e:	f7fd f9c9 	bl	80016f4 <HAL_InitTick>
 8004362:	4603      	mov	r3, r0
 8004364:	2b00      	cmp	r3, #0
 8004366:	d039      	beq.n	80043dc <HAL_RCC_OscConfig+0x138>
        {
          return HAL_ERROR;
 8004368:	2301      	movs	r3, #1
 800436a:	e308      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      }
    }
    else
    {
      /* Check the MSI State */
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800436c:	687b      	ldr	r3, [r7, #4]
 800436e:	69db      	ldr	r3, [r3, #28]
 8004370:	2b00      	cmp	r3, #0
 8004372:	d01e      	beq.n	80043b2 <HAL_RCC_OscConfig+0x10e>
      {
        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
 8004374:	f7ff fda3 	bl	8003ebe <LL_RCC_MSI_Enable>

        /* Get timeout */
        tickstart = HAL_GetTick();
 8004378:	f7fd fed0 	bl	800211c <HAL_GetTick>
 800437c:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
 800437e:	e008      	b.n	8004392 <HAL_RCC_OscConfig+0xee>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8004380:	f7fd fecc 	bl	800211c <HAL_GetTick>
 8004384:	4602      	mov	r2, r0
 8004386:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004388:	1ad3      	subs	r3, r2, r3
 800438a:	2b02      	cmp	r3, #2
 800438c:	d901      	bls.n	8004392 <HAL_RCC_OscConfig+0xee>
          {
            return HAL_TIMEOUT;
 800438e:	2303      	movs	r3, #3
 8004390:	e2f5      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_MSI_IsReady() == 0U)
 8004392:	f7ff fdb2 	bl	8003efa <LL_RCC_MSI_IsReady>
 8004396:	4603      	mov	r3, r0
 8004398:	2b00      	cmp	r3, #0
 800439a:	d0f1      	beq.n	8004380 <HAL_RCC_OscConfig+0xdc>
          }
        }

        /* Selects the Multiple Speed oscillator (MSI) clock range .*/
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800439c:	687b      	ldr	r3, [r7, #4]
 800439e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80043a0:	4618      	mov	r0, r3
 80043a2:	f7ff fdbb 	bl	8003f1c <LL_RCC_MSI_SetRange>
        /* Adjusts the Multiple Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80043a6:	687b      	ldr	r3, [r7, #4]
 80043a8:	6a1b      	ldr	r3, [r3, #32]
 80043aa:	4618      	mov	r0, r3
 80043ac:	f7ff fddf 	bl	8003f6e <LL_RCC_MSI_SetCalibTrimming>
 80043b0:	e015      	b.n	80043de <HAL_RCC_OscConfig+0x13a>

      }
      else
      {
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
 80043b2:	f7ff fd93 	bl	8003edc <LL_RCC_MSI_Disable>

        /* Get timeout */
        tickstart = HAL_GetTick();
 80043b6:	f7fd feb1 	bl	800211c <HAL_GetTick>
 80043ba:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
 80043bc:	e008      	b.n	80043d0 <HAL_RCC_OscConfig+0x12c>
        {
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80043be:	f7fd fead 	bl	800211c <HAL_GetTick>
 80043c2:	4602      	mov	r2, r0
 80043c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80043c6:	1ad3      	subs	r3, r2, r3
 80043c8:	2b02      	cmp	r3, #2
 80043ca:	d901      	bls.n	80043d0 <HAL_RCC_OscConfig+0x12c>
          {
            return HAL_TIMEOUT;
 80043cc:	2303      	movs	r3, #3
 80043ce:	e2d6      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_MSI_IsReady() != 0U)
 80043d0:	f7ff fd93 	bl	8003efa <LL_RCC_MSI_IsReady>
 80043d4:	4603      	mov	r3, r0
 80043d6:	2b00      	cmp	r3, #0
 80043d8:	d1f1      	bne.n	80043be <HAL_RCC_OscConfig+0x11a>
 80043da:	e000      	b.n	80043de <HAL_RCC_OscConfig+0x13a>
      if (RCC_OscInitStruct->MSIState == RCC_MSI_OFF)
 80043dc:	bf00      	nop
      }
    }
  }

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80043de:	687b      	ldr	r3, [r7, #4]
 80043e0:	681b      	ldr	r3, [r3, #0]
 80043e2:	f003 0301 	and.w	r3, r3, #1
 80043e6:	2b00      	cmp	r3, #0
 80043e8:	d047      	beq.n	800447a <HAL_RCC_OscConfig+0x1d6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80043ea:	f7ff fde9 	bl	8003fc0 <LL_RCC_GetSysClkSource>
 80043ee:	6238      	str	r0, [r7, #32]
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 80043f0:	f7ff feef 	bl	80041d2 <LL_RCC_PLL_GetMainSource>
 80043f4:	61f8      	str	r0, [r7, #28]
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 80043f6:	6a3b      	ldr	r3, [r7, #32]
 80043f8:	2b08      	cmp	r3, #8
 80043fa:	d005      	beq.n	8004408 <HAL_RCC_OscConfig+0x164>
 80043fc:	6a3b      	ldr	r3, [r7, #32]
 80043fe:	2b0c      	cmp	r3, #12
 8004400:	d108      	bne.n	8004414 <HAL_RCC_OscConfig+0x170>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_HSE)))
 8004402:	69fb      	ldr	r3, [r7, #28]
 8004404:	2b03      	cmp	r3, #3
 8004406:	d105      	bne.n	8004414 <HAL_RCC_OscConfig+0x170>
    {
      if (RCC_OscInitStruct->HSEState == RCC_HSE_OFF)
 8004408:	687b      	ldr	r3, [r7, #4]
 800440a:	685b      	ldr	r3, [r3, #4]
 800440c:	2b00      	cmp	r3, #0
 800440e:	d134      	bne.n	800447a <HAL_RCC_OscConfig+0x1d6>
      {
        return HAL_ERROR;
 8004410:	2301      	movs	r3, #1
 8004412:	e2b4      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004414:	687b      	ldr	r3, [r7, #4]
 8004416:	685b      	ldr	r3, [r3, #4]
 8004418:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800441c:	d102      	bne.n	8004424 <HAL_RCC_OscConfig+0x180>
 800441e:	f7ff fbd0 	bl	8003bc2 <LL_RCC_HSE_Enable>
 8004422:	e001      	b.n	8004428 <HAL_RCC_OscConfig+0x184>
 8004424:	f7ff fbdc 	bl	8003be0 <LL_RCC_HSE_Disable>

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8004428:	687b      	ldr	r3, [r7, #4]
 800442a:	685b      	ldr	r3, [r3, #4]
 800442c:	2b00      	cmp	r3, #0
 800442e:	d012      	beq.n	8004456 <HAL_RCC_OscConfig+0x1b2>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004430:	f7fd fe74 	bl	800211c <HAL_GetTick>
 8004434:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while (LL_RCC_HSE_IsReady() == 0U)
 8004436:	e008      	b.n	800444a <HAL_RCC_OscConfig+0x1a6>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004438:	f7fd fe70 	bl	800211c <HAL_GetTick>
 800443c:	4602      	mov	r2, r0
 800443e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004440:	1ad3      	subs	r3, r2, r3
 8004442:	2b64      	cmp	r3, #100	; 0x64
 8004444:	d901      	bls.n	800444a <HAL_RCC_OscConfig+0x1a6>
          {
            return HAL_TIMEOUT;
 8004446:	2303      	movs	r3, #3
 8004448:	e299      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_HSE_IsReady() == 0U)
 800444a:	f7ff fbd8 	bl	8003bfe <LL_RCC_HSE_IsReady>
 800444e:	4603      	mov	r3, r0
 8004450:	2b00      	cmp	r3, #0
 8004452:	d0f1      	beq.n	8004438 <HAL_RCC_OscConfig+0x194>
 8004454:	e011      	b.n	800447a <HAL_RCC_OscConfig+0x1d6>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004456:	f7fd fe61 	bl	800211c <HAL_GetTick>
 800445a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while (LL_RCC_HSE_IsReady() != 0U)
 800445c:	e008      	b.n	8004470 <HAL_RCC_OscConfig+0x1cc>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800445e:	f7fd fe5d 	bl	800211c <HAL_GetTick>
 8004462:	4602      	mov	r2, r0
 8004464:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004466:	1ad3      	subs	r3, r2, r3
 8004468:	2b64      	cmp	r3, #100	; 0x64
 800446a:	d901      	bls.n	8004470 <HAL_RCC_OscConfig+0x1cc>
          {
            return HAL_TIMEOUT;
 800446c:	2303      	movs	r3, #3
 800446e:	e286      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_HSE_IsReady() != 0U)
 8004470:	f7ff fbc5 	bl	8003bfe <LL_RCC_HSE_IsReady>
 8004474:	4603      	mov	r3, r0
 8004476:	2b00      	cmp	r3, #0
 8004478:	d1f1      	bne.n	800445e <HAL_RCC_OscConfig+0x1ba>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800447a:	687b      	ldr	r3, [r7, #4]
 800447c:	681b      	ldr	r3, [r3, #0]
 800447e:	f003 0302 	and.w	r3, r3, #2
 8004482:	2b00      	cmp	r3, #0
 8004484:	d04c      	beq.n	8004520 <HAL_RCC_OscConfig+0x27c>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8004486:	f7ff fd9b 	bl	8003fc0 <LL_RCC_GetSysClkSource>
 800448a:	61b8      	str	r0, [r7, #24]
    const uint32_t temp_plloscsrc = __HAL_RCC_GET_PLL_OSCSOURCE();
 800448c:	f7ff fea1 	bl	80041d2 <LL_RCC_PLL_GetMainSource>
 8004490:	6178      	str	r0, [r7, #20]
    if ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 8004492:	69bb      	ldr	r3, [r7, #24]
 8004494:	2b04      	cmp	r3, #4
 8004496:	d005      	beq.n	80044a4 <HAL_RCC_OscConfig+0x200>
 8004498:	69bb      	ldr	r3, [r7, #24]
 800449a:	2b0c      	cmp	r3, #12
 800449c:	d10e      	bne.n	80044bc <HAL_RCC_OscConfig+0x218>
        ((temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (temp_plloscsrc == RCC_PLLSOURCE_HSI)))
 800449e:	697b      	ldr	r3, [r7, #20]
 80044a0:	2b02      	cmp	r3, #2
 80044a2:	d10b      	bne.n	80044bc <HAL_RCC_OscConfig+0x218>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (RCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 80044a4:	687b      	ldr	r3, [r7, #4]
 80044a6:	68db      	ldr	r3, [r3, #12]
 80044a8:	2b00      	cmp	r3, #0
 80044aa:	d101      	bne.n	80044b0 <HAL_RCC_OscConfig+0x20c>
      {
        return HAL_ERROR;
 80044ac:	2301      	movs	r3, #1
 80044ae:	e266      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80044b0:	687b      	ldr	r3, [r7, #4]
 80044b2:	691b      	ldr	r3, [r3, #16]
 80044b4:	4618      	mov	r0, r3
 80044b6:	f7ff fbe4 	bl	8003c82 <LL_RCC_HSI_SetCalibTrimming>
      if (RCC_OscInitStruct->HSIState == RCC_HSI_OFF)
 80044ba:	e031      	b.n	8004520 <HAL_RCC_OscConfig+0x27c>
      }
    }
    else
    {
      /* Check the HSI State */
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80044bc:	687b      	ldr	r3, [r7, #4]
 80044be:	68db      	ldr	r3, [r3, #12]
 80044c0:	2b00      	cmp	r3, #0
 80044c2:	d019      	beq.n	80044f8 <HAL_RCC_OscConfig+0x254>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80044c4:	f7ff fbad 	bl	8003c22 <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80044c8:	f7fd fe28 	bl	800211c <HAL_GetTick>
 80044cc:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
 80044ce:	e008      	b.n	80044e2 <HAL_RCC_OscConfig+0x23e>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80044d0:	f7fd fe24 	bl	800211c <HAL_GetTick>
 80044d4:	4602      	mov	r2, r0
 80044d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80044d8:	1ad3      	subs	r3, r2, r3
 80044da:	2b02      	cmp	r3, #2
 80044dc:	d901      	bls.n	80044e2 <HAL_RCC_OscConfig+0x23e>
          {
            return HAL_TIMEOUT;
 80044de:	2303      	movs	r3, #3
 80044e0:	e24d      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_HSI_IsReady() == 0U)
 80044e2:	f7ff fbbc 	bl	8003c5e <LL_RCC_HSI_IsReady>
 80044e6:	4603      	mov	r3, r0
 80044e8:	2b00      	cmp	r3, #0
 80044ea:	d0f1      	beq.n	80044d0 <HAL_RCC_OscConfig+0x22c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80044ec:	687b      	ldr	r3, [r7, #4]
 80044ee:	691b      	ldr	r3, [r3, #16]
 80044f0:	4618      	mov	r0, r3
 80044f2:	f7ff fbc6 	bl	8003c82 <LL_RCC_HSI_SetCalibTrimming>
 80044f6:	e013      	b.n	8004520 <HAL_RCC_OscConfig+0x27c>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 80044f8:	f7ff fba2 	bl	8003c40 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80044fc:	f7fd fe0e 	bl	800211c <HAL_GetTick>
 8004500:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
 8004502:	e008      	b.n	8004516 <HAL_RCC_OscConfig+0x272>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004504:	f7fd fe0a 	bl	800211c <HAL_GetTick>
 8004508:	4602      	mov	r2, r0
 800450a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800450c:	1ad3      	subs	r3, r2, r3
 800450e:	2b02      	cmp	r3, #2
 8004510:	d901      	bls.n	8004516 <HAL_RCC_OscConfig+0x272>
          {
            return HAL_TIMEOUT;
 8004512:	2303      	movs	r3, #3
 8004514:	e233      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_HSI_IsReady() != 0U)
 8004516:	f7ff fba2 	bl	8003c5e <LL_RCC_HSI_IsReady>
 800451a:	4603      	mov	r3, r0
 800451c:	2b00      	cmp	r3, #0
 800451e:	d1f1      	bne.n	8004504 <HAL_RCC_OscConfig+0x260>
      }
    }
  }
  /*------------------------------ LSI Configuration (LSI1 or LSI2) -------------------------*/

  if ((((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI1) == RCC_OSCILLATORTYPE_LSI1) || \
 8004520:	687b      	ldr	r3, [r7, #4]
 8004522:	681b      	ldr	r3, [r3, #0]
 8004524:	f003 0308 	and.w	r3, r3, #8
 8004528:	2b00      	cmp	r3, #0
 800452a:	d106      	bne.n	800453a <HAL_RCC_OscConfig+0x296>
      (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI2) == RCC_OSCILLATORTYPE_LSI2))
 800452c:	687b      	ldr	r3, [r7, #4]
 800452e:	681b      	ldr	r3, [r3, #0]
 8004530:	f003 0310 	and.w	r3, r3, #16
  if ((((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI1) == RCC_OSCILLATORTYPE_LSI1) || \
 8004534:	2b00      	cmp	r3, #0
 8004536:	f000 80a3 	beq.w	8004680 <HAL_RCC_OscConfig+0x3dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800453a:	687b      	ldr	r3, [r7, #4]
 800453c:	695b      	ldr	r3, [r3, #20]
 800453e:	2b00      	cmp	r3, #0
 8004540:	d076      	beq.n	8004630 <HAL_RCC_OscConfig+0x38c>
    {
      /*------------------------------ LSI2 selected by default (when Switch ON) -------------------------*/
      if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI2) == RCC_OSCILLATORTYPE_LSI2)
 8004542:	687b      	ldr	r3, [r7, #4]
 8004544:	681b      	ldr	r3, [r3, #0]
 8004546:	f003 0310 	and.w	r3, r3, #16
 800454a:	2b00      	cmp	r3, #0
 800454c:	d046      	beq.n	80045dc <HAL_RCC_OscConfig+0x338>
      {
        assert_param(IS_RCC_LSI2_CALIBRATION_VALUE(RCC_OscInitStruct->LSI2CalibrationValue));

        /* 1. Check LSI1 state and enable if required */
        if (LL_RCC_LSI1_IsReady() == 0U)
 800454e:	f7ff fc59 	bl	8003e04 <LL_RCC_LSI1_IsReady>
 8004552:	4603      	mov	r3, r0
 8004554:	2b00      	cmp	r3, #0
 8004556:	d113      	bne.n	8004580 <HAL_RCC_OscConfig+0x2dc>
        {
          /* This is required to enable LSI1 before enabling LSI2 */
          __HAL_RCC_LSI1_ENABLE();
 8004558:	f7ff fc32 	bl	8003dc0 <LL_RCC_LSI1_Enable>

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 800455c:	f7fd fdde 	bl	800211c <HAL_GetTick>
 8004560:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till LSI1 is ready */
          while (LL_RCC_LSI1_IsReady() == 0U)
 8004562:	e008      	b.n	8004576 <HAL_RCC_OscConfig+0x2d2>
          {
            if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 8004564:	f7fd fdda 	bl	800211c <HAL_GetTick>
 8004568:	4602      	mov	r2, r0
 800456a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800456c:	1ad3      	subs	r3, r2, r3
 800456e:	2b02      	cmp	r3, #2
 8004570:	d901      	bls.n	8004576 <HAL_RCC_OscConfig+0x2d2>
            {
              return HAL_TIMEOUT;
 8004572:	2303      	movs	r3, #3
 8004574:	e203      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
          while (LL_RCC_LSI1_IsReady() == 0U)
 8004576:	f7ff fc45 	bl	8003e04 <LL_RCC_LSI1_IsReady>
 800457a:	4603      	mov	r3, r0
 800457c:	2b00      	cmp	r3, #0
 800457e:	d0f1      	beq.n	8004564 <HAL_RCC_OscConfig+0x2c0>
            }
          }
        }

        /* 2. Enable the Internal Low Speed oscillator (LSI2) and set trimming value */
        __HAL_RCC_LSI2_ENABLE();
 8004580:	f7ff fc52 	bl	8003e28 <LL_RCC_LSI2_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004584:	f7fd fdca 	bl	800211c <HAL_GetTick>
 8004588:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI2 is ready */
        while (LL_RCC_LSI2_IsReady() == 0U)
 800458a:	e008      	b.n	800459e <HAL_RCC_OscConfig+0x2fa>
        {
          if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 800458c:	f7fd fdc6 	bl	800211c <HAL_GetTick>
 8004590:	4602      	mov	r2, r0
 8004592:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004594:	1ad3      	subs	r3, r2, r3
 8004596:	2b03      	cmp	r3, #3
 8004598:	d901      	bls.n	800459e <HAL_RCC_OscConfig+0x2fa>
          {
            return HAL_TIMEOUT;
 800459a:	2303      	movs	r3, #3
 800459c:	e1ef      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_LSI2_IsReady() == 0U)
 800459e:	f7ff fc65 	bl	8003e6c <LL_RCC_LSI2_IsReady>
 80045a2:	4603      	mov	r3, r0
 80045a4:	2b00      	cmp	r3, #0
 80045a6:	d0f1      	beq.n	800458c <HAL_RCC_OscConfig+0x2e8>
          }
        }
        /* Adjusts the Internal Low Spee oscillator (LSI2) calibration value */
        __HAL_RCC_LSI2_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->LSI2CalibrationValue);
 80045a8:	687b      	ldr	r3, [r7, #4]
 80045aa:	699b      	ldr	r3, [r3, #24]
 80045ac:	4618      	mov	r0, r3
 80045ae:	f7ff fc6f 	bl	8003e90 <LL_RCC_LSI2_SetTrimming>

        /* 3. Disable LSI1 */

        /* LSI1 was initially not enable, require to disable it */
        __HAL_RCC_LSI1_DISABLE();
 80045b2:	f7ff fc16 	bl	8003de2 <LL_RCC_LSI1_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80045b6:	f7fd fdb1 	bl	800211c <HAL_GetTick>
 80045ba:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI1 is disabled */
        while (LL_RCC_LSI1_IsReady() != 0U)
 80045bc:	e008      	b.n	80045d0 <HAL_RCC_OscConfig+0x32c>
        {
          if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 80045be:	f7fd fdad 	bl	800211c <HAL_GetTick>
 80045c2:	4602      	mov	r2, r0
 80045c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045c6:	1ad3      	subs	r3, r2, r3
 80045c8:	2b02      	cmp	r3, #2
 80045ca:	d901      	bls.n	80045d0 <HAL_RCC_OscConfig+0x32c>
          {
            return HAL_TIMEOUT;
 80045cc:	2303      	movs	r3, #3
 80045ce:	e1d6      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_LSI1_IsReady() != 0U)
 80045d0:	f7ff fc18 	bl	8003e04 <LL_RCC_LSI1_IsReady>
 80045d4:	4603      	mov	r3, r0
 80045d6:	2b00      	cmp	r3, #0
 80045d8:	d1f1      	bne.n	80045be <HAL_RCC_OscConfig+0x31a>
 80045da:	e051      	b.n	8004680 <HAL_RCC_OscConfig+0x3dc>
      else
      {
        /*------------------------------ LSI1 selected (only if LSI2 OFF)-------------------------*/

        /* 1. Enable the Internal Low Speed oscillator (LSI1). */
        __HAL_RCC_LSI1_ENABLE();
 80045dc:	f7ff fbf0 	bl	8003dc0 <LL_RCC_LSI1_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80045e0:	f7fd fd9c 	bl	800211c <HAL_GetTick>
 80045e4:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till LSI1 is ready */
        while (LL_RCC_LSI1_IsReady() == 0U)
 80045e6:	e00c      	b.n	8004602 <HAL_RCC_OscConfig+0x35e>
 80045e8:	20000018 	.word	0x20000018
 80045ec:	2000001c 	.word	0x2000001c
        {
          if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 80045f0:	f7fd fd94 	bl	800211c <HAL_GetTick>
 80045f4:	4602      	mov	r2, r0
 80045f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045f8:	1ad3      	subs	r3, r2, r3
 80045fa:	2b02      	cmp	r3, #2
 80045fc:	d901      	bls.n	8004602 <HAL_RCC_OscConfig+0x35e>
          {
            return HAL_TIMEOUT;
 80045fe:	2303      	movs	r3, #3
 8004600:	e1bd      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_LSI1_IsReady() == 0U)
 8004602:	f7ff fbff 	bl	8003e04 <LL_RCC_LSI1_IsReady>
 8004606:	4603      	mov	r3, r0
 8004608:	2b00      	cmp	r3, #0
 800460a:	d0f1      	beq.n	80045f0 <HAL_RCC_OscConfig+0x34c>
          }
        }
        /*2. Switch OFF LSI2*/

        /* Disable the Internal Low Speed oscillator (LSI2). */
        __HAL_RCC_LSI2_DISABLE();
 800460c:	f7ff fc1d 	bl	8003e4a <LL_RCC_LSI2_Disable>

        /* Wait till LSI2 is disabled */
        while (LL_RCC_LSI2_IsReady() != 0U)
 8004610:	e008      	b.n	8004624 <HAL_RCC_OscConfig+0x380>
        {
          if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 8004612:	f7fd fd83 	bl	800211c <HAL_GetTick>
 8004616:	4602      	mov	r2, r0
 8004618:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800461a:	1ad3      	subs	r3, r2, r3
 800461c:	2b03      	cmp	r3, #3
 800461e:	d901      	bls.n	8004624 <HAL_RCC_OscConfig+0x380>
          {
            return HAL_TIMEOUT;
 8004620:	2303      	movs	r3, #3
 8004622:	e1ac      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (LL_RCC_LSI2_IsReady() != 0U)
 8004624:	f7ff fc22 	bl	8003e6c <LL_RCC_LSI2_IsReady>
 8004628:	4603      	mov	r3, r0
 800462a:	2b00      	cmp	r3, #0
 800462c:	d1f1      	bne.n	8004612 <HAL_RCC_OscConfig+0x36e>
 800462e:	e027      	b.n	8004680 <HAL_RCC_OscConfig+0x3dc>
    }
    else
    {

      /* Disable the Internal Low Speed oscillator (LSI2). */
      __HAL_RCC_LSI2_DISABLE();
 8004630:	f7ff fc0b 	bl	8003e4a <LL_RCC_LSI2_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004634:	f7fd fd72 	bl	800211c <HAL_GetTick>
 8004638:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI2 is disabled */
      while (LL_RCC_LSI2_IsReady() != 0U)
 800463a:	e008      	b.n	800464e <HAL_RCC_OscConfig+0x3aa>
      {
        if ((HAL_GetTick() - tickstart) > LSI2_TIMEOUT_VALUE)
 800463c:	f7fd fd6e 	bl	800211c <HAL_GetTick>
 8004640:	4602      	mov	r2, r0
 8004642:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004644:	1ad3      	subs	r3, r2, r3
 8004646:	2b03      	cmp	r3, #3
 8004648:	d901      	bls.n	800464e <HAL_RCC_OscConfig+0x3aa>
        {
          return HAL_TIMEOUT;
 800464a:	2303      	movs	r3, #3
 800464c:	e197      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_LSI2_IsReady() != 0U)
 800464e:	f7ff fc0d 	bl	8003e6c <LL_RCC_LSI2_IsReady>
 8004652:	4603      	mov	r3, r0
 8004654:	2b00      	cmp	r3, #0
 8004656:	d1f1      	bne.n	800463c <HAL_RCC_OscConfig+0x398>
        }
      }

      /* Disable the Internal Low Speed oscillator (LSI1). */
      __HAL_RCC_LSI1_DISABLE();
 8004658:	f7ff fbc3 	bl	8003de2 <LL_RCC_LSI1_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800465c:	f7fd fd5e 	bl	800211c <HAL_GetTick>
 8004660:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI1 is disabled */
      while (LL_RCC_LSI1_IsReady() != 0U)
 8004662:	e008      	b.n	8004676 <HAL_RCC_OscConfig+0x3d2>
      {
        if ((HAL_GetTick() - tickstart) > LSI1_TIMEOUT_VALUE)
 8004664:	f7fd fd5a 	bl	800211c <HAL_GetTick>
 8004668:	4602      	mov	r2, r0
 800466a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800466c:	1ad3      	subs	r3, r2, r3
 800466e:	2b02      	cmp	r3, #2
 8004670:	d901      	bls.n	8004676 <HAL_RCC_OscConfig+0x3d2>
        {
          return HAL_TIMEOUT;
 8004672:	2303      	movs	r3, #3
 8004674:	e183      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_LSI1_IsReady() != 0U)
 8004676:	f7ff fbc5 	bl	8003e04 <LL_RCC_LSI1_IsReady>
 800467a:	4603      	mov	r3, r0
 800467c:	2b00      	cmp	r3, #0
 800467e:	d1f1      	bne.n	8004664 <HAL_RCC_OscConfig+0x3c0>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8004680:	687b      	ldr	r3, [r7, #4]
 8004682:	681b      	ldr	r3, [r3, #0]
 8004684:	f003 0304 	and.w	r3, r3, #4
 8004688:	2b00      	cmp	r3, #0
 800468a:	d05b      	beq.n	8004744 <HAL_RCC_OscConfig+0x4a0>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800468c:	4ba7      	ldr	r3, [pc, #668]	; (800492c <HAL_RCC_OscConfig+0x688>)
 800468e:	681b      	ldr	r3, [r3, #0]
 8004690:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004694:	2b00      	cmp	r3, #0
 8004696:	d114      	bne.n	80046c2 <HAL_RCC_OscConfig+0x41e>
    {
      /* Enable write access to Backup domain */
      HAL_PWR_EnableBkUpAccess();
 8004698:	f7ff f9a8 	bl	80039ec <HAL_PWR_EnableBkUpAccess>

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800469c:	f7fd fd3e 	bl	800211c <HAL_GetTick>
 80046a0:	6278      	str	r0, [r7, #36]	; 0x24

      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80046a2:	e008      	b.n	80046b6 <HAL_RCC_OscConfig+0x412>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80046a4:	f7fd fd3a 	bl	800211c <HAL_GetTick>
 80046a8:	4602      	mov	r2, r0
 80046aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80046ac:	1ad3      	subs	r3, r2, r3
 80046ae:	2b02      	cmp	r3, #2
 80046b0:	d901      	bls.n	80046b6 <HAL_RCC_OscConfig+0x412>
        {
          return HAL_TIMEOUT;
 80046b2:	2303      	movs	r3, #3
 80046b4:	e163      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80046b6:	4b9d      	ldr	r3, [pc, #628]	; (800492c <HAL_RCC_OscConfig+0x688>)
 80046b8:	681b      	ldr	r3, [r3, #0]
 80046ba:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80046be:	2b00      	cmp	r3, #0
 80046c0:	d0f0      	beq.n	80046a4 <HAL_RCC_OscConfig+0x400>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80046c2:	687b      	ldr	r3, [r7, #4]
 80046c4:	689b      	ldr	r3, [r3, #8]
 80046c6:	2b01      	cmp	r3, #1
 80046c8:	d102      	bne.n	80046d0 <HAL_RCC_OscConfig+0x42c>
 80046ca:	f7ff fb23 	bl	8003d14 <LL_RCC_LSE_Enable>
 80046ce:	e00c      	b.n	80046ea <HAL_RCC_OscConfig+0x446>
 80046d0:	687b      	ldr	r3, [r7, #4]
 80046d2:	689b      	ldr	r3, [r3, #8]
 80046d4:	2b05      	cmp	r3, #5
 80046d6:	d104      	bne.n	80046e2 <HAL_RCC_OscConfig+0x43e>
 80046d8:	f7ff fb3e 	bl	8003d58 <LL_RCC_LSE_EnableBypass>
 80046dc:	f7ff fb1a 	bl	8003d14 <LL_RCC_LSE_Enable>
 80046e0:	e003      	b.n	80046ea <HAL_RCC_OscConfig+0x446>
 80046e2:	f7ff fb28 	bl	8003d36 <LL_RCC_LSE_Disable>
 80046e6:	f7ff fb48 	bl	8003d7a <LL_RCC_LSE_DisableBypass>

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80046ea:	687b      	ldr	r3, [r7, #4]
 80046ec:	689b      	ldr	r3, [r3, #8]
 80046ee:	2b00      	cmp	r3, #0
 80046f0:	d014      	beq.n	800471c <HAL_RCC_OscConfig+0x478>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80046f2:	f7fd fd13 	bl	800211c <HAL_GetTick>
 80046f6:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
 80046f8:	e00a      	b.n	8004710 <HAL_RCC_OscConfig+0x46c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80046fa:	f7fd fd0f 	bl	800211c <HAL_GetTick>
 80046fe:	4602      	mov	r2, r0
 8004700:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004702:	1ad3      	subs	r3, r2, r3
 8004704:	f241 3288 	movw	r2, #5000	; 0x1388
 8004708:	4293      	cmp	r3, r2
 800470a:	d901      	bls.n	8004710 <HAL_RCC_OscConfig+0x46c>
        {
          return HAL_TIMEOUT;
 800470c:	2303      	movs	r3, #3
 800470e:	e136      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_LSE_IsReady() == 0U)
 8004710:	f7ff fb44 	bl	8003d9c <LL_RCC_LSE_IsReady>
 8004714:	4603      	mov	r3, r0
 8004716:	2b00      	cmp	r3, #0
 8004718:	d0ef      	beq.n	80046fa <HAL_RCC_OscConfig+0x456>
 800471a:	e013      	b.n	8004744 <HAL_RCC_OscConfig+0x4a0>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800471c:	f7fd fcfe 	bl	800211c <HAL_GetTick>
 8004720:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
 8004722:	e00a      	b.n	800473a <HAL_RCC_OscConfig+0x496>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004724:	f7fd fcfa 	bl	800211c <HAL_GetTick>
 8004728:	4602      	mov	r2, r0
 800472a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800472c:	1ad3      	subs	r3, r2, r3
 800472e:	f241 3288 	movw	r2, #5000	; 0x1388
 8004732:	4293      	cmp	r3, r2
 8004734:	d901      	bls.n	800473a <HAL_RCC_OscConfig+0x496>
        {
          return HAL_TIMEOUT;
 8004736:	2303      	movs	r3, #3
 8004738:	e121      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_LSE_IsReady() != 0U)
 800473a:	f7ff fb2f 	bl	8003d9c <LL_RCC_LSE_IsReady>
 800473e:	4603      	mov	r3, r0
 8004740:	2b00      	cmp	r3, #0
 8004742:	d1ef      	bne.n	8004724 <HAL_RCC_OscConfig+0x480>
    }

  }
#if defined(RCC_HSI48_SUPPORT)
  /*------------------------------ HSI48 Configuration -----------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8004744:	687b      	ldr	r3, [r7, #4]
 8004746:	681b      	ldr	r3, [r3, #0]
 8004748:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800474c:	2b00      	cmp	r3, #0
 800474e:	d02c      	beq.n	80047aa <HAL_RCC_OscConfig+0x506>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI State */
    if (RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8004750:	687b      	ldr	r3, [r7, #4]
 8004752:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004754:	2b00      	cmp	r3, #0
 8004756:	d014      	beq.n	8004782 <HAL_RCC_OscConfig+0x4de>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8004758:	f7ff faa8 	bl	8003cac <LL_RCC_HSI48_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800475c:	f7fd fcde 	bl	800211c <HAL_GetTick>
 8004760:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while (LL_RCC_HSI48_IsReady() == 0U)
 8004762:	e008      	b.n	8004776 <HAL_RCC_OscConfig+0x4d2>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8004764:	f7fd fcda 	bl	800211c <HAL_GetTick>
 8004768:	4602      	mov	r2, r0
 800476a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800476c:	1ad3      	subs	r3, r2, r3
 800476e:	2b02      	cmp	r3, #2
 8004770:	d901      	bls.n	8004776 <HAL_RCC_OscConfig+0x4d2>
        {
          return HAL_TIMEOUT;
 8004772:	2303      	movs	r3, #3
 8004774:	e103      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_HSI48_IsReady() == 0U)
 8004776:	f7ff fabb 	bl	8003cf0 <LL_RCC_HSI48_IsReady>
 800477a:	4603      	mov	r3, r0
 800477c:	2b00      	cmp	r3, #0
 800477e:	d0f1      	beq.n	8004764 <HAL_RCC_OscConfig+0x4c0>
 8004780:	e013      	b.n	80047aa <HAL_RCC_OscConfig+0x506>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 8004782:	f7ff faa4 	bl	8003cce <LL_RCC_HSI48_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004786:	f7fd fcc9 	bl	800211c <HAL_GetTick>
 800478a:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is disabled */
      while (LL_RCC_HSI48_IsReady() != 0U)
 800478c:	e008      	b.n	80047a0 <HAL_RCC_OscConfig+0x4fc>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800478e:	f7fd fcc5 	bl	800211c <HAL_GetTick>
 8004792:	4602      	mov	r2, r0
 8004794:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004796:	1ad3      	subs	r3, r2, r3
 8004798:	2b02      	cmp	r3, #2
 800479a:	d901      	bls.n	80047a0 <HAL_RCC_OscConfig+0x4fc>
        {
          return HAL_TIMEOUT;
 800479c:	2303      	movs	r3, #3
 800479e:	e0ee      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      while (LL_RCC_HSI48_IsReady() != 0U)
 80047a0:	f7ff faa6 	bl	8003cf0 <LL_RCC_HSI48_IsReady>
 80047a4:	4603      	mov	r3, r0
 80047a6:	2b00      	cmp	r3, #0
 80047a8:	d1f1      	bne.n	800478e <HAL_RCC_OscConfig+0x4ea>
#endif /* RCC_HSI48_SUPPORT */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 80047aa:	687b      	ldr	r3, [r7, #4]
 80047ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80047ae:	2b00      	cmp	r3, #0
 80047b0:	f000 80e4 	beq.w	800497c <HAL_RCC_OscConfig+0x6d8>
  {
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80047b4:	f7ff fc04 	bl	8003fc0 <LL_RCC_GetSysClkSource>
 80047b8:	6138      	str	r0, [r7, #16]
    const uint32_t temp_pllconfig = RCC->PLLCFGR;
 80047ba:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80047be:	68db      	ldr	r3, [r3, #12]
 80047c0:	60fb      	str	r3, [r7, #12]

    /* PLL On ? */
    if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80047c2:	687b      	ldr	r3, [r7, #4]
 80047c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80047c6:	2b02      	cmp	r3, #2
 80047c8:	f040 80b4 	bne.w	8004934 <HAL_RCC_OscConfig+0x690>
      assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
      assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

      /* Do nothing if PLL configuration is unchanged */
      if ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80047cc:	68fb      	ldr	r3, [r7, #12]
 80047ce:	f003 0203 	and.w	r2, r3, #3
 80047d2:	687b      	ldr	r3, [r7, #4]
 80047d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80047d6:	429a      	cmp	r2, r3
 80047d8:	d123      	bne.n	8004822 <HAL_RCC_OscConfig+0x57e>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 80047da:	68fb      	ldr	r3, [r7, #12]
 80047dc:	f003 0270 	and.w	r2, r3, #112	; 0x70
 80047e0:	687b      	ldr	r3, [r7, #4]
 80047e2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
      if ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80047e4:	429a      	cmp	r2, r3
 80047e6:	d11c      	bne.n	8004822 <HAL_RCC_OscConfig+0x57e>
          ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) != RCC_OscInitStruct->PLL.PLLN) ||
 80047e8:	68fb      	ldr	r3, [r7, #12]
 80047ea:	0a1b      	lsrs	r3, r3, #8
 80047ec:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 80047f0:	687b      	ldr	r3, [r7, #4]
 80047f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 80047f4:	429a      	cmp	r2, r3
 80047f6:	d114      	bne.n	8004822 <HAL_RCC_OscConfig+0x57e>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 80047f8:	68fb      	ldr	r3, [r7, #12]
 80047fa:	f403 1278 	and.w	r2, r3, #4063232	; 0x3e0000
 80047fe:	687b      	ldr	r3, [r7, #4]
 8004800:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
          ((READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos) != RCC_OscInitStruct->PLL.PLLN) ||
 8004802:	429a      	cmp	r2, r3
 8004804:	d10d      	bne.n	8004822 <HAL_RCC_OscConfig+0x57e>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ) ||
 8004806:	68fb      	ldr	r3, [r7, #12]
 8004808:	f003 6260 	and.w	r2, r3, #234881024	; 0xe000000
 800480c:	687b      	ldr	r3, [r7, #4]
 800480e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8004810:	429a      	cmp	r2, r3
 8004812:	d106      	bne.n	8004822 <HAL_RCC_OscConfig+0x57e>
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLR) != RCC_OscInitStruct->PLL.PLLR))
 8004814:	68fb      	ldr	r3, [r7, #12]
 8004816:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
 800481a:	687b      	ldr	r3, [r7, #4]
 800481c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
          (READ_BIT(temp_pllconfig, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ) ||
 800481e:	429a      	cmp	r2, r3
 8004820:	d05d      	beq.n	80048de <HAL_RCC_OscConfig+0x63a>
      {
        /* Check if the PLL is used as system clock or not */
        if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8004822:	693b      	ldr	r3, [r7, #16]
 8004824:	2b0c      	cmp	r3, #12
 8004826:	d058      	beq.n	80048da <HAL_RCC_OscConfig+0x636>
        {
#if defined(SAI1)
          /* Check if main PLL can be updated */
          /* Not possible if the source is shared by other enabled PLLSAIx */
          if (READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 8004828:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800482c:	681b      	ldr	r3, [r3, #0]
 800482e:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8004832:	2b00      	cmp	r3, #0
 8004834:	d001      	beq.n	800483a <HAL_RCC_OscConfig+0x596>

          {
            return HAL_ERROR;
 8004836:	2301      	movs	r3, #1
 8004838:	e0a1      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
          }
          else
#endif /* SAI1 */
          {
            /* Disable the main PLL. */
            __HAL_RCC_PLL_DISABLE();
 800483a:	f7ff fc84 	bl	8004146 <LL_RCC_PLL_Disable>

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 800483e:	f7fd fc6d 	bl	800211c <HAL_GetTick>
 8004842:	6278      	str	r0, [r7, #36]	; 0x24

            /* Wait till PLL is ready */
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8004844:	e008      	b.n	8004858 <HAL_RCC_OscConfig+0x5b4>
            {
              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004846:	f7fd fc69 	bl	800211c <HAL_GetTick>
 800484a:	4602      	mov	r2, r0
 800484c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800484e:	1ad3      	subs	r3, r2, r3
 8004850:	2b02      	cmp	r3, #2
 8004852:	d901      	bls.n	8004858 <HAL_RCC_OscConfig+0x5b4>
              {
                return HAL_TIMEOUT;
 8004854:	2303      	movs	r3, #3
 8004856:	e092      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8004858:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800485c:	681b      	ldr	r3, [r3, #0]
 800485e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004862:	2b00      	cmp	r3, #0
 8004864:	d1ef      	bne.n	8004846 <HAL_RCC_OscConfig+0x5a2>
              }
            }

            /* Configure the main PLL clock source, multiplication and division factors. */
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8004866:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800486a:	68da      	ldr	r2, [r3, #12]
 800486c:	4b30      	ldr	r3, [pc, #192]	; (8004930 <HAL_RCC_OscConfig+0x68c>)
 800486e:	4013      	ands	r3, r2
 8004870:	687a      	ldr	r2, [r7, #4]
 8004872:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8004874:	687a      	ldr	r2, [r7, #4]
 8004876:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8004878:	4311      	orrs	r1, r2
 800487a:	687a      	ldr	r2, [r7, #4]
 800487c:	6b92      	ldr	r2, [r2, #56]	; 0x38
 800487e:	0212      	lsls	r2, r2, #8
 8004880:	4311      	orrs	r1, r2
 8004882:	687a      	ldr	r2, [r7, #4]
 8004884:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8004886:	4311      	orrs	r1, r2
 8004888:	687a      	ldr	r2, [r7, #4]
 800488a:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800488c:	4311      	orrs	r1, r2
 800488e:	687a      	ldr	r2, [r7, #4]
 8004890:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8004892:	430a      	orrs	r2, r1
 8004894:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004898:	4313      	orrs	r3, r2
 800489a:	60cb      	str	r3, [r1, #12]
                                 RCC_OscInitStruct->PLL.PLLP,
                                 RCC_OscInitStruct->PLL.PLLQ,
                                 RCC_OscInitStruct->PLL.PLLR);

            /* Enable the main PLL. */
            __HAL_RCC_PLL_ENABLE();
 800489c:	f7ff fc44 	bl	8004128 <LL_RCC_PLL_Enable>

            /* Enable PLL System Clock output. */
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 80048a0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80048a4:	68db      	ldr	r3, [r3, #12]
 80048a6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80048aa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80048ae:	60d3      	str	r3, [r2, #12]

            /* Get Start Tick*/
            tickstart = HAL_GetTick();
 80048b0:	f7fd fc34 	bl	800211c <HAL_GetTick>
 80048b4:	6278      	str	r0, [r7, #36]	; 0x24

            /* Wait till PLL is ready */
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80048b6:	e008      	b.n	80048ca <HAL_RCC_OscConfig+0x626>
            {
              if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80048b8:	f7fd fc30 	bl	800211c <HAL_GetTick>
 80048bc:	4602      	mov	r2, r0
 80048be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80048c0:	1ad3      	subs	r3, r2, r3
 80048c2:	2b02      	cmp	r3, #2
 80048c4:	d901      	bls.n	80048ca <HAL_RCC_OscConfig+0x626>
              {
                return HAL_TIMEOUT;
 80048c6:	2303      	movs	r3, #3
 80048c8:	e059      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
            while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80048ca:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80048ce:	681b      	ldr	r3, [r3, #0]
 80048d0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80048d4:	2b00      	cmp	r3, #0
 80048d6:	d0ef      	beq.n	80048b8 <HAL_RCC_OscConfig+0x614>
        if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80048d8:	e050      	b.n	800497c <HAL_RCC_OscConfig+0x6d8>
          }
        }
        else
        {
          /* PLL is already used as System core clock */
          return HAL_ERROR;
 80048da:	2301      	movs	r3, #1
 80048dc:	e04f      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      }
      else
      {
        /* PLL configuration is unchanged */
        /* Re-enable PLL if it was disabled (ie. low power mode) */
        if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80048de:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80048e2:	681b      	ldr	r3, [r3, #0]
 80048e4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80048e8:	2b00      	cmp	r3, #0
 80048ea:	d147      	bne.n	800497c <HAL_RCC_OscConfig+0x6d8>
        {
          /* Enable the main PLL. */
          __HAL_RCC_PLL_ENABLE();
 80048ec:	f7ff fc1c 	bl	8004128 <LL_RCC_PLL_Enable>

          /* Enable PLL System Clock output. */
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 80048f0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80048f4:	68db      	ldr	r3, [r3, #12]
 80048f6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80048fa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80048fe:	60d3      	str	r3, [r2, #12]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8004900:	f7fd fc0c 	bl	800211c <HAL_GetTick>
 8004904:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till PLL is ready */
          while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8004906:	e008      	b.n	800491a <HAL_RCC_OscConfig+0x676>
          {
            if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004908:	f7fd fc08 	bl	800211c <HAL_GetTick>
 800490c:	4602      	mov	r2, r0
 800490e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004910:	1ad3      	subs	r3, r2, r3
 8004912:	2b02      	cmp	r3, #2
 8004914:	d901      	bls.n	800491a <HAL_RCC_OscConfig+0x676>
            {
              return HAL_TIMEOUT;
 8004916:	2303      	movs	r3, #3
 8004918:	e031      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
          while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800491a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800491e:	681b      	ldr	r3, [r3, #0]
 8004920:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004924:	2b00      	cmp	r3, #0
 8004926:	d0ef      	beq.n	8004908 <HAL_RCC_OscConfig+0x664>
 8004928:	e028      	b.n	800497c <HAL_RCC_OscConfig+0x6d8>
 800492a:	bf00      	nop
 800492c:	58000400 	.word	0x58000400
 8004930:	11c1808c 	.word	0x11c1808c
      }
    }
    else
    {
      /* Check that PLL is not used as system clock or not */
      if (temp_sysclksrc != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8004934:	693b      	ldr	r3, [r7, #16]
 8004936:	2b0c      	cmp	r3, #12
 8004938:	d01e      	beq.n	8004978 <HAL_RCC_OscConfig+0x6d4>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800493a:	f7ff fc04 	bl	8004146 <LL_RCC_PLL_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800493e:	f7fd fbed 	bl	800211c <HAL_GetTick>
 8004942:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8004944:	e008      	b.n	8004958 <HAL_RCC_OscConfig+0x6b4>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004946:	f7fd fbe9 	bl	800211c <HAL_GetTick>
 800494a:	4602      	mov	r2, r0
 800494c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800494e:	1ad3      	subs	r3, r2, r3
 8004950:	2b02      	cmp	r3, #2
 8004952:	d901      	bls.n	8004958 <HAL_RCC_OscConfig+0x6b4>
          {
            return HAL_TIMEOUT;
 8004954:	2303      	movs	r3, #3
 8004956:	e012      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8004958:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800495c:	681b      	ldr	r3, [r3, #0]
 800495e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004962:	2b00      	cmp	r3, #0
 8004964:	d1ef      	bne.n	8004946 <HAL_RCC_OscConfig+0x6a2>
          }
        }

        /* Disable the PLL source and outputs to save power when PLL is off */
#if defined(SAI1) && defined(USB)
        CLEAR_BIT(RCC->PLLCFGR, (RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLPEN | RCC_PLLCFGR_PLLQEN | RCC_PLLCFGR_PLLREN));
 8004966:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800496a:	68da      	ldr	r2, [r3, #12]
 800496c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004970:	4b05      	ldr	r3, [pc, #20]	; (8004988 <HAL_RCC_OscConfig+0x6e4>)
 8004972:	4013      	ands	r3, r2
 8004974:	60cb      	str	r3, [r1, #12]
 8004976:	e001      	b.n	800497c <HAL_RCC_OscConfig+0x6d8>
#endif /* SAI1 && USB */
      }
      else
      {
        /* PLL is already used as System core clock */
        return HAL_ERROR;
 8004978:	2301      	movs	r3, #1
 800497a:	e000      	b.n	800497e <HAL_RCC_OscConfig+0x6da>
      }
    }
  }
  return HAL_OK;
 800497c:	2300      	movs	r3, #0
}
 800497e:	4618      	mov	r0, r3
 8004980:	3734      	adds	r7, #52	; 0x34
 8004982:	46bd      	mov	sp, r7
 8004984:	bd90      	pop	{r4, r7, pc}
 8004986:	bf00      	nop
 8004988:	eefefffc 	.word	0xeefefffc

0800498c <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK1 not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800498c:	b580      	push	{r7, lr}
 800498e:	b084      	sub	sp, #16
 8004990:	af00      	add	r7, sp, #0
 8004992:	6078      	str	r0, [r7, #4]
 8004994:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 8004996:	687b      	ldr	r3, [r7, #4]
 8004998:	2b00      	cmp	r3, #0
 800499a:	d101      	bne.n	80049a0 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800499c:	2301      	movs	r3, #1
 800499e:	e12d      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the FLASH clock
    (HCLK4) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 80049a0:	4b98      	ldr	r3, [pc, #608]	; (8004c04 <HAL_RCC_ClockConfig+0x278>)
 80049a2:	681b      	ldr	r3, [r3, #0]
 80049a4:	f003 0307 	and.w	r3, r3, #7
 80049a8:	683a      	ldr	r2, [r7, #0]
 80049aa:	429a      	cmp	r2, r3
 80049ac:	d91b      	bls.n	80049e6 <HAL_RCC_ClockConfig+0x5a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80049ae:	4b95      	ldr	r3, [pc, #596]	; (8004c04 <HAL_RCC_ClockConfig+0x278>)
 80049b0:	681b      	ldr	r3, [r3, #0]
 80049b2:	f023 0207 	bic.w	r2, r3, #7
 80049b6:	4993      	ldr	r1, [pc, #588]	; (8004c04 <HAL_RCC_ClockConfig+0x278>)
 80049b8:	683b      	ldr	r3, [r7, #0]
 80049ba:	4313      	orrs	r3, r2
 80049bc:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80049be:	f7fd fbad 	bl	800211c <HAL_GetTick>
 80049c2:	60f8      	str	r0, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
       memory by reading the FLASH_ACR register */
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80049c4:	e008      	b.n	80049d8 <HAL_RCC_ClockConfig+0x4c>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 80049c6:	f7fd fba9 	bl	800211c <HAL_GetTick>
 80049ca:	4602      	mov	r2, r0
 80049cc:	68fb      	ldr	r3, [r7, #12]
 80049ce:	1ad3      	subs	r3, r2, r3
 80049d0:	2b02      	cmp	r3, #2
 80049d2:	d901      	bls.n	80049d8 <HAL_RCC_ClockConfig+0x4c>
      {
        return HAL_TIMEOUT;
 80049d4:	2303      	movs	r3, #3
 80049d6:	e111      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80049d8:	4b8a      	ldr	r3, [pc, #552]	; (8004c04 <HAL_RCC_ClockConfig+0x278>)
 80049da:	681b      	ldr	r3, [r3, #0]
 80049dc:	f003 0307 	and.w	r3, r3, #7
 80049e0:	683a      	ldr	r2, [r7, #0]
 80049e2:	429a      	cmp	r2, r3
 80049e4:	d1ef      	bne.n	80049c6 <HAL_RCC_ClockConfig+0x3a>
      }
    }
  }

  /*-------------------------- HCLK1 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80049e6:	687b      	ldr	r3, [r7, #4]
 80049e8:	681b      	ldr	r3, [r3, #0]
 80049ea:	f003 0302 	and.w	r3, r3, #2
 80049ee:	2b00      	cmp	r3, #0
 80049f0:	d016      	beq.n	8004a20 <HAL_RCC_ClockConfig+0x94>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLKDivider));
    LL_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLKDivider);
 80049f2:	687b      	ldr	r3, [r7, #4]
 80049f4:	689b      	ldr	r3, [r3, #8]
 80049f6:	4618      	mov	r0, r3
 80049f8:	f7ff faee 	bl	8003fd8 <LL_RCC_SetAHBPrescaler>

    /* HCLK1 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 80049fc:	f7fd fb8e 	bl	800211c <HAL_GetTick>
 8004a00:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_HPRE() == 0U)
 8004a02:	e008      	b.n	8004a16 <HAL_RCC_ClockConfig+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8004a04:	f7fd fb8a 	bl	800211c <HAL_GetTick>
 8004a08:	4602      	mov	r2, r0
 8004a0a:	68fb      	ldr	r3, [r7, #12]
 8004a0c:	1ad3      	subs	r3, r2, r3
 8004a0e:	2b02      	cmp	r3, #2
 8004a10:	d901      	bls.n	8004a16 <HAL_RCC_ClockConfig+0x8a>
      {
        return HAL_TIMEOUT;
 8004a12:	2303      	movs	r3, #3
 8004a14:	e0f2      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_HPRE() == 0U)
 8004a16:	f7ff fbe8 	bl	80041ea <LL_RCC_IsActiveFlag_HPRE>
 8004a1a:	4603      	mov	r3, r0
 8004a1c:	2b00      	cmp	r3, #0
 8004a1e:	d0f1      	beq.n	8004a04 <HAL_RCC_ClockConfig+0x78>
      }
    }
  }

  /*-------------------------- HCLK2 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 8004a20:	687b      	ldr	r3, [r7, #4]
 8004a22:	681b      	ldr	r3, [r3, #0]
 8004a24:	f003 0320 	and.w	r3, r3, #32
 8004a28:	2b00      	cmp	r3, #0
 8004a2a:	d016      	beq.n	8004a5a <HAL_RCC_ClockConfig+0xce>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLK2Divider));
    LL_C2_RCC_SetAHBPrescaler(RCC_ClkInitStruct->AHBCLK2Divider);
 8004a2c:	687b      	ldr	r3, [r7, #4]
 8004a2e:	695b      	ldr	r3, [r3, #20]
 8004a30:	4618      	mov	r0, r3
 8004a32:	f7ff fae5 	bl	8004000 <LL_C2_RCC_SetAHBPrescaler>

    /* HCLK2 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8004a36:	f7fd fb71 	bl	800211c <HAL_GetTick>
 8004a3a:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_C2HPRE() == 0U)
 8004a3c:	e008      	b.n	8004a50 <HAL_RCC_ClockConfig+0xc4>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8004a3e:	f7fd fb6d 	bl	800211c <HAL_GetTick>
 8004a42:	4602      	mov	r2, r0
 8004a44:	68fb      	ldr	r3, [r7, #12]
 8004a46:	1ad3      	subs	r3, r2, r3
 8004a48:	2b02      	cmp	r3, #2
 8004a4a:	d901      	bls.n	8004a50 <HAL_RCC_ClockConfig+0xc4>
      {
        return HAL_TIMEOUT;
 8004a4c:	2303      	movs	r3, #3
 8004a4e:	e0d5      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_C2HPRE() == 0U)
 8004a50:	f7ff fbdd 	bl	800420e <LL_RCC_IsActiveFlag_C2HPRE>
 8004a54:	4603      	mov	r3, r0
 8004a56:	2b00      	cmp	r3, #0
 8004a58:	d0f1      	beq.n	8004a3e <HAL_RCC_ClockConfig+0xb2>
      }
    }
  }
  /*-------------------------- HCLK4 Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK4) == RCC_CLOCKTYPE_HCLK4)
 8004a5a:	687b      	ldr	r3, [r7, #4]
 8004a5c:	681b      	ldr	r3, [r3, #0]
 8004a5e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8004a62:	2b00      	cmp	r3, #0
 8004a64:	d016      	beq.n	8004a94 <HAL_RCC_ClockConfig+0x108>
  {
    assert_param(IS_RCC_HCLKx(RCC_ClkInitStruct->AHBCLK4Divider));
    LL_RCC_SetAHB4Prescaler(RCC_ClkInitStruct->AHBCLK4Divider);
 8004a66:	687b      	ldr	r3, [r7, #4]
 8004a68:	699b      	ldr	r3, [r3, #24]
 8004a6a:	4618      	mov	r0, r3
 8004a6c:	f7ff fade 	bl	800402c <LL_RCC_SetAHB4Prescaler>

    /* AHB shared prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8004a70:	f7fd fb54 	bl	800211c <HAL_GetTick>
 8004a74:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_SHDHPRE() == 0U)
 8004a76:	e008      	b.n	8004a8a <HAL_RCC_ClockConfig+0xfe>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8004a78:	f7fd fb50 	bl	800211c <HAL_GetTick>
 8004a7c:	4602      	mov	r2, r0
 8004a7e:	68fb      	ldr	r3, [r7, #12]
 8004a80:	1ad3      	subs	r3, r2, r3
 8004a82:	2b02      	cmp	r3, #2
 8004a84:	d901      	bls.n	8004a8a <HAL_RCC_ClockConfig+0xfe>
      {
        return HAL_TIMEOUT;
 8004a86:	2303      	movs	r3, #3
 8004a88:	e0b8      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_SHDHPRE() == 0U)
 8004a8a:	f7ff fbd3 	bl	8004234 <LL_RCC_IsActiveFlag_SHDHPRE>
 8004a8e:	4603      	mov	r3, r0
 8004a90:	2b00      	cmp	r3, #0
 8004a92:	d0f1      	beq.n	8004a78 <HAL_RCC_ClockConfig+0xec>
      }
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004a94:	687b      	ldr	r3, [r7, #4]
 8004a96:	681b      	ldr	r3, [r3, #0]
 8004a98:	f003 0304 	and.w	r3, r3, #4
 8004a9c:	2b00      	cmp	r3, #0
 8004a9e:	d016      	beq.n	8004ace <HAL_RCC_ClockConfig+0x142>
  {
    assert_param(IS_RCC_PCLKx(RCC_ClkInitStruct->APB1CLKDivider));
    LL_RCC_SetAPB1Prescaler(RCC_ClkInitStruct->APB1CLKDivider);
 8004aa0:	687b      	ldr	r3, [r7, #4]
 8004aa2:	68db      	ldr	r3, [r3, #12]
 8004aa4:	4618      	mov	r0, r3
 8004aa6:	f7ff fad8 	bl	800405a <LL_RCC_SetAPB1Prescaler>

    /* APB1 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8004aaa:	f7fd fb37 	bl	800211c <HAL_GetTick>
 8004aae:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_PPRE1() == 0U)
 8004ab0:	e008      	b.n	8004ac4 <HAL_RCC_ClockConfig+0x138>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8004ab2:	f7fd fb33 	bl	800211c <HAL_GetTick>
 8004ab6:	4602      	mov	r2, r0
 8004ab8:	68fb      	ldr	r3, [r7, #12]
 8004aba:	1ad3      	subs	r3, r2, r3
 8004abc:	2b02      	cmp	r3, #2
 8004abe:	d901      	bls.n	8004ac4 <HAL_RCC_ClockConfig+0x138>
      {
        return HAL_TIMEOUT;
 8004ac0:	2303      	movs	r3, #3
 8004ac2:	e09b      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_PPRE1() == 0U)
 8004ac4:	f7ff fbc9 	bl	800425a <LL_RCC_IsActiveFlag_PPRE1>
 8004ac8:	4603      	mov	r3, r0
 8004aca:	2b00      	cmp	r3, #0
 8004acc:	d0f1      	beq.n	8004ab2 <HAL_RCC_ClockConfig+0x126>
      }
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004ace:	687b      	ldr	r3, [r7, #4]
 8004ad0:	681b      	ldr	r3, [r3, #0]
 8004ad2:	f003 0308 	and.w	r3, r3, #8
 8004ad6:	2b00      	cmp	r3, #0
 8004ad8:	d017      	beq.n	8004b0a <HAL_RCC_ClockConfig+0x17e>
  {
    assert_param(IS_RCC_PCLKx(RCC_ClkInitStruct->APB2CLKDivider));
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 8004ada:	687b      	ldr	r3, [r7, #4]
 8004adc:	691b      	ldr	r3, [r3, #16]
 8004ade:	00db      	lsls	r3, r3, #3
 8004ae0:	4618      	mov	r0, r3
 8004ae2:	f7ff face 	bl	8004082 <LL_RCC_SetAPB2Prescaler>

    /* APB2 prescaler flag when value applied */
    tickstart = HAL_GetTick();
 8004ae6:	f7fd fb19 	bl	800211c <HAL_GetTick>
 8004aea:	60f8      	str	r0, [r7, #12]
    while (LL_RCC_IsActiveFlag_PPRE2() == 0U)
 8004aec:	e008      	b.n	8004b00 <HAL_RCC_ClockConfig+0x174>
    {
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8004aee:	f7fd fb15 	bl	800211c <HAL_GetTick>
 8004af2:	4602      	mov	r2, r0
 8004af4:	68fb      	ldr	r3, [r7, #12]
 8004af6:	1ad3      	subs	r3, r2, r3
 8004af8:	2b02      	cmp	r3, #2
 8004afa:	d901      	bls.n	8004b00 <HAL_RCC_ClockConfig+0x174>
      {
        return HAL_TIMEOUT;
 8004afc:	2303      	movs	r3, #3
 8004afe:	e07d      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
    while (LL_RCC_IsActiveFlag_PPRE2() == 0U)
 8004b00:	f7ff fbbd 	bl	800427e <LL_RCC_IsActiveFlag_PPRE2>
 8004b04:	4603      	mov	r3, r0
 8004b06:	2b00      	cmp	r3, #0
 8004b08:	d0f1      	beq.n	8004aee <HAL_RCC_ClockConfig+0x162>
      }
    }
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8004b0a:	687b      	ldr	r3, [r7, #4]
 8004b0c:	681b      	ldr	r3, [r3, #0]
 8004b0e:	f003 0301 	and.w	r3, r3, #1
 8004b12:	2b00      	cmp	r3, #0
 8004b14:	d043      	beq.n	8004b9e <HAL_RCC_ClockConfig+0x212>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8004b16:	687b      	ldr	r3, [r7, #4]
 8004b18:	685b      	ldr	r3, [r3, #4]
 8004b1a:	2b02      	cmp	r3, #2
 8004b1c:	d106      	bne.n	8004b2c <HAL_RCC_ClockConfig+0x1a0>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
 8004b1e:	f7ff f86e 	bl	8003bfe <LL_RCC_HSE_IsReady>
 8004b22:	4603      	mov	r3, r0
 8004b24:	2b00      	cmp	r3, #0
 8004b26:	d11e      	bne.n	8004b66 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8004b28:	2301      	movs	r3, #1
 8004b2a:	e067      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8004b2c:	687b      	ldr	r3, [r7, #4]
 8004b2e:	685b      	ldr	r3, [r3, #4]
 8004b30:	2b03      	cmp	r3, #3
 8004b32:	d106      	bne.n	8004b42 <HAL_RCC_ClockConfig+0x1b6>
    {
      /* Check the PLL ready flag */
      if (LL_RCC_PLL_IsReady() == 0U)
 8004b34:	f7ff fb16 	bl	8004164 <LL_RCC_PLL_IsReady>
 8004b38:	4603      	mov	r3, r0
 8004b3a:	2b00      	cmp	r3, #0
 8004b3c:	d113      	bne.n	8004b66 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8004b3e:	2301      	movs	r3, #1
 8004b40:	e05c      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
      }
    }
    /* MSI is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8004b42:	687b      	ldr	r3, [r7, #4]
 8004b44:	685b      	ldr	r3, [r3, #4]
 8004b46:	2b00      	cmp	r3, #0
 8004b48:	d106      	bne.n	8004b58 <HAL_RCC_ClockConfig+0x1cc>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
 8004b4a:	f7ff f9d6 	bl	8003efa <LL_RCC_MSI_IsReady>
 8004b4e:	4603      	mov	r3, r0
 8004b50:	2b00      	cmp	r3, #0
 8004b52:	d108      	bne.n	8004b66 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8004b54:	2301      	movs	r3, #1
 8004b56:	e051      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
 8004b58:	f7ff f881 	bl	8003c5e <LL_RCC_HSI_IsReady>
 8004b5c:	4603      	mov	r3, r0
 8004b5e:	2b00      	cmp	r3, #0
 8004b60:	d101      	bne.n	8004b66 <HAL_RCC_ClockConfig+0x1da>
      {
        return HAL_ERROR;
 8004b62:	2301      	movs	r3, #1
 8004b64:	e04a      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
      }

    }

    /* apply system clock switch */
    LL_RCC_SetSysClkSource(RCC_ClkInitStruct->SYSCLKSource);
 8004b66:	687b      	ldr	r3, [r7, #4]
 8004b68:	685b      	ldr	r3, [r3, #4]
 8004b6a:	4618      	mov	r0, r3
 8004b6c:	f7ff fa14 	bl	8003f98 <LL_RCC_SetSysClkSource>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004b70:	f7fd fad4 	bl	800211c <HAL_GetTick>
 8004b74:	60f8      	str	r0, [r7, #12]

    /* check system clock source switch status */
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004b76:	e00a      	b.n	8004b8e <HAL_RCC_ClockConfig+0x202>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004b78:	f7fd fad0 	bl	800211c <HAL_GetTick>
 8004b7c:	4602      	mov	r2, r0
 8004b7e:	68fb      	ldr	r3, [r7, #12]
 8004b80:	1ad3      	subs	r3, r2, r3
 8004b82:	f241 3288 	movw	r2, #5000	; 0x1388
 8004b86:	4293      	cmp	r3, r2
 8004b88:	d901      	bls.n	8004b8e <HAL_RCC_ClockConfig+0x202>
      {
        return HAL_TIMEOUT;
 8004b8a:	2303      	movs	r3, #3
 8004b8c:	e036      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004b8e:	f7ff fa17 	bl	8003fc0 <LL_RCC_GetSysClkSource>
 8004b92:	4602      	mov	r2, r0
 8004b94:	687b      	ldr	r3, [r7, #4]
 8004b96:	685b      	ldr	r3, [r3, #4]
 8004b98:	009b      	lsls	r3, r3, #2
 8004b9a:	429a      	cmp	r2, r3
 8004b9c:	d1ec      	bne.n	8004b78 <HAL_RCC_ClockConfig+0x1ec>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8004b9e:	4b19      	ldr	r3, [pc, #100]	; (8004c04 <HAL_RCC_ClockConfig+0x278>)
 8004ba0:	681b      	ldr	r3, [r3, #0]
 8004ba2:	f003 0307 	and.w	r3, r3, #7
 8004ba6:	683a      	ldr	r2, [r7, #0]
 8004ba8:	429a      	cmp	r2, r3
 8004baa:	d21b      	bcs.n	8004be4 <HAL_RCC_ClockConfig+0x258>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004bac:	4b15      	ldr	r3, [pc, #84]	; (8004c04 <HAL_RCC_ClockConfig+0x278>)
 8004bae:	681b      	ldr	r3, [r3, #0]
 8004bb0:	f023 0207 	bic.w	r2, r3, #7
 8004bb4:	4913      	ldr	r1, [pc, #76]	; (8004c04 <HAL_RCC_ClockConfig+0x278>)
 8004bb6:	683b      	ldr	r3, [r7, #0]
 8004bb8:	4313      	orrs	r3, r2
 8004bba:	600b      	str	r3, [r1, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004bbc:	f7fd faae 	bl	800211c <HAL_GetTick>
 8004bc0:	60f8      	str	r0, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004bc2:	e008      	b.n	8004bd6 <HAL_RCC_ClockConfig+0x24a>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8004bc4:	f7fd faaa 	bl	800211c <HAL_GetTick>
 8004bc8:	4602      	mov	r2, r0
 8004bca:	68fb      	ldr	r3, [r7, #12]
 8004bcc:	1ad3      	subs	r3, r2, r3
 8004bce:	2b02      	cmp	r3, #2
 8004bd0:	d901      	bls.n	8004bd6 <HAL_RCC_ClockConfig+0x24a>
      {
        return HAL_TIMEOUT;
 8004bd2:	2303      	movs	r3, #3
 8004bd4:	e012      	b.n	8004bfc <HAL_RCC_ClockConfig+0x270>
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004bd6:	4b0b      	ldr	r3, [pc, #44]	; (8004c04 <HAL_RCC_ClockConfig+0x278>)
 8004bd8:	681b      	ldr	r3, [r3, #0]
 8004bda:	f003 0307 	and.w	r3, r3, #7
 8004bde:	683a      	ldr	r2, [r7, #0]
 8004be0:	429a      	cmp	r2, r3
 8004be2:	d1ef      	bne.n	8004bc4 <HAL_RCC_ClockConfig+0x238>
  }

  /*---------------------------------------------------------------------------*/

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 8004be4:	f000 f87e 	bl	8004ce4 <HAL_RCC_GetHCLKFreq>
 8004be8:	4603      	mov	r3, r0
 8004bea:	4a07      	ldr	r2, [pc, #28]	; (8004c08 <HAL_RCC_ClockConfig+0x27c>)
 8004bec:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(HAL_GetTickPrio());
 8004bee:	f7fd faa1 	bl	8002134 <HAL_GetTickPrio>
 8004bf2:	4603      	mov	r3, r0
 8004bf4:	4618      	mov	r0, r3
 8004bf6:	f7fc fd7d 	bl	80016f4 <HAL_InitTick>
 8004bfa:	4603      	mov	r3, r0
}
 8004bfc:	4618      	mov	r0, r3
 8004bfe:	3710      	adds	r7, #16
 8004c00:	46bd      	mov	sp, r7
 8004c02:	bd80      	pop	{r7, pc}
 8004c04:	58004000 	.word	0x58004000
 8004c08:	20000018 	.word	0x20000018

08004c0c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8004c0c:	b590      	push	{r4, r7, lr}
 8004c0e:	b085      	sub	sp, #20
 8004c10:	af00      	add	r7, sp, #0
  uint32_t pllsource;
  uint32_t sysclockfreq;
  uint32_t pllinputfreq;
  const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8004c12:	f7ff f9d5 	bl	8003fc0 <LL_RCC_GetSysClkSource>
 8004c16:	6078      	str	r0, [r7, #4]

  if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI)
 8004c18:	687b      	ldr	r3, [r7, #4]
 8004c1a:	2b00      	cmp	r3, #0
 8004c1c:	d10a      	bne.n	8004c34 <HAL_RCC_GetSysClockFreq+0x28>
  {
    /* Retrieve MSI frequency range in HZ*/
    /* MSI used as system clock source */
    sysclockfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8004c1e:	f7ff f991 	bl	8003f44 <LL_RCC_MSI_GetRange>
 8004c22:	4603      	mov	r3, r0
 8004c24:	091b      	lsrs	r3, r3, #4
 8004c26:	f003 030f 	and.w	r3, r3, #15
 8004c2a:	4a2b      	ldr	r2, [pc, #172]	; (8004cd8 <HAL_RCC_GetSysClockFreq+0xcc>)
 8004c2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004c30:	60fb      	str	r3, [r7, #12]
 8004c32:	e04b      	b.n	8004ccc <HAL_RCC_GetSysClockFreq+0xc0>
  }
  else if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI)
 8004c34:	687b      	ldr	r3, [r7, #4]
 8004c36:	2b04      	cmp	r3, #4
 8004c38:	d102      	bne.n	8004c40 <HAL_RCC_GetSysClockFreq+0x34>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8004c3a:	4b28      	ldr	r3, [pc, #160]	; (8004cdc <HAL_RCC_GetSysClockFreq+0xd0>)
 8004c3c:	60fb      	str	r3, [r7, #12]
 8004c3e:	e045      	b.n	8004ccc <HAL_RCC_GetSysClockFreq+0xc0>
  }
  else if (temp_sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE)
 8004c40:	687b      	ldr	r3, [r7, #4]
 8004c42:	2b08      	cmp	r3, #8
 8004c44:	d10a      	bne.n	8004c5c <HAL_RCC_GetSysClockFreq+0x50>
  {
    /* HSE used as system clock source */
    if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8004c46:	f7fe ffaa 	bl	8003b9e <LL_RCC_HSE_IsEnabledDiv2>
 8004c4a:	4603      	mov	r3, r0
 8004c4c:	2b01      	cmp	r3, #1
 8004c4e:	d102      	bne.n	8004c56 <HAL_RCC_GetSysClockFreq+0x4a>
    {
      sysclockfreq = HSE_VALUE / 2U;
 8004c50:	4b22      	ldr	r3, [pc, #136]	; (8004cdc <HAL_RCC_GetSysClockFreq+0xd0>)
 8004c52:	60fb      	str	r3, [r7, #12]
 8004c54:	e03a      	b.n	8004ccc <HAL_RCC_GetSysClockFreq+0xc0>
    }
    else
    {
      sysclockfreq = HSE_VALUE;
 8004c56:	4b22      	ldr	r3, [pc, #136]	; (8004ce0 <HAL_RCC_GetSysClockFreq+0xd4>)
 8004c58:	60fb      	str	r3, [r7, #12]
 8004c5a:	e037      	b.n	8004ccc <HAL_RCC_GetSysClockFreq+0xc0>
    }
  }
  else
  {
    /* PLL used as system clock  source */
    pllsource = LL_RCC_PLL_GetMainSource();
 8004c5c:	f7ff fab9 	bl	80041d2 <LL_RCC_PLL_GetMainSource>
 8004c60:	6038      	str	r0, [r7, #0]
    switch (pllsource)
 8004c62:	683b      	ldr	r3, [r7, #0]
 8004c64:	2b02      	cmp	r3, #2
 8004c66:	d003      	beq.n	8004c70 <HAL_RCC_GetSysClockFreq+0x64>
 8004c68:	683b      	ldr	r3, [r7, #0]
 8004c6a:	2b03      	cmp	r3, #3
 8004c6c:	d003      	beq.n	8004c76 <HAL_RCC_GetSysClockFreq+0x6a>
 8004c6e:	e00d      	b.n	8004c8c <HAL_RCC_GetSysClockFreq+0x80>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllinputfreq = HSI_VALUE;
 8004c70:	4b1a      	ldr	r3, [pc, #104]	; (8004cdc <HAL_RCC_GetSysClockFreq+0xd0>)
 8004c72:	60bb      	str	r3, [r7, #8]
        break;
 8004c74:	e015      	b.n	8004ca2 <HAL_RCC_GetSysClockFreq+0x96>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8004c76:	f7fe ff92 	bl	8003b9e <LL_RCC_HSE_IsEnabledDiv2>
 8004c7a:	4603      	mov	r3, r0
 8004c7c:	2b01      	cmp	r3, #1
 8004c7e:	d102      	bne.n	8004c86 <HAL_RCC_GetSysClockFreq+0x7a>
        {
          pllinputfreq = HSE_VALUE / 2U;
 8004c80:	4b16      	ldr	r3, [pc, #88]	; (8004cdc <HAL_RCC_GetSysClockFreq+0xd0>)
 8004c82:	60bb      	str	r3, [r7, #8]
        }
        else
        {
          pllinputfreq = HSE_VALUE;
        }
        break;
 8004c84:	e00d      	b.n	8004ca2 <HAL_RCC_GetSysClockFreq+0x96>
          pllinputfreq = HSE_VALUE;
 8004c86:	4b16      	ldr	r3, [pc, #88]	; (8004ce0 <HAL_RCC_GetSysClockFreq+0xd4>)
 8004c88:	60bb      	str	r3, [r7, #8]
        break;
 8004c8a:	e00a      	b.n	8004ca2 <HAL_RCC_GetSysClockFreq+0x96>
      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_GetRange());
 8004c8c:	f7ff f95a 	bl	8003f44 <LL_RCC_MSI_GetRange>
 8004c90:	4603      	mov	r3, r0
 8004c92:	091b      	lsrs	r3, r3, #4
 8004c94:	f003 030f 	and.w	r3, r3, #15
 8004c98:	4a0f      	ldr	r2, [pc, #60]	; (8004cd8 <HAL_RCC_GetSysClockFreq+0xcc>)
 8004c9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004c9e:	60bb      	str	r3, [r7, #8]
        break;
 8004ca0:	bf00      	nop
    }
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(), LL_RCC_PLL_GetN(),
 8004ca2:	f7ff fa71 	bl	8004188 <LL_RCC_PLL_GetN>
 8004ca6:	4602      	mov	r2, r0
 8004ca8:	68bb      	ldr	r3, [r7, #8]
 8004caa:	fb03 f402 	mul.w	r4, r3, r2
 8004cae:	f7ff fa84 	bl	80041ba <LL_RCC_PLL_GetDivider>
 8004cb2:	4603      	mov	r3, r0
 8004cb4:	091b      	lsrs	r3, r3, #4
 8004cb6:	3301      	adds	r3, #1
 8004cb8:	fbb4 f4f3 	udiv	r4, r4, r3
 8004cbc:	f7ff fa71 	bl	80041a2 <LL_RCC_PLL_GetR>
 8004cc0:	4603      	mov	r3, r0
 8004cc2:	0f5b      	lsrs	r3, r3, #29
 8004cc4:	3301      	adds	r3, #1
 8004cc6:	fbb4 f3f3 	udiv	r3, r4, r3
 8004cca:	60fb      	str	r3, [r7, #12]
                                             LL_RCC_PLL_GetR());
  }

  return sysclockfreq;
 8004ccc:	68fb      	ldr	r3, [r7, #12]
}
 8004cce:	4618      	mov	r0, r3
 8004cd0:	3714      	adds	r7, #20
 8004cd2:	46bd      	mov	sp, r7
 8004cd4:	bd90      	pop	{r4, r7, pc}
 8004cd6:	bf00      	nop
 8004cd8:	08013544 	.word	0x08013544
 8004cdc:	00f42400 	.word	0x00f42400
 8004ce0:	01e84800 	.word	0x01e84800

08004ce4 <HAL_RCC_GetHCLKFreq>:
/**
  * @brief  Return the HCLK frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8004ce4:	b598      	push	{r3, r4, r7, lr}
 8004ce6:	af00      	add	r7, sp, #0
  /* Get SysClock and Compute HCLK1 frequency ---------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 8004ce8:	f7ff ff90 	bl	8004c0c <HAL_RCC_GetSysClockFreq>
 8004cec:	4604      	mov	r4, r0
 8004cee:	f7ff f9dc 	bl	80040aa <LL_RCC_GetAHBPrescaler>
 8004cf2:	4603      	mov	r3, r0
 8004cf4:	091b      	lsrs	r3, r3, #4
 8004cf6:	f003 030f 	and.w	r3, r3, #15
 8004cfa:	4a03      	ldr	r2, [pc, #12]	; (8004d08 <HAL_RCC_GetHCLKFreq+0x24>)
 8004cfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004d00:	fbb4 f3f3 	udiv	r3, r4, r3
}
 8004d04:	4618      	mov	r0, r3
 8004d06:	bd98      	pop	{r3, r4, r7, pc}
 8004d08:	080134e4 	.word	0x080134e4

08004d0c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8004d0c:	b598      	push	{r3, r4, r7, lr}
 8004d0e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 8004d10:	f7ff ffe8 	bl	8004ce4 <HAL_RCC_GetHCLKFreq>
 8004d14:	4604      	mov	r4, r0
 8004d16:	f7ff f9ef 	bl	80040f8 <LL_RCC_GetAPB1Prescaler>
 8004d1a:	4603      	mov	r3, r0
 8004d1c:	0a1b      	lsrs	r3, r3, #8
 8004d1e:	f003 0307 	and.w	r3, r3, #7
 8004d22:	4a04      	ldr	r2, [pc, #16]	; (8004d34 <HAL_RCC_GetPCLK1Freq+0x28>)
 8004d24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004d28:	f003 031f 	and.w	r3, r3, #31
 8004d2c:	fa24 f303 	lsr.w	r3, r4, r3
}
 8004d30:	4618      	mov	r0, r3
 8004d32:	bd98      	pop	{r3, r4, r7, pc}
 8004d34:	08013524 	.word	0x08013524

08004d38 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8004d38:	b598      	push	{r3, r4, r7, lr}
 8004d3a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 8004d3c:	f7ff ffd2 	bl	8004ce4 <HAL_RCC_GetHCLKFreq>
 8004d40:	4604      	mov	r4, r0
 8004d42:	f7ff f9e5 	bl	8004110 <LL_RCC_GetAPB2Prescaler>
 8004d46:	4603      	mov	r3, r0
 8004d48:	0adb      	lsrs	r3, r3, #11
 8004d4a:	f003 0307 	and.w	r3, r3, #7
 8004d4e:	4a04      	ldr	r2, [pc, #16]	; (8004d60 <HAL_RCC_GetPCLK2Freq+0x28>)
 8004d50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004d54:	f003 031f 	and.w	r3, r3, #31
 8004d58:	fa24 f303 	lsr.w	r3, r4, r3
}
 8004d5c:	4618      	mov	r0, r3
 8004d5e:	bd98      	pop	{r3, r4, r7, pc}
 8004d60:	08013524 	.word	0x08013524

08004d64 <HAL_RCC_GetClockConfig>:
  *                           will be configured.
  * @param  pFLatency         Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8004d64:	b580      	push	{r7, lr}
 8004d66:	b082      	sub	sp, #8
 8004d68:	af00      	add	r7, sp, #0
 8004d6a:	6078      	str	r0, [r7, #4]
 8004d6c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != (void *)NULL);
  assert_param(pFLatency != (void *)NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 |
 8004d6e:	687b      	ldr	r3, [r7, #4]
 8004d70:	226f      	movs	r2, #111	; 0x6f
 8004d72:	601a      	str	r2, [r3, #0]
                                  RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_HCLK2 | RCC_CLOCKTYPE_HCLK4);

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = LL_RCC_GetSysClkSource();
 8004d74:	f7ff f924 	bl	8003fc0 <LL_RCC_GetSysClkSource>
 8004d78:	4602      	mov	r2, r0
 8004d7a:	687b      	ldr	r3, [r7, #4]
 8004d7c:	605a      	str	r2, [r3, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = LL_RCC_GetAHBPrescaler();
 8004d7e:	f7ff f994 	bl	80040aa <LL_RCC_GetAHBPrescaler>
 8004d82:	4602      	mov	r2, r0
 8004d84:	687b      	ldr	r3, [r7, #4]
 8004d86:	609a      	str	r2, [r3, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = LL_RCC_GetAPB1Prescaler();
 8004d88:	f7ff f9b6 	bl	80040f8 <LL_RCC_GetAPB1Prescaler>
 8004d8c:	4602      	mov	r2, r0
 8004d8e:	687b      	ldr	r3, [r7, #4]
 8004d90:	60da      	str	r2, [r3, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = LL_RCC_GetAPB2Prescaler();
 8004d92:	f7ff f9bd 	bl	8004110 <LL_RCC_GetAPB2Prescaler>
 8004d96:	4602      	mov	r2, r0
 8004d98:	687b      	ldr	r3, [r7, #4]
 8004d9a:	611a      	str	r2, [r3, #16]

  /* Get the AHBCLK2Divider configuration ------------------------------------*/
  RCC_ClkInitStruct->AHBCLK2Divider = LL_C2_RCC_GetAHBPrescaler();
 8004d9c:	f7ff f991 	bl	80040c2 <LL_C2_RCC_GetAHBPrescaler>
 8004da0:	4602      	mov	r2, r0
 8004da2:	687b      	ldr	r3, [r7, #4]
 8004da4:	615a      	str	r2, [r3, #20]

  /* Get the AHBCLK4Divider configuration ------------------------------------*/
  RCC_ClkInitStruct->AHBCLK4Divider = LL_RCC_GetAHB4Prescaler();
 8004da6:	f7ff f999 	bl	80040dc <LL_RCC_GetAHB4Prescaler>
 8004daa:	4602      	mov	r2, r0
 8004dac:	687b      	ldr	r3, [r7, #4]
 8004dae:	619a      	str	r2, [r3, #24]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8004db0:	4b04      	ldr	r3, [pc, #16]	; (8004dc4 <HAL_RCC_GetClockConfig+0x60>)
 8004db2:	681b      	ldr	r3, [r3, #0]
 8004db4:	f003 0207 	and.w	r2, r3, #7
 8004db8:	683b      	ldr	r3, [r7, #0]
 8004dba:	601a      	str	r2, [r3, #0]
}
 8004dbc:	bf00      	nop
 8004dbe:	3708      	adds	r7, #8
 8004dc0:	46bd      	mov	sp, r7
 8004dc2:	bd80      	pop	{r7, pc}
 8004dc4:	58004000 	.word	0x58004000

08004dc8 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 8004dc8:	b590      	push	{r4, r7, lr}
 8004dca:	b085      	sub	sp, #20
 8004dcc:	af00      	add	r7, sp, #0
 8004dce:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_RCC_MSI_CLOCK_RANGE(MSI_Range));

  /* MSI frequency range in Hz */
  if (MSI_Range > RCC_MSIRANGE_11)
 8004dd0:	687b      	ldr	r3, [r7, #4]
 8004dd2:	2bb0      	cmp	r3, #176	; 0xb0
 8004dd4:	d903      	bls.n	8004dde <RCC_SetFlashLatencyFromMSIRange+0x16>
  {
    msifreq = __LL_RCC_CALC_MSI_FREQ(RCC_MSIRANGE_11);
 8004dd6:	4b15      	ldr	r3, [pc, #84]	; (8004e2c <RCC_SetFlashLatencyFromMSIRange+0x64>)
 8004dd8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004dda:	60fb      	str	r3, [r7, #12]
 8004ddc:	e007      	b.n	8004dee <RCC_SetFlashLatencyFromMSIRange+0x26>
  }
  else
  {
    msifreq = __LL_RCC_CALC_MSI_FREQ(MSI_Range);
 8004dde:	687b      	ldr	r3, [r7, #4]
 8004de0:	091b      	lsrs	r3, r3, #4
 8004de2:	f003 030f 	and.w	r3, r3, #15
 8004de6:	4a11      	ldr	r2, [pc, #68]	; (8004e2c <RCC_SetFlashLatencyFromMSIRange+0x64>)
 8004de8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004dec:	60fb      	str	r3, [r7, #12]
  }

  flash_clksrcfreq = __LL_RCC_CALC_HCLK4_FREQ(msifreq, LL_RCC_GetAHB4Prescaler());
 8004dee:	f7ff f975 	bl	80040dc <LL_RCC_GetAHB4Prescaler>
 8004df2:	4603      	mov	r3, r0
 8004df4:	091b      	lsrs	r3, r3, #4
 8004df6:	f003 030f 	and.w	r3, r3, #15
 8004dfa:	4a0d      	ldr	r2, [pc, #52]	; (8004e30 <RCC_SetFlashLatencyFromMSIRange+0x68>)
 8004dfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8004e00:	68fa      	ldr	r2, [r7, #12]
 8004e02:	fbb2 f3f3 	udiv	r3, r2, r3
 8004e06:	60bb      	str	r3, [r7, #8]

#if defined(PWR_CR1_VOS)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 8004e08:	68bb      	ldr	r3, [r7, #8]
 8004e0a:	4a0a      	ldr	r2, [pc, #40]	; (8004e34 <RCC_SetFlashLatencyFromMSIRange+0x6c>)
 8004e0c:	fba2 2303 	umull	r2, r3, r2, r3
 8004e10:	0c9c      	lsrs	r4, r3, #18
 8004e12:	f7fe fdfb 	bl	8003a0c <HAL_PWREx_GetVoltageRange>
 8004e16:	4603      	mov	r3, r0
 8004e18:	4619      	mov	r1, r3
 8004e1a:	4620      	mov	r0, r4
 8004e1c:	f000 f80c 	bl	8004e38 <RCC_SetFlashLatency>
 8004e20:	4603      	mov	r3, r0
#else
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), PWR_REGULATOR_VOLTAGE_SCALE1);
#endif /* PWR_CR1_VOS */
}
 8004e22:	4618      	mov	r0, r3
 8004e24:	3714      	adds	r7, #20
 8004e26:	46bd      	mov	sp, r7
 8004e28:	bd90      	pop	{r4, r7, pc}
 8004e2a:	bf00      	nop
 8004e2c:	08013544 	.word	0x08013544
 8004e30:	080134e4 	.word	0x080134e4
 8004e34:	431bde83 	.word	0x431bde83

08004e38 <RCC_SetFlashLatency>:
  * @param  Flash_ClkSrcFreq  Flash Clock Source (in MHz)
  * @param  VCORE_Voltage     Current Vcore voltage (PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2)
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatency(uint32_t Flash_ClkSrcFreq, uint32_t VCORE_Voltage)
{
 8004e38:	b590      	push	{r4, r7, lr}
 8004e3a:	b093      	sub	sp, #76	; 0x4c
 8004e3c:	af00      	add	r7, sp, #0
 8004e3e:	6078      	str	r0, [r7, #4]
 8004e40:	6039      	str	r1, [r7, #0]
  /* Flash Clock source (HCLK4) range in MHz with a VCORE is range1 */
  const uint32_t FLASH_CLK_SRC_RANGE_VOS1[] = {18UL, 36UL, 54UL, 64UL};
 8004e42:	4b37      	ldr	r3, [pc, #220]	; (8004f20 <RCC_SetFlashLatency+0xe8>)
 8004e44:	f107 0428 	add.w	r4, r7, #40	; 0x28
 8004e48:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8004e4a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
#if defined(PWR_CR1_VOS)
  /* Flash Clock source (HCLK4) range in MHz with a VCORE is range2 */
  const uint32_t FLASH_CLK_SRC_RANGE_VOS2[] = {6UL, 12UL, 16UL};
 8004e4e:	4a35      	ldr	r2, [pc, #212]	; (8004f24 <RCC_SetFlashLatency+0xec>)
 8004e50:	f107 031c 	add.w	r3, r7, #28
 8004e54:	ca07      	ldmia	r2, {r0, r1, r2}
 8004e56:	e883 0007 	stmia.w	r3, {r0, r1, r2}
#endif /* PWR_CR1_VOS */
  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2, FLASH_LATENCY_3};
 8004e5a:	4b33      	ldr	r3, [pc, #204]	; (8004f28 <RCC_SetFlashLatency+0xf0>)
 8004e5c:	f107 040c 	add.w	r4, r7, #12
 8004e60:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8004e62:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 8004e66:	2300      	movs	r3, #0
 8004e68:	647b      	str	r3, [r7, #68]	; 0x44
  uint32_t tickstart;

#if defined(PWR_CR1_VOS)
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 8004e6a:	683b      	ldr	r3, [r7, #0]
 8004e6c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8004e70:	d11a      	bne.n	8004ea8 <RCC_SetFlashLatency+0x70>
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 8004e72:	2300      	movs	r3, #0
 8004e74:	643b      	str	r3, [r7, #64]	; 0x40
 8004e76:	e013      	b.n	8004ea0 <RCC_SetFlashLatency+0x68>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 8004e78:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004e7a:	009b      	lsls	r3, r3, #2
 8004e7c:	3348      	adds	r3, #72	; 0x48
 8004e7e:	443b      	add	r3, r7
 8004e80:	f853 3c20 	ldr.w	r3, [r3, #-32]
 8004e84:	687a      	ldr	r2, [r7, #4]
 8004e86:	429a      	cmp	r2, r3
 8004e88:	d807      	bhi.n	8004e9a <RCC_SetFlashLatency+0x62>
      {
        latency = FLASH_LATENCY_RANGE[index];
 8004e8a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004e8c:	009b      	lsls	r3, r3, #2
 8004e8e:	3348      	adds	r3, #72	; 0x48
 8004e90:	443b      	add	r3, r7
 8004e92:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 8004e96:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 8004e98:	e020      	b.n	8004edc <RCC_SetFlashLatency+0xa4>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS1); index++)
 8004e9a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004e9c:	3301      	adds	r3, #1
 8004e9e:	643b      	str	r3, [r7, #64]	; 0x40
 8004ea0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8004ea2:	2b03      	cmp	r3, #3
 8004ea4:	d9e8      	bls.n	8004e78 <RCC_SetFlashLatency+0x40>
 8004ea6:	e019      	b.n	8004edc <RCC_SetFlashLatency+0xa4>
      }
    }
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 8004ea8:	2300      	movs	r3, #0
 8004eaa:	63fb      	str	r3, [r7, #60]	; 0x3c
 8004eac:	e013      	b.n	8004ed6 <RCC_SetFlashLatency+0x9e>
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 8004eae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004eb0:	009b      	lsls	r3, r3, #2
 8004eb2:	3348      	adds	r3, #72	; 0x48
 8004eb4:	443b      	add	r3, r7
 8004eb6:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 8004eba:	687a      	ldr	r2, [r7, #4]
 8004ebc:	429a      	cmp	r2, r3
 8004ebe:	d807      	bhi.n	8004ed0 <RCC_SetFlashLatency+0x98>
      {
        latency = FLASH_LATENCY_RANGE[index];
 8004ec0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004ec2:	009b      	lsls	r3, r3, #2
 8004ec4:	3348      	adds	r3, #72	; 0x48
 8004ec6:	443b      	add	r3, r7
 8004ec8:	f853 3c3c 	ldr.w	r3, [r3, #-60]
 8004ecc:	647b      	str	r3, [r7, #68]	; 0x44
        break;
 8004ece:	e005      	b.n	8004edc <RCC_SetFlashLatency+0xa4>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 8004ed0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004ed2:	3301      	adds	r3, #1
 8004ed4:	63fb      	str	r3, [r7, #60]	; 0x3c
 8004ed6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004ed8:	2b02      	cmp	r3, #2
 8004eda:	d9e8      	bls.n	8004eae <RCC_SetFlashLatency+0x76>
      break;
    }
  }
#endif /* PWR_CR1_VOS */

  __HAL_FLASH_SET_LATENCY(latency);
 8004edc:	4b13      	ldr	r3, [pc, #76]	; (8004f2c <RCC_SetFlashLatency+0xf4>)
 8004ede:	681b      	ldr	r3, [r3, #0]
 8004ee0:	f023 0207 	bic.w	r2, r3, #7
 8004ee4:	4911      	ldr	r1, [pc, #68]	; (8004f2c <RCC_SetFlashLatency+0xf4>)
 8004ee6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8004ee8:	4313      	orrs	r3, r2
 8004eea:	600b      	str	r3, [r1, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8004eec:	f7fd f916 	bl	800211c <HAL_GetTick>
 8004ef0:	63b8      	str	r0, [r7, #56]	; 0x38

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 8004ef2:	e008      	b.n	8004f06 <RCC_SetFlashLatency+0xce>
  {
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8004ef4:	f7fd f912 	bl	800211c <HAL_GetTick>
 8004ef8:	4602      	mov	r2, r0
 8004efa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004efc:	1ad3      	subs	r3, r2, r3
 8004efe:	2b02      	cmp	r3, #2
 8004f00:	d901      	bls.n	8004f06 <RCC_SetFlashLatency+0xce>
    {
      return HAL_TIMEOUT;
 8004f02:	2303      	movs	r3, #3
 8004f04:	e007      	b.n	8004f16 <RCC_SetFlashLatency+0xde>
  while (__HAL_FLASH_GET_LATENCY() != latency)
 8004f06:	4b09      	ldr	r3, [pc, #36]	; (8004f2c <RCC_SetFlashLatency+0xf4>)
 8004f08:	681b      	ldr	r3, [r3, #0]
 8004f0a:	f003 0307 	and.w	r3, r3, #7
 8004f0e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8004f10:	429a      	cmp	r2, r3
 8004f12:	d1ef      	bne.n	8004ef4 <RCC_SetFlashLatency+0xbc>
    }
  }
  return HAL_OK;
 8004f14:	2300      	movs	r3, #0
}
 8004f16:	4618      	mov	r0, r3
 8004f18:	374c      	adds	r7, #76	; 0x4c
 8004f1a:	46bd      	mov	sp, r7
 8004f1c:	bd90      	pop	{r4, r7, pc}
 8004f1e:	bf00      	nop
 8004f20:	08013344 	.word	0x08013344
 8004f24:	08013354 	.word	0x08013354
 8004f28:	08013360 	.word	0x08013360
 8004f2c:	58004000 	.word	0x58004000

08004f30 <LL_RCC_LSE_IsEnabled>:
{
 8004f30:	b480      	push	{r7}
 8004f32:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSEON) == (RCC_BDCR_LSEON)) ? 1UL : 0UL);
 8004f34:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004f38:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004f3c:	f003 0301 	and.w	r3, r3, #1
 8004f40:	2b01      	cmp	r3, #1
 8004f42:	d101      	bne.n	8004f48 <LL_RCC_LSE_IsEnabled+0x18>
 8004f44:	2301      	movs	r3, #1
 8004f46:	e000      	b.n	8004f4a <LL_RCC_LSE_IsEnabled+0x1a>
 8004f48:	2300      	movs	r3, #0
}
 8004f4a:	4618      	mov	r0, r3
 8004f4c:	46bd      	mov	sp, r7
 8004f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f52:	4770      	bx	lr

08004f54 <LL_RCC_LSE_IsReady>:
{
 8004f54:	b480      	push	{r7}
 8004f56:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8004f58:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004f5c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004f60:	f003 0302 	and.w	r3, r3, #2
 8004f64:	2b02      	cmp	r3, #2
 8004f66:	d101      	bne.n	8004f6c <LL_RCC_LSE_IsReady+0x18>
 8004f68:	2301      	movs	r3, #1
 8004f6a:	e000      	b.n	8004f6e <LL_RCC_LSE_IsReady+0x1a>
 8004f6c:	2300      	movs	r3, #0
}
 8004f6e:	4618      	mov	r0, r3
 8004f70:	46bd      	mov	sp, r7
 8004f72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f76:	4770      	bx	lr

08004f78 <LL_RCC_SetRFWKPClockSource>:
{
 8004f78:	b480      	push	{r7}
 8004f7a:	b083      	sub	sp, #12
 8004f7c:	af00      	add	r7, sp, #0
 8004f7e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CSR, RCC_CSR_RFWKPSEL, Source);
 8004f80:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004f84:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8004f88:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 8004f8c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004f90:	687b      	ldr	r3, [r7, #4]
 8004f92:	4313      	orrs	r3, r2
 8004f94:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
}
 8004f98:	bf00      	nop
 8004f9a:	370c      	adds	r7, #12
 8004f9c:	46bd      	mov	sp, r7
 8004f9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004fa2:	4770      	bx	lr

08004fa4 <LL_RCC_SetSMPSClockSource>:
{
 8004fa4:	b480      	push	{r7}
 8004fa6:	b083      	sub	sp, #12
 8004fa8:	af00      	add	r7, sp, #0
 8004faa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->SMPSCR, RCC_SMPSCR_SMPSSEL, SMPSSource);
 8004fac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004fb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004fb2:	f023 0203 	bic.w	r2, r3, #3
 8004fb6:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004fba:	687b      	ldr	r3, [r7, #4]
 8004fbc:	4313      	orrs	r3, r2
 8004fbe:	624b      	str	r3, [r1, #36]	; 0x24
}
 8004fc0:	bf00      	nop
 8004fc2:	370c      	adds	r7, #12
 8004fc4:	46bd      	mov	sp, r7
 8004fc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004fca:	4770      	bx	lr

08004fcc <LL_RCC_SetSMPSPrescaler>:
{
 8004fcc:	b480      	push	{r7}
 8004fce:	b083      	sub	sp, #12
 8004fd0:	af00      	add	r7, sp, #0
 8004fd2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->SMPSCR, RCC_SMPSCR_SMPSDIV, Prescaler);
 8004fd4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004fd8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004fda:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 8004fde:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004fe2:	687b      	ldr	r3, [r7, #4]
 8004fe4:	4313      	orrs	r3, r2
 8004fe6:	624b      	str	r3, [r1, #36]	; 0x24
}
 8004fe8:	bf00      	nop
 8004fea:	370c      	adds	r7, #12
 8004fec:	46bd      	mov	sp, r7
 8004fee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ff2:	4770      	bx	lr

08004ff4 <LL_RCC_SetUSARTClockSource>:
{
 8004ff4:	b480      	push	{r7}
 8004ff6:	b083      	sub	sp, #12
 8004ff8:	af00      	add	r7, sp, #0
 8004ffa:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_USART1SEL, USARTxSource);
 8004ffc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005000:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005004:	f023 0203 	bic.w	r2, r3, #3
 8005008:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800500c:	687b      	ldr	r3, [r7, #4]
 800500e:	4313      	orrs	r3, r2
 8005010:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8005014:	bf00      	nop
 8005016:	370c      	adds	r7, #12
 8005018:	46bd      	mov	sp, r7
 800501a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800501e:	4770      	bx	lr

08005020 <LL_RCC_SetLPUARTClockSource>:
{
 8005020:	b480      	push	{r7}
 8005022:	b083      	sub	sp, #12
 8005024:	af00      	add	r7, sp, #0
 8005026:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 8005028:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800502c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005030:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 8005034:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8005038:	687b      	ldr	r3, [r7, #4]
 800503a:	4313      	orrs	r3, r2
 800503c:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8005040:	bf00      	nop
 8005042:	370c      	adds	r7, #12
 8005044:	46bd      	mov	sp, r7
 8005046:	f85d 7b04 	ldr.w	r7, [sp], #4
 800504a:	4770      	bx	lr

0800504c <LL_RCC_SetI2CClockSource>:
{
 800504c:	b480      	push	{r7}
 800504e:	b083      	sub	sp, #12
 8005050:	af00      	add	r7, sp, #0
 8005052:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 8005054:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005058:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800505c:	687b      	ldr	r3, [r7, #4]
 800505e:	091b      	lsrs	r3, r3, #4
 8005060:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 8005064:	43db      	mvns	r3, r3
 8005066:	401a      	ands	r2, r3
 8005068:	687b      	ldr	r3, [r7, #4]
 800506a:	011b      	lsls	r3, r3, #4
 800506c:	f403 237f 	and.w	r3, r3, #1044480	; 0xff000
 8005070:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8005074:	4313      	orrs	r3, r2
 8005076:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 800507a:	bf00      	nop
 800507c:	370c      	adds	r7, #12
 800507e:	46bd      	mov	sp, r7
 8005080:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005084:	4770      	bx	lr

08005086 <LL_RCC_SetLPTIMClockSource>:
{
 8005086:	b480      	push	{r7}
 8005088:	b083      	sub	sp, #12
 800508a:	af00      	add	r7, sp, #0
 800508c:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 800508e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005092:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8005096:	687b      	ldr	r3, [r7, #4]
 8005098:	0c1b      	lsrs	r3, r3, #16
 800509a:	041b      	lsls	r3, r3, #16
 800509c:	43db      	mvns	r3, r3
 800509e:	401a      	ands	r2, r3
 80050a0:	687b      	ldr	r3, [r7, #4]
 80050a2:	041b      	lsls	r3, r3, #16
 80050a4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80050a8:	4313      	orrs	r3, r2
 80050aa:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 80050ae:	bf00      	nop
 80050b0:	370c      	adds	r7, #12
 80050b2:	46bd      	mov	sp, r7
 80050b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80050b8:	4770      	bx	lr

080050ba <LL_RCC_SetSAIClockSource>:
{
 80050ba:	b480      	push	{r7}
 80050bc:	b083      	sub	sp, #12
 80050be:	af00      	add	r7, sp, #0
 80050c0:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_SAI1SEL, SAIxSource);
 80050c2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80050c6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80050ca:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 80050ce:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80050d2:	687b      	ldr	r3, [r7, #4]
 80050d4:	4313      	orrs	r3, r2
 80050d6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 80050da:	bf00      	nop
 80050dc:	370c      	adds	r7, #12
 80050de:	46bd      	mov	sp, r7
 80050e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80050e4:	4770      	bx	lr

080050e6 <LL_RCC_SetRNGClockSource>:
{
 80050e6:	b480      	push	{r7}
 80050e8:	b083      	sub	sp, #12
 80050ea:	af00      	add	r7, sp, #0
 80050ec:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 80050ee:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80050f2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80050f6:	f023 4240 	bic.w	r2, r3, #3221225472	; 0xc0000000
 80050fa:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80050fe:	687b      	ldr	r3, [r7, #4]
 8005100:	4313      	orrs	r3, r2
 8005102:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8005106:	bf00      	nop
 8005108:	370c      	adds	r7, #12
 800510a:	46bd      	mov	sp, r7
 800510c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005110:	4770      	bx	lr

08005112 <LL_RCC_SetCLK48ClockSource>:
{
 8005112:	b480      	push	{r7}
 8005114:	b083      	sub	sp, #12
 8005116:	af00      	add	r7, sp, #0
 8005118:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_CLK48SEL, CLK48xSource);
 800511a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800511e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005122:	f023 6240 	bic.w	r2, r3, #201326592	; 0xc000000
 8005126:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800512a:	687b      	ldr	r3, [r7, #4]
 800512c:	4313      	orrs	r3, r2
 800512e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8005132:	bf00      	nop
 8005134:	370c      	adds	r7, #12
 8005136:	46bd      	mov	sp, r7
 8005138:	f85d 7b04 	ldr.w	r7, [sp], #4
 800513c:	4770      	bx	lr

0800513e <LL_RCC_SetUSBClockSource>:
{
 800513e:	b580      	push	{r7, lr}
 8005140:	b082      	sub	sp, #8
 8005142:	af00      	add	r7, sp, #0
 8005144:	6078      	str	r0, [r7, #4]
  LL_RCC_SetCLK48ClockSource(USBxSource);
 8005146:	6878      	ldr	r0, [r7, #4]
 8005148:	f7ff ffe3 	bl	8005112 <LL_RCC_SetCLK48ClockSource>
}
 800514c:	bf00      	nop
 800514e:	3708      	adds	r7, #8
 8005150:	46bd      	mov	sp, r7
 8005152:	bd80      	pop	{r7, pc}

08005154 <LL_RCC_SetADCClockSource>:
{
 8005154:	b480      	push	{r7}
 8005156:	b083      	sub	sp, #12
 8005158:	af00      	add	r7, sp, #0
 800515a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 800515c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005160:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005164:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 8005168:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800516c:	687b      	ldr	r3, [r7, #4]
 800516e:	4313      	orrs	r3, r2
 8005170:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
}
 8005174:	bf00      	nop
 8005176:	370c      	adds	r7, #12
 8005178:	46bd      	mov	sp, r7
 800517a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800517e:	4770      	bx	lr

08005180 <LL_RCC_SetRTCClockSource>:
{
 8005180:	b480      	push	{r7}
 8005182:	b083      	sub	sp, #12
 8005184:	af00      	add	r7, sp, #0
 8005186:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 8005188:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800518c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005190:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8005194:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8005198:	687b      	ldr	r3, [r7, #4]
 800519a:	4313      	orrs	r3, r2
 800519c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 80051a0:	bf00      	nop
 80051a2:	370c      	adds	r7, #12
 80051a4:	46bd      	mov	sp, r7
 80051a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80051aa:	4770      	bx	lr

080051ac <LL_RCC_GetRTCClockSource>:
{
 80051ac:	b480      	push	{r7}
 80051ae:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 80051b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80051b4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80051b8:	f403 7340 	and.w	r3, r3, #768	; 0x300
}
 80051bc:	4618      	mov	r0, r3
 80051be:	46bd      	mov	sp, r7
 80051c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80051c4:	4770      	bx	lr

080051c6 <LL_RCC_ForceBackupDomainReset>:
{
 80051c6:	b480      	push	{r7}
 80051c8:	af00      	add	r7, sp, #0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 80051ca:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80051ce:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80051d2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80051d6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80051da:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 80051de:	bf00      	nop
 80051e0:	46bd      	mov	sp, r7
 80051e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80051e6:	4770      	bx	lr

080051e8 <LL_RCC_ReleaseBackupDomainReset>:
{
 80051e8:	b480      	push	{r7}
 80051ea:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 80051ec:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80051f0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80051f4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80051f8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80051fc:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8005200:	bf00      	nop
 8005202:	46bd      	mov	sp, r7
 8005204:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005208:	4770      	bx	lr

0800520a <LL_RCC_PLLSAI1_Enable>:
{
 800520a:	b480      	push	{r7}
 800520c:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 800520e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005212:	681b      	ldr	r3, [r3, #0]
 8005214:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8005218:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800521c:	6013      	str	r3, [r2, #0]
}
 800521e:	bf00      	nop
 8005220:	46bd      	mov	sp, r7
 8005222:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005226:	4770      	bx	lr

08005228 <LL_RCC_PLLSAI1_Disable>:
{
 8005228:	b480      	push	{r7}
 800522a:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_PLLSAI1ON);
 800522c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005230:	681b      	ldr	r3, [r3, #0]
 8005232:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8005236:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800523a:	6013      	str	r3, [r2, #0]
}
 800523c:	bf00      	nop
 800523e:	46bd      	mov	sp, r7
 8005240:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005244:	4770      	bx	lr

08005246 <LL_RCC_PLLSAI1_IsReady>:
{
 8005246:	b480      	push	{r7}
 8005248:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == (RCC_CR_PLLSAI1RDY)) ? 1UL : 0UL);
 800524a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800524e:	681b      	ldr	r3, [r3, #0]
 8005250:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8005254:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8005258:	d101      	bne.n	800525e <LL_RCC_PLLSAI1_IsReady+0x18>
 800525a:	2301      	movs	r3, #1
 800525c:	e000      	b.n	8005260 <LL_RCC_PLLSAI1_IsReady+0x1a>
 800525e:	2300      	movs	r3, #0
}
 8005260:	4618      	mov	r0, r3
 8005262:	46bd      	mov	sp, r7
 8005264:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005268:	4770      	bx	lr

0800526a <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800526a:	b580      	push	{r7, lr}
 800526c:	b088      	sub	sp, #32
 800526e:	af00      	add	r7, sp, #0
 8005270:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef ret     = HAL_OK;      /* Intermediate status */
 8005272:	2300      	movs	r3, #0
 8005274:	77fb      	strb	r3, [r7, #31]
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 8005276:	2300      	movs	r3, #0
 8005278:	77bb      	strb	r3, [r7, #30]
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

#if defined(SAI1)
  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 800527a:	687b      	ldr	r3, [r7, #4]
 800527c:	681b      	ldr	r3, [r3, #0]
 800527e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005282:	2b00      	cmp	r3, #0
 8005284:	d034      	beq.n	80052f0 <HAL_RCCEx_PeriphCLKConfig+0x86>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLK(PeriphClkInit->Sai1ClockSelection));

    switch (PeriphClkInit->Sai1ClockSelection)
 8005286:	687b      	ldr	r3, [r7, #4]
 8005288:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800528a:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 800528e:	d021      	beq.n	80052d4 <HAL_RCCEx_PeriphCLKConfig+0x6a>
 8005290:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 8005294:	d81b      	bhi.n	80052ce <HAL_RCCEx_PeriphCLKConfig+0x64>
 8005296:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800529a:	d01d      	beq.n	80052d8 <HAL_RCCEx_PeriphCLKConfig+0x6e>
 800529c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80052a0:	d815      	bhi.n	80052ce <HAL_RCCEx_PeriphCLKConfig+0x64>
 80052a2:	2b00      	cmp	r3, #0
 80052a4:	d00b      	beq.n	80052be <HAL_RCCEx_PeriphCLKConfig+0x54>
 80052a6:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80052aa:	d110      	bne.n	80052ce <HAL_RCCEx_PeriphCLKConfig+0x64>
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1 */
        /* Enable SAI1 Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI1CLK);
 80052ac:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80052b0:	68db      	ldr	r3, [r3, #12]
 80052b2:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80052b6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80052ba:	60d3      	str	r3, [r2, #12]

        /* SAI1 clock source config set later after clock selection check */
        break;
 80052bc:	e00d      	b.n	80052da <HAL_RCCEx_PeriphCLKConfig+0x70>

      case RCC_SAI1CLKSOURCE_PLLSAI1: /* PLLSAI1 is used as clock source for SAI1 */
        /* PLLSAI1 parameters N & P configuration and clock output (PLLSAI1ClockOut) */
        ret = RCCEx_PLLSAI1_ConfigNP(&(PeriphClkInit->PLLSAI1));
 80052be:	687b      	ldr	r3, [r7, #4]
 80052c0:	3304      	adds	r3, #4
 80052c2:	4618      	mov	r0, r3
 80052c4:	f000 f947 	bl	8005556 <RCCEx_PLLSAI1_ConfigNP>
 80052c8:	4603      	mov	r3, r0
 80052ca:	77fb      	strb	r3, [r7, #31]
        /* SAI1 clock source config set later after clock selection check */
        break;
 80052cc:	e005      	b.n	80052da <HAL_RCCEx_PeriphCLKConfig+0x70>
      case RCC_SAI1CLKSOURCE_HSI:

        break;

      default:
        ret = HAL_ERROR;
 80052ce:	2301      	movs	r3, #1
 80052d0:	77fb      	strb	r3, [r7, #31]
        break;
 80052d2:	e002      	b.n	80052da <HAL_RCCEx_PeriphCLKConfig+0x70>
        break;
 80052d4:	bf00      	nop
 80052d6:	e000      	b.n	80052da <HAL_RCCEx_PeriphCLKConfig+0x70>
        break;
 80052d8:	bf00      	nop
    }

    if (ret == HAL_OK)
 80052da:	7ffb      	ldrb	r3, [r7, #31]
 80052dc:	2b00      	cmp	r3, #0
 80052de:	d105      	bne.n	80052ec <HAL_RCCEx_PeriphCLKConfig+0x82>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80052e0:	687b      	ldr	r3, [r7, #4]
 80052e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80052e4:	4618      	mov	r0, r3
 80052e6:	f7ff fee8 	bl	80050ba <LL_RCC_SetSAIClockSource>
 80052ea:	e001      	b.n	80052f0 <HAL_RCCEx_PeriphCLKConfig+0x86>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80052ec:	7ffb      	ldrb	r3, [r7, #31]
 80052ee:	77bb      	strb	r3, [r7, #30]
    }
  }
#endif /* SAI1 */

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80052f0:	687b      	ldr	r3, [r7, #4]
 80052f2:	681b      	ldr	r3, [r3, #0]
 80052f4:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80052f8:	2b00      	cmp	r3, #0
 80052fa:	d046      	beq.n	800538a <HAL_RCCEx_PeriphCLKConfig+0x120>
  {
    uint32_t rtcclocksource = LL_RCC_GetRTCClockSource();
 80052fc:	f7ff ff56 	bl	80051ac <LL_RCC_GetRTCClockSource>
 8005300:	61b8      	str	r0, [r7, #24]

    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Configure the clock source only if a different source is expected */
    if (rtcclocksource != PeriphClkInit->RTCClockSelection)
 8005302:	687b      	ldr	r3, [r7, #4]
 8005304:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005306:	69ba      	ldr	r2, [r7, #24]
 8005308:	429a      	cmp	r2, r3
 800530a:	d03c      	beq.n	8005386 <HAL_RCCEx_PeriphCLKConfig+0x11c>
    {
      /* Enable write access to Backup domain */
      HAL_PWR_EnableBkUpAccess();
 800530c:	f7fe fb6e 	bl	80039ec <HAL_PWR_EnableBkUpAccess>

      /* If a clock source is not yet selected */
      if (rtcclocksource == RCC_RTCCLKSOURCE_NONE)
 8005310:	69bb      	ldr	r3, [r7, #24]
 8005312:	2b00      	cmp	r3, #0
 8005314:	d105      	bne.n	8005322 <HAL_RCCEx_PeriphCLKConfig+0xb8>
      {
        /* Directly set the configuration of the clock source selection */
        LL_RCC_SetRTCClockSource(PeriphClkInit->RTCClockSelection);
 8005316:	687b      	ldr	r3, [r7, #4]
 8005318:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800531a:	4618      	mov	r0, r3
 800531c:	f7ff ff30 	bl	8005180 <LL_RCC_SetRTCClockSource>
 8005320:	e02e      	b.n	8005380 <HAL_RCCEx_PeriphCLKConfig+0x116>
      }
      else /* A clock source is already selected */
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        uint32_t bdcr = LL_RCC_ReadReg(BDCR);
 8005322:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005326:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800532a:	617b      	str	r3, [r7, #20]

        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        LL_RCC_ForceBackupDomainReset();
 800532c:	f7ff ff4b 	bl	80051c6 <LL_RCC_ForceBackupDomainReset>
        LL_RCC_ReleaseBackupDomainReset();
 8005330:	f7ff ff5a 	bl	80051e8 <LL_RCC_ReleaseBackupDomainReset>

        /* Set the value of the clock source selection */
        MODIFY_REG(bdcr, RCC_BDCR_RTCSEL, PeriphClkInit->RTCClockSelection);
 8005334:	697b      	ldr	r3, [r7, #20]
 8005336:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 800533a:	687b      	ldr	r3, [r7, #4]
 800533c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800533e:	4313      	orrs	r3, r2
 8005340:	617b      	str	r3, [r7, #20]

        /* Restore the content of BDCR register */
        LL_RCC_WriteReg(BDCR, bdcr);
 8005342:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8005346:	697b      	ldr	r3, [r7, #20]
 8005348:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

        /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
        if (LL_RCC_LSE_IsEnabled() == 1U)
 800534c:	f7ff fdf0 	bl	8004f30 <LL_RCC_LSE_IsEnabled>
 8005350:	4603      	mov	r3, r0
 8005352:	2b01      	cmp	r3, #1
 8005354:	d114      	bne.n	8005380 <HAL_RCCEx_PeriphCLKConfig+0x116>
        {
          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8005356:	f7fc fee1 	bl	800211c <HAL_GetTick>
 800535a:	6138      	str	r0, [r7, #16]

          /* Wait till LSE is ready */
          while (LL_RCC_LSE_IsReady() != 1U)
 800535c:	e00b      	b.n	8005376 <HAL_RCCEx_PeriphCLKConfig+0x10c>
          {
            if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800535e:	f7fc fedd 	bl	800211c <HAL_GetTick>
 8005362:	4602      	mov	r2, r0
 8005364:	693b      	ldr	r3, [r7, #16]
 8005366:	1ad3      	subs	r3, r2, r3
 8005368:	f241 3288 	movw	r2, #5000	; 0x1388
 800536c:	4293      	cmp	r3, r2
 800536e:	d902      	bls.n	8005376 <HAL_RCCEx_PeriphCLKConfig+0x10c>
            {
              ret = HAL_TIMEOUT;
 8005370:	2303      	movs	r3, #3
 8005372:	77fb      	strb	r3, [r7, #31]
              break;
 8005374:	e004      	b.n	8005380 <HAL_RCCEx_PeriphCLKConfig+0x116>
          while (LL_RCC_LSE_IsReady() != 1U)
 8005376:	f7ff fded 	bl	8004f54 <LL_RCC_LSE_IsReady>
 800537a:	4603      	mov	r3, r0
 800537c:	2b01      	cmp	r3, #1
 800537e:	d1ee      	bne.n	800535e <HAL_RCCEx_PeriphCLKConfig+0xf4>
          }
        }
      }

      /* set overall return value */
      status = ret;
 8005380:	7ffb      	ldrb	r3, [r7, #31]
 8005382:	77bb      	strb	r3, [r7, #30]
 8005384:	e001      	b.n	800538a <HAL_RCCEx_PeriphCLKConfig+0x120>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005386:	7ffb      	ldrb	r3, [r7, #31]
 8005388:	77bb      	strb	r3, [r7, #30]
    }

  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800538a:	687b      	ldr	r3, [r7, #4]
 800538c:	681b      	ldr	r3, [r3, #0]
 800538e:	f003 0301 	and.w	r3, r3, #1
 8005392:	2b00      	cmp	r3, #0
 8005394:	d004      	beq.n	80053a0 <HAL_RCCEx_PeriphCLKConfig+0x136>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8005396:	687b      	ldr	r3, [r7, #4]
 8005398:	699b      	ldr	r3, [r3, #24]
 800539a:	4618      	mov	r0, r3
 800539c:	f7ff fe2a 	bl	8004ff4 <LL_RCC_SetUSARTClockSource>
  }

#if defined(LPUART1)
  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80053a0:	687b      	ldr	r3, [r7, #4]
 80053a2:	681b      	ldr	r3, [r3, #0]
 80053a4:	f003 0302 	and.w	r3, r3, #2
 80053a8:	2b00      	cmp	r3, #0
 80053aa:	d004      	beq.n	80053b6 <HAL_RCCEx_PeriphCLKConfig+0x14c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80053ac:	687b      	ldr	r3, [r7, #4]
 80053ae:	69db      	ldr	r3, [r3, #28]
 80053b0:	4618      	mov	r0, r3
 80053b2:	f7ff fe35 	bl	8005020 <LL_RCC_SetLPUARTClockSource>
  }
#endif /* LPUART1 */

  /*-------------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 80053b6:	687b      	ldr	r3, [r7, #4]
 80053b8:	681b      	ldr	r3, [r3, #0]
 80053ba:	f003 0310 	and.w	r3, r3, #16
 80053be:	2b00      	cmp	r3, #0
 80053c0:	d004      	beq.n	80053cc <HAL_RCCEx_PeriphCLKConfig+0x162>
  {
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80053c2:	687b      	ldr	r3, [r7, #4]
 80053c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80053c6:	4618      	mov	r0, r3
 80053c8:	f7ff fe5d 	bl	8005086 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 80053cc:	687b      	ldr	r3, [r7, #4]
 80053ce:	681b      	ldr	r3, [r3, #0]
 80053d0:	f003 0320 	and.w	r3, r3, #32
 80053d4:	2b00      	cmp	r3, #0
 80053d6:	d004      	beq.n	80053e2 <HAL_RCCEx_PeriphCLKConfig+0x178>
  {
    assert_param(IS_RCC_LPTIM2CLK(PeriphClkInit->Lptim2ClockSelection));
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 80053d8:	687b      	ldr	r3, [r7, #4]
 80053da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80053dc:	4618      	mov	r0, r3
 80053de:	f7ff fe52 	bl	8005086 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80053e2:	687b      	ldr	r3, [r7, #4]
 80053e4:	681b      	ldr	r3, [r3, #0]
 80053e6:	f003 0304 	and.w	r3, r3, #4
 80053ea:	2b00      	cmp	r3, #0
 80053ec:	d004      	beq.n	80053f8 <HAL_RCCEx_PeriphCLKConfig+0x18e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80053ee:	687b      	ldr	r3, [r7, #4]
 80053f0:	6a1b      	ldr	r3, [r3, #32]
 80053f2:	4618      	mov	r0, r3
 80053f4:	f7ff fe2a 	bl	800504c <LL_RCC_SetI2CClockSource>
  }

#if defined(I2C3)
  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80053f8:	687b      	ldr	r3, [r7, #4]
 80053fa:	681b      	ldr	r3, [r3, #0]
 80053fc:	f003 0308 	and.w	r3, r3, #8
 8005400:	2b00      	cmp	r3, #0
 8005402:	d004      	beq.n	800540e <HAL_RCCEx_PeriphCLKConfig+0x1a4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8005404:	687b      	ldr	r3, [r7, #4]
 8005406:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8005408:	4618      	mov	r0, r3
 800540a:	f7ff fe1f 	bl	800504c <LL_RCC_SetI2CClockSource>
  }
#endif /* I2C3 */

#if defined(USB)
  /*-------------------------- USB clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 800540e:	687b      	ldr	r3, [r7, #4]
 8005410:	681b      	ldr	r3, [r3, #0]
 8005412:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005416:	2b00      	cmp	r3, #0
 8005418:	d022      	beq.n	8005460 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800541a:	687b      	ldr	r3, [r7, #4]
 800541c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800541e:	4618      	mov	r0, r3
 8005420:	f7ff fe8d 	bl	800513e <LL_RCC_SetUSBClockSource>

    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8005424:	687b      	ldr	r3, [r7, #4]
 8005426:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005428:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800542c:	d107      	bne.n	800543e <HAL_RCCEx_PeriphCLKConfig+0x1d4>
    {
      /* Enable PLLQ output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_USBCLK);
 800542e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005432:	68db      	ldr	r3, [r3, #12]
 8005434:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8005438:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800543c:	60d3      	str	r3, [r2, #12]
    }
#if defined(SAI1)
    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 800543e:	687b      	ldr	r3, [r7, #4]
 8005440:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005442:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8005446:	d10b      	bne.n	8005460 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
    {
      /* PLLSAI1 parameters N & Q configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNQ(&(PeriphClkInit->PLLSAI1));
 8005448:	687b      	ldr	r3, [r7, #4]
 800544a:	3304      	adds	r3, #4
 800544c:	4618      	mov	r0, r3
 800544e:	f000 f8dd 	bl	800560c <RCCEx_PLLSAI1_ConfigNQ>
 8005452:	4603      	mov	r3, r0
 8005454:	77fb      	strb	r3, [r7, #31]

      if (ret != HAL_OK)
 8005456:	7ffb      	ldrb	r3, [r7, #31]
 8005458:	2b00      	cmp	r3, #0
 800545a:	d001      	beq.n	8005460 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
      {
        /* set overall return value */
        status = ret;
 800545c:	7ffb      	ldrb	r3, [r7, #31]
 800545e:	77bb      	strb	r3, [r7, #30]
#endif /* SAI1 */
  }
#endif /* USB */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8005460:	687b      	ldr	r3, [r7, #4]
 8005462:	681b      	ldr	r3, [r3, #0]
 8005464:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8005468:	2b00      	cmp	r3, #0
 800546a:	d02b      	beq.n	80054c4 <HAL_RCCEx_PeriphCLKConfig+0x25a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));

    /* Configure the RNG clock source */
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800546c:	687b      	ldr	r3, [r7, #4]
 800546e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005470:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005474:	d008      	beq.n	8005488 <HAL_RCCEx_PeriphCLKConfig+0x21e>
 8005476:	687b      	ldr	r3, [r7, #4]
 8005478:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800547a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800547e:	d003      	beq.n	8005488 <HAL_RCCEx_PeriphCLKConfig+0x21e>
 8005480:	687b      	ldr	r3, [r7, #4]
 8005482:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005484:	2b00      	cmp	r3, #0
 8005486:	d105      	bne.n	8005494 <HAL_RCCEx_PeriphCLKConfig+0x22a>
 8005488:	687b      	ldr	r3, [r7, #4]
 800548a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800548c:	4618      	mov	r0, r3
 800548e:	f7ff fe2a 	bl	80050e6 <LL_RCC_SetRNGClockSource>
 8005492:	e00a      	b.n	80054aa <HAL_RCCEx_PeriphCLKConfig+0x240>
 8005494:	687b      	ldr	r3, [r7, #4]
 8005496:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005498:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800549c:	60fb      	str	r3, [r7, #12]
 800549e:	2000      	movs	r0, #0
 80054a0:	f7ff fe21 	bl	80050e6 <LL_RCC_SetRNGClockSource>
 80054a4:	68f8      	ldr	r0, [r7, #12]
 80054a6:	f7ff fe34 	bl	8005112 <LL_RCC_SetCLK48ClockSource>

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80054aa:	687b      	ldr	r3, [r7, #4]
 80054ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80054ae:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
 80054b2:	d107      	bne.n	80054c4 <HAL_RCCEx_PeriphCLKConfig+0x25a>
    {
      /* Enable PLLQ output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 80054b4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80054b8:	68db      	ldr	r3, [r3, #12]
 80054ba:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80054be:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80054c2:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80054c4:	687b      	ldr	r3, [r7, #4]
 80054c6:	681b      	ldr	r3, [r3, #0]
 80054c8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80054cc:	2b00      	cmp	r3, #0
 80054ce:	d022      	beq.n	8005516 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 80054d0:	687b      	ldr	r3, [r7, #4]
 80054d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80054d4:	4618      	mov	r0, r3
 80054d6:	f7ff fe3d 	bl	8005154 <LL_RCC_SetADCClockSource>

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 80054da:	687b      	ldr	r3, [r7, #4]
 80054dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80054de:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80054e2:	d107      	bne.n	80054f4 <HAL_RCCEx_PeriphCLKConfig+0x28a>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 80054e4:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80054e8:	68db      	ldr	r3, [r3, #12]
 80054ea:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80054ee:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80054f2:	60d3      	str	r3, [r2, #12]
    }

#if defined(SAI1)
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 80054f4:	687b      	ldr	r3, [r7, #4]
 80054f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80054f8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80054fc:	d10b      	bne.n	8005516 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
    {
      /* PLLSAI1 parameters N & R configuration and clock output (PLLSAI1ClockOut) */
      ret = RCCEx_PLLSAI1_ConfigNR(&(PeriphClkInit->PLLSAI1));
 80054fe:	687b      	ldr	r3, [r7, #4]
 8005500:	3304      	adds	r3, #4
 8005502:	4618      	mov	r0, r3
 8005504:	f000 f8dd 	bl	80056c2 <RCCEx_PLLSAI1_ConfigNR>
 8005508:	4603      	mov	r3, r0
 800550a:	77fb      	strb	r3, [r7, #31]

      if (ret != HAL_OK)
 800550c:	7ffb      	ldrb	r3, [r7, #31]
 800550e:	2b00      	cmp	r3, #0
 8005510:	d001      	beq.n	8005516 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
      {
        /* set overall return value */
        status = ret;
 8005512:	7ffb      	ldrb	r3, [r7, #31]
 8005514:	77bb      	strb	r3, [r7, #30]
    }
#endif /* SAI1 */
  }

  /*-------------------------- RFWKP clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RFWAKEUP) == RCC_PERIPHCLK_RFWAKEUP)
 8005516:	687b      	ldr	r3, [r7, #4]
 8005518:	681b      	ldr	r3, [r3, #0]
 800551a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 800551e:	2b00      	cmp	r3, #0
 8005520:	d004      	beq.n	800552c <HAL_RCCEx_PeriphCLKConfig+0x2c2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_RFWKPCLKSOURCE(PeriphClkInit->RFWakeUpClockSelection));

    /* Configure the RFWKP interface clock source */
    __HAL_RCC_RFWAKEUP_CONFIG(PeriphClkInit->RFWakeUpClockSelection);
 8005522:	687b      	ldr	r3, [r7, #4]
 8005524:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8005526:	4618      	mov	r0, r3
 8005528:	f7ff fd26 	bl	8004f78 <LL_RCC_SetRFWKPClockSource>

  }

#if defined(RCC_SMPS_SUPPORT)
  /*-------------------------- SMPS clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SMPS) == RCC_PERIPHCLK_SMPS)
 800552c:	687b      	ldr	r3, [r7, #4]
 800552e:	681b      	ldr	r3, [r3, #0]
 8005530:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8005534:	2b00      	cmp	r3, #0
 8005536:	d009      	beq.n	800554c <HAL_RCCEx_PeriphCLKConfig+0x2e2>
    /* Check the parameters */
    assert_param(IS_RCC_SMPSCLKDIV(PeriphClkInit->SmpsDivSelection));
    assert_param(IS_RCC_SMPSCLKSOURCE(PeriphClkInit->SmpsClockSelection));

    /* Configure the SMPS interface clock division factor */
    __HAL_RCC_SMPS_DIV_CONFIG(PeriphClkInit->SmpsDivSelection);
 8005538:	687b      	ldr	r3, [r7, #4]
 800553a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800553c:	4618      	mov	r0, r3
 800553e:	f7ff fd45 	bl	8004fcc <LL_RCC_SetSMPSPrescaler>

    /* Configure the SMPS interface clock source */
    __HAL_RCC_SMPS_CONFIG(PeriphClkInit->SmpsClockSelection);
 8005542:	687b      	ldr	r3, [r7, #4]
 8005544:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005546:	4618      	mov	r0, r3
 8005548:	f7ff fd2c 	bl	8004fa4 <LL_RCC_SetSMPSClockSource>
  }
#endif /* RCC_SMPS_SUPPORT */

  return status;
 800554c:	7fbb      	ldrb	r3, [r7, #30]
}
 800554e:	4618      	mov	r0, r3
 8005550:	3720      	adds	r7, #32
 8005552:	46bd      	mov	sp, r7
 8005554:	bd80      	pop	{r7, pc}

08005556 <RCCEx_PLLSAI1_ConfigNP>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNP(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 8005556:	b580      	push	{r7, lr}
 8005558:	b084      	sub	sp, #16
 800555a:	af00      	add	r7, sp, #0
 800555c:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 800555e:	2300      	movs	r3, #0
 8005560:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLSAI1->PLLP));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8005562:	f7ff fe61 	bl	8005228 <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8005566:	f7fc fdd9 	bl	800211c <HAL_GetTick>
 800556a:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 800556c:	e009      	b.n	8005582 <RCCEx_PLLSAI1_ConfigNP+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800556e:	f7fc fdd5 	bl	800211c <HAL_GetTick>
 8005572:	4602      	mov	r2, r0
 8005574:	68bb      	ldr	r3, [r7, #8]
 8005576:	1ad3      	subs	r3, r2, r3
 8005578:	2b02      	cmp	r3, #2
 800557a:	d902      	bls.n	8005582 <RCCEx_PLLSAI1_ConfigNP+0x2c>
    {
      status = HAL_TIMEOUT;
 800557c:	2303      	movs	r3, #3
 800557e:	73fb      	strb	r3, [r7, #15]
      break;
 8005580:	e004      	b.n	800558c <RCCEx_PLLSAI1_ConfigNP+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 8005582:	f7ff fe60 	bl	8005246 <LL_RCC_PLLSAI1_IsReady>
 8005586:	4603      	mov	r3, r0
 8005588:	2b00      	cmp	r3, #0
 800558a:	d1f0      	bne.n	800556e <RCCEx_PLLSAI1_ConfigNP+0x18>
    }
  }

  if (status == HAL_OK)
 800558c:	7bfb      	ldrb	r3, [r7, #15]
 800558e:	2b00      	cmp	r3, #0
 8005590:	d137      	bne.n	8005602 <RCCEx_PLLSAI1_ConfigNP+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 8005592:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005596:	691b      	ldr	r3, [r3, #16]
 8005598:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 800559c:	687b      	ldr	r3, [r7, #4]
 800559e:	681b      	ldr	r3, [r3, #0]
 80055a0:	021b      	lsls	r3, r3, #8
 80055a2:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80055a6:	4313      	orrs	r3, r2
 80055a8:	610b      	str	r3, [r1, #16]

    /* Configure the PLLSAI1 Division factor P */
    __HAL_RCC_PLLSAI1_DIVP_CONFIG(PLLSAI1->PLLP);
 80055aa:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80055ae:	691b      	ldr	r3, [r3, #16]
 80055b0:	f423 1278 	bic.w	r2, r3, #4063232	; 0x3e0000
 80055b4:	687b      	ldr	r3, [r7, #4]
 80055b6:	685b      	ldr	r3, [r3, #4]
 80055b8:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80055bc:	4313      	orrs	r3, r2
 80055be:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 80055c0:	f7ff fe23 	bl	800520a <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80055c4:	f7fc fdaa 	bl	800211c <HAL_GetTick>
 80055c8:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 80055ca:	e009      	b.n	80055e0 <RCCEx_PLLSAI1_ConfigNP+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80055cc:	f7fc fda6 	bl	800211c <HAL_GetTick>
 80055d0:	4602      	mov	r2, r0
 80055d2:	68bb      	ldr	r3, [r7, #8]
 80055d4:	1ad3      	subs	r3, r2, r3
 80055d6:	2b02      	cmp	r3, #2
 80055d8:	d902      	bls.n	80055e0 <RCCEx_PLLSAI1_ConfigNP+0x8a>
      {
        status = HAL_TIMEOUT;
 80055da:	2303      	movs	r3, #3
 80055dc:	73fb      	strb	r3, [r7, #15]
        break;
 80055de:	e004      	b.n	80055ea <RCCEx_PLLSAI1_ConfigNP+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 80055e0:	f7ff fe31 	bl	8005246 <LL_RCC_PLLSAI1_IsReady>
 80055e4:	4603      	mov	r3, r0
 80055e6:	2b01      	cmp	r3, #1
 80055e8:	d1f0      	bne.n	80055cc <RCCEx_PLLSAI1_ConfigNP+0x76>
      }
    }

    if (status == HAL_OK)
 80055ea:	7bfb      	ldrb	r3, [r7, #15]
 80055ec:	2b00      	cmp	r3, #0
 80055ee:	d108      	bne.n	8005602 <RCCEx_PLLSAI1_ConfigNP+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 80055f0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80055f4:	691a      	ldr	r2, [r3, #16]
 80055f6:	687b      	ldr	r3, [r7, #4]
 80055f8:	691b      	ldr	r3, [r3, #16]
 80055fa:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80055fe:	4313      	orrs	r3, r2
 8005600:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 8005602:	7bfb      	ldrb	r3, [r7, #15]
}
 8005604:	4618      	mov	r0, r3
 8005606:	3710      	adds	r7, #16
 8005608:	46bd      	mov	sp, r7
 800560a:	bd80      	pop	{r7, pc}

0800560c <RCCEx_PLLSAI1_ConfigNQ>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNQ(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 800560c:	b580      	push	{r7, lr}
 800560e:	b084      	sub	sp, #16
 8005610:	af00      	add	r7, sp, #0
 8005612:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 8005614:	2300      	movs	r3, #0
 8005616:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLQ_VALUE(PLLSAI1->PLLQ));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 8005618:	f7ff fe06 	bl	8005228 <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 800561c:	f7fc fd7e 	bl	800211c <HAL_GetTick>
 8005620:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 8005622:	e009      	b.n	8005638 <RCCEx_PLLSAI1_ConfigNQ+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8005624:	f7fc fd7a 	bl	800211c <HAL_GetTick>
 8005628:	4602      	mov	r2, r0
 800562a:	68bb      	ldr	r3, [r7, #8]
 800562c:	1ad3      	subs	r3, r2, r3
 800562e:	2b02      	cmp	r3, #2
 8005630:	d902      	bls.n	8005638 <RCCEx_PLLSAI1_ConfigNQ+0x2c>
    {
      status = HAL_TIMEOUT;
 8005632:	2303      	movs	r3, #3
 8005634:	73fb      	strb	r3, [r7, #15]
      break;
 8005636:	e004      	b.n	8005642 <RCCEx_PLLSAI1_ConfigNQ+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 8005638:	f7ff fe05 	bl	8005246 <LL_RCC_PLLSAI1_IsReady>
 800563c:	4603      	mov	r3, r0
 800563e:	2b00      	cmp	r3, #0
 8005640:	d1f0      	bne.n	8005624 <RCCEx_PLLSAI1_ConfigNQ+0x18>
    }
  }

  if (status == HAL_OK)
 8005642:	7bfb      	ldrb	r3, [r7, #15]
 8005644:	2b00      	cmp	r3, #0
 8005646:	d137      	bne.n	80056b8 <RCCEx_PLLSAI1_ConfigNQ+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 8005648:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800564c:	691b      	ldr	r3, [r3, #16]
 800564e:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 8005652:	687b      	ldr	r3, [r7, #4]
 8005654:	681b      	ldr	r3, [r3, #0]
 8005656:	021b      	lsls	r3, r3, #8
 8005658:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800565c:	4313      	orrs	r3, r2
 800565e:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor Q */
    __HAL_RCC_PLLSAI1_DIVQ_CONFIG(PLLSAI1->PLLQ);
 8005660:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005664:	691b      	ldr	r3, [r3, #16]
 8005666:	f023 6260 	bic.w	r2, r3, #234881024	; 0xe000000
 800566a:	687b      	ldr	r3, [r7, #4]
 800566c:	689b      	ldr	r3, [r3, #8]
 800566e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8005672:	4313      	orrs	r3, r2
 8005674:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 8005676:	f7ff fdc8 	bl	800520a <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800567a:	f7fc fd4f 	bl	800211c <HAL_GetTick>
 800567e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 8005680:	e009      	b.n	8005696 <RCCEx_PLLSAI1_ConfigNQ+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8005682:	f7fc fd4b 	bl	800211c <HAL_GetTick>
 8005686:	4602      	mov	r2, r0
 8005688:	68bb      	ldr	r3, [r7, #8]
 800568a:	1ad3      	subs	r3, r2, r3
 800568c:	2b02      	cmp	r3, #2
 800568e:	d902      	bls.n	8005696 <RCCEx_PLLSAI1_ConfigNQ+0x8a>
      {
        status = HAL_TIMEOUT;
 8005690:	2303      	movs	r3, #3
 8005692:	73fb      	strb	r3, [r7, #15]
        break;
 8005694:	e004      	b.n	80056a0 <RCCEx_PLLSAI1_ConfigNQ+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 8005696:	f7ff fdd6 	bl	8005246 <LL_RCC_PLLSAI1_IsReady>
 800569a:	4603      	mov	r3, r0
 800569c:	2b01      	cmp	r3, #1
 800569e:	d1f0      	bne.n	8005682 <RCCEx_PLLSAI1_ConfigNQ+0x76>
      }
    }

    if (status == HAL_OK)
 80056a0:	7bfb      	ldrb	r3, [r7, #15]
 80056a2:	2b00      	cmp	r3, #0
 80056a4:	d108      	bne.n	80056b8 <RCCEx_PLLSAI1_ConfigNQ+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 80056a6:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80056aa:	691a      	ldr	r2, [r3, #16]
 80056ac:	687b      	ldr	r3, [r7, #4]
 80056ae:	691b      	ldr	r3, [r3, #16]
 80056b0:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80056b4:	4313      	orrs	r3, r2
 80056b6:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 80056b8:	7bfb      	ldrb	r3, [r7, #15]
}
 80056ba:	4618      	mov	r0, r3
 80056bc:	3710      	adds	r7, #16
 80056be:	46bd      	mov	sp, r7
 80056c0:	bd80      	pop	{r7, pc}

080056c2 <RCCEx_PLLSAI1_ConfigNR>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_ConfigNR(RCC_PLLSAI1InitTypeDef *PLLSAI1)
{
 80056c2:	b580      	push	{r7, lr}
 80056c4:	b084      	sub	sp, #16
 80056c6:	af00      	add	r7, sp, #0
 80056c8:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 80056ca:	2300      	movs	r3, #0
 80056cc:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLLN_VALUE(PLLSAI1->PLLN));
  assert_param(IS_RCC_PLLR_VALUE(PLLSAI1->PLLR));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PLLSAI1->PLLSAI1ClockOut));

  /* Disable the PLLSAI1 */
  __HAL_RCC_PLLSAI1_DISABLE();
 80056ce:	f7ff fdab 	bl	8005228 <LL_RCC_PLLSAI1_Disable>

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 80056d2:	f7fc fd23 	bl	800211c <HAL_GetTick>
 80056d6:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLSAI1 is ready to be updated */
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 80056d8:	e009      	b.n	80056ee <RCCEx_PLLSAI1_ConfigNR+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80056da:	f7fc fd1f 	bl	800211c <HAL_GetTick>
 80056de:	4602      	mov	r2, r0
 80056e0:	68bb      	ldr	r3, [r7, #8]
 80056e2:	1ad3      	subs	r3, r2, r3
 80056e4:	2b02      	cmp	r3, #2
 80056e6:	d902      	bls.n	80056ee <RCCEx_PLLSAI1_ConfigNR+0x2c>
    {
      status = HAL_TIMEOUT;
 80056e8:	2303      	movs	r3, #3
 80056ea:	73fb      	strb	r3, [r7, #15]
      break;
 80056ec:	e004      	b.n	80056f8 <RCCEx_PLLSAI1_ConfigNR+0x36>
  while (LL_RCC_PLLSAI1_IsReady() != 0U)
 80056ee:	f7ff fdaa 	bl	8005246 <LL_RCC_PLLSAI1_IsReady>
 80056f2:	4603      	mov	r3, r0
 80056f4:	2b00      	cmp	r3, #0
 80056f6:	d1f0      	bne.n	80056da <RCCEx_PLLSAI1_ConfigNR+0x18>
    }
  }

  if (status == HAL_OK)
 80056f8:	7bfb      	ldrb	r3, [r7, #15]
 80056fa:	2b00      	cmp	r3, #0
 80056fc:	d137      	bne.n	800576e <RCCEx_PLLSAI1_ConfigNR+0xac>
  {
    /* Configure the PLLSAI1 Multiplication factor N */
    __HAL_RCC_PLLSAI1_MULN_CONFIG(PLLSAI1->PLLN);
 80056fe:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005702:	691b      	ldr	r3, [r3, #16]
 8005704:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
 8005708:	687b      	ldr	r3, [r7, #4]
 800570a:	681b      	ldr	r3, [r3, #0]
 800570c:	021b      	lsls	r3, r3, #8
 800570e:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8005712:	4313      	orrs	r3, r2
 8005714:	610b      	str	r3, [r1, #16]
    /* Configure the PLLSAI1 Division factor R */
    __HAL_RCC_PLLSAI1_DIVR_CONFIG(PLLSAI1->PLLR);
 8005716:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800571a:	691b      	ldr	r3, [r3, #16]
 800571c:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 8005720:	687b      	ldr	r3, [r7, #4]
 8005722:	68db      	ldr	r3, [r3, #12]
 8005724:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8005728:	4313      	orrs	r3, r2
 800572a:	610b      	str	r3, [r1, #16]

    /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
    __HAL_RCC_PLLSAI1_ENABLE();
 800572c:	f7ff fd6d 	bl	800520a <LL_RCC_PLLSAI1_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8005730:	f7fc fcf4 	bl	800211c <HAL_GetTick>
 8005734:	60b8      	str	r0, [r7, #8]

    /* Wait till PLLSAI1 is ready */
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 8005736:	e009      	b.n	800574c <RCCEx_PLLSAI1_ConfigNR+0x8a>
    {
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8005738:	f7fc fcf0 	bl	800211c <HAL_GetTick>
 800573c:	4602      	mov	r2, r0
 800573e:	68bb      	ldr	r3, [r7, #8]
 8005740:	1ad3      	subs	r3, r2, r3
 8005742:	2b02      	cmp	r3, #2
 8005744:	d902      	bls.n	800574c <RCCEx_PLLSAI1_ConfigNR+0x8a>
      {
        status = HAL_TIMEOUT;
 8005746:	2303      	movs	r3, #3
 8005748:	73fb      	strb	r3, [r7, #15]
        break;
 800574a:	e004      	b.n	8005756 <RCCEx_PLLSAI1_ConfigNR+0x94>
    while (LL_RCC_PLLSAI1_IsReady() != 1U)
 800574c:	f7ff fd7b 	bl	8005246 <LL_RCC_PLLSAI1_IsReady>
 8005750:	4603      	mov	r3, r0
 8005752:	2b01      	cmp	r3, #1
 8005754:	d1f0      	bne.n	8005738 <RCCEx_PLLSAI1_ConfigNR+0x76>
      }
    }

    if (status == HAL_OK)
 8005756:	7bfb      	ldrb	r3, [r7, #15]
 8005758:	2b00      	cmp	r3, #0
 800575a:	d108      	bne.n	800576e <RCCEx_PLLSAI1_ConfigNR+0xac>
    {
      /* Configure the PLLSAI1 Clock output(s) */
      __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PLLSAI1->PLLSAI1ClockOut);
 800575c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005760:	691a      	ldr	r2, [r3, #16]
 8005762:	687b      	ldr	r3, [r7, #4]
 8005764:	691b      	ldr	r3, [r3, #16]
 8005766:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 800576a:	4313      	orrs	r3, r2
 800576c:	610b      	str	r3, [r1, #16]
    }
  }

  return status;
 800576e:	7bfb      	ldrb	r3, [r7, #15]
}
 8005770:	4618      	mov	r0, r3
 8005772:	3710      	adds	r7, #16
 8005774:	46bd      	mov	sp, r7
 8005776:	bd80      	pop	{r7, pc}

08005778 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8005778:	b580      	push	{r7, lr}
 800577a:	b084      	sub	sp, #16
 800577c:	af00      	add	r7, sp, #0
 800577e:	6078      	str	r0, [r7, #4]
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 8005780:	687b      	ldr	r3, [r7, #4]
 8005782:	2b00      	cmp	r3, #0
 8005784:	d101      	bne.n	800578a <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 8005786:	2301      	movs	r3, #1
 8005788:	e095      	b.n	80058b6 <HAL_SPI_Init+0x13e>
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 800578a:	687b      	ldr	r3, [r7, #4]
 800578c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800578e:	2b00      	cmp	r3, #0
 8005790:	d108      	bne.n	80057a4 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 8005792:	687b      	ldr	r3, [r7, #4]
 8005794:	685b      	ldr	r3, [r3, #4]
 8005796:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 800579a:	d009      	beq.n	80057b0 <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 800579c:	687b      	ldr	r3, [r7, #4]
 800579e:	2200      	movs	r2, #0
 80057a0:	61da      	str	r2, [r3, #28]
 80057a2:	e005      	b.n	80057b0 <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 80057a4:	687b      	ldr	r3, [r7, #4]
 80057a6:	2200      	movs	r2, #0
 80057a8:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 80057aa:	687b      	ldr	r3, [r7, #4]
 80057ac:	2200      	movs	r2, #0
 80057ae:	615a      	str	r2, [r3, #20]
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80057b0:	687b      	ldr	r3, [r7, #4]
 80057b2:	2200      	movs	r2, #0
 80057b4:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 80057b6:	687b      	ldr	r3, [r7, #4]
 80057b8:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 80057bc:	b2db      	uxtb	r3, r3
 80057be:	2b00      	cmp	r3, #0
 80057c0:	d106      	bne.n	80057d0 <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 80057c2:	687b      	ldr	r3, [r7, #4]
 80057c4:	2200      	movs	r2, #0
 80057c6:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 80057ca:	6878      	ldr	r0, [r7, #4]
 80057cc:	f7fb fee8 	bl	80015a0 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80057d0:	687b      	ldr	r3, [r7, #4]
 80057d2:	2202      	movs	r2, #2
 80057d4:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80057d8:	687b      	ldr	r3, [r7, #4]
 80057da:	681b      	ldr	r3, [r3, #0]
 80057dc:	681a      	ldr	r2, [r3, #0]
 80057de:	687b      	ldr	r3, [r7, #4]
 80057e0:	681b      	ldr	r3, [r3, #0]
 80057e2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80057e6:	601a      	str	r2, [r3, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80057e8:	687b      	ldr	r3, [r7, #4]
 80057ea:	68db      	ldr	r3, [r3, #12]
 80057ec:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 80057f0:	d902      	bls.n	80057f8 <HAL_SPI_Init+0x80>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 80057f2:	2300      	movs	r3, #0
 80057f4:	60fb      	str	r3, [r7, #12]
 80057f6:	e002      	b.n	80057fe <HAL_SPI_Init+0x86>
  }
  else
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80057f8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80057fc:	60fb      	str	r3, [r7, #12]
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80057fe:	687b      	ldr	r3, [r7, #4]
 8005800:	68db      	ldr	r3, [r3, #12]
 8005802:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 8005806:	d007      	beq.n	8005818 <HAL_SPI_Init+0xa0>
 8005808:	687b      	ldr	r3, [r7, #4]
 800580a:	68db      	ldr	r3, [r3, #12]
 800580c:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8005810:	d002      	beq.n	8005818 <HAL_SPI_Init+0xa0>
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8005812:	687b      	ldr	r3, [r7, #4]
 8005814:	2200      	movs	r2, #0
 8005816:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8005818:	687b      	ldr	r3, [r7, #4]
 800581a:	685b      	ldr	r3, [r3, #4]
 800581c:	f403 7282 	and.w	r2, r3, #260	; 0x104
 8005820:	687b      	ldr	r3, [r7, #4]
 8005822:	689b      	ldr	r3, [r3, #8]
 8005824:	f403 4304 	and.w	r3, r3, #33792	; 0x8400
 8005828:	431a      	orrs	r2, r3
 800582a:	687b      	ldr	r3, [r7, #4]
 800582c:	691b      	ldr	r3, [r3, #16]
 800582e:	f003 0302 	and.w	r3, r3, #2
 8005832:	431a      	orrs	r2, r3
 8005834:	687b      	ldr	r3, [r7, #4]
 8005836:	695b      	ldr	r3, [r3, #20]
 8005838:	f003 0301 	and.w	r3, r3, #1
 800583c:	431a      	orrs	r2, r3
 800583e:	687b      	ldr	r3, [r7, #4]
 8005840:	699b      	ldr	r3, [r3, #24]
 8005842:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8005846:	431a      	orrs	r2, r3
 8005848:	687b      	ldr	r3, [r7, #4]
 800584a:	69db      	ldr	r3, [r3, #28]
 800584c:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8005850:	431a      	orrs	r2, r3
 8005852:	687b      	ldr	r3, [r7, #4]
 8005854:	6a1b      	ldr	r3, [r3, #32]
 8005856:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800585a:	ea42 0103 	orr.w	r1, r2, r3
 800585e:	687b      	ldr	r3, [r7, #4]
 8005860:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005862:	f403 5200 	and.w	r2, r3, #8192	; 0x2000
 8005866:	687b      	ldr	r3, [r7, #4]
 8005868:	681b      	ldr	r3, [r3, #0]
 800586a:	430a      	orrs	r2, r1
 800586c:	601a      	str	r2, [r3, #0]
    }
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 800586e:	687b      	ldr	r3, [r7, #4]
 8005870:	699b      	ldr	r3, [r3, #24]
 8005872:	0c1b      	lsrs	r3, r3, #16
 8005874:	f003 0204 	and.w	r2, r3, #4
 8005878:	687b      	ldr	r3, [r7, #4]
 800587a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800587c:	f003 0310 	and.w	r3, r3, #16
 8005880:	431a      	orrs	r2, r3
 8005882:	687b      	ldr	r3, [r7, #4]
 8005884:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005886:	f003 0308 	and.w	r3, r3, #8
 800588a:	431a      	orrs	r2, r3
 800588c:	687b      	ldr	r3, [r7, #4]
 800588e:	68db      	ldr	r3, [r3, #12]
 8005890:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8005894:	ea42 0103 	orr.w	r1, r2, r3
 8005898:	68fb      	ldr	r3, [r7, #12]
 800589a:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
 800589e:	687b      	ldr	r3, [r7, #4]
 80058a0:	681b      	ldr	r3, [r3, #0]
 80058a2:	430a      	orrs	r2, r1
 80058a4:	605a      	str	r2, [r3, #4]
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80058a6:	687b      	ldr	r3, [r7, #4]
 80058a8:	2200      	movs	r2, #0
 80058aa:	661a      	str	r2, [r3, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 80058ac:	687b      	ldr	r3, [r7, #4]
 80058ae:	2201      	movs	r2, #1
 80058b0:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d

  return HAL_OK;
 80058b4:	2300      	movs	r3, #0
}
 80058b6:	4618      	mov	r0, r3
 80058b8:	3710      	adds	r7, #16
 80058ba:	46bd      	mov	sp, r7
 80058bc:	bd80      	pop	{r7, pc}

080058be <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 80058be:	b580      	push	{r7, lr}
 80058c0:	b082      	sub	sp, #8
 80058c2:	af00      	add	r7, sp, #0
 80058c4:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 80058c6:	687b      	ldr	r3, [r7, #4]
 80058c8:	2b00      	cmp	r3, #0
 80058ca:	d101      	bne.n	80058d0 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 80058cc:	2301      	movs	r3, #1
 80058ce:	e049      	b.n	8005964 <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 80058d0:	687b      	ldr	r3, [r7, #4]
 80058d2:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 80058d6:	b2db      	uxtb	r3, r3
 80058d8:	2b00      	cmp	r3, #0
 80058da:	d106      	bne.n	80058ea <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 80058dc:	687b      	ldr	r3, [r7, #4]
 80058de:	2200      	movs	r2, #0
 80058e0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 80058e4:	6878      	ldr	r0, [r7, #4]
 80058e6:	f000 f841 	bl	800596c <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 80058ea:	687b      	ldr	r3, [r7, #4]
 80058ec:	2202      	movs	r2, #2
 80058ee:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80058f2:	687b      	ldr	r3, [r7, #4]
 80058f4:	681a      	ldr	r2, [r3, #0]
 80058f6:	687b      	ldr	r3, [r7, #4]
 80058f8:	3304      	adds	r3, #4
 80058fa:	4619      	mov	r1, r3
 80058fc:	4610      	mov	r0, r2
 80058fe:	f000 f9d5 	bl	8005cac <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8005902:	687b      	ldr	r3, [r7, #4]
 8005904:	2201      	movs	r2, #1
 8005906:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800590a:	687b      	ldr	r3, [r7, #4]
 800590c:	2201      	movs	r2, #1
 800590e:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8005912:	687b      	ldr	r3, [r7, #4]
 8005914:	2201      	movs	r2, #1
 8005916:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 800591a:	687b      	ldr	r3, [r7, #4]
 800591c:	2201      	movs	r2, #1
 800591e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8005922:	687b      	ldr	r3, [r7, #4]
 8005924:	2201      	movs	r2, #1
 8005926:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 800592a:	687b      	ldr	r3, [r7, #4]
 800592c:	2201      	movs	r2, #1
 800592e:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8005932:	687b      	ldr	r3, [r7, #4]
 8005934:	2201      	movs	r2, #1
 8005936:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800593a:	687b      	ldr	r3, [r7, #4]
 800593c:	2201      	movs	r2, #1
 800593e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8005942:	687b      	ldr	r3, [r7, #4]
 8005944:	2201      	movs	r2, #1
 8005946:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800594a:	687b      	ldr	r3, [r7, #4]
 800594c:	2201      	movs	r2, #1
 800594e:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 8005952:	687b      	ldr	r3, [r7, #4]
 8005954:	2201      	movs	r2, #1
 8005956:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800595a:	687b      	ldr	r3, [r7, #4]
 800595c:	2201      	movs	r2, #1
 800595e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 8005962:	2300      	movs	r3, #0
}
 8005964:	4618      	mov	r0, r3
 8005966:	3708      	adds	r7, #8
 8005968:	46bd      	mov	sp, r7
 800596a:	bd80      	pop	{r7, pc}

0800596c <HAL_TIM_Base_MspInit>:
  * @brief  Initializes the TIM Base MSP.
  * @param  htim TIM Base handle
  * @retval None
  */
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
 800596c:	b480      	push	{r7}
 800596e:	b083      	sub	sp, #12
 8005970:	af00      	add	r7, sp, #0
 8005972:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 8005974:	bf00      	nop
 8005976:	370c      	adds	r7, #12
 8005978:	46bd      	mov	sp, r7
 800597a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800597e:	4770      	bx	lr

08005980 <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 8005980:	b480      	push	{r7}
 8005982:	b085      	sub	sp, #20
 8005984:	af00      	add	r7, sp, #0
 8005986:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 8005988:	687b      	ldr	r3, [r7, #4]
 800598a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800598e:	b2db      	uxtb	r3, r3
 8005990:	2b01      	cmp	r3, #1
 8005992:	d001      	beq.n	8005998 <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
 8005994:	2301      	movs	r3, #1
 8005996:	e036      	b.n	8005a06 <HAL_TIM_Base_Start_IT+0x86>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8005998:	687b      	ldr	r3, [r7, #4]
 800599a:	2202      	movs	r2, #2
 800599c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80059a0:	687b      	ldr	r3, [r7, #4]
 80059a2:	681b      	ldr	r3, [r3, #0]
 80059a4:	68da      	ldr	r2, [r3, #12]
 80059a6:	687b      	ldr	r3, [r7, #4]
 80059a8:	681b      	ldr	r3, [r3, #0]
 80059aa:	f042 0201 	orr.w	r2, r2, #1
 80059ae:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80059b0:	687b      	ldr	r3, [r7, #4]
 80059b2:	681b      	ldr	r3, [r3, #0]
 80059b4:	4a17      	ldr	r2, [pc, #92]	; (8005a14 <HAL_TIM_Base_Start_IT+0x94>)
 80059b6:	4293      	cmp	r3, r2
 80059b8:	d004      	beq.n	80059c4 <HAL_TIM_Base_Start_IT+0x44>
 80059ba:	687b      	ldr	r3, [r7, #4]
 80059bc:	681b      	ldr	r3, [r3, #0]
 80059be:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80059c2:	d115      	bne.n	80059f0 <HAL_TIM_Base_Start_IT+0x70>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80059c4:	687b      	ldr	r3, [r7, #4]
 80059c6:	681b      	ldr	r3, [r3, #0]
 80059c8:	689a      	ldr	r2, [r3, #8]
 80059ca:	4b13      	ldr	r3, [pc, #76]	; (8005a18 <HAL_TIM_Base_Start_IT+0x98>)
 80059cc:	4013      	ands	r3, r2
 80059ce:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80059d0:	68fb      	ldr	r3, [r7, #12]
 80059d2:	2b06      	cmp	r3, #6
 80059d4:	d015      	beq.n	8005a02 <HAL_TIM_Base_Start_IT+0x82>
 80059d6:	68fb      	ldr	r3, [r7, #12]
 80059d8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80059dc:	d011      	beq.n	8005a02 <HAL_TIM_Base_Start_IT+0x82>
    {
      __HAL_TIM_ENABLE(htim);
 80059de:	687b      	ldr	r3, [r7, #4]
 80059e0:	681b      	ldr	r3, [r3, #0]
 80059e2:	681a      	ldr	r2, [r3, #0]
 80059e4:	687b      	ldr	r3, [r7, #4]
 80059e6:	681b      	ldr	r3, [r3, #0]
 80059e8:	f042 0201 	orr.w	r2, r2, #1
 80059ec:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80059ee:	e008      	b.n	8005a02 <HAL_TIM_Base_Start_IT+0x82>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 80059f0:	687b      	ldr	r3, [r7, #4]
 80059f2:	681b      	ldr	r3, [r3, #0]
 80059f4:	681a      	ldr	r2, [r3, #0]
 80059f6:	687b      	ldr	r3, [r7, #4]
 80059f8:	681b      	ldr	r3, [r3, #0]
 80059fa:	f042 0201 	orr.w	r2, r2, #1
 80059fe:	601a      	str	r2, [r3, #0]
 8005a00:	e000      	b.n	8005a04 <HAL_TIM_Base_Start_IT+0x84>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8005a02:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 8005a04:	2300      	movs	r3, #0
}
 8005a06:	4618      	mov	r0, r3
 8005a08:	3714      	adds	r7, #20
 8005a0a:	46bd      	mov	sp, r7
 8005a0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a10:	4770      	bx	lr
 8005a12:	bf00      	nop
 8005a14:	40012c00 	.word	0x40012c00
 8005a18:	00010007 	.word	0x00010007

08005a1c <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 8005a1c:	b580      	push	{r7, lr}
 8005a1e:	b082      	sub	sp, #8
 8005a20:	af00      	add	r7, sp, #0
 8005a22:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8005a24:	687b      	ldr	r3, [r7, #4]
 8005a26:	681b      	ldr	r3, [r3, #0]
 8005a28:	691b      	ldr	r3, [r3, #16]
 8005a2a:	f003 0302 	and.w	r3, r3, #2
 8005a2e:	2b02      	cmp	r3, #2
 8005a30:	d122      	bne.n	8005a78 <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8005a32:	687b      	ldr	r3, [r7, #4]
 8005a34:	681b      	ldr	r3, [r3, #0]
 8005a36:	68db      	ldr	r3, [r3, #12]
 8005a38:	f003 0302 	and.w	r3, r3, #2
 8005a3c:	2b02      	cmp	r3, #2
 8005a3e:	d11b      	bne.n	8005a78 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8005a40:	687b      	ldr	r3, [r7, #4]
 8005a42:	681b      	ldr	r3, [r3, #0]
 8005a44:	f06f 0202 	mvn.w	r2, #2
 8005a48:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8005a4a:	687b      	ldr	r3, [r7, #4]
 8005a4c:	2201      	movs	r2, #1
 8005a4e:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8005a50:	687b      	ldr	r3, [r7, #4]
 8005a52:	681b      	ldr	r3, [r3, #0]
 8005a54:	699b      	ldr	r3, [r3, #24]
 8005a56:	f003 0303 	and.w	r3, r3, #3
 8005a5a:	2b00      	cmp	r3, #0
 8005a5c:	d003      	beq.n	8005a66 <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8005a5e:	6878      	ldr	r0, [r7, #4]
 8005a60:	f000 f905 	bl	8005c6e <HAL_TIM_IC_CaptureCallback>
 8005a64:	e005      	b.n	8005a72 <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8005a66:	6878      	ldr	r0, [r7, #4]
 8005a68:	f000 f8f7 	bl	8005c5a <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005a6c:	6878      	ldr	r0, [r7, #4]
 8005a6e:	f000 f908 	bl	8005c82 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005a72:	687b      	ldr	r3, [r7, #4]
 8005a74:	2200      	movs	r2, #0
 8005a76:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8005a78:	687b      	ldr	r3, [r7, #4]
 8005a7a:	681b      	ldr	r3, [r3, #0]
 8005a7c:	691b      	ldr	r3, [r3, #16]
 8005a7e:	f003 0304 	and.w	r3, r3, #4
 8005a82:	2b04      	cmp	r3, #4
 8005a84:	d122      	bne.n	8005acc <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8005a86:	687b      	ldr	r3, [r7, #4]
 8005a88:	681b      	ldr	r3, [r3, #0]
 8005a8a:	68db      	ldr	r3, [r3, #12]
 8005a8c:	f003 0304 	and.w	r3, r3, #4
 8005a90:	2b04      	cmp	r3, #4
 8005a92:	d11b      	bne.n	8005acc <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8005a94:	687b      	ldr	r3, [r7, #4]
 8005a96:	681b      	ldr	r3, [r3, #0]
 8005a98:	f06f 0204 	mvn.w	r2, #4
 8005a9c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8005a9e:	687b      	ldr	r3, [r7, #4]
 8005aa0:	2202      	movs	r2, #2
 8005aa2:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8005aa4:	687b      	ldr	r3, [r7, #4]
 8005aa6:	681b      	ldr	r3, [r3, #0]
 8005aa8:	699b      	ldr	r3, [r3, #24]
 8005aaa:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005aae:	2b00      	cmp	r3, #0
 8005ab0:	d003      	beq.n	8005aba <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8005ab2:	6878      	ldr	r0, [r7, #4]
 8005ab4:	f000 f8db 	bl	8005c6e <HAL_TIM_IC_CaptureCallback>
 8005ab8:	e005      	b.n	8005ac6 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005aba:	6878      	ldr	r0, [r7, #4]
 8005abc:	f000 f8cd 	bl	8005c5a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005ac0:	6878      	ldr	r0, [r7, #4]
 8005ac2:	f000 f8de 	bl	8005c82 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005ac6:	687b      	ldr	r3, [r7, #4]
 8005ac8:	2200      	movs	r2, #0
 8005aca:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8005acc:	687b      	ldr	r3, [r7, #4]
 8005ace:	681b      	ldr	r3, [r3, #0]
 8005ad0:	691b      	ldr	r3, [r3, #16]
 8005ad2:	f003 0308 	and.w	r3, r3, #8
 8005ad6:	2b08      	cmp	r3, #8
 8005ad8:	d122      	bne.n	8005b20 <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8005ada:	687b      	ldr	r3, [r7, #4]
 8005adc:	681b      	ldr	r3, [r3, #0]
 8005ade:	68db      	ldr	r3, [r3, #12]
 8005ae0:	f003 0308 	and.w	r3, r3, #8
 8005ae4:	2b08      	cmp	r3, #8
 8005ae6:	d11b      	bne.n	8005b20 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8005ae8:	687b      	ldr	r3, [r7, #4]
 8005aea:	681b      	ldr	r3, [r3, #0]
 8005aec:	f06f 0208 	mvn.w	r2, #8
 8005af0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8005af2:	687b      	ldr	r3, [r7, #4]
 8005af4:	2204      	movs	r2, #4
 8005af6:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8005af8:	687b      	ldr	r3, [r7, #4]
 8005afa:	681b      	ldr	r3, [r3, #0]
 8005afc:	69db      	ldr	r3, [r3, #28]
 8005afe:	f003 0303 	and.w	r3, r3, #3
 8005b02:	2b00      	cmp	r3, #0
 8005b04:	d003      	beq.n	8005b0e <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8005b06:	6878      	ldr	r0, [r7, #4]
 8005b08:	f000 f8b1 	bl	8005c6e <HAL_TIM_IC_CaptureCallback>
 8005b0c:	e005      	b.n	8005b1a <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005b0e:	6878      	ldr	r0, [r7, #4]
 8005b10:	f000 f8a3 	bl	8005c5a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005b14:	6878      	ldr	r0, [r7, #4]
 8005b16:	f000 f8b4 	bl	8005c82 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005b1a:	687b      	ldr	r3, [r7, #4]
 8005b1c:	2200      	movs	r2, #0
 8005b1e:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8005b20:	687b      	ldr	r3, [r7, #4]
 8005b22:	681b      	ldr	r3, [r3, #0]
 8005b24:	691b      	ldr	r3, [r3, #16]
 8005b26:	f003 0310 	and.w	r3, r3, #16
 8005b2a:	2b10      	cmp	r3, #16
 8005b2c:	d122      	bne.n	8005b74 <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8005b2e:	687b      	ldr	r3, [r7, #4]
 8005b30:	681b      	ldr	r3, [r3, #0]
 8005b32:	68db      	ldr	r3, [r3, #12]
 8005b34:	f003 0310 	and.w	r3, r3, #16
 8005b38:	2b10      	cmp	r3, #16
 8005b3a:	d11b      	bne.n	8005b74 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8005b3c:	687b      	ldr	r3, [r7, #4]
 8005b3e:	681b      	ldr	r3, [r3, #0]
 8005b40:	f06f 0210 	mvn.w	r2, #16
 8005b44:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8005b46:	687b      	ldr	r3, [r7, #4]
 8005b48:	2208      	movs	r2, #8
 8005b4a:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8005b4c:	687b      	ldr	r3, [r7, #4]
 8005b4e:	681b      	ldr	r3, [r3, #0]
 8005b50:	69db      	ldr	r3, [r3, #28]
 8005b52:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005b56:	2b00      	cmp	r3, #0
 8005b58:	d003      	beq.n	8005b62 <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8005b5a:	6878      	ldr	r0, [r7, #4]
 8005b5c:	f000 f887 	bl	8005c6e <HAL_TIM_IC_CaptureCallback>
 8005b60:	e005      	b.n	8005b6e <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8005b62:	6878      	ldr	r0, [r7, #4]
 8005b64:	f000 f879 	bl	8005c5a <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8005b68:	6878      	ldr	r0, [r7, #4]
 8005b6a:	f000 f88a 	bl	8005c82 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8005b6e:	687b      	ldr	r3, [r7, #4]
 8005b70:	2200      	movs	r2, #0
 8005b72:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8005b74:	687b      	ldr	r3, [r7, #4]
 8005b76:	681b      	ldr	r3, [r3, #0]
 8005b78:	691b      	ldr	r3, [r3, #16]
 8005b7a:	f003 0301 	and.w	r3, r3, #1
 8005b7e:	2b01      	cmp	r3, #1
 8005b80:	d10e      	bne.n	8005ba0 <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8005b82:	687b      	ldr	r3, [r7, #4]
 8005b84:	681b      	ldr	r3, [r3, #0]
 8005b86:	68db      	ldr	r3, [r3, #12]
 8005b88:	f003 0301 	and.w	r3, r3, #1
 8005b8c:	2b01      	cmp	r3, #1
 8005b8e:	d107      	bne.n	8005ba0 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8005b90:	687b      	ldr	r3, [r7, #4]
 8005b92:	681b      	ldr	r3, [r3, #0]
 8005b94:	f06f 0201 	mvn.w	r2, #1
 8005b98:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8005b9a:	6878      	ldr	r0, [r7, #4]
 8005b9c:	f7fb fb92 	bl	80012c4 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8005ba0:	687b      	ldr	r3, [r7, #4]
 8005ba2:	681b      	ldr	r3, [r3, #0]
 8005ba4:	691b      	ldr	r3, [r3, #16]
 8005ba6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005baa:	2b80      	cmp	r3, #128	; 0x80
 8005bac:	d10e      	bne.n	8005bcc <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8005bae:	687b      	ldr	r3, [r7, #4]
 8005bb0:	681b      	ldr	r3, [r3, #0]
 8005bb2:	68db      	ldr	r3, [r3, #12]
 8005bb4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005bb8:	2b80      	cmp	r3, #128	; 0x80
 8005bba:	d107      	bne.n	8005bcc <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8005bbc:	687b      	ldr	r3, [r7, #4]
 8005bbe:	681b      	ldr	r3, [r3, #0]
 8005bc0:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8005bc4:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8005bc6:	6878      	ldr	r0, [r7, #4]
 8005bc8:	f000 f8de 	bl	8005d88 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8005bcc:	687b      	ldr	r3, [r7, #4]
 8005bce:	681b      	ldr	r3, [r3, #0]
 8005bd0:	691b      	ldr	r3, [r3, #16]
 8005bd2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005bd6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005bda:	d10e      	bne.n	8005bfa <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8005bdc:	687b      	ldr	r3, [r7, #4]
 8005bde:	681b      	ldr	r3, [r3, #0]
 8005be0:	68db      	ldr	r3, [r3, #12]
 8005be2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005be6:	2b80      	cmp	r3, #128	; 0x80
 8005be8:	d107      	bne.n	8005bfa <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8005bea:	687b      	ldr	r3, [r7, #4]
 8005bec:	681b      	ldr	r3, [r3, #0]
 8005bee:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8005bf2:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 8005bf4:	6878      	ldr	r0, [r7, #4]
 8005bf6:	f000 f8d1 	bl	8005d9c <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8005bfa:	687b      	ldr	r3, [r7, #4]
 8005bfc:	681b      	ldr	r3, [r3, #0]
 8005bfe:	691b      	ldr	r3, [r3, #16]
 8005c00:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005c04:	2b40      	cmp	r3, #64	; 0x40
 8005c06:	d10e      	bne.n	8005c26 <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8005c08:	687b      	ldr	r3, [r7, #4]
 8005c0a:	681b      	ldr	r3, [r3, #0]
 8005c0c:	68db      	ldr	r3, [r3, #12]
 8005c0e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005c12:	2b40      	cmp	r3, #64	; 0x40
 8005c14:	d107      	bne.n	8005c26 <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8005c16:	687b      	ldr	r3, [r7, #4]
 8005c18:	681b      	ldr	r3, [r3, #0]
 8005c1a:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8005c1e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 8005c20:	6878      	ldr	r0, [r7, #4]
 8005c22:	f000 f838 	bl	8005c96 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8005c26:	687b      	ldr	r3, [r7, #4]
 8005c28:	681b      	ldr	r3, [r3, #0]
 8005c2a:	691b      	ldr	r3, [r3, #16]
 8005c2c:	f003 0320 	and.w	r3, r3, #32
 8005c30:	2b20      	cmp	r3, #32
 8005c32:	d10e      	bne.n	8005c52 <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8005c34:	687b      	ldr	r3, [r7, #4]
 8005c36:	681b      	ldr	r3, [r3, #0]
 8005c38:	68db      	ldr	r3, [r3, #12]
 8005c3a:	f003 0320 	and.w	r3, r3, #32
 8005c3e:	2b20      	cmp	r3, #32
 8005c40:	d107      	bne.n	8005c52 <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8005c42:	687b      	ldr	r3, [r7, #4]
 8005c44:	681b      	ldr	r3, [r3, #0]
 8005c46:	f06f 0220 	mvn.w	r2, #32
 8005c4a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 8005c4c:	6878      	ldr	r0, [r7, #4]
 8005c4e:	f000 f891 	bl	8005d74 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8005c52:	bf00      	nop
 8005c54:	3708      	adds	r7, #8
 8005c56:	46bd      	mov	sp, r7
 8005c58:	bd80      	pop	{r7, pc}

08005c5a <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 8005c5a:	b480      	push	{r7}
 8005c5c:	b083      	sub	sp, #12
 8005c5e:	af00      	add	r7, sp, #0
 8005c60:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8005c62:	bf00      	nop
 8005c64:	370c      	adds	r7, #12
 8005c66:	46bd      	mov	sp, r7
 8005c68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005c6c:	4770      	bx	lr

08005c6e <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8005c6e:	b480      	push	{r7}
 8005c70:	b083      	sub	sp, #12
 8005c72:	af00      	add	r7, sp, #0
 8005c74:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8005c76:	bf00      	nop
 8005c78:	370c      	adds	r7, #12
 8005c7a:	46bd      	mov	sp, r7
 8005c7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005c80:	4770      	bx	lr

08005c82 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 8005c82:	b480      	push	{r7}
 8005c84:	b083      	sub	sp, #12
 8005c86:	af00      	add	r7, sp, #0
 8005c88:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8005c8a:	bf00      	nop
 8005c8c:	370c      	adds	r7, #12
 8005c8e:	46bd      	mov	sp, r7
 8005c90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005c94:	4770      	bx	lr

08005c96 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 8005c96:	b480      	push	{r7}
 8005c98:	b083      	sub	sp, #12
 8005c9a:	af00      	add	r7, sp, #0
 8005c9c:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8005c9e:	bf00      	nop
 8005ca0:	370c      	adds	r7, #12
 8005ca2:	46bd      	mov	sp, r7
 8005ca4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ca8:	4770      	bx	lr
	...

08005cac <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
 8005cac:	b480      	push	{r7}
 8005cae:	b085      	sub	sp, #20
 8005cb0:	af00      	add	r7, sp, #0
 8005cb2:	6078      	str	r0, [r7, #4]
 8005cb4:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 8005cb6:	687b      	ldr	r3, [r7, #4]
 8005cb8:	681b      	ldr	r3, [r3, #0]
 8005cba:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8005cbc:	687b      	ldr	r3, [r7, #4]
 8005cbe:	4a2a      	ldr	r2, [pc, #168]	; (8005d68 <TIM_Base_SetConfig+0xbc>)
 8005cc0:	4293      	cmp	r3, r2
 8005cc2:	d003      	beq.n	8005ccc <TIM_Base_SetConfig+0x20>
 8005cc4:	687b      	ldr	r3, [r7, #4]
 8005cc6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005cca:	d108      	bne.n	8005cde <TIM_Base_SetConfig+0x32>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8005ccc:	68fb      	ldr	r3, [r7, #12]
 8005cce:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8005cd2:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 8005cd4:	683b      	ldr	r3, [r7, #0]
 8005cd6:	685b      	ldr	r3, [r3, #4]
 8005cd8:	68fa      	ldr	r2, [r7, #12]
 8005cda:	4313      	orrs	r3, r2
 8005cdc:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8005cde:	687b      	ldr	r3, [r7, #4]
 8005ce0:	4a21      	ldr	r2, [pc, #132]	; (8005d68 <TIM_Base_SetConfig+0xbc>)
 8005ce2:	4293      	cmp	r3, r2
 8005ce4:	d00b      	beq.n	8005cfe <TIM_Base_SetConfig+0x52>
 8005ce6:	687b      	ldr	r3, [r7, #4]
 8005ce8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005cec:	d007      	beq.n	8005cfe <TIM_Base_SetConfig+0x52>
 8005cee:	687b      	ldr	r3, [r7, #4]
 8005cf0:	4a1e      	ldr	r2, [pc, #120]	; (8005d6c <TIM_Base_SetConfig+0xc0>)
 8005cf2:	4293      	cmp	r3, r2
 8005cf4:	d003      	beq.n	8005cfe <TIM_Base_SetConfig+0x52>
 8005cf6:	687b      	ldr	r3, [r7, #4]
 8005cf8:	4a1d      	ldr	r2, [pc, #116]	; (8005d70 <TIM_Base_SetConfig+0xc4>)
 8005cfa:	4293      	cmp	r3, r2
 8005cfc:	d108      	bne.n	8005d10 <TIM_Base_SetConfig+0x64>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8005cfe:	68fb      	ldr	r3, [r7, #12]
 8005d00:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8005d04:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8005d06:	683b      	ldr	r3, [r7, #0]
 8005d08:	68db      	ldr	r3, [r3, #12]
 8005d0a:	68fa      	ldr	r2, [r7, #12]
 8005d0c:	4313      	orrs	r3, r2
 8005d0e:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8005d10:	68fb      	ldr	r3, [r7, #12]
 8005d12:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8005d16:	683b      	ldr	r3, [r7, #0]
 8005d18:	695b      	ldr	r3, [r3, #20]
 8005d1a:	4313      	orrs	r3, r2
 8005d1c:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 8005d1e:	687b      	ldr	r3, [r7, #4]
 8005d20:	68fa      	ldr	r2, [r7, #12]
 8005d22:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8005d24:	683b      	ldr	r3, [r7, #0]
 8005d26:	689a      	ldr	r2, [r3, #8]
 8005d28:	687b      	ldr	r3, [r7, #4]
 8005d2a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8005d2c:	683b      	ldr	r3, [r7, #0]
 8005d2e:	681a      	ldr	r2, [r3, #0]
 8005d30:	687b      	ldr	r3, [r7, #4]
 8005d32:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8005d34:	687b      	ldr	r3, [r7, #4]
 8005d36:	4a0c      	ldr	r2, [pc, #48]	; (8005d68 <TIM_Base_SetConfig+0xbc>)
 8005d38:	4293      	cmp	r3, r2
 8005d3a:	d007      	beq.n	8005d4c <TIM_Base_SetConfig+0xa0>
 8005d3c:	687b      	ldr	r3, [r7, #4]
 8005d3e:	4a0b      	ldr	r2, [pc, #44]	; (8005d6c <TIM_Base_SetConfig+0xc0>)
 8005d40:	4293      	cmp	r3, r2
 8005d42:	d003      	beq.n	8005d4c <TIM_Base_SetConfig+0xa0>
 8005d44:	687b      	ldr	r3, [r7, #4]
 8005d46:	4a0a      	ldr	r2, [pc, #40]	; (8005d70 <TIM_Base_SetConfig+0xc4>)
 8005d48:	4293      	cmp	r3, r2
 8005d4a:	d103      	bne.n	8005d54 <TIM_Base_SetConfig+0xa8>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8005d4c:	683b      	ldr	r3, [r7, #0]
 8005d4e:	691a      	ldr	r2, [r3, #16]
 8005d50:	687b      	ldr	r3, [r7, #4]
 8005d52:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8005d54:	687b      	ldr	r3, [r7, #4]
 8005d56:	2201      	movs	r2, #1
 8005d58:	615a      	str	r2, [r3, #20]
}
 8005d5a:	bf00      	nop
 8005d5c:	3714      	adds	r7, #20
 8005d5e:	46bd      	mov	sp, r7
 8005d60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d64:	4770      	bx	lr
 8005d66:	bf00      	nop
 8005d68:	40012c00 	.word	0x40012c00
 8005d6c:	40014400 	.word	0x40014400
 8005d70:	40014800 	.word	0x40014800

08005d74 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 8005d74:	b480      	push	{r7}
 8005d76:	b083      	sub	sp, #12
 8005d78:	af00      	add	r7, sp, #0
 8005d7a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8005d7c:	bf00      	nop
 8005d7e:	370c      	adds	r7, #12
 8005d80:	46bd      	mov	sp, r7
 8005d82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d86:	4770      	bx	lr

08005d88 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8005d88:	b480      	push	{r7}
 8005d8a:	b083      	sub	sp, #12
 8005d8c:	af00      	add	r7, sp, #0
 8005d8e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8005d90:	bf00      	nop
 8005d92:	370c      	adds	r7, #12
 8005d94:	46bd      	mov	sp, r7
 8005d96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d9a:	4770      	bx	lr

08005d9c <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 8005d9c:	b480      	push	{r7}
 8005d9e:	b083      	sub	sp, #12
 8005da0:	af00      	add	r7, sp, #0
 8005da2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8005da4:	bf00      	nop
 8005da6:	370c      	adds	r7, #12
 8005da8:	46bd      	mov	sp, r7
 8005daa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005dae:	4770      	bx	lr

08005db0 <LL_RCC_GetUSARTClockSource>:
{
 8005db0:	b480      	push	{r7}
 8005db2:	b083      	sub	sp, #12
 8005db4:	af00      	add	r7, sp, #0
 8005db6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx));
 8005db8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005dbc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8005dc0:	687b      	ldr	r3, [r7, #4]
 8005dc2:	4013      	ands	r3, r2
}
 8005dc4:	4618      	mov	r0, r3
 8005dc6:	370c      	adds	r7, #12
 8005dc8:	46bd      	mov	sp, r7
 8005dca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005dce:	4770      	bx	lr

08005dd0 <LL_RCC_GetLPUARTClockSource>:
{
 8005dd0:	b480      	push	{r7}
 8005dd2:	b083      	sub	sp, #12
 8005dd4:	af00      	add	r7, sp, #0
 8005dd6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
 8005dd8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005ddc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8005de0:	687b      	ldr	r3, [r7, #4]
 8005de2:	4013      	ands	r3, r2
}
 8005de4:	4618      	mov	r0, r3
 8005de6:	370c      	adds	r7, #12
 8005de8:	46bd      	mov	sp, r7
 8005dea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005dee:	4770      	bx	lr

08005df0 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8005df0:	b580      	push	{r7, lr}
 8005df2:	b082      	sub	sp, #8
 8005df4:	af00      	add	r7, sp, #0
 8005df6:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 8005df8:	687b      	ldr	r3, [r7, #4]
 8005dfa:	2b00      	cmp	r3, #0
 8005dfc:	d101      	bne.n	8005e02 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 8005dfe:	2301      	movs	r3, #1
 8005e00:	e042      	b.n	8005e88 <HAL_UART_Init+0x98>
#else
    assert_param(IS_UART_INSTANCE(huart->Instance));
#endif /* LPUART1 */
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 8005e02:	687b      	ldr	r3, [r7, #4]
 8005e04:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005e08:	2b00      	cmp	r3, #0
 8005e0a:	d106      	bne.n	8005e1a <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8005e0c:	687b      	ldr	r3, [r7, #4]
 8005e0e:	2200      	movs	r2, #0
 8005e10:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8005e14:	6878      	ldr	r0, [r7, #4]
 8005e16:	f7fc f843 	bl	8001ea0 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8005e1a:	687b      	ldr	r3, [r7, #4]
 8005e1c:	2224      	movs	r2, #36	; 0x24
 8005e1e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  __HAL_UART_DISABLE(huart);
 8005e22:	687b      	ldr	r3, [r7, #4]
 8005e24:	681b      	ldr	r3, [r3, #0]
 8005e26:	681a      	ldr	r2, [r3, #0]
 8005e28:	687b      	ldr	r3, [r7, #4]
 8005e2a:	681b      	ldr	r3, [r3, #0]
 8005e2c:	f022 0201 	bic.w	r2, r2, #1
 8005e30:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 8005e32:	6878      	ldr	r0, [r7, #4]
 8005e34:	f000 f82c 	bl	8005e90 <UART_SetConfig>
 8005e38:	4603      	mov	r3, r0
 8005e3a:	2b01      	cmp	r3, #1
 8005e3c:	d101      	bne.n	8005e42 <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 8005e3e:	2301      	movs	r3, #1
 8005e40:	e022      	b.n	8005e88 <HAL_UART_Init+0x98>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8005e42:	687b      	ldr	r3, [r7, #4]
 8005e44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005e46:	2b00      	cmp	r3, #0
 8005e48:	d002      	beq.n	8005e50 <HAL_UART_Init+0x60>
  {
    UART_AdvFeatureConfig(huart);
 8005e4a:	6878      	ldr	r0, [r7, #4]
 8005e4c:	f000 fa48 	bl	80062e0 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8005e50:	687b      	ldr	r3, [r7, #4]
 8005e52:	681b      	ldr	r3, [r3, #0]
 8005e54:	685a      	ldr	r2, [r3, #4]
 8005e56:	687b      	ldr	r3, [r7, #4]
 8005e58:	681b      	ldr	r3, [r3, #0]
 8005e5a:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8005e5e:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8005e60:	687b      	ldr	r3, [r7, #4]
 8005e62:	681b      	ldr	r3, [r3, #0]
 8005e64:	689a      	ldr	r2, [r3, #8]
 8005e66:	687b      	ldr	r3, [r7, #4]
 8005e68:	681b      	ldr	r3, [r3, #0]
 8005e6a:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8005e6e:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 8005e70:	687b      	ldr	r3, [r7, #4]
 8005e72:	681b      	ldr	r3, [r3, #0]
 8005e74:	681a      	ldr	r2, [r3, #0]
 8005e76:	687b      	ldr	r3, [r7, #4]
 8005e78:	681b      	ldr	r3, [r3, #0]
 8005e7a:	f042 0201 	orr.w	r2, r2, #1
 8005e7e:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8005e80:	6878      	ldr	r0, [r7, #4]
 8005e82:	f000 facf 	bl	8006424 <UART_CheckIdleState>
 8005e86:	4603      	mov	r3, r0
}
 8005e88:	4618      	mov	r0, r3
 8005e8a:	3708      	adds	r7, #8
 8005e8c:	46bd      	mov	sp, r7
 8005e8e:	bd80      	pop	{r7, pc}

08005e90 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8005e90:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8005e94:	b08c      	sub	sp, #48	; 0x30
 8005e96:	af00      	add	r7, sp, #0
 8005e98:	6178      	str	r0, [r7, #20]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 8005e9a:	2300      	movs	r3, #0
 8005e9c:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8005ea0:	697b      	ldr	r3, [r7, #20]
 8005ea2:	689a      	ldr	r2, [r3, #8]
 8005ea4:	697b      	ldr	r3, [r7, #20]
 8005ea6:	691b      	ldr	r3, [r3, #16]
 8005ea8:	431a      	orrs	r2, r3
 8005eaa:	697b      	ldr	r3, [r7, #20]
 8005eac:	695b      	ldr	r3, [r3, #20]
 8005eae:	431a      	orrs	r2, r3
 8005eb0:	697b      	ldr	r3, [r7, #20]
 8005eb2:	69db      	ldr	r3, [r3, #28]
 8005eb4:	4313      	orrs	r3, r2
 8005eb6:	62fb      	str	r3, [r7, #44]	; 0x2c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8005eb8:	697b      	ldr	r3, [r7, #20]
 8005eba:	681b      	ldr	r3, [r3, #0]
 8005ebc:	681a      	ldr	r2, [r3, #0]
 8005ebe:	4baf      	ldr	r3, [pc, #700]	; (800617c <UART_SetConfig+0x2ec>)
 8005ec0:	4013      	ands	r3, r2
 8005ec2:	697a      	ldr	r2, [r7, #20]
 8005ec4:	6812      	ldr	r2, [r2, #0]
 8005ec6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005ec8:	430b      	orrs	r3, r1
 8005eca:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8005ecc:	697b      	ldr	r3, [r7, #20]
 8005ece:	681b      	ldr	r3, [r3, #0]
 8005ed0:	685b      	ldr	r3, [r3, #4]
 8005ed2:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8005ed6:	697b      	ldr	r3, [r7, #20]
 8005ed8:	68da      	ldr	r2, [r3, #12]
 8005eda:	697b      	ldr	r3, [r7, #20]
 8005edc:	681b      	ldr	r3, [r3, #0]
 8005ede:	430a      	orrs	r2, r1
 8005ee0:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8005ee2:	697b      	ldr	r3, [r7, #20]
 8005ee4:	699b      	ldr	r3, [r3, #24]
 8005ee6:	62fb      	str	r3, [r7, #44]	; 0x2c

#if defined(LPUART1)
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8005ee8:	697b      	ldr	r3, [r7, #20]
 8005eea:	681b      	ldr	r3, [r3, #0]
 8005eec:	4aa4      	ldr	r2, [pc, #656]	; (8006180 <UART_SetConfig+0x2f0>)
 8005eee:	4293      	cmp	r3, r2
 8005ef0:	d004      	beq.n	8005efc <UART_SetConfig+0x6c>
  {
    tmpreg |= huart->Init.OneBitSampling;
 8005ef2:	697b      	ldr	r3, [r7, #20]
 8005ef4:	6a1b      	ldr	r3, [r3, #32]
 8005ef6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8005ef8:	4313      	orrs	r3, r2
 8005efa:	62fb      	str	r3, [r7, #44]	; 0x2c
  }
#else
  tmpreg |= huart->Init.OneBitSampling;
#endif /* LPUART1 */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8005efc:	697b      	ldr	r3, [r7, #20]
 8005efe:	681b      	ldr	r3, [r3, #0]
 8005f00:	689b      	ldr	r3, [r3, #8]
 8005f02:	f023 436e 	bic.w	r3, r3, #3992977408	; 0xee000000
 8005f06:	f423 6330 	bic.w	r3, r3, #2816	; 0xb00
 8005f0a:	697a      	ldr	r2, [r7, #20]
 8005f0c:	6812      	ldr	r2, [r2, #0]
 8005f0e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8005f10:	430b      	orrs	r3, r1
 8005f12:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8005f14:	697b      	ldr	r3, [r7, #20]
 8005f16:	681b      	ldr	r3, [r3, #0]
 8005f18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005f1a:	f023 010f 	bic.w	r1, r3, #15
 8005f1e:	697b      	ldr	r3, [r7, #20]
 8005f20:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005f22:	697b      	ldr	r3, [r7, #20]
 8005f24:	681b      	ldr	r3, [r3, #0]
 8005f26:	430a      	orrs	r2, r1
 8005f28:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8005f2a:	697b      	ldr	r3, [r7, #20]
 8005f2c:	681b      	ldr	r3, [r3, #0]
 8005f2e:	4a95      	ldr	r2, [pc, #596]	; (8006184 <UART_SetConfig+0x2f4>)
 8005f30:	4293      	cmp	r3, r2
 8005f32:	d125      	bne.n	8005f80 <UART_SetConfig+0xf0>
 8005f34:	2003      	movs	r0, #3
 8005f36:	f7ff ff3b 	bl	8005db0 <LL_RCC_GetUSARTClockSource>
 8005f3a:	4603      	mov	r3, r0
 8005f3c:	2b03      	cmp	r3, #3
 8005f3e:	d81b      	bhi.n	8005f78 <UART_SetConfig+0xe8>
 8005f40:	a201      	add	r2, pc, #4	; (adr r2, 8005f48 <UART_SetConfig+0xb8>)
 8005f42:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005f46:	bf00      	nop
 8005f48:	08005f59 	.word	0x08005f59
 8005f4c:	08005f69 	.word	0x08005f69
 8005f50:	08005f61 	.word	0x08005f61
 8005f54:	08005f71 	.word	0x08005f71
 8005f58:	2301      	movs	r3, #1
 8005f5a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8005f5e:	e042      	b.n	8005fe6 <UART_SetConfig+0x156>
 8005f60:	2302      	movs	r3, #2
 8005f62:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8005f66:	e03e      	b.n	8005fe6 <UART_SetConfig+0x156>
 8005f68:	2304      	movs	r3, #4
 8005f6a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8005f6e:	e03a      	b.n	8005fe6 <UART_SetConfig+0x156>
 8005f70:	2308      	movs	r3, #8
 8005f72:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8005f76:	e036      	b.n	8005fe6 <UART_SetConfig+0x156>
 8005f78:	2310      	movs	r3, #16
 8005f7a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8005f7e:	e032      	b.n	8005fe6 <UART_SetConfig+0x156>
 8005f80:	697b      	ldr	r3, [r7, #20]
 8005f82:	681b      	ldr	r3, [r3, #0]
 8005f84:	4a7e      	ldr	r2, [pc, #504]	; (8006180 <UART_SetConfig+0x2f0>)
 8005f86:	4293      	cmp	r3, r2
 8005f88:	d12a      	bne.n	8005fe0 <UART_SetConfig+0x150>
 8005f8a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8005f8e:	f7ff ff1f 	bl	8005dd0 <LL_RCC_GetLPUARTClockSource>
 8005f92:	4603      	mov	r3, r0
 8005f94:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8005f98:	d01a      	beq.n	8005fd0 <UART_SetConfig+0x140>
 8005f9a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8005f9e:	d81b      	bhi.n	8005fd8 <UART_SetConfig+0x148>
 8005fa0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8005fa4:	d00c      	beq.n	8005fc0 <UART_SetConfig+0x130>
 8005fa6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8005faa:	d815      	bhi.n	8005fd8 <UART_SetConfig+0x148>
 8005fac:	2b00      	cmp	r3, #0
 8005fae:	d003      	beq.n	8005fb8 <UART_SetConfig+0x128>
 8005fb0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005fb4:	d008      	beq.n	8005fc8 <UART_SetConfig+0x138>
 8005fb6:	e00f      	b.n	8005fd8 <UART_SetConfig+0x148>
 8005fb8:	2300      	movs	r3, #0
 8005fba:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8005fbe:	e012      	b.n	8005fe6 <UART_SetConfig+0x156>
 8005fc0:	2302      	movs	r3, #2
 8005fc2:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8005fc6:	e00e      	b.n	8005fe6 <UART_SetConfig+0x156>
 8005fc8:	2304      	movs	r3, #4
 8005fca:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8005fce:	e00a      	b.n	8005fe6 <UART_SetConfig+0x156>
 8005fd0:	2308      	movs	r3, #8
 8005fd2:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8005fd6:	e006      	b.n	8005fe6 <UART_SetConfig+0x156>
 8005fd8:	2310      	movs	r3, #16
 8005fda:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 8005fde:	e002      	b.n	8005fe6 <UART_SetConfig+0x156>
 8005fe0:	2310      	movs	r3, #16
 8005fe2:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

#if defined(LPUART1)
  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 8005fe6:	697b      	ldr	r3, [r7, #20]
 8005fe8:	681b      	ldr	r3, [r3, #0]
 8005fea:	4a65      	ldr	r2, [pc, #404]	; (8006180 <UART_SetConfig+0x2f0>)
 8005fec:	4293      	cmp	r3, r2
 8005fee:	f040 8097 	bne.w	8006120 <UART_SetConfig+0x290>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 8005ff2:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8005ff6:	2b08      	cmp	r3, #8
 8005ff8:	d823      	bhi.n	8006042 <UART_SetConfig+0x1b2>
 8005ffa:	a201      	add	r2, pc, #4	; (adr r2, 8006000 <UART_SetConfig+0x170>)
 8005ffc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006000:	08006025 	.word	0x08006025
 8006004:	08006043 	.word	0x08006043
 8006008:	0800602d 	.word	0x0800602d
 800600c:	08006043 	.word	0x08006043
 8006010:	08006033 	.word	0x08006033
 8006014:	08006043 	.word	0x08006043
 8006018:	08006043 	.word	0x08006043
 800601c:	08006043 	.word	0x08006043
 8006020:	0800603b 	.word	0x0800603b
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 8006024:	f7fe fe72 	bl	8004d0c <HAL_RCC_GetPCLK1Freq>
 8006028:	6278      	str	r0, [r7, #36]	; 0x24
        break;
 800602a:	e010      	b.n	800604e <UART_SetConfig+0x1be>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 800602c:	4b56      	ldr	r3, [pc, #344]	; (8006188 <UART_SetConfig+0x2f8>)
 800602e:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8006030:	e00d      	b.n	800604e <UART_SetConfig+0x1be>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8006032:	f7fe fdeb 	bl	8004c0c <HAL_RCC_GetSysClockFreq>
 8006036:	6278      	str	r0, [r7, #36]	; 0x24
        break;
 8006038:	e009      	b.n	800604e <UART_SetConfig+0x1be>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800603a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800603e:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8006040:	e005      	b.n	800604e <UART_SetConfig+0x1be>
      default:
        pclk = 0U;
 8006042:	2300      	movs	r3, #0
 8006044:	627b      	str	r3, [r7, #36]	; 0x24
        ret = HAL_ERROR;
 8006046:	2301      	movs	r3, #1
 8006048:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
        break;
 800604c:	bf00      	nop
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 800604e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006050:	2b00      	cmp	r3, #0
 8006052:	f000 812b 	beq.w	80062ac <UART_SetConfig+0x41c>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8006056:	697b      	ldr	r3, [r7, #20]
 8006058:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800605a:	4a4c      	ldr	r2, [pc, #304]	; (800618c <UART_SetConfig+0x2fc>)
 800605c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8006060:	461a      	mov	r2, r3
 8006062:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006064:	fbb3 f3f2 	udiv	r3, r3, r2
 8006068:	61bb      	str	r3, [r7, #24]

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800606a:	697b      	ldr	r3, [r7, #20]
 800606c:	685a      	ldr	r2, [r3, #4]
 800606e:	4613      	mov	r3, r2
 8006070:	005b      	lsls	r3, r3, #1
 8006072:	4413      	add	r3, r2
 8006074:	69ba      	ldr	r2, [r7, #24]
 8006076:	429a      	cmp	r2, r3
 8006078:	d305      	bcc.n	8006086 <UART_SetConfig+0x1f6>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 800607a:	697b      	ldr	r3, [r7, #20]
 800607c:	685b      	ldr	r3, [r3, #4]
 800607e:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8006080:	69ba      	ldr	r2, [r7, #24]
 8006082:	429a      	cmp	r2, r3
 8006084:	d903      	bls.n	800608e <UART_SetConfig+0x1fe>
      {
        ret = HAL_ERROR;
 8006086:	2301      	movs	r3, #1
 8006088:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 800608c:	e10e      	b.n	80062ac <UART_SetConfig+0x41c>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800608e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006090:	2200      	movs	r2, #0
 8006092:	60bb      	str	r3, [r7, #8]
 8006094:	60fa      	str	r2, [r7, #12]
 8006096:	697b      	ldr	r3, [r7, #20]
 8006098:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800609a:	4a3c      	ldr	r2, [pc, #240]	; (800618c <UART_SetConfig+0x2fc>)
 800609c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80060a0:	b29b      	uxth	r3, r3
 80060a2:	2200      	movs	r2, #0
 80060a4:	603b      	str	r3, [r7, #0]
 80060a6:	607a      	str	r2, [r7, #4]
 80060a8:	e9d7 2300 	ldrd	r2, r3, [r7]
 80060ac:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 80060b0:	f7fa f98a 	bl	80003c8 <__aeabi_uldivmod>
 80060b4:	4602      	mov	r2, r0
 80060b6:	460b      	mov	r3, r1
 80060b8:	4610      	mov	r0, r2
 80060ba:	4619      	mov	r1, r3
 80060bc:	f04f 0200 	mov.w	r2, #0
 80060c0:	f04f 0300 	mov.w	r3, #0
 80060c4:	020b      	lsls	r3, r1, #8
 80060c6:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 80060ca:	0202      	lsls	r2, r0, #8
 80060cc:	6979      	ldr	r1, [r7, #20]
 80060ce:	6849      	ldr	r1, [r1, #4]
 80060d0:	0849      	lsrs	r1, r1, #1
 80060d2:	2000      	movs	r0, #0
 80060d4:	460c      	mov	r4, r1
 80060d6:	4605      	mov	r5, r0
 80060d8:	eb12 0804 	adds.w	r8, r2, r4
 80060dc:	eb43 0905 	adc.w	r9, r3, r5
 80060e0:	697b      	ldr	r3, [r7, #20]
 80060e2:	685b      	ldr	r3, [r3, #4]
 80060e4:	2200      	movs	r2, #0
 80060e6:	469a      	mov	sl, r3
 80060e8:	4693      	mov	fp, r2
 80060ea:	4652      	mov	r2, sl
 80060ec:	465b      	mov	r3, fp
 80060ee:	4640      	mov	r0, r8
 80060f0:	4649      	mov	r1, r9
 80060f2:	f7fa f969 	bl	80003c8 <__aeabi_uldivmod>
 80060f6:	4602      	mov	r2, r0
 80060f8:	460b      	mov	r3, r1
 80060fa:	4613      	mov	r3, r2
 80060fc:	623b      	str	r3, [r7, #32]
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80060fe:	6a3b      	ldr	r3, [r7, #32]
 8006100:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8006104:	d308      	bcc.n	8006118 <UART_SetConfig+0x288>
 8006106:	6a3b      	ldr	r3, [r7, #32]
 8006108:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800610c:	d204      	bcs.n	8006118 <UART_SetConfig+0x288>
        {
          huart->Instance->BRR = usartdiv;
 800610e:	697b      	ldr	r3, [r7, #20]
 8006110:	681b      	ldr	r3, [r3, #0]
 8006112:	6a3a      	ldr	r2, [r7, #32]
 8006114:	60da      	str	r2, [r3, #12]
 8006116:	e0c9      	b.n	80062ac <UART_SetConfig+0x41c>
        }
        else
        {
          ret = HAL_ERROR;
 8006118:	2301      	movs	r3, #1
 800611a:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 800611e:	e0c5      	b.n	80062ac <UART_SetConfig+0x41c>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8006120:	697b      	ldr	r3, [r7, #20]
 8006122:	69db      	ldr	r3, [r3, #28]
 8006124:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8006128:	d16d      	bne.n	8006206 <UART_SetConfig+0x376>
#else
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
#endif /* LPUART1 */
  {
    switch (clocksource)
 800612a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800612e:	3b01      	subs	r3, #1
 8006130:	2b07      	cmp	r3, #7
 8006132:	d82d      	bhi.n	8006190 <UART_SetConfig+0x300>
 8006134:	a201      	add	r2, pc, #4	; (adr r2, 800613c <UART_SetConfig+0x2ac>)
 8006136:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800613a:	bf00      	nop
 800613c:	0800615d 	.word	0x0800615d
 8006140:	08006165 	.word	0x08006165
 8006144:	08006191 	.word	0x08006191
 8006148:	0800616b 	.word	0x0800616b
 800614c:	08006191 	.word	0x08006191
 8006150:	08006191 	.word	0x08006191
 8006154:	08006191 	.word	0x08006191
 8006158:	08006173 	.word	0x08006173
    {
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800615c:	f7fe fdec 	bl	8004d38 <HAL_RCC_GetPCLK2Freq>
 8006160:	6278      	str	r0, [r7, #36]	; 0x24
        break;
 8006162:	e01b      	b.n	800619c <UART_SetConfig+0x30c>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 8006164:	4b08      	ldr	r3, [pc, #32]	; (8006188 <UART_SetConfig+0x2f8>)
 8006166:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8006168:	e018      	b.n	800619c <UART_SetConfig+0x30c>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 800616a:	f7fe fd4f 	bl	8004c0c <HAL_RCC_GetSysClockFreq>
 800616e:	6278      	str	r0, [r7, #36]	; 0x24
        break;
 8006170:	e014      	b.n	800619c <UART_SetConfig+0x30c>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8006172:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8006176:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8006178:	e010      	b.n	800619c <UART_SetConfig+0x30c>
 800617a:	bf00      	nop
 800617c:	cfff69f3 	.word	0xcfff69f3
 8006180:	40008000 	.word	0x40008000
 8006184:	40013800 	.word	0x40013800
 8006188:	00f42400 	.word	0x00f42400
 800618c:	0801359c 	.word	0x0801359c
      default:
        pclk = 0U;
 8006190:	2300      	movs	r3, #0
 8006192:	627b      	str	r3, [r7, #36]	; 0x24
        ret = HAL_ERROR;
 8006194:	2301      	movs	r3, #1
 8006196:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
        break;
 800619a:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 800619c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800619e:	2b00      	cmp	r3, #0
 80061a0:	f000 8084 	beq.w	80062ac <UART_SetConfig+0x41c>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80061a4:	697b      	ldr	r3, [r7, #20]
 80061a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80061a8:	4a4b      	ldr	r2, [pc, #300]	; (80062d8 <UART_SetConfig+0x448>)
 80061aa:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80061ae:	461a      	mov	r2, r3
 80061b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80061b2:	fbb3 f3f2 	udiv	r3, r3, r2
 80061b6:	005a      	lsls	r2, r3, #1
 80061b8:	697b      	ldr	r3, [r7, #20]
 80061ba:	685b      	ldr	r3, [r3, #4]
 80061bc:	085b      	lsrs	r3, r3, #1
 80061be:	441a      	add	r2, r3
 80061c0:	697b      	ldr	r3, [r7, #20]
 80061c2:	685b      	ldr	r3, [r3, #4]
 80061c4:	fbb2 f3f3 	udiv	r3, r2, r3
 80061c8:	623b      	str	r3, [r7, #32]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80061ca:	6a3b      	ldr	r3, [r7, #32]
 80061cc:	2b0f      	cmp	r3, #15
 80061ce:	d916      	bls.n	80061fe <UART_SetConfig+0x36e>
 80061d0:	6a3b      	ldr	r3, [r7, #32]
 80061d2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80061d6:	d212      	bcs.n	80061fe <UART_SetConfig+0x36e>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 80061d8:	6a3b      	ldr	r3, [r7, #32]
 80061da:	b29b      	uxth	r3, r3
 80061dc:	f023 030f 	bic.w	r3, r3, #15
 80061e0:	83fb      	strh	r3, [r7, #30]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80061e2:	6a3b      	ldr	r3, [r7, #32]
 80061e4:	085b      	lsrs	r3, r3, #1
 80061e6:	b29b      	uxth	r3, r3
 80061e8:	f003 0307 	and.w	r3, r3, #7
 80061ec:	b29a      	uxth	r2, r3
 80061ee:	8bfb      	ldrh	r3, [r7, #30]
 80061f0:	4313      	orrs	r3, r2
 80061f2:	83fb      	strh	r3, [r7, #30]
        huart->Instance->BRR = brrtemp;
 80061f4:	697b      	ldr	r3, [r7, #20]
 80061f6:	681b      	ldr	r3, [r3, #0]
 80061f8:	8bfa      	ldrh	r2, [r7, #30]
 80061fa:	60da      	str	r2, [r3, #12]
 80061fc:	e056      	b.n	80062ac <UART_SetConfig+0x41c>
      }
      else
      {
        ret = HAL_ERROR;
 80061fe:	2301      	movs	r3, #1
 8006200:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 8006204:	e052      	b.n	80062ac <UART_SetConfig+0x41c>
      }
    }
  }
  else
  {
    switch (clocksource)
 8006206:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800620a:	3b01      	subs	r3, #1
 800620c:	2b07      	cmp	r3, #7
 800620e:	d822      	bhi.n	8006256 <UART_SetConfig+0x3c6>
 8006210:	a201      	add	r2, pc, #4	; (adr r2, 8006218 <UART_SetConfig+0x388>)
 8006212:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006216:	bf00      	nop
 8006218:	08006239 	.word	0x08006239
 800621c:	08006241 	.word	0x08006241
 8006220:	08006257 	.word	0x08006257
 8006224:	08006247 	.word	0x08006247
 8006228:	08006257 	.word	0x08006257
 800622c:	08006257 	.word	0x08006257
 8006230:	08006257 	.word	0x08006257
 8006234:	0800624f 	.word	0x0800624f
    {
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8006238:	f7fe fd7e 	bl	8004d38 <HAL_RCC_GetPCLK2Freq>
 800623c:	6278      	str	r0, [r7, #36]	; 0x24
        break;
 800623e:	e010      	b.n	8006262 <UART_SetConfig+0x3d2>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
 8006240:	4b26      	ldr	r3, [pc, #152]	; (80062dc <UART_SetConfig+0x44c>)
 8006242:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8006244:	e00d      	b.n	8006262 <UART_SetConfig+0x3d2>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
 8006246:	f7fe fce1 	bl	8004c0c <HAL_RCC_GetSysClockFreq>
 800624a:	6278      	str	r0, [r7, #36]	; 0x24
        break;
 800624c:	e009      	b.n	8006262 <UART_SetConfig+0x3d2>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800624e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8006252:	627b      	str	r3, [r7, #36]	; 0x24
        break;
 8006254:	e005      	b.n	8006262 <UART_SetConfig+0x3d2>
      default:
        pclk = 0U;
 8006256:	2300      	movs	r3, #0
 8006258:	627b      	str	r3, [r7, #36]	; 0x24
        ret = HAL_ERROR;
 800625a:	2301      	movs	r3, #1
 800625c:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
        break;
 8006260:	bf00      	nop
    }

    if (pclk != 0U)
 8006262:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006264:	2b00      	cmp	r3, #0
 8006266:	d021      	beq.n	80062ac <UART_SetConfig+0x41c>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8006268:	697b      	ldr	r3, [r7, #20]
 800626a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800626c:	4a1a      	ldr	r2, [pc, #104]	; (80062d8 <UART_SetConfig+0x448>)
 800626e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8006272:	461a      	mov	r2, r3
 8006274:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006276:	fbb3 f2f2 	udiv	r2, r3, r2
 800627a:	697b      	ldr	r3, [r7, #20]
 800627c:	685b      	ldr	r3, [r3, #4]
 800627e:	085b      	lsrs	r3, r3, #1
 8006280:	441a      	add	r2, r3
 8006282:	697b      	ldr	r3, [r7, #20]
 8006284:	685b      	ldr	r3, [r3, #4]
 8006286:	fbb2 f3f3 	udiv	r3, r2, r3
 800628a:	623b      	str	r3, [r7, #32]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800628c:	6a3b      	ldr	r3, [r7, #32]
 800628e:	2b0f      	cmp	r3, #15
 8006290:	d909      	bls.n	80062a6 <UART_SetConfig+0x416>
 8006292:	6a3b      	ldr	r3, [r7, #32]
 8006294:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8006298:	d205      	bcs.n	80062a6 <UART_SetConfig+0x416>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 800629a:	6a3b      	ldr	r3, [r7, #32]
 800629c:	b29a      	uxth	r2, r3
 800629e:	697b      	ldr	r3, [r7, #20]
 80062a0:	681b      	ldr	r3, [r3, #0]
 80062a2:	60da      	str	r2, [r3, #12]
 80062a4:	e002      	b.n	80062ac <UART_SetConfig+0x41c>
      }
      else
      {
        ret = HAL_ERROR;
 80062a6:	2301      	movs	r3, #1
 80062a8:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 80062ac:	697b      	ldr	r3, [r7, #20]
 80062ae:	2201      	movs	r2, #1
 80062b0:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  huart->NbRxDataToProcess = 1;
 80062b4:	697b      	ldr	r3, [r7, #20]
 80062b6:	2201      	movs	r2, #1
 80062b8:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 80062bc:	697b      	ldr	r3, [r7, #20]
 80062be:	2200      	movs	r2, #0
 80062c0:	675a      	str	r2, [r3, #116]	; 0x74
  huart->TxISR = NULL;
 80062c2:	697b      	ldr	r3, [r7, #20]
 80062c4:	2200      	movs	r2, #0
 80062c6:	679a      	str	r2, [r3, #120]	; 0x78

  return ret;
 80062c8:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
}
 80062cc:	4618      	mov	r0, r3
 80062ce:	3730      	adds	r7, #48	; 0x30
 80062d0:	46bd      	mov	sp, r7
 80062d2:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80062d6:	bf00      	nop
 80062d8:	0801359c 	.word	0x0801359c
 80062dc:	00f42400 	.word	0x00f42400

080062e0 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 80062e0:	b480      	push	{r7}
 80062e2:	b083      	sub	sp, #12
 80062e4:	af00      	add	r7, sp, #0
 80062e6:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80062e8:	687b      	ldr	r3, [r7, #4]
 80062ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80062ec:	f003 0301 	and.w	r3, r3, #1
 80062f0:	2b00      	cmp	r3, #0
 80062f2:	d00a      	beq.n	800630a <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80062f4:	687b      	ldr	r3, [r7, #4]
 80062f6:	681b      	ldr	r3, [r3, #0]
 80062f8:	685b      	ldr	r3, [r3, #4]
 80062fa:	f423 3100 	bic.w	r1, r3, #131072	; 0x20000
 80062fe:	687b      	ldr	r3, [r7, #4]
 8006300:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006302:	687b      	ldr	r3, [r7, #4]
 8006304:	681b      	ldr	r3, [r3, #0]
 8006306:	430a      	orrs	r2, r1
 8006308:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800630a:	687b      	ldr	r3, [r7, #4]
 800630c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800630e:	f003 0302 	and.w	r3, r3, #2
 8006312:	2b00      	cmp	r3, #0
 8006314:	d00a      	beq.n	800632c <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8006316:	687b      	ldr	r3, [r7, #4]
 8006318:	681b      	ldr	r3, [r3, #0]
 800631a:	685b      	ldr	r3, [r3, #4]
 800631c:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 8006320:	687b      	ldr	r3, [r7, #4]
 8006322:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006324:	687b      	ldr	r3, [r7, #4]
 8006326:	681b      	ldr	r3, [r3, #0]
 8006328:	430a      	orrs	r2, r1
 800632a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800632c:	687b      	ldr	r3, [r7, #4]
 800632e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006330:	f003 0304 	and.w	r3, r3, #4
 8006334:	2b00      	cmp	r3, #0
 8006336:	d00a      	beq.n	800634e <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8006338:	687b      	ldr	r3, [r7, #4]
 800633a:	681b      	ldr	r3, [r3, #0]
 800633c:	685b      	ldr	r3, [r3, #4]
 800633e:	f423 2180 	bic.w	r1, r3, #262144	; 0x40000
 8006342:	687b      	ldr	r3, [r7, #4]
 8006344:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8006346:	687b      	ldr	r3, [r7, #4]
 8006348:	681b      	ldr	r3, [r3, #0]
 800634a:	430a      	orrs	r2, r1
 800634c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800634e:	687b      	ldr	r3, [r7, #4]
 8006350:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006352:	f003 0308 	and.w	r3, r3, #8
 8006356:	2b00      	cmp	r3, #0
 8006358:	d00a      	beq.n	8006370 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800635a:	687b      	ldr	r3, [r7, #4]
 800635c:	681b      	ldr	r3, [r3, #0]
 800635e:	685b      	ldr	r3, [r3, #4]
 8006360:	f423 4100 	bic.w	r1, r3, #32768	; 0x8000
 8006364:	687b      	ldr	r3, [r7, #4]
 8006366:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8006368:	687b      	ldr	r3, [r7, #4]
 800636a:	681b      	ldr	r3, [r3, #0]
 800636c:	430a      	orrs	r2, r1
 800636e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8006370:	687b      	ldr	r3, [r7, #4]
 8006372:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006374:	f003 0310 	and.w	r3, r3, #16
 8006378:	2b00      	cmp	r3, #0
 800637a:	d00a      	beq.n	8006392 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800637c:	687b      	ldr	r3, [r7, #4]
 800637e:	681b      	ldr	r3, [r3, #0]
 8006380:	689b      	ldr	r3, [r3, #8]
 8006382:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 8006386:	687b      	ldr	r3, [r7, #4]
 8006388:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800638a:	687b      	ldr	r3, [r7, #4]
 800638c:	681b      	ldr	r3, [r3, #0]
 800638e:	430a      	orrs	r2, r1
 8006390:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8006392:	687b      	ldr	r3, [r7, #4]
 8006394:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006396:	f003 0320 	and.w	r3, r3, #32
 800639a:	2b00      	cmp	r3, #0
 800639c:	d00a      	beq.n	80063b4 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800639e:	687b      	ldr	r3, [r7, #4]
 80063a0:	681b      	ldr	r3, [r3, #0]
 80063a2:	689b      	ldr	r3, [r3, #8]
 80063a4:	f423 5100 	bic.w	r1, r3, #8192	; 0x2000
 80063a8:	687b      	ldr	r3, [r7, #4]
 80063aa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80063ac:	687b      	ldr	r3, [r7, #4]
 80063ae:	681b      	ldr	r3, [r3, #0]
 80063b0:	430a      	orrs	r2, r1
 80063b2:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80063b4:	687b      	ldr	r3, [r7, #4]
 80063b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80063b8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80063bc:	2b00      	cmp	r3, #0
 80063be:	d01a      	beq.n	80063f6 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80063c0:	687b      	ldr	r3, [r7, #4]
 80063c2:	681b      	ldr	r3, [r3, #0]
 80063c4:	685b      	ldr	r3, [r3, #4]
 80063c6:	f423 1180 	bic.w	r1, r3, #1048576	; 0x100000
 80063ca:	687b      	ldr	r3, [r7, #4]
 80063cc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80063ce:	687b      	ldr	r3, [r7, #4]
 80063d0:	681b      	ldr	r3, [r3, #0]
 80063d2:	430a      	orrs	r2, r1
 80063d4:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80063d6:	687b      	ldr	r3, [r7, #4]
 80063d8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80063da:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80063de:	d10a      	bne.n	80063f6 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80063e0:	687b      	ldr	r3, [r7, #4]
 80063e2:	681b      	ldr	r3, [r3, #0]
 80063e4:	685b      	ldr	r3, [r3, #4]
 80063e6:	f423 01c0 	bic.w	r1, r3, #6291456	; 0x600000
 80063ea:	687b      	ldr	r3, [r7, #4]
 80063ec:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80063ee:	687b      	ldr	r3, [r7, #4]
 80063f0:	681b      	ldr	r3, [r3, #0]
 80063f2:	430a      	orrs	r2, r1
 80063f4:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80063f6:	687b      	ldr	r3, [r7, #4]
 80063f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80063fa:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80063fe:	2b00      	cmp	r3, #0
 8006400:	d00a      	beq.n	8006418 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8006402:	687b      	ldr	r3, [r7, #4]
 8006404:	681b      	ldr	r3, [r3, #0]
 8006406:	685b      	ldr	r3, [r3, #4]
 8006408:	f423 2100 	bic.w	r1, r3, #524288	; 0x80000
 800640c:	687b      	ldr	r3, [r7, #4]
 800640e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8006410:	687b      	ldr	r3, [r7, #4]
 8006412:	681b      	ldr	r3, [r3, #0]
 8006414:	430a      	orrs	r2, r1
 8006416:	605a      	str	r2, [r3, #4]
  }
}
 8006418:	bf00      	nop
 800641a:	370c      	adds	r7, #12
 800641c:	46bd      	mov	sp, r7
 800641e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006422:	4770      	bx	lr

08006424 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8006424:	b580      	push	{r7, lr}
 8006426:	b098      	sub	sp, #96	; 0x60
 8006428:	af02      	add	r7, sp, #8
 800642a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800642c:	687b      	ldr	r3, [r7, #4]
 800642e:	2200      	movs	r2, #0
 8006430:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8006434:	f7fb fe72 	bl	800211c <HAL_GetTick>
 8006438:	6578      	str	r0, [r7, #84]	; 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800643a:	687b      	ldr	r3, [r7, #4]
 800643c:	681b      	ldr	r3, [r3, #0]
 800643e:	681b      	ldr	r3, [r3, #0]
 8006440:	f003 0308 	and.w	r3, r3, #8
 8006444:	2b08      	cmp	r3, #8
 8006446:	d12f      	bne.n	80064a8 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8006448:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800644c:	9300      	str	r3, [sp, #0]
 800644e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8006450:	2200      	movs	r2, #0
 8006452:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8006456:	6878      	ldr	r0, [r7, #4]
 8006458:	f000 f88e 	bl	8006578 <UART_WaitOnFlagUntilTimeout>
 800645c:	4603      	mov	r3, r0
 800645e:	2b00      	cmp	r3, #0
 8006460:	d022      	beq.n	80064a8 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 8006462:	687b      	ldr	r3, [r7, #4]
 8006464:	681b      	ldr	r3, [r3, #0]
 8006466:	63bb      	str	r3, [r7, #56]	; 0x38
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006468:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800646a:	e853 3f00 	ldrex	r3, [r3]
 800646e:	637b      	str	r3, [r7, #52]	; 0x34
   return(result);
 8006470:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006472:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8006476:	653b      	str	r3, [r7, #80]	; 0x50
 8006478:	687b      	ldr	r3, [r7, #4]
 800647a:	681b      	ldr	r3, [r3, #0]
 800647c:	461a      	mov	r2, r3
 800647e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8006480:	647b      	str	r3, [r7, #68]	; 0x44
 8006482:	643a      	str	r2, [r7, #64]	; 0x40
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006484:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8006486:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8006488:	e841 2300 	strex	r3, r2, [r1]
 800648c:	63fb      	str	r3, [r7, #60]	; 0x3c
   return(result);
 800648e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006490:	2b00      	cmp	r3, #0
 8006492:	d1e6      	bne.n	8006462 <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
 8006494:	687b      	ldr	r3, [r7, #4]
 8006496:	2220      	movs	r2, #32
 8006498:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

      __HAL_UNLOCK(huart);
 800649c:	687b      	ldr	r3, [r7, #4]
 800649e:	2200      	movs	r2, #0
 80064a0:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 80064a4:	2303      	movs	r3, #3
 80064a6:	e063      	b.n	8006570 <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80064a8:	687b      	ldr	r3, [r7, #4]
 80064aa:	681b      	ldr	r3, [r3, #0]
 80064ac:	681b      	ldr	r3, [r3, #0]
 80064ae:	f003 0304 	and.w	r3, r3, #4
 80064b2:	2b04      	cmp	r3, #4
 80064b4:	d149      	bne.n	800654a <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80064b6:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80064ba:	9300      	str	r3, [sp, #0]
 80064bc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80064be:	2200      	movs	r2, #0
 80064c0:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 80064c4:	6878      	ldr	r0, [r7, #4]
 80064c6:	f000 f857 	bl	8006578 <UART_WaitOnFlagUntilTimeout>
 80064ca:	4603      	mov	r3, r0
 80064cc:	2b00      	cmp	r3, #0
 80064ce:	d03c      	beq.n	800654a <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80064d0:	687b      	ldr	r3, [r7, #4]
 80064d2:	681b      	ldr	r3, [r3, #0]
 80064d4:	627b      	str	r3, [r7, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80064d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80064d8:	e853 3f00 	ldrex	r3, [r3]
 80064dc:	623b      	str	r3, [r7, #32]
   return(result);
 80064de:	6a3b      	ldr	r3, [r7, #32]
 80064e0:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 80064e4:	64fb      	str	r3, [r7, #76]	; 0x4c
 80064e6:	687b      	ldr	r3, [r7, #4]
 80064e8:	681b      	ldr	r3, [r3, #0]
 80064ea:	461a      	mov	r2, r3
 80064ec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80064ee:	633b      	str	r3, [r7, #48]	; 0x30
 80064f0:	62fa      	str	r2, [r7, #44]	; 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80064f2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80064f4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80064f6:	e841 2300 	strex	r3, r2, [r1]
 80064fa:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 80064fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80064fe:	2b00      	cmp	r3, #0
 8006500:	d1e6      	bne.n	80064d0 <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8006502:	687b      	ldr	r3, [r7, #4]
 8006504:	681b      	ldr	r3, [r3, #0]
 8006506:	3308      	adds	r3, #8
 8006508:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800650a:	693b      	ldr	r3, [r7, #16]
 800650c:	e853 3f00 	ldrex	r3, [r3]
 8006510:	60fb      	str	r3, [r7, #12]
   return(result);
 8006512:	68fb      	ldr	r3, [r7, #12]
 8006514:	f023 0301 	bic.w	r3, r3, #1
 8006518:	64bb      	str	r3, [r7, #72]	; 0x48
 800651a:	687b      	ldr	r3, [r7, #4]
 800651c:	681b      	ldr	r3, [r3, #0]
 800651e:	3308      	adds	r3, #8
 8006520:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006522:	61fa      	str	r2, [r7, #28]
 8006524:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006526:	69b9      	ldr	r1, [r7, #24]
 8006528:	69fa      	ldr	r2, [r7, #28]
 800652a:	e841 2300 	strex	r3, r2, [r1]
 800652e:	617b      	str	r3, [r7, #20]
   return(result);
 8006530:	697b      	ldr	r3, [r7, #20]
 8006532:	2b00      	cmp	r3, #0
 8006534:	d1e5      	bne.n	8006502 <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
 8006536:	687b      	ldr	r3, [r7, #4]
 8006538:	2220      	movs	r2, #32
 800653a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

      __HAL_UNLOCK(huart);
 800653e:	687b      	ldr	r3, [r7, #4]
 8006540:	2200      	movs	r2, #0
 8006542:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 8006546:	2303      	movs	r3, #3
 8006548:	e012      	b.n	8006570 <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 800654a:	687b      	ldr	r3, [r7, #4]
 800654c:	2220      	movs	r2, #32
 800654e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  huart->RxState = HAL_UART_STATE_READY;
 8006552:	687b      	ldr	r3, [r7, #4]
 8006554:	2220      	movs	r2, #32
 8006556:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800655a:	687b      	ldr	r3, [r7, #4]
 800655c:	2200      	movs	r2, #0
 800655e:	66da      	str	r2, [r3, #108]	; 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8006560:	687b      	ldr	r3, [r7, #4]
 8006562:	2200      	movs	r2, #0
 8006564:	671a      	str	r2, [r3, #112]	; 0x70

  __HAL_UNLOCK(huart);
 8006566:	687b      	ldr	r3, [r7, #4]
 8006568:	2200      	movs	r2, #0
 800656a:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  return HAL_OK;
 800656e:	2300      	movs	r3, #0
}
 8006570:	4618      	mov	r0, r3
 8006572:	3758      	adds	r7, #88	; 0x58
 8006574:	46bd      	mov	sp, r7
 8006576:	bd80      	pop	{r7, pc}

08006578 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 8006578:	b580      	push	{r7, lr}
 800657a:	b084      	sub	sp, #16
 800657c:	af00      	add	r7, sp, #0
 800657e:	60f8      	str	r0, [r7, #12]
 8006580:	60b9      	str	r1, [r7, #8]
 8006582:	603b      	str	r3, [r7, #0]
 8006584:	4613      	mov	r3, r2
 8006586:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006588:	e049      	b.n	800661e <UART_WaitOnFlagUntilTimeout+0xa6>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800658a:	69bb      	ldr	r3, [r7, #24]
 800658c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006590:	d045      	beq.n	800661e <UART_WaitOnFlagUntilTimeout+0xa6>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006592:	f7fb fdc3 	bl	800211c <HAL_GetTick>
 8006596:	4602      	mov	r2, r0
 8006598:	683b      	ldr	r3, [r7, #0]
 800659a:	1ad3      	subs	r3, r2, r3
 800659c:	69ba      	ldr	r2, [r7, #24]
 800659e:	429a      	cmp	r2, r3
 80065a0:	d302      	bcc.n	80065a8 <UART_WaitOnFlagUntilTimeout+0x30>
 80065a2:	69bb      	ldr	r3, [r7, #24]
 80065a4:	2b00      	cmp	r3, #0
 80065a6:	d101      	bne.n	80065ac <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
 80065a8:	2303      	movs	r3, #3
 80065aa:	e048      	b.n	800663e <UART_WaitOnFlagUntilTimeout+0xc6>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 80065ac:	68fb      	ldr	r3, [r7, #12]
 80065ae:	681b      	ldr	r3, [r3, #0]
 80065b0:	681b      	ldr	r3, [r3, #0]
 80065b2:	f003 0304 	and.w	r3, r3, #4
 80065b6:	2b00      	cmp	r3, #0
 80065b8:	d031      	beq.n	800661e <UART_WaitOnFlagUntilTimeout+0xa6>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 80065ba:	68fb      	ldr	r3, [r7, #12]
 80065bc:	681b      	ldr	r3, [r3, #0]
 80065be:	69db      	ldr	r3, [r3, #28]
 80065c0:	f003 0308 	and.w	r3, r3, #8
 80065c4:	2b08      	cmp	r3, #8
 80065c6:	d110      	bne.n	80065ea <UART_WaitOnFlagUntilTimeout+0x72>
        {
           /* Clear Overrun Error flag*/
           __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 80065c8:	68fb      	ldr	r3, [r7, #12]
 80065ca:	681b      	ldr	r3, [r3, #0]
 80065cc:	2208      	movs	r2, #8
 80065ce:	621a      	str	r2, [r3, #32]

           /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts if ongoing */
           UART_EndRxTransfer(huart);
 80065d0:	68f8      	ldr	r0, [r7, #12]
 80065d2:	f000 f838 	bl	8006646 <UART_EndRxTransfer>

           huart->ErrorCode = HAL_UART_ERROR_ORE;
 80065d6:	68fb      	ldr	r3, [r7, #12]
 80065d8:	2208      	movs	r2, #8
 80065da:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

           /* Process Unlocked */
           __HAL_UNLOCK(huart);
 80065de:	68fb      	ldr	r3, [r7, #12]
 80065e0:	2200      	movs	r2, #0
 80065e2:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

           return HAL_ERROR;
 80065e6:	2301      	movs	r3, #1
 80065e8:	e029      	b.n	800663e <UART_WaitOnFlagUntilTimeout+0xc6>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80065ea:	68fb      	ldr	r3, [r7, #12]
 80065ec:	681b      	ldr	r3, [r3, #0]
 80065ee:	69db      	ldr	r3, [r3, #28]
 80065f0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 80065f4:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80065f8:	d111      	bne.n	800661e <UART_WaitOnFlagUntilTimeout+0xa6>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80065fa:	68fb      	ldr	r3, [r7, #12]
 80065fc:	681b      	ldr	r3, [r3, #0]
 80065fe:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8006602:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 8006604:	68f8      	ldr	r0, [r7, #12]
 8006606:	f000 f81e 	bl	8006646 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800660a:	68fb      	ldr	r3, [r7, #12]
 800660c:	2220      	movs	r2, #32
 800660e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8006612:	68fb      	ldr	r3, [r7, #12]
 8006614:	2200      	movs	r2, #0
 8006616:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

          return HAL_TIMEOUT;
 800661a:	2303      	movs	r3, #3
 800661c:	e00f      	b.n	800663e <UART_WaitOnFlagUntilTimeout+0xc6>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800661e:	68fb      	ldr	r3, [r7, #12]
 8006620:	681b      	ldr	r3, [r3, #0]
 8006622:	69da      	ldr	r2, [r3, #28]
 8006624:	68bb      	ldr	r3, [r7, #8]
 8006626:	4013      	ands	r3, r2
 8006628:	68ba      	ldr	r2, [r7, #8]
 800662a:	429a      	cmp	r2, r3
 800662c:	bf0c      	ite	eq
 800662e:	2301      	moveq	r3, #1
 8006630:	2300      	movne	r3, #0
 8006632:	b2db      	uxtb	r3, r3
 8006634:	461a      	mov	r2, r3
 8006636:	79fb      	ldrb	r3, [r7, #7]
 8006638:	429a      	cmp	r2, r3
 800663a:	d0a6      	beq.n	800658a <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 800663c:	2300      	movs	r3, #0
}
 800663e:	4618      	mov	r0, r3
 8006640:	3710      	adds	r7, #16
 8006642:	46bd      	mov	sp, r7
 8006644:	bd80      	pop	{r7, pc}

08006646 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8006646:	b480      	push	{r7}
 8006648:	b095      	sub	sp, #84	; 0x54
 800664a:	af00      	add	r7, sp, #0
 800664c:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800664e:	687b      	ldr	r3, [r7, #4]
 8006650:	681b      	ldr	r3, [r3, #0]
 8006652:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006654:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006656:	e853 3f00 	ldrex	r3, [r3]
 800665a:	633b      	str	r3, [r7, #48]	; 0x30
   return(result);
 800665c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800665e:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8006662:	64fb      	str	r3, [r7, #76]	; 0x4c
 8006664:	687b      	ldr	r3, [r7, #4]
 8006666:	681b      	ldr	r3, [r3, #0]
 8006668:	461a      	mov	r2, r3
 800666a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800666c:	643b      	str	r3, [r7, #64]	; 0x40
 800666e:	63fa      	str	r2, [r7, #60]	; 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006670:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8006672:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8006674:	e841 2300 	strex	r3, r2, [r1]
 8006678:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 800667a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800667c:	2b00      	cmp	r3, #0
 800667e:	d1e6      	bne.n	800664e <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8006680:	687b      	ldr	r3, [r7, #4]
 8006682:	681b      	ldr	r3, [r3, #0]
 8006684:	3308      	adds	r3, #8
 8006686:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006688:	6a3b      	ldr	r3, [r7, #32]
 800668a:	e853 3f00 	ldrex	r3, [r3]
 800668e:	61fb      	str	r3, [r7, #28]
   return(result);
 8006690:	69fb      	ldr	r3, [r7, #28]
 8006692:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8006696:	f023 0301 	bic.w	r3, r3, #1
 800669a:	64bb      	str	r3, [r7, #72]	; 0x48
 800669c:	687b      	ldr	r3, [r7, #4]
 800669e:	681b      	ldr	r3, [r3, #0]
 80066a0:	3308      	adds	r3, #8
 80066a2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80066a4:	62fa      	str	r2, [r7, #44]	; 0x2c
 80066a6:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80066a8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80066aa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80066ac:	e841 2300 	strex	r3, r2, [r1]
 80066b0:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 80066b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80066b4:	2b00      	cmp	r3, #0
 80066b6:	d1e3      	bne.n	8006680 <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80066b8:	687b      	ldr	r3, [r7, #4]
 80066ba:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80066bc:	2b01      	cmp	r3, #1
 80066be:	d118      	bne.n	80066f2 <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80066c0:	687b      	ldr	r3, [r7, #4]
 80066c2:	681b      	ldr	r3, [r3, #0]
 80066c4:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80066c6:	68fb      	ldr	r3, [r7, #12]
 80066c8:	e853 3f00 	ldrex	r3, [r3]
 80066cc:	60bb      	str	r3, [r7, #8]
   return(result);
 80066ce:	68bb      	ldr	r3, [r7, #8]
 80066d0:	f023 0310 	bic.w	r3, r3, #16
 80066d4:	647b      	str	r3, [r7, #68]	; 0x44
 80066d6:	687b      	ldr	r3, [r7, #4]
 80066d8:	681b      	ldr	r3, [r3, #0]
 80066da:	461a      	mov	r2, r3
 80066dc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80066de:	61bb      	str	r3, [r7, #24]
 80066e0:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80066e2:	6979      	ldr	r1, [r7, #20]
 80066e4:	69ba      	ldr	r2, [r7, #24]
 80066e6:	e841 2300 	strex	r3, r2, [r1]
 80066ea:	613b      	str	r3, [r7, #16]
   return(result);
 80066ec:	693b      	ldr	r3, [r7, #16]
 80066ee:	2b00      	cmp	r3, #0
 80066f0:	d1e6      	bne.n	80066c0 <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 80066f2:	687b      	ldr	r3, [r7, #4]
 80066f4:	2220      	movs	r2, #32
 80066f6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80066fa:	687b      	ldr	r3, [r7, #4]
 80066fc:	2200      	movs	r2, #0
 80066fe:	66da      	str	r2, [r3, #108]	; 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8006700:	687b      	ldr	r3, [r7, #4]
 8006702:	2200      	movs	r2, #0
 8006704:	675a      	str	r2, [r3, #116]	; 0x74
}
 8006706:	bf00      	nop
 8006708:	3754      	adds	r7, #84	; 0x54
 800670a:	46bd      	mov	sp, r7
 800670c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006710:	4770      	bx	lr

08006712 <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
 8006712:	b480      	push	{r7}
 8006714:	b085      	sub	sp, #20
 8006716:	af00      	add	r7, sp, #0
 8006718:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 800671a:	687b      	ldr	r3, [r7, #4]
 800671c:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8006720:	2b01      	cmp	r3, #1
 8006722:	d101      	bne.n	8006728 <HAL_UARTEx_DisableFifoMode+0x16>
 8006724:	2302      	movs	r3, #2
 8006726:	e027      	b.n	8006778 <HAL_UARTEx_DisableFifoMode+0x66>
 8006728:	687b      	ldr	r3, [r7, #4]
 800672a:	2201      	movs	r2, #1
 800672c:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 8006730:	687b      	ldr	r3, [r7, #4]
 8006732:	2224      	movs	r2, #36	; 0x24
 8006734:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006738:	687b      	ldr	r3, [r7, #4]
 800673a:	681b      	ldr	r3, [r3, #0]
 800673c:	681b      	ldr	r3, [r3, #0]
 800673e:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8006740:	687b      	ldr	r3, [r7, #4]
 8006742:	681b      	ldr	r3, [r3, #0]
 8006744:	681a      	ldr	r2, [r3, #0]
 8006746:	687b      	ldr	r3, [r7, #4]
 8006748:	681b      	ldr	r3, [r3, #0]
 800674a:	f022 0201 	bic.w	r2, r2, #1
 800674e:	601a      	str	r2, [r3, #0]

  /* Enable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 8006750:	68fb      	ldr	r3, [r7, #12]
 8006752:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8006756:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 8006758:	687b      	ldr	r3, [r7, #4]
 800675a:	2200      	movs	r2, #0
 800675c:	665a      	str	r2, [r3, #100]	; 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800675e:	687b      	ldr	r3, [r7, #4]
 8006760:	681b      	ldr	r3, [r3, #0]
 8006762:	68fa      	ldr	r2, [r7, #12]
 8006764:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8006766:	687b      	ldr	r3, [r7, #4]
 8006768:	2220      	movs	r2, #32
 800676a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800676e:	687b      	ldr	r3, [r7, #4]
 8006770:	2200      	movs	r2, #0
 8006772:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  return HAL_OK;
 8006776:	2300      	movs	r3, #0
}
 8006778:	4618      	mov	r0, r3
 800677a:	3714      	adds	r7, #20
 800677c:	46bd      	mov	sp, r7
 800677e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006782:	4770      	bx	lr

08006784 <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 8006784:	b580      	push	{r7, lr}
 8006786:	b084      	sub	sp, #16
 8006788:	af00      	add	r7, sp, #0
 800678a:	6078      	str	r0, [r7, #4]
 800678c:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 800678e:	687b      	ldr	r3, [r7, #4]
 8006790:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8006794:	2b01      	cmp	r3, #1
 8006796:	d101      	bne.n	800679c <HAL_UARTEx_SetTxFifoThreshold+0x18>
 8006798:	2302      	movs	r3, #2
 800679a:	e02d      	b.n	80067f8 <HAL_UARTEx_SetTxFifoThreshold+0x74>
 800679c:	687b      	ldr	r3, [r7, #4]
 800679e:	2201      	movs	r2, #1
 80067a0:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 80067a4:	687b      	ldr	r3, [r7, #4]
 80067a6:	2224      	movs	r2, #36	; 0x24
 80067a8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 80067ac:	687b      	ldr	r3, [r7, #4]
 80067ae:	681b      	ldr	r3, [r3, #0]
 80067b0:	681b      	ldr	r3, [r3, #0]
 80067b2:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 80067b4:	687b      	ldr	r3, [r7, #4]
 80067b6:	681b      	ldr	r3, [r3, #0]
 80067b8:	681a      	ldr	r2, [r3, #0]
 80067ba:	687b      	ldr	r3, [r7, #4]
 80067bc:	681b      	ldr	r3, [r3, #0]
 80067be:	f022 0201 	bic.w	r2, r2, #1
 80067c2:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 80067c4:	687b      	ldr	r3, [r7, #4]
 80067c6:	681b      	ldr	r3, [r3, #0]
 80067c8:	689b      	ldr	r3, [r3, #8]
 80067ca:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 80067ce:	687b      	ldr	r3, [r7, #4]
 80067d0:	681b      	ldr	r3, [r3, #0]
 80067d2:	683a      	ldr	r2, [r7, #0]
 80067d4:	430a      	orrs	r2, r1
 80067d6:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 80067d8:	6878      	ldr	r0, [r7, #4]
 80067da:	f000 f84f 	bl	800687c <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 80067de:	687b      	ldr	r3, [r7, #4]
 80067e0:	681b      	ldr	r3, [r3, #0]
 80067e2:	68fa      	ldr	r2, [r7, #12]
 80067e4:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 80067e6:	687b      	ldr	r3, [r7, #4]
 80067e8:	2220      	movs	r2, #32
 80067ea:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 80067ee:	687b      	ldr	r3, [r7, #4]
 80067f0:	2200      	movs	r2, #0
 80067f2:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  return HAL_OK;
 80067f6:	2300      	movs	r3, #0
}
 80067f8:	4618      	mov	r0, r3
 80067fa:	3710      	adds	r7, #16
 80067fc:	46bd      	mov	sp, r7
 80067fe:	bd80      	pop	{r7, pc}

08006800 <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 8006800:	b580      	push	{r7, lr}
 8006802:	b084      	sub	sp, #16
 8006804:	af00      	add	r7, sp, #0
 8006806:	6078      	str	r0, [r7, #4]
 8006808:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 800680a:	687b      	ldr	r3, [r7, #4]
 800680c:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8006810:	2b01      	cmp	r3, #1
 8006812:	d101      	bne.n	8006818 <HAL_UARTEx_SetRxFifoThreshold+0x18>
 8006814:	2302      	movs	r3, #2
 8006816:	e02d      	b.n	8006874 <HAL_UARTEx_SetRxFifoThreshold+0x74>
 8006818:	687b      	ldr	r3, [r7, #4]
 800681a:	2201      	movs	r2, #1
 800681c:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 8006820:	687b      	ldr	r3, [r7, #4]
 8006822:	2224      	movs	r2, #36	; 0x24
 8006824:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006828:	687b      	ldr	r3, [r7, #4]
 800682a:	681b      	ldr	r3, [r3, #0]
 800682c:	681b      	ldr	r3, [r3, #0]
 800682e:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 8006830:	687b      	ldr	r3, [r7, #4]
 8006832:	681b      	ldr	r3, [r3, #0]
 8006834:	681a      	ldr	r2, [r3, #0]
 8006836:	687b      	ldr	r3, [r7, #4]
 8006838:	681b      	ldr	r3, [r3, #0]
 800683a:	f022 0201 	bic.w	r2, r2, #1
 800683e:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 8006840:	687b      	ldr	r3, [r7, #4]
 8006842:	681b      	ldr	r3, [r3, #0]
 8006844:	689b      	ldr	r3, [r3, #8]
 8006846:	f023 6160 	bic.w	r1, r3, #234881024	; 0xe000000
 800684a:	687b      	ldr	r3, [r7, #4]
 800684c:	681b      	ldr	r3, [r3, #0]
 800684e:	683a      	ldr	r2, [r7, #0]
 8006850:	430a      	orrs	r2, r1
 8006852:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 8006854:	6878      	ldr	r0, [r7, #4]
 8006856:	f000 f811 	bl	800687c <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800685a:	687b      	ldr	r3, [r7, #4]
 800685c:	681b      	ldr	r3, [r3, #0]
 800685e:	68fa      	ldr	r2, [r7, #12]
 8006860:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 8006862:	687b      	ldr	r3, [r7, #4]
 8006864:	2220      	movs	r2, #32
 8006866:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800686a:	687b      	ldr	r3, [r7, #4]
 800686c:	2200      	movs	r2, #0
 800686e:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84

  return HAL_OK;
 8006872:	2300      	movs	r3, #0
}
 8006874:	4618      	mov	r0, r3
 8006876:	3710      	adds	r7, #16
 8006878:	46bd      	mov	sp, r7
 800687a:	bd80      	pop	{r7, pc}

0800687c <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
 800687c:	b480      	push	{r7}
 800687e:	b085      	sub	sp, #20
 8006880:	af00      	add	r7, sp, #0
 8006882:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 8006884:	687b      	ldr	r3, [r7, #4]
 8006886:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006888:	2b00      	cmp	r3, #0
 800688a:	d108      	bne.n	800689e <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
 800688c:	687b      	ldr	r3, [r7, #4]
 800688e:	2201      	movs	r2, #1
 8006890:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    huart->NbRxDataToProcess = 1U;
 8006894:	687b      	ldr	r3, [r7, #4]
 8006896:	2201      	movs	r2, #1
 8006898:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 800689c:	e031      	b.n	8006902 <UARTEx_SetNbDataToProcess+0x86>
    rx_fifo_depth = RX_FIFO_DEPTH;
 800689e:	2308      	movs	r3, #8
 80068a0:	73fb      	strb	r3, [r7, #15]
    tx_fifo_depth = TX_FIFO_DEPTH;
 80068a2:	2308      	movs	r3, #8
 80068a4:	73bb      	strb	r3, [r7, #14]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80068a6:	687b      	ldr	r3, [r7, #4]
 80068a8:	681b      	ldr	r3, [r3, #0]
 80068aa:	689b      	ldr	r3, [r3, #8]
 80068ac:	0e5b      	lsrs	r3, r3, #25
 80068ae:	b2db      	uxtb	r3, r3
 80068b0:	f003 0307 	and.w	r3, r3, #7
 80068b4:	737b      	strb	r3, [r7, #13]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80068b6:	687b      	ldr	r3, [r7, #4]
 80068b8:	681b      	ldr	r3, [r3, #0]
 80068ba:	689b      	ldr	r3, [r3, #8]
 80068bc:	0f5b      	lsrs	r3, r3, #29
 80068be:	b2db      	uxtb	r3, r3
 80068c0:	f003 0307 	and.w	r3, r3, #7
 80068c4:	733b      	strb	r3, [r7, #12]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80068c6:	7bbb      	ldrb	r3, [r7, #14]
 80068c8:	7b3a      	ldrb	r2, [r7, #12]
 80068ca:	4911      	ldr	r1, [pc, #68]	; (8006910 <UARTEx_SetNbDataToProcess+0x94>)
 80068cc:	5c8a      	ldrb	r2, [r1, r2]
 80068ce:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[tx_fifo_threshold];
 80068d2:	7b3a      	ldrb	r2, [r7, #12]
 80068d4:	490f      	ldr	r1, [pc, #60]	; (8006914 <UARTEx_SetNbDataToProcess+0x98>)
 80068d6:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80068d8:	fb93 f3f2 	sdiv	r3, r3, r2
 80068dc:	b29a      	uxth	r2, r3
 80068de:	687b      	ldr	r3, [r7, #4]
 80068e0:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80068e4:	7bfb      	ldrb	r3, [r7, #15]
 80068e6:	7b7a      	ldrb	r2, [r7, #13]
 80068e8:	4909      	ldr	r1, [pc, #36]	; (8006910 <UARTEx_SetNbDataToProcess+0x94>)
 80068ea:	5c8a      	ldrb	r2, [r1, r2]
 80068ec:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[rx_fifo_threshold];
 80068f0:	7b7a      	ldrb	r2, [r7, #13]
 80068f2:	4908      	ldr	r1, [pc, #32]	; (8006914 <UARTEx_SetNbDataToProcess+0x98>)
 80068f4:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 80068f6:	fb93 f3f2 	sdiv	r3, r3, r2
 80068fa:	b29a      	uxth	r2, r3
 80068fc:	687b      	ldr	r3, [r7, #4]
 80068fe:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
}
 8006902:	bf00      	nop
 8006904:	3714      	adds	r7, #20
 8006906:	46bd      	mov	sp, r7
 8006908:	f85d 7b04 	ldr.w	r7, [sp], #4
 800690c:	4770      	bx	lr
 800690e:	bf00      	nop
 8006910:	080135b4 	.word	0x080135b4
 8006914:	080135bc 	.word	0x080135bc

08006918 <LL_EXTI_EnableIT_0_31>:
  *         @arg @ref LL_EXTI_LINE_ALL_0_31
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_0_31(uint32_t ExtiLine)
{
 8006918:	b480      	push	{r7}
 800691a:	b083      	sub	sp, #12
 800691c:	af00      	add	r7, sp, #0
 800691e:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->IMR1, ExtiLine);
 8006920:	4b06      	ldr	r3, [pc, #24]	; (800693c <LL_EXTI_EnableIT_0_31+0x24>)
 8006922:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8006926:	4905      	ldr	r1, [pc, #20]	; (800693c <LL_EXTI_EnableIT_0_31+0x24>)
 8006928:	687b      	ldr	r3, [r7, #4]
 800692a:	4313      	orrs	r3, r2
 800692c:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
}
 8006930:	bf00      	nop
 8006932:	370c      	adds	r7, #12
 8006934:	46bd      	mov	sp, r7
 8006936:	f85d 7b04 	ldr.w	r7, [sp], #4
 800693a:	4770      	bx	lr
 800693c:	58000800 	.word	0x58000800

08006940 <LL_EXTI_EnableIT_32_63>:
  *         @arg @ref LL_EXTI_LINE_ALL_32_63
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
 8006940:	b480      	push	{r7}
 8006942:	b083      	sub	sp, #12
 8006944:	af00      	add	r7, sp, #0
 8006946:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->IMR2, ExtiLine);
 8006948:	4b06      	ldr	r3, [pc, #24]	; (8006964 <LL_EXTI_EnableIT_32_63+0x24>)
 800694a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800694e:	4905      	ldr	r1, [pc, #20]	; (8006964 <LL_EXTI_EnableIT_32_63+0x24>)
 8006950:	687b      	ldr	r3, [r7, #4]
 8006952:	4313      	orrs	r3, r2
 8006954:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 8006958:	bf00      	nop
 800695a:	370c      	adds	r7, #12
 800695c:	46bd      	mov	sp, r7
 800695e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006962:	4770      	bx	lr
 8006964:	58000800 	.word	0x58000800

08006968 <LL_EXTI_DisableIT_0_31>:
  *         @arg @ref LL_EXTI_LINE_ALL_0_31
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableIT_0_31(uint32_t ExtiLine)
{
 8006968:	b480      	push	{r7}
 800696a:	b083      	sub	sp, #12
 800696c:	af00      	add	r7, sp, #0
 800696e:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->IMR1, ExtiLine);
 8006970:	4b07      	ldr	r3, [pc, #28]	; (8006990 <LL_EXTI_DisableIT_0_31+0x28>)
 8006972:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8006976:	687b      	ldr	r3, [r7, #4]
 8006978:	43db      	mvns	r3, r3
 800697a:	4905      	ldr	r1, [pc, #20]	; (8006990 <LL_EXTI_DisableIT_0_31+0x28>)
 800697c:	4013      	ands	r3, r2
 800697e:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
}
 8006982:	bf00      	nop
 8006984:	370c      	adds	r7, #12
 8006986:	46bd      	mov	sp, r7
 8006988:	f85d 7b04 	ldr.w	r7, [sp], #4
 800698c:	4770      	bx	lr
 800698e:	bf00      	nop
 8006990:	58000800 	.word	0x58000800

08006994 <LL_EXTI_DisableIT_32_63>:
  *         @arg @ref LL_EXTI_LINE_ALL_32_63
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableIT_32_63(uint32_t ExtiLine)
{
 8006994:	b480      	push	{r7}
 8006996:	b083      	sub	sp, #12
 8006998:	af00      	add	r7, sp, #0
 800699a:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->IMR2, ExtiLine);
 800699c:	4b07      	ldr	r3, [pc, #28]	; (80069bc <LL_EXTI_DisableIT_32_63+0x28>)
 800699e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80069a2:	687b      	ldr	r3, [r7, #4]
 80069a4:	43db      	mvns	r3, r3
 80069a6:	4905      	ldr	r1, [pc, #20]	; (80069bc <LL_EXTI_DisableIT_32_63+0x28>)
 80069a8:	4013      	ands	r3, r2
 80069aa:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
}
 80069ae:	bf00      	nop
 80069b0:	370c      	adds	r7, #12
 80069b2:	46bd      	mov	sp, r7
 80069b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80069b8:	4770      	bx	lr
 80069ba:	bf00      	nop
 80069bc:	58000800 	.word	0x58000800

080069c0 <LL_EXTI_EnableEvent_0_31>:
  *         @arg @ref LL_EXTI_LINE_21 (*)
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableEvent_0_31(uint32_t ExtiLine)
{
 80069c0:	b480      	push	{r7}
 80069c2:	b083      	sub	sp, #12
 80069c4:	af00      	add	r7, sp, #0
 80069c6:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->EMR1, ExtiLine);
 80069c8:	4b06      	ldr	r3, [pc, #24]	; (80069e4 <LL_EXTI_EnableEvent_0_31+0x24>)
 80069ca:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 80069ce:	4905      	ldr	r1, [pc, #20]	; (80069e4 <LL_EXTI_EnableEvent_0_31+0x24>)
 80069d0:	687b      	ldr	r3, [r7, #4]
 80069d2:	4313      	orrs	r3, r2
 80069d4:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
}
 80069d8:	bf00      	nop
 80069da:	370c      	adds	r7, #12
 80069dc:	46bd      	mov	sp, r7
 80069de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80069e2:	4770      	bx	lr
 80069e4:	58000800 	.word	0x58000800

080069e8 <LL_EXTI_EnableEvent_32_63>:
  *         @arg @ref LL_EXTI_LINE_40
  *         @arg @ref LL_EXTI_LINE_41
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableEvent_32_63(uint32_t ExtiLine)
{
 80069e8:	b480      	push	{r7}
 80069ea:	b083      	sub	sp, #12
 80069ec:	af00      	add	r7, sp, #0
 80069ee:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->EMR2, ExtiLine);
 80069f0:	4b06      	ldr	r3, [pc, #24]	; (8006a0c <LL_EXTI_EnableEvent_32_63+0x24>)
 80069f2:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80069f6:	4905      	ldr	r1, [pc, #20]	; (8006a0c <LL_EXTI_EnableEvent_32_63+0x24>)
 80069f8:	687b      	ldr	r3, [r7, #4]
 80069fa:	4313      	orrs	r3, r2
 80069fc:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
}
 8006a00:	bf00      	nop
 8006a02:	370c      	adds	r7, #12
 8006a04:	46bd      	mov	sp, r7
 8006a06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a0a:	4770      	bx	lr
 8006a0c:	58000800 	.word	0x58000800

08006a10 <LL_EXTI_DisableEvent_0_31>:
  *         @arg @ref LL_EXTI_LINE_20 (*)
  *         @arg @ref LL_EXTI_LINE_21 (*)
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableEvent_0_31(uint32_t ExtiLine)
{
 8006a10:	b480      	push	{r7}
 8006a12:	b083      	sub	sp, #12
 8006a14:	af00      	add	r7, sp, #0
 8006a16:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->EMR1, ExtiLine);
 8006a18:	4b07      	ldr	r3, [pc, #28]	; (8006a38 <LL_EXTI_DisableEvent_0_31+0x28>)
 8006a1a:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8006a1e:	687b      	ldr	r3, [r7, #4]
 8006a20:	43db      	mvns	r3, r3
 8006a22:	4905      	ldr	r1, [pc, #20]	; (8006a38 <LL_EXTI_DisableEvent_0_31+0x28>)
 8006a24:	4013      	ands	r3, r2
 8006a26:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
}
 8006a2a:	bf00      	nop
 8006a2c:	370c      	adds	r7, #12
 8006a2e:	46bd      	mov	sp, r7
 8006a30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a34:	4770      	bx	lr
 8006a36:	bf00      	nop
 8006a38:	58000800 	.word	0x58000800

08006a3c <LL_EXTI_DisableEvent_32_63>:
  *         @arg @ref LL_EXTI_LINE_41
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableEvent_32_63(uint32_t ExtiLine)
{
 8006a3c:	b480      	push	{r7}
 8006a3e:	b083      	sub	sp, #12
 8006a40:	af00      	add	r7, sp, #0
 8006a42:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->EMR2, ExtiLine);
 8006a44:	4b07      	ldr	r3, [pc, #28]	; (8006a64 <LL_EXTI_DisableEvent_32_63+0x28>)
 8006a46:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8006a4a:	687b      	ldr	r3, [r7, #4]
 8006a4c:	43db      	mvns	r3, r3
 8006a4e:	4905      	ldr	r1, [pc, #20]	; (8006a64 <LL_EXTI_DisableEvent_32_63+0x28>)
 8006a50:	4013      	ands	r3, r2
 8006a52:	f8c1 3094 	str.w	r3, [r1, #148]	; 0x94
}
 8006a56:	bf00      	nop
 8006a58:	370c      	adds	r7, #12
 8006a5a:	46bd      	mov	sp, r7
 8006a5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a60:	4770      	bx	lr
 8006a62:	bf00      	nop
 8006a64:	58000800 	.word	0x58000800

08006a68 <LL_EXTI_EnableRisingTrig_0_31>:
  *         @arg @ref LL_EXTI_LINE_31 (*)
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_0_31(uint32_t ExtiLine)
{
 8006a68:	b480      	push	{r7}
 8006a6a:	b083      	sub	sp, #12
 8006a6c:	af00      	add	r7, sp, #0
 8006a6e:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->RTSR1, ExtiLine);
 8006a70:	4b05      	ldr	r3, [pc, #20]	; (8006a88 <LL_EXTI_EnableRisingTrig_0_31+0x20>)
 8006a72:	681a      	ldr	r2, [r3, #0]
 8006a74:	4904      	ldr	r1, [pc, #16]	; (8006a88 <LL_EXTI_EnableRisingTrig_0_31+0x20>)
 8006a76:	687b      	ldr	r3, [r7, #4]
 8006a78:	4313      	orrs	r3, r2
 8006a7a:	600b      	str	r3, [r1, #0]

}
 8006a7c:	bf00      	nop
 8006a7e:	370c      	adds	r7, #12
 8006a80:	46bd      	mov	sp, r7
 8006a82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006a86:	4770      	bx	lr
 8006a88:	58000800 	.word	0x58000800

08006a8c <LL_EXTI_EnableRisingTrig_32_63>:
  *         @arg @ref LL_EXTI_LINE_41
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
{
 8006a8c:	b480      	push	{r7}
 8006a8e:	b083      	sub	sp, #12
 8006a90:	af00      	add	r7, sp, #0
 8006a92:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->RTSR2, ExtiLine);
 8006a94:	4b05      	ldr	r3, [pc, #20]	; (8006aac <LL_EXTI_EnableRisingTrig_32_63+0x20>)
 8006a96:	6a1a      	ldr	r2, [r3, #32]
 8006a98:	4904      	ldr	r1, [pc, #16]	; (8006aac <LL_EXTI_EnableRisingTrig_32_63+0x20>)
 8006a9a:	687b      	ldr	r3, [r7, #4]
 8006a9c:	4313      	orrs	r3, r2
 8006a9e:	620b      	str	r3, [r1, #32]
}
 8006aa0:	bf00      	nop
 8006aa2:	370c      	adds	r7, #12
 8006aa4:	46bd      	mov	sp, r7
 8006aa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006aaa:	4770      	bx	lr
 8006aac:	58000800 	.word	0x58000800

08006ab0 <LL_EXTI_DisableRisingTrig_0_31>:
  *         @arg @ref LL_EXTI_LINE_31 (*)
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableRisingTrig_0_31(uint32_t ExtiLine)
{
 8006ab0:	b480      	push	{r7}
 8006ab2:	b083      	sub	sp, #12
 8006ab4:	af00      	add	r7, sp, #0
 8006ab6:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->RTSR1, ExtiLine);
 8006ab8:	4b06      	ldr	r3, [pc, #24]	; (8006ad4 <LL_EXTI_DisableRisingTrig_0_31+0x24>)
 8006aba:	681a      	ldr	r2, [r3, #0]
 8006abc:	687b      	ldr	r3, [r7, #4]
 8006abe:	43db      	mvns	r3, r3
 8006ac0:	4904      	ldr	r1, [pc, #16]	; (8006ad4 <LL_EXTI_DisableRisingTrig_0_31+0x24>)
 8006ac2:	4013      	ands	r3, r2
 8006ac4:	600b      	str	r3, [r1, #0]

}
 8006ac6:	bf00      	nop
 8006ac8:	370c      	adds	r7, #12
 8006aca:	46bd      	mov	sp, r7
 8006acc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ad0:	4770      	bx	lr
 8006ad2:	bf00      	nop
 8006ad4:	58000800 	.word	0x58000800

08006ad8 <LL_EXTI_DisableRisingTrig_32_63>:
  *         @arg @ref LL_EXTI_LINE_41
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableRisingTrig_32_63(uint32_t ExtiLine)
{
 8006ad8:	b480      	push	{r7}
 8006ada:	b083      	sub	sp, #12
 8006adc:	af00      	add	r7, sp, #0
 8006ade:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->RTSR2, ExtiLine);
 8006ae0:	4b06      	ldr	r3, [pc, #24]	; (8006afc <LL_EXTI_DisableRisingTrig_32_63+0x24>)
 8006ae2:	6a1a      	ldr	r2, [r3, #32]
 8006ae4:	687b      	ldr	r3, [r7, #4]
 8006ae6:	43db      	mvns	r3, r3
 8006ae8:	4904      	ldr	r1, [pc, #16]	; (8006afc <LL_EXTI_DisableRisingTrig_32_63+0x24>)
 8006aea:	4013      	ands	r3, r2
 8006aec:	620b      	str	r3, [r1, #32]
}
 8006aee:	bf00      	nop
 8006af0:	370c      	adds	r7, #12
 8006af2:	46bd      	mov	sp, r7
 8006af4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006af8:	4770      	bx	lr
 8006afa:	bf00      	nop
 8006afc:	58000800 	.word	0x58000800

08006b00 <LL_EXTI_EnableFallingTrig_0_31>:
  *         (*) value not defined in all devices
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableFallingTrig_0_31(uint32_t ExtiLine)
{
 8006b00:	b480      	push	{r7}
 8006b02:	b083      	sub	sp, #12
 8006b04:	af00      	add	r7, sp, #0
 8006b06:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->FTSR1, ExtiLine);
 8006b08:	4b05      	ldr	r3, [pc, #20]	; (8006b20 <LL_EXTI_EnableFallingTrig_0_31+0x20>)
 8006b0a:	685a      	ldr	r2, [r3, #4]
 8006b0c:	4904      	ldr	r1, [pc, #16]	; (8006b20 <LL_EXTI_EnableFallingTrig_0_31+0x20>)
 8006b0e:	687b      	ldr	r3, [r7, #4]
 8006b10:	4313      	orrs	r3, r2
 8006b12:	604b      	str	r3, [r1, #4]
}
 8006b14:	bf00      	nop
 8006b16:	370c      	adds	r7, #12
 8006b18:	46bd      	mov	sp, r7
 8006b1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006b1e:	4770      	bx	lr
 8006b20:	58000800 	.word	0x58000800

08006b24 <LL_EXTI_EnableFallingTrig_32_63>:
  *         @arg @ref LL_EXTI_LINE_41
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableFallingTrig_32_63(uint32_t ExtiLine)
{
 8006b24:	b480      	push	{r7}
 8006b26:	b083      	sub	sp, #12
 8006b28:	af00      	add	r7, sp, #0
 8006b2a:	6078      	str	r0, [r7, #4]
  SET_BIT(EXTI->FTSR2, ExtiLine);
 8006b2c:	4b05      	ldr	r3, [pc, #20]	; (8006b44 <LL_EXTI_EnableFallingTrig_32_63+0x20>)
 8006b2e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006b30:	4904      	ldr	r1, [pc, #16]	; (8006b44 <LL_EXTI_EnableFallingTrig_32_63+0x20>)
 8006b32:	687b      	ldr	r3, [r7, #4]
 8006b34:	4313      	orrs	r3, r2
 8006b36:	624b      	str	r3, [r1, #36]	; 0x24
}
 8006b38:	bf00      	nop
 8006b3a:	370c      	adds	r7, #12
 8006b3c:	46bd      	mov	sp, r7
 8006b3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006b42:	4770      	bx	lr
 8006b44:	58000800 	.word	0x58000800

08006b48 <LL_EXTI_DisableFallingTrig_0_31>:
  *         (*) value not defined in all devices
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine)
{
 8006b48:	b480      	push	{r7}
 8006b4a:	b083      	sub	sp, #12
 8006b4c:	af00      	add	r7, sp, #0
 8006b4e:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->FTSR1, ExtiLine);
 8006b50:	4b06      	ldr	r3, [pc, #24]	; (8006b6c <LL_EXTI_DisableFallingTrig_0_31+0x24>)
 8006b52:	685a      	ldr	r2, [r3, #4]
 8006b54:	687b      	ldr	r3, [r7, #4]
 8006b56:	43db      	mvns	r3, r3
 8006b58:	4904      	ldr	r1, [pc, #16]	; (8006b6c <LL_EXTI_DisableFallingTrig_0_31+0x24>)
 8006b5a:	4013      	ands	r3, r2
 8006b5c:	604b      	str	r3, [r1, #4]
}
 8006b5e:	bf00      	nop
 8006b60:	370c      	adds	r7, #12
 8006b62:	46bd      	mov	sp, r7
 8006b64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006b68:	4770      	bx	lr
 8006b6a:	bf00      	nop
 8006b6c:	58000800 	.word	0x58000800

08006b70 <LL_EXTI_DisableFallingTrig_32_63>:
  *         @arg @ref LL_EXTI_LINE_41
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableFallingTrig_32_63(uint32_t ExtiLine)
{
 8006b70:	b480      	push	{r7}
 8006b72:	b083      	sub	sp, #12
 8006b74:	af00      	add	r7, sp, #0
 8006b76:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(EXTI->FTSR2, ExtiLine);
 8006b78:	4b06      	ldr	r3, [pc, #24]	; (8006b94 <LL_EXTI_DisableFallingTrig_32_63+0x24>)
 8006b7a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006b7c:	687b      	ldr	r3, [r7, #4]
 8006b7e:	43db      	mvns	r3, r3
 8006b80:	4904      	ldr	r1, [pc, #16]	; (8006b94 <LL_EXTI_DisableFallingTrig_32_63+0x24>)
 8006b82:	4013      	ands	r3, r2
 8006b84:	624b      	str	r3, [r1, #36]	; 0x24
}
 8006b86:	bf00      	nop
 8006b88:	370c      	adds	r7, #12
 8006b8a:	46bd      	mov	sp, r7
 8006b8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006b90:	4770      	bx	lr
 8006b92:	bf00      	nop
 8006b94:	58000800 	.word	0x58000800

08006b98 <LL_EXTI_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: EXTI registers are initialized
  *          - ERROR: not applicable
  */
ErrorStatus LL_EXTI_Init(LL_EXTI_InitTypeDef *EXTI_InitStruct)
{
 8006b98:	b580      	push	{r7, lr}
 8006b9a:	b084      	sub	sp, #16
 8006b9c:	af00      	add	r7, sp, #0
 8006b9e:	6078      	str	r0, [r7, #4]
  ErrorStatus status = SUCCESS;
 8006ba0:	2300      	movs	r3, #0
 8006ba2:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_LL_EXTI_LINE_32_63(EXTI_InitStruct->Line_32_63));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->LineCommand));
  assert_param(IS_LL_EXTI_MODE(EXTI_InitStruct->Mode));

  /* ENABLE LineCommand */
  if (EXTI_InitStruct->LineCommand != DISABLE)
 8006ba4:	687b      	ldr	r3, [r7, #4]
 8006ba6:	7a1b      	ldrb	r3, [r3, #8]
 8006ba8:	2b00      	cmp	r3, #0
 8006baa:	f000 80cc 	beq.w	8006d46 <LL_EXTI_Init+0x1ae>
  {
    assert_param(IS_LL_EXTI_TRIGGER(EXTI_InitStruct->Trigger));

    /* Configure EXTI Lines in range from 0 to 31 */
    if (EXTI_InitStruct->Line_0_31 != LL_EXTI_LINE_NONE)
 8006bae:	687b      	ldr	r3, [r7, #4]
 8006bb0:	681b      	ldr	r3, [r3, #0]
 8006bb2:	2b00      	cmp	r3, #0
 8006bb4:	d061      	beq.n	8006c7a <LL_EXTI_Init+0xe2>
    {
      switch (EXTI_InitStruct->Mode)
 8006bb6:	687b      	ldr	r3, [r7, #4]
 8006bb8:	7a5b      	ldrb	r3, [r3, #9]
 8006bba:	2b02      	cmp	r3, #2
 8006bbc:	d01c      	beq.n	8006bf8 <LL_EXTI_Init+0x60>
 8006bbe:	2b02      	cmp	r3, #2
 8006bc0:	dc25      	bgt.n	8006c0e <LL_EXTI_Init+0x76>
 8006bc2:	2b00      	cmp	r3, #0
 8006bc4:	d002      	beq.n	8006bcc <LL_EXTI_Init+0x34>
 8006bc6:	2b01      	cmp	r3, #1
 8006bc8:	d00b      	beq.n	8006be2 <LL_EXTI_Init+0x4a>
 8006bca:	e020      	b.n	8006c0e <LL_EXTI_Init+0x76>
      {
        case LL_EXTI_MODE_IT:
          /* First Disable Event on provided Lines */
          LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);
 8006bcc:	687b      	ldr	r3, [r7, #4]
 8006bce:	681b      	ldr	r3, [r3, #0]
 8006bd0:	4618      	mov	r0, r3
 8006bd2:	f7ff ff1d 	bl	8006a10 <LL_EXTI_DisableEvent_0_31>
          /* Then Enable IT on provided Lines */
          LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);
 8006bd6:	687b      	ldr	r3, [r7, #4]
 8006bd8:	681b      	ldr	r3, [r3, #0]
 8006bda:	4618      	mov	r0, r3
 8006bdc:	f7ff fe9c 	bl	8006918 <LL_EXTI_EnableIT_0_31>
          break;
 8006be0:	e018      	b.n	8006c14 <LL_EXTI_Init+0x7c>
        case LL_EXTI_MODE_EVENT:
          /* First Disable IT on provided Lines */
          LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);
 8006be2:	687b      	ldr	r3, [r7, #4]
 8006be4:	681b      	ldr	r3, [r3, #0]
 8006be6:	4618      	mov	r0, r3
 8006be8:	f7ff febe 	bl	8006968 <LL_EXTI_DisableIT_0_31>
          /* Then Enable Event on provided Lines */
          LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);
 8006bec:	687b      	ldr	r3, [r7, #4]
 8006bee:	681b      	ldr	r3, [r3, #0]
 8006bf0:	4618      	mov	r0, r3
 8006bf2:	f7ff fee5 	bl	80069c0 <LL_EXTI_EnableEvent_0_31>
          break;
 8006bf6:	e00d      	b.n	8006c14 <LL_EXTI_Init+0x7c>
        case LL_EXTI_MODE_IT_EVENT:
          /* Directly Enable IT & Event on provided Lines */
          LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);
 8006bf8:	687b      	ldr	r3, [r7, #4]
 8006bfa:	681b      	ldr	r3, [r3, #0]
 8006bfc:	4618      	mov	r0, r3
 8006bfe:	f7ff fe8b 	bl	8006918 <LL_EXTI_EnableIT_0_31>
          LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);
 8006c02:	687b      	ldr	r3, [r7, #4]
 8006c04:	681b      	ldr	r3, [r3, #0]
 8006c06:	4618      	mov	r0, r3
 8006c08:	f7ff feda 	bl	80069c0 <LL_EXTI_EnableEvent_0_31>
          break;
 8006c0c:	e002      	b.n	8006c14 <LL_EXTI_Init+0x7c>
        default:
          status = ERROR;
 8006c0e:	2301      	movs	r3, #1
 8006c10:	73fb      	strb	r3, [r7, #15]
          break;
 8006c12:	bf00      	nop
      }
      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)
 8006c14:	687b      	ldr	r3, [r7, #4]
 8006c16:	7a9b      	ldrb	r3, [r3, #10]
 8006c18:	2b00      	cmp	r3, #0
 8006c1a:	d02e      	beq.n	8006c7a <LL_EXTI_Init+0xe2>
      {
        switch (EXTI_InitStruct->Trigger)
 8006c1c:	687b      	ldr	r3, [r7, #4]
 8006c1e:	7a9b      	ldrb	r3, [r3, #10]
 8006c20:	2b03      	cmp	r3, #3
 8006c22:	d01c      	beq.n	8006c5e <LL_EXTI_Init+0xc6>
 8006c24:	2b03      	cmp	r3, #3
 8006c26:	dc25      	bgt.n	8006c74 <LL_EXTI_Init+0xdc>
 8006c28:	2b01      	cmp	r3, #1
 8006c2a:	d002      	beq.n	8006c32 <LL_EXTI_Init+0x9a>
 8006c2c:	2b02      	cmp	r3, #2
 8006c2e:	d00b      	beq.n	8006c48 <LL_EXTI_Init+0xb0>
 8006c30:	e020      	b.n	8006c74 <LL_EXTI_Init+0xdc>
        {
          case LL_EXTI_TRIGGER_RISING:
            /* First Disable Falling Trigger on provided Lines */
            LL_EXTI_DisableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);
 8006c32:	687b      	ldr	r3, [r7, #4]
 8006c34:	681b      	ldr	r3, [r3, #0]
 8006c36:	4618      	mov	r0, r3
 8006c38:	f7ff ff86 	bl	8006b48 <LL_EXTI_DisableFallingTrig_0_31>
            /* Then Enable Rising Trigger on provided Lines */
            LL_EXTI_EnableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);
 8006c3c:	687b      	ldr	r3, [r7, #4]
 8006c3e:	681b      	ldr	r3, [r3, #0]
 8006c40:	4618      	mov	r0, r3
 8006c42:	f7ff ff11 	bl	8006a68 <LL_EXTI_EnableRisingTrig_0_31>
            break;
 8006c46:	e018      	b.n	8006c7a <LL_EXTI_Init+0xe2>
          case LL_EXTI_TRIGGER_FALLING:
            /* First Disable Rising Trigger on provided Lines */
            LL_EXTI_DisableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);
 8006c48:	687b      	ldr	r3, [r7, #4]
 8006c4a:	681b      	ldr	r3, [r3, #0]
 8006c4c:	4618      	mov	r0, r3
 8006c4e:	f7ff ff2f 	bl	8006ab0 <LL_EXTI_DisableRisingTrig_0_31>
            /* Then Enable Falling Trigger on provided Lines */
            LL_EXTI_EnableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);
 8006c52:	687b      	ldr	r3, [r7, #4]
 8006c54:	681b      	ldr	r3, [r3, #0]
 8006c56:	4618      	mov	r0, r3
 8006c58:	f7ff ff52 	bl	8006b00 <LL_EXTI_EnableFallingTrig_0_31>
            break;
 8006c5c:	e00d      	b.n	8006c7a <LL_EXTI_Init+0xe2>
          case LL_EXTI_TRIGGER_RISING_FALLING:
            LL_EXTI_EnableRisingTrig_0_31(EXTI_InitStruct->Line_0_31);
 8006c5e:	687b      	ldr	r3, [r7, #4]
 8006c60:	681b      	ldr	r3, [r3, #0]
 8006c62:	4618      	mov	r0, r3
 8006c64:	f7ff ff00 	bl	8006a68 <LL_EXTI_EnableRisingTrig_0_31>
            LL_EXTI_EnableFallingTrig_0_31(EXTI_InitStruct->Line_0_31);
 8006c68:	687b      	ldr	r3, [r7, #4]
 8006c6a:	681b      	ldr	r3, [r3, #0]
 8006c6c:	4618      	mov	r0, r3
 8006c6e:	f7ff ff47 	bl	8006b00 <LL_EXTI_EnableFallingTrig_0_31>
            break;
 8006c72:	e002      	b.n	8006c7a <LL_EXTI_Init+0xe2>
          default:
            status = ERROR;
 8006c74:	2301      	movs	r3, #1
 8006c76:	73fb      	strb	r3, [r7, #15]
            break;
 8006c78:	bf00      	nop
        }
      }
    }
    /* Configure EXTI Lines in range from 32 to 63 */
    if (EXTI_InitStruct->Line_32_63 != LL_EXTI_LINE_NONE)
 8006c7a:	687b      	ldr	r3, [r7, #4]
 8006c7c:	685b      	ldr	r3, [r3, #4]
 8006c7e:	2b00      	cmp	r3, #0
 8006c80:	d075      	beq.n	8006d6e <LL_EXTI_Init+0x1d6>
    {
      switch (EXTI_InitStruct->Mode)
 8006c82:	687b      	ldr	r3, [r7, #4]
 8006c84:	7a5b      	ldrb	r3, [r3, #9]
 8006c86:	2b02      	cmp	r3, #2
 8006c88:	d01c      	beq.n	8006cc4 <LL_EXTI_Init+0x12c>
 8006c8a:	2b02      	cmp	r3, #2
 8006c8c:	dc25      	bgt.n	8006cda <LL_EXTI_Init+0x142>
 8006c8e:	2b00      	cmp	r3, #0
 8006c90:	d002      	beq.n	8006c98 <LL_EXTI_Init+0x100>
 8006c92:	2b01      	cmp	r3, #1
 8006c94:	d00b      	beq.n	8006cae <LL_EXTI_Init+0x116>
 8006c96:	e020      	b.n	8006cda <LL_EXTI_Init+0x142>
      {
        case LL_EXTI_MODE_IT:
          /* First Disable Event on provided Lines */
          LL_EXTI_DisableEvent_32_63(EXTI_InitStruct->Line_32_63);
 8006c98:	687b      	ldr	r3, [r7, #4]
 8006c9a:	685b      	ldr	r3, [r3, #4]
 8006c9c:	4618      	mov	r0, r3
 8006c9e:	f7ff fecd 	bl	8006a3c <LL_EXTI_DisableEvent_32_63>
          /* Then Enable IT on provided Lines */
          LL_EXTI_EnableIT_32_63(EXTI_InitStruct->Line_32_63);
 8006ca2:	687b      	ldr	r3, [r7, #4]
 8006ca4:	685b      	ldr	r3, [r3, #4]
 8006ca6:	4618      	mov	r0, r3
 8006ca8:	f7ff fe4a 	bl	8006940 <LL_EXTI_EnableIT_32_63>
          break;
 8006cac:	e018      	b.n	8006ce0 <LL_EXTI_Init+0x148>
        case LL_EXTI_MODE_EVENT:
          /* First Disable IT on provided Lines */
          LL_EXTI_DisableIT_32_63(EXTI_InitStruct->Line_32_63);
 8006cae:	687b      	ldr	r3, [r7, #4]
 8006cb0:	685b      	ldr	r3, [r3, #4]
 8006cb2:	4618      	mov	r0, r3
 8006cb4:	f7ff fe6e 	bl	8006994 <LL_EXTI_DisableIT_32_63>
          /* Then Enable Event on provided Lines */
          LL_EXTI_EnableEvent_32_63(EXTI_InitStruct->Line_32_63);
 8006cb8:	687b      	ldr	r3, [r7, #4]
 8006cba:	685b      	ldr	r3, [r3, #4]
 8006cbc:	4618      	mov	r0, r3
 8006cbe:	f7ff fe93 	bl	80069e8 <LL_EXTI_EnableEvent_32_63>
          break;
 8006cc2:	e00d      	b.n	8006ce0 <LL_EXTI_Init+0x148>
        case LL_EXTI_MODE_IT_EVENT:
          /* Directly Enable IT & Event on provided Lines */
          LL_EXTI_EnableIT_32_63(EXTI_InitStruct->Line_32_63);
 8006cc4:	687b      	ldr	r3, [r7, #4]
 8006cc6:	685b      	ldr	r3, [r3, #4]
 8006cc8:	4618      	mov	r0, r3
 8006cca:	f7ff fe39 	bl	8006940 <LL_EXTI_EnableIT_32_63>
          LL_EXTI_EnableEvent_32_63(EXTI_InitStruct->Line_32_63);
 8006cce:	687b      	ldr	r3, [r7, #4]
 8006cd0:	685b      	ldr	r3, [r3, #4]
 8006cd2:	4618      	mov	r0, r3
 8006cd4:	f7ff fe88 	bl	80069e8 <LL_EXTI_EnableEvent_32_63>
          break;
 8006cd8:	e002      	b.n	8006ce0 <LL_EXTI_Init+0x148>
        default:
          status = ERROR;
 8006cda:	2301      	movs	r3, #1
 8006cdc:	73fb      	strb	r3, [r7, #15]
          break;
 8006cde:	bf00      	nop
      }
      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)
 8006ce0:	687b      	ldr	r3, [r7, #4]
 8006ce2:	7a9b      	ldrb	r3, [r3, #10]
 8006ce4:	2b00      	cmp	r3, #0
 8006ce6:	d042      	beq.n	8006d6e <LL_EXTI_Init+0x1d6>
      {
        switch (EXTI_InitStruct->Trigger)
 8006ce8:	687b      	ldr	r3, [r7, #4]
 8006cea:	7a9b      	ldrb	r3, [r3, #10]
 8006cec:	2b03      	cmp	r3, #3
 8006cee:	d01c      	beq.n	8006d2a <LL_EXTI_Init+0x192>
 8006cf0:	2b03      	cmp	r3, #3
 8006cf2:	dc25      	bgt.n	8006d40 <LL_EXTI_Init+0x1a8>
 8006cf4:	2b01      	cmp	r3, #1
 8006cf6:	d002      	beq.n	8006cfe <LL_EXTI_Init+0x166>
 8006cf8:	2b02      	cmp	r3, #2
 8006cfa:	d00b      	beq.n	8006d14 <LL_EXTI_Init+0x17c>
 8006cfc:	e020      	b.n	8006d40 <LL_EXTI_Init+0x1a8>
        {
          case LL_EXTI_TRIGGER_RISING:
            /* First Disable Falling Trigger on provided Lines */
            LL_EXTI_DisableFallingTrig_32_63(EXTI_InitStruct->Line_32_63);
 8006cfe:	687b      	ldr	r3, [r7, #4]
 8006d00:	685b      	ldr	r3, [r3, #4]
 8006d02:	4618      	mov	r0, r3
 8006d04:	f7ff ff34 	bl	8006b70 <LL_EXTI_DisableFallingTrig_32_63>
            /* Then Enable IT on provided Lines */
            LL_EXTI_EnableRisingTrig_32_63(EXTI_InitStruct->Line_32_63);
 8006d08:	687b      	ldr	r3, [r7, #4]
 8006d0a:	685b      	ldr	r3, [r3, #4]
 8006d0c:	4618      	mov	r0, r3
 8006d0e:	f7ff febd 	bl	8006a8c <LL_EXTI_EnableRisingTrig_32_63>
            break;
 8006d12:	e02c      	b.n	8006d6e <LL_EXTI_Init+0x1d6>
          case LL_EXTI_TRIGGER_FALLING:
            /* First Disable Rising Trigger on provided Lines */
            LL_EXTI_DisableRisingTrig_32_63(EXTI_InitStruct->Line_32_63);
 8006d14:	687b      	ldr	r3, [r7, #4]
 8006d16:	685b      	ldr	r3, [r3, #4]
 8006d18:	4618      	mov	r0, r3
 8006d1a:	f7ff fedd 	bl	8006ad8 <LL_EXTI_DisableRisingTrig_32_63>
            /* Then Enable Falling Trigger on provided Lines */
            LL_EXTI_EnableFallingTrig_32_63(EXTI_InitStruct->Line_32_63);
 8006d1e:	687b      	ldr	r3, [r7, #4]
 8006d20:	685b      	ldr	r3, [r3, #4]
 8006d22:	4618      	mov	r0, r3
 8006d24:	f7ff fefe 	bl	8006b24 <LL_EXTI_EnableFallingTrig_32_63>
            break;
 8006d28:	e021      	b.n	8006d6e <LL_EXTI_Init+0x1d6>
          case LL_EXTI_TRIGGER_RISING_FALLING:
            LL_EXTI_EnableRisingTrig_32_63(EXTI_InitStruct->Line_32_63);
 8006d2a:	687b      	ldr	r3, [r7, #4]
 8006d2c:	685b      	ldr	r3, [r3, #4]
 8006d2e:	4618      	mov	r0, r3
 8006d30:	f7ff feac 	bl	8006a8c <LL_EXTI_EnableRisingTrig_32_63>
            LL_EXTI_EnableFallingTrig_32_63(EXTI_InitStruct->Line_32_63);
 8006d34:	687b      	ldr	r3, [r7, #4]
 8006d36:	685b      	ldr	r3, [r3, #4]
 8006d38:	4618      	mov	r0, r3
 8006d3a:	f7ff fef3 	bl	8006b24 <LL_EXTI_EnableFallingTrig_32_63>
            break;
 8006d3e:	e016      	b.n	8006d6e <LL_EXTI_Init+0x1d6>
          default:
            status = ERROR;
 8006d40:	2301      	movs	r3, #1
 8006d42:	73fb      	strb	r3, [r7, #15]
            break;
 8006d44:	e013      	b.n	8006d6e <LL_EXTI_Init+0x1d6>
  }
  /* DISABLE LineCommand */
  else
  {
    /* De-configure EXTI Lines in range from 0 to 31 */
    LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);
 8006d46:	687b      	ldr	r3, [r7, #4]
 8006d48:	681b      	ldr	r3, [r3, #0]
 8006d4a:	4618      	mov	r0, r3
 8006d4c:	f7ff fe0c 	bl	8006968 <LL_EXTI_DisableIT_0_31>
    LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);
 8006d50:	687b      	ldr	r3, [r7, #4]
 8006d52:	681b      	ldr	r3, [r3, #0]
 8006d54:	4618      	mov	r0, r3
 8006d56:	f7ff fe5b 	bl	8006a10 <LL_EXTI_DisableEvent_0_31>
    /* De-configure EXTI Lines in range from 32 to 63 */
    LL_EXTI_DisableIT_32_63(EXTI_InitStruct->Line_32_63);
 8006d5a:	687b      	ldr	r3, [r7, #4]
 8006d5c:	685b      	ldr	r3, [r3, #4]
 8006d5e:	4618      	mov	r0, r3
 8006d60:	f7ff fe18 	bl	8006994 <LL_EXTI_DisableIT_32_63>
    LL_EXTI_DisableEvent_32_63(EXTI_InitStruct->Line_32_63);
 8006d64:	687b      	ldr	r3, [r7, #4]
 8006d66:	685b      	ldr	r3, [r3, #4]
 8006d68:	4618      	mov	r0, r3
 8006d6a:	f7ff fe67 	bl	8006a3c <LL_EXTI_DisableEvent_32_63>
  }
  return status;
 8006d6e:	7bfb      	ldrb	r3, [r7, #15]
}
 8006d70:	4618      	mov	r0, r3
 8006d72:	3710      	adds	r7, #16
 8006d74:	46bd      	mov	sp, r7
 8006d76:	bd80      	pop	{r7, pc}

08006d78 <LL_GPIO_SetPinMode>:
{
 8006d78:	b480      	push	{r7}
 8006d7a:	b08b      	sub	sp, #44	; 0x2c
 8006d7c:	af00      	add	r7, sp, #0
 8006d7e:	60f8      	str	r0, [r7, #12]
 8006d80:	60b9      	str	r1, [r7, #8]
 8006d82:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODE0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8006d84:	68fb      	ldr	r3, [r7, #12]
 8006d86:	681a      	ldr	r2, [r3, #0]
 8006d88:	68bb      	ldr	r3, [r7, #8]
 8006d8a:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006d8c:	697b      	ldr	r3, [r7, #20]
 8006d8e:	fa93 f3a3 	rbit	r3, r3
 8006d92:	613b      	str	r3, [r7, #16]
  return result;
 8006d94:	693b      	ldr	r3, [r7, #16]
 8006d96:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8006d98:	69bb      	ldr	r3, [r7, #24]
 8006d9a:	2b00      	cmp	r3, #0
 8006d9c:	d101      	bne.n	8006da2 <LL_GPIO_SetPinMode+0x2a>
    return 32U;
 8006d9e:	2320      	movs	r3, #32
 8006da0:	e003      	b.n	8006daa <LL_GPIO_SetPinMode+0x32>
  return __builtin_clz(value);
 8006da2:	69bb      	ldr	r3, [r7, #24]
 8006da4:	fab3 f383 	clz	r3, r3
 8006da8:	b2db      	uxtb	r3, r3
 8006daa:	005b      	lsls	r3, r3, #1
 8006dac:	2103      	movs	r1, #3
 8006dae:	fa01 f303 	lsl.w	r3, r1, r3
 8006db2:	43db      	mvns	r3, r3
 8006db4:	401a      	ands	r2, r3
 8006db6:	68bb      	ldr	r3, [r7, #8]
 8006db8:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006dba:	6a3b      	ldr	r3, [r7, #32]
 8006dbc:	fa93 f3a3 	rbit	r3, r3
 8006dc0:	61fb      	str	r3, [r7, #28]
  return result;
 8006dc2:	69fb      	ldr	r3, [r7, #28]
 8006dc4:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 8006dc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006dc8:	2b00      	cmp	r3, #0
 8006dca:	d101      	bne.n	8006dd0 <LL_GPIO_SetPinMode+0x58>
    return 32U;
 8006dcc:	2320      	movs	r3, #32
 8006dce:	e003      	b.n	8006dd8 <LL_GPIO_SetPinMode+0x60>
  return __builtin_clz(value);
 8006dd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006dd2:	fab3 f383 	clz	r3, r3
 8006dd6:	b2db      	uxtb	r3, r3
 8006dd8:	005b      	lsls	r3, r3, #1
 8006dda:	6879      	ldr	r1, [r7, #4]
 8006ddc:	fa01 f303 	lsl.w	r3, r1, r3
 8006de0:	431a      	orrs	r2, r3
 8006de2:	68fb      	ldr	r3, [r7, #12]
 8006de4:	601a      	str	r2, [r3, #0]
}
 8006de6:	bf00      	nop
 8006de8:	372c      	adds	r7, #44	; 0x2c
 8006dea:	46bd      	mov	sp, r7
 8006dec:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006df0:	4770      	bx	lr

08006df2 <LL_GPIO_SetPinOutputType>:
{
 8006df2:	b480      	push	{r7}
 8006df4:	b085      	sub	sp, #20
 8006df6:	af00      	add	r7, sp, #0
 8006df8:	60f8      	str	r0, [r7, #12]
 8006dfa:	60b9      	str	r1, [r7, #8]
 8006dfc:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8006dfe:	68fb      	ldr	r3, [r7, #12]
 8006e00:	685a      	ldr	r2, [r3, #4]
 8006e02:	68bb      	ldr	r3, [r7, #8]
 8006e04:	43db      	mvns	r3, r3
 8006e06:	401a      	ands	r2, r3
 8006e08:	68bb      	ldr	r3, [r7, #8]
 8006e0a:	6879      	ldr	r1, [r7, #4]
 8006e0c:	fb01 f303 	mul.w	r3, r1, r3
 8006e10:	431a      	orrs	r2, r3
 8006e12:	68fb      	ldr	r3, [r7, #12]
 8006e14:	605a      	str	r2, [r3, #4]
}
 8006e16:	bf00      	nop
 8006e18:	3714      	adds	r7, #20
 8006e1a:	46bd      	mov	sp, r7
 8006e1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e20:	4770      	bx	lr

08006e22 <LL_GPIO_SetPinSpeed>:
{
 8006e22:	b480      	push	{r7}
 8006e24:	b08b      	sub	sp, #44	; 0x2c
 8006e26:	af00      	add	r7, sp, #0
 8006e28:	60f8      	str	r0, [r7, #12]
 8006e2a:	60b9      	str	r1, [r7, #8]
 8006e2c:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDR_OSPEED0 << (POSITION_VAL(Pin) * 2U)),
 8006e2e:	68fb      	ldr	r3, [r7, #12]
 8006e30:	689a      	ldr	r2, [r3, #8]
 8006e32:	68bb      	ldr	r3, [r7, #8]
 8006e34:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006e36:	697b      	ldr	r3, [r7, #20]
 8006e38:	fa93 f3a3 	rbit	r3, r3
 8006e3c:	613b      	str	r3, [r7, #16]
  return result;
 8006e3e:	693b      	ldr	r3, [r7, #16]
 8006e40:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8006e42:	69bb      	ldr	r3, [r7, #24]
 8006e44:	2b00      	cmp	r3, #0
 8006e46:	d101      	bne.n	8006e4c <LL_GPIO_SetPinSpeed+0x2a>
    return 32U;
 8006e48:	2320      	movs	r3, #32
 8006e4a:	e003      	b.n	8006e54 <LL_GPIO_SetPinSpeed+0x32>
  return __builtin_clz(value);
 8006e4c:	69bb      	ldr	r3, [r7, #24]
 8006e4e:	fab3 f383 	clz	r3, r3
 8006e52:	b2db      	uxtb	r3, r3
 8006e54:	005b      	lsls	r3, r3, #1
 8006e56:	2103      	movs	r1, #3
 8006e58:	fa01 f303 	lsl.w	r3, r1, r3
 8006e5c:	43db      	mvns	r3, r3
 8006e5e:	401a      	ands	r2, r3
 8006e60:	68bb      	ldr	r3, [r7, #8]
 8006e62:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006e64:	6a3b      	ldr	r3, [r7, #32]
 8006e66:	fa93 f3a3 	rbit	r3, r3
 8006e6a:	61fb      	str	r3, [r7, #28]
  return result;
 8006e6c:	69fb      	ldr	r3, [r7, #28]
 8006e6e:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 8006e70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006e72:	2b00      	cmp	r3, #0
 8006e74:	d101      	bne.n	8006e7a <LL_GPIO_SetPinSpeed+0x58>
    return 32U;
 8006e76:	2320      	movs	r3, #32
 8006e78:	e003      	b.n	8006e82 <LL_GPIO_SetPinSpeed+0x60>
  return __builtin_clz(value);
 8006e7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006e7c:	fab3 f383 	clz	r3, r3
 8006e80:	b2db      	uxtb	r3, r3
 8006e82:	005b      	lsls	r3, r3, #1
 8006e84:	6879      	ldr	r1, [r7, #4]
 8006e86:	fa01 f303 	lsl.w	r3, r1, r3
 8006e8a:	431a      	orrs	r2, r3
 8006e8c:	68fb      	ldr	r3, [r7, #12]
 8006e8e:	609a      	str	r2, [r3, #8]
}
 8006e90:	bf00      	nop
 8006e92:	372c      	adds	r7, #44	; 0x2c
 8006e94:	46bd      	mov	sp, r7
 8006e96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e9a:	4770      	bx	lr

08006e9c <LL_GPIO_SetPinPull>:
{
 8006e9c:	b480      	push	{r7}
 8006e9e:	b08b      	sub	sp, #44	; 0x2c
 8006ea0:	af00      	add	r7, sp, #0
 8006ea2:	60f8      	str	r0, [r7, #12]
 8006ea4:	60b9      	str	r1, [r7, #8]
 8006ea6:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPD0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 8006ea8:	68fb      	ldr	r3, [r7, #12]
 8006eaa:	68da      	ldr	r2, [r3, #12]
 8006eac:	68bb      	ldr	r3, [r7, #8]
 8006eae:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006eb0:	697b      	ldr	r3, [r7, #20]
 8006eb2:	fa93 f3a3 	rbit	r3, r3
 8006eb6:	613b      	str	r3, [r7, #16]
  return result;
 8006eb8:	693b      	ldr	r3, [r7, #16]
 8006eba:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8006ebc:	69bb      	ldr	r3, [r7, #24]
 8006ebe:	2b00      	cmp	r3, #0
 8006ec0:	d101      	bne.n	8006ec6 <LL_GPIO_SetPinPull+0x2a>
    return 32U;
 8006ec2:	2320      	movs	r3, #32
 8006ec4:	e003      	b.n	8006ece <LL_GPIO_SetPinPull+0x32>
  return __builtin_clz(value);
 8006ec6:	69bb      	ldr	r3, [r7, #24]
 8006ec8:	fab3 f383 	clz	r3, r3
 8006ecc:	b2db      	uxtb	r3, r3
 8006ece:	005b      	lsls	r3, r3, #1
 8006ed0:	2103      	movs	r1, #3
 8006ed2:	fa01 f303 	lsl.w	r3, r1, r3
 8006ed6:	43db      	mvns	r3, r3
 8006ed8:	401a      	ands	r2, r3
 8006eda:	68bb      	ldr	r3, [r7, #8]
 8006edc:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006ede:	6a3b      	ldr	r3, [r7, #32]
 8006ee0:	fa93 f3a3 	rbit	r3, r3
 8006ee4:	61fb      	str	r3, [r7, #28]
  return result;
 8006ee6:	69fb      	ldr	r3, [r7, #28]
 8006ee8:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 8006eea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006eec:	2b00      	cmp	r3, #0
 8006eee:	d101      	bne.n	8006ef4 <LL_GPIO_SetPinPull+0x58>
    return 32U;
 8006ef0:	2320      	movs	r3, #32
 8006ef2:	e003      	b.n	8006efc <LL_GPIO_SetPinPull+0x60>
  return __builtin_clz(value);
 8006ef4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006ef6:	fab3 f383 	clz	r3, r3
 8006efa:	b2db      	uxtb	r3, r3
 8006efc:	005b      	lsls	r3, r3, #1
 8006efe:	6879      	ldr	r1, [r7, #4]
 8006f00:	fa01 f303 	lsl.w	r3, r1, r3
 8006f04:	431a      	orrs	r2, r3
 8006f06:	68fb      	ldr	r3, [r7, #12]
 8006f08:	60da      	str	r2, [r3, #12]
}
 8006f0a:	bf00      	nop
 8006f0c:	372c      	adds	r7, #44	; 0x2c
 8006f0e:	46bd      	mov	sp, r7
 8006f10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f14:	4770      	bx	lr

08006f16 <LL_GPIO_SetAFPin_0_7>:
{
 8006f16:	b480      	push	{r7}
 8006f18:	b08b      	sub	sp, #44	; 0x2c
 8006f1a:	af00      	add	r7, sp, #0
 8006f1c:	60f8      	str	r0, [r7, #12]
 8006f1e:	60b9      	str	r1, [r7, #8]
 8006f20:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8006f22:	68fb      	ldr	r3, [r7, #12]
 8006f24:	6a1a      	ldr	r2, [r3, #32]
 8006f26:	68bb      	ldr	r3, [r7, #8]
 8006f28:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006f2a:	697b      	ldr	r3, [r7, #20]
 8006f2c:	fa93 f3a3 	rbit	r3, r3
 8006f30:	613b      	str	r3, [r7, #16]
  return result;
 8006f32:	693b      	ldr	r3, [r7, #16]
 8006f34:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8006f36:	69bb      	ldr	r3, [r7, #24]
 8006f38:	2b00      	cmp	r3, #0
 8006f3a:	d101      	bne.n	8006f40 <LL_GPIO_SetAFPin_0_7+0x2a>
    return 32U;
 8006f3c:	2320      	movs	r3, #32
 8006f3e:	e003      	b.n	8006f48 <LL_GPIO_SetAFPin_0_7+0x32>
  return __builtin_clz(value);
 8006f40:	69bb      	ldr	r3, [r7, #24]
 8006f42:	fab3 f383 	clz	r3, r3
 8006f46:	b2db      	uxtb	r3, r3
 8006f48:	009b      	lsls	r3, r3, #2
 8006f4a:	210f      	movs	r1, #15
 8006f4c:	fa01 f303 	lsl.w	r3, r1, r3
 8006f50:	43db      	mvns	r3, r3
 8006f52:	401a      	ands	r2, r3
 8006f54:	68bb      	ldr	r3, [r7, #8]
 8006f56:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006f58:	6a3b      	ldr	r3, [r7, #32]
 8006f5a:	fa93 f3a3 	rbit	r3, r3
 8006f5e:	61fb      	str	r3, [r7, #28]
  return result;
 8006f60:	69fb      	ldr	r3, [r7, #28]
 8006f62:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 8006f64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006f66:	2b00      	cmp	r3, #0
 8006f68:	d101      	bne.n	8006f6e <LL_GPIO_SetAFPin_0_7+0x58>
    return 32U;
 8006f6a:	2320      	movs	r3, #32
 8006f6c:	e003      	b.n	8006f76 <LL_GPIO_SetAFPin_0_7+0x60>
  return __builtin_clz(value);
 8006f6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006f70:	fab3 f383 	clz	r3, r3
 8006f74:	b2db      	uxtb	r3, r3
 8006f76:	009b      	lsls	r3, r3, #2
 8006f78:	6879      	ldr	r1, [r7, #4]
 8006f7a:	fa01 f303 	lsl.w	r3, r1, r3
 8006f7e:	431a      	orrs	r2, r3
 8006f80:	68fb      	ldr	r3, [r7, #12]
 8006f82:	621a      	str	r2, [r3, #32]
}
 8006f84:	bf00      	nop
 8006f86:	372c      	adds	r7, #44	; 0x2c
 8006f88:	46bd      	mov	sp, r7
 8006f8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f8e:	4770      	bx	lr

08006f90 <LL_GPIO_SetAFPin_8_15>:
{
 8006f90:	b480      	push	{r7}
 8006f92:	b08b      	sub	sp, #44	; 0x2c
 8006f94:	af00      	add	r7, sp, #0
 8006f96:	60f8      	str	r0, [r7, #12]
 8006f98:	60b9      	str	r1, [r7, #8]
 8006f9a:	607a      	str	r2, [r7, #4]
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8006f9c:	68fb      	ldr	r3, [r7, #12]
 8006f9e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006fa0:	68bb      	ldr	r3, [r7, #8]
 8006fa2:	0a1b      	lsrs	r3, r3, #8
 8006fa4:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006fa6:	697b      	ldr	r3, [r7, #20]
 8006fa8:	fa93 f3a3 	rbit	r3, r3
 8006fac:	613b      	str	r3, [r7, #16]
  return result;
 8006fae:	693b      	ldr	r3, [r7, #16]
 8006fb0:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8006fb2:	69bb      	ldr	r3, [r7, #24]
 8006fb4:	2b00      	cmp	r3, #0
 8006fb6:	d101      	bne.n	8006fbc <LL_GPIO_SetAFPin_8_15+0x2c>
    return 32U;
 8006fb8:	2320      	movs	r3, #32
 8006fba:	e003      	b.n	8006fc4 <LL_GPIO_SetAFPin_8_15+0x34>
  return __builtin_clz(value);
 8006fbc:	69bb      	ldr	r3, [r7, #24]
 8006fbe:	fab3 f383 	clz	r3, r3
 8006fc2:	b2db      	uxtb	r3, r3
 8006fc4:	009b      	lsls	r3, r3, #2
 8006fc6:	210f      	movs	r1, #15
 8006fc8:	fa01 f303 	lsl.w	r3, r1, r3
 8006fcc:	43db      	mvns	r3, r3
 8006fce:	401a      	ands	r2, r3
 8006fd0:	68bb      	ldr	r3, [r7, #8]
 8006fd2:	0a1b      	lsrs	r3, r3, #8
 8006fd4:	623b      	str	r3, [r7, #32]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8006fd6:	6a3b      	ldr	r3, [r7, #32]
 8006fd8:	fa93 f3a3 	rbit	r3, r3
 8006fdc:	61fb      	str	r3, [r7, #28]
  return result;
 8006fde:	69fb      	ldr	r3, [r7, #28]
 8006fe0:	627b      	str	r3, [r7, #36]	; 0x24
  if (value == 0U)
 8006fe2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006fe4:	2b00      	cmp	r3, #0
 8006fe6:	d101      	bne.n	8006fec <LL_GPIO_SetAFPin_8_15+0x5c>
    return 32U;
 8006fe8:	2320      	movs	r3, #32
 8006fea:	e003      	b.n	8006ff4 <LL_GPIO_SetAFPin_8_15+0x64>
  return __builtin_clz(value);
 8006fec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006fee:	fab3 f383 	clz	r3, r3
 8006ff2:	b2db      	uxtb	r3, r3
 8006ff4:	009b      	lsls	r3, r3, #2
 8006ff6:	6879      	ldr	r1, [r7, #4]
 8006ff8:	fa01 f303 	lsl.w	r3, r1, r3
 8006ffc:	431a      	orrs	r2, r3
 8006ffe:	68fb      	ldr	r3, [r7, #12]
 8007000:	625a      	str	r2, [r3, #36]	; 0x24
}
 8007002:	bf00      	nop
 8007004:	372c      	adds	r7, #44	; 0x2c
 8007006:	46bd      	mov	sp, r7
 8007008:	f85d 7b04 	ldr.w	r7, [sp], #4
 800700c:	4770      	bx	lr

0800700e <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 800700e:	b580      	push	{r7, lr}
 8007010:	b08a      	sub	sp, #40	; 0x28
 8007012:	af00      	add	r7, sp, #0
 8007014:	6078      	str	r0, [r7, #4]
 8007016:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));

  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 8007018:	683b      	ldr	r3, [r7, #0]
 800701a:	681b      	ldr	r3, [r3, #0]
 800701c:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800701e:	69bb      	ldr	r3, [r7, #24]
 8007020:	fa93 f3a3 	rbit	r3, r3
 8007024:	617b      	str	r3, [r7, #20]
  return result;
 8007026:	697b      	ldr	r3, [r7, #20]
 8007028:	61fb      	str	r3, [r7, #28]
  if (value == 0U)
 800702a:	69fb      	ldr	r3, [r7, #28]
 800702c:	2b00      	cmp	r3, #0
 800702e:	d101      	bne.n	8007034 <LL_GPIO_Init+0x26>
    return 32U;
 8007030:	2320      	movs	r3, #32
 8007032:	e003      	b.n	800703c <LL_GPIO_Init+0x2e>
  return __builtin_clz(value);
 8007034:	69fb      	ldr	r3, [r7, #28]
 8007036:	fab3 f383 	clz	r3, r3
 800703a:	b2db      	uxtb	r3, r3
 800703c:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the port pins */
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00u)
 800703e:	e057      	b.n	80070f0 <LL_GPIO_Init+0xe2>
  {
    /* Get current io position */
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001uL << pinpos);
 8007040:	683b      	ldr	r3, [r7, #0]
 8007042:	681a      	ldr	r2, [r3, #0]
 8007044:	2101      	movs	r1, #1
 8007046:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007048:	fa01 f303 	lsl.w	r3, r1, r3
 800704c:	4013      	ands	r3, r2
 800704e:	623b      	str	r3, [r7, #32]

    if (currentpin != 0x00u)
 8007050:	6a3b      	ldr	r3, [r7, #32]
 8007052:	2b00      	cmp	r3, #0
 8007054:	d049      	beq.n	80070ea <LL_GPIO_Init+0xdc>
    {
      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8007056:	683b      	ldr	r3, [r7, #0]
 8007058:	685b      	ldr	r3, [r3, #4]
 800705a:	2b01      	cmp	r3, #1
 800705c:	d003      	beq.n	8007066 <LL_GPIO_Init+0x58>
 800705e:	683b      	ldr	r3, [r7, #0]
 8007060:	685b      	ldr	r3, [r3, #4]
 8007062:	2b02      	cmp	r3, #2
 8007064:	d10d      	bne.n	8007082 <LL_GPIO_Init+0x74>
      {
        /* Check Speed mode parameters */
        assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));

        /* Speed mode configuration */
        LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
 8007066:	683b      	ldr	r3, [r7, #0]
 8007068:	689b      	ldr	r3, [r3, #8]
 800706a:	461a      	mov	r2, r3
 800706c:	6a39      	ldr	r1, [r7, #32]
 800706e:	6878      	ldr	r0, [r7, #4]
 8007070:	f7ff fed7 	bl	8006e22 <LL_GPIO_SetPinSpeed>

        /* Check Output mode parameters */
        assert_param(IS_LL_GPIO_OUTPUT_TYPE(GPIO_InitStruct->OutputType));

        /* Output mode configuration*/
        LL_GPIO_SetPinOutputType(GPIOx, currentpin, GPIO_InitStruct->OutputType);
 8007074:	683b      	ldr	r3, [r7, #0]
 8007076:	68db      	ldr	r3, [r3, #12]
 8007078:	461a      	mov	r2, r3
 800707a:	6a39      	ldr	r1, [r7, #32]
 800707c:	6878      	ldr	r0, [r7, #4]
 800707e:	f7ff feb8 	bl	8006df2 <LL_GPIO_SetPinOutputType>
      }

      /* Pull-up Pull down resistor configuration*/
      LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
 8007082:	683b      	ldr	r3, [r7, #0]
 8007084:	691b      	ldr	r3, [r3, #16]
 8007086:	461a      	mov	r2, r3
 8007088:	6a39      	ldr	r1, [r7, #32]
 800708a:	6878      	ldr	r0, [r7, #4]
 800708c:	f7ff ff06 	bl	8006e9c <LL_GPIO_SetPinPull>

      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 8007090:	683b      	ldr	r3, [r7, #0]
 8007092:	685b      	ldr	r3, [r3, #4]
 8007094:	2b02      	cmp	r3, #2
 8007096:	d121      	bne.n	80070dc <LL_GPIO_Init+0xce>
 8007098:	6a3b      	ldr	r3, [r7, #32]
 800709a:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800709c:	68fb      	ldr	r3, [r7, #12]
 800709e:	fa93 f3a3 	rbit	r3, r3
 80070a2:	60bb      	str	r3, [r7, #8]
  return result;
 80070a4:	68bb      	ldr	r3, [r7, #8]
 80070a6:	613b      	str	r3, [r7, #16]
  if (value == 0U)
 80070a8:	693b      	ldr	r3, [r7, #16]
 80070aa:	2b00      	cmp	r3, #0
 80070ac:	d101      	bne.n	80070b2 <LL_GPIO_Init+0xa4>
    return 32U;
 80070ae:	2320      	movs	r3, #32
 80070b0:	e003      	b.n	80070ba <LL_GPIO_Init+0xac>
  return __builtin_clz(value);
 80070b2:	693b      	ldr	r3, [r7, #16]
 80070b4:	fab3 f383 	clz	r3, r3
 80070b8:	b2db      	uxtb	r3, r3
      {
        /* Check Alternate parameter */
        assert_param(IS_LL_GPIO_ALTERNATE(GPIO_InitStruct->Alternate));

        /* Speed mode configuration */
        if (POSITION_VAL(currentpin) < 0x00000008uL)
 80070ba:	2b07      	cmp	r3, #7
 80070bc:	d807      	bhi.n	80070ce <LL_GPIO_Init+0xc0>
        {
          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 80070be:	683b      	ldr	r3, [r7, #0]
 80070c0:	695b      	ldr	r3, [r3, #20]
 80070c2:	461a      	mov	r2, r3
 80070c4:	6a39      	ldr	r1, [r7, #32]
 80070c6:	6878      	ldr	r0, [r7, #4]
 80070c8:	f7ff ff25 	bl	8006f16 <LL_GPIO_SetAFPin_0_7>
 80070cc:	e006      	b.n	80070dc <LL_GPIO_Init+0xce>
        }
        else
        {
          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 80070ce:	683b      	ldr	r3, [r7, #0]
 80070d0:	695b      	ldr	r3, [r3, #20]
 80070d2:	461a      	mov	r2, r3
 80070d4:	6a39      	ldr	r1, [r7, #32]
 80070d6:	6878      	ldr	r0, [r7, #4]
 80070d8:	f7ff ff5a 	bl	8006f90 <LL_GPIO_SetAFPin_8_15>
        }
      }

      /* Pin Mode configuration */
      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
 80070dc:	683b      	ldr	r3, [r7, #0]
 80070de:	685b      	ldr	r3, [r3, #4]
 80070e0:	461a      	mov	r2, r3
 80070e2:	6a39      	ldr	r1, [r7, #32]
 80070e4:	6878      	ldr	r0, [r7, #4]
 80070e6:	f7ff fe47 	bl	8006d78 <LL_GPIO_SetPinMode>
    }
    pinpos++;
 80070ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80070ec:	3301      	adds	r3, #1
 80070ee:	627b      	str	r3, [r7, #36]	; 0x24
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00u)
 80070f0:	683b      	ldr	r3, [r7, #0]
 80070f2:	681a      	ldr	r2, [r3, #0]
 80070f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80070f6:	fa22 f303 	lsr.w	r3, r2, r3
 80070fa:	2b00      	cmp	r3, #0
 80070fc:	d1a0      	bne.n	8007040 <LL_GPIO_Init+0x32>
  }

  return (SUCCESS);
 80070fe:	2300      	movs	r3, #0
}
 8007100:	4618      	mov	r0, r3
 8007102:	3728      	adds	r7, #40	; 0x28
 8007104:	46bd      	mov	sp, r7
 8007106:	bd80      	pop	{r7, pc}

08007108 <LL_TIM_SetPrescaler>:
{
 8007108:	b480      	push	{r7}
 800710a:	b083      	sub	sp, #12
 800710c:	af00      	add	r7, sp, #0
 800710e:	6078      	str	r0, [r7, #4]
 8007110:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->PSC, Prescaler);
 8007112:	687b      	ldr	r3, [r7, #4]
 8007114:	683a      	ldr	r2, [r7, #0]
 8007116:	629a      	str	r2, [r3, #40]	; 0x28
}
 8007118:	bf00      	nop
 800711a:	370c      	adds	r7, #12
 800711c:	46bd      	mov	sp, r7
 800711e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007122:	4770      	bx	lr

08007124 <LL_TIM_SetAutoReload>:
{
 8007124:	b480      	push	{r7}
 8007126:	b083      	sub	sp, #12
 8007128:	af00      	add	r7, sp, #0
 800712a:	6078      	str	r0, [r7, #4]
 800712c:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->ARR, AutoReload);
 800712e:	687b      	ldr	r3, [r7, #4]
 8007130:	683a      	ldr	r2, [r7, #0]
 8007132:	62da      	str	r2, [r3, #44]	; 0x2c
}
 8007134:	bf00      	nop
 8007136:	370c      	adds	r7, #12
 8007138:	46bd      	mov	sp, r7
 800713a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800713e:	4770      	bx	lr

08007140 <LL_TIM_SetRepetitionCounter>:
{
 8007140:	b480      	push	{r7}
 8007142:	b083      	sub	sp, #12
 8007144:	af00      	add	r7, sp, #0
 8007146:	6078      	str	r0, [r7, #4]
 8007148:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 800714a:	687b      	ldr	r3, [r7, #4]
 800714c:	683a      	ldr	r2, [r7, #0]
 800714e:	631a      	str	r2, [r3, #48]	; 0x30
}
 8007150:	bf00      	nop
 8007152:	370c      	adds	r7, #12
 8007154:	46bd      	mov	sp, r7
 8007156:	f85d 7b04 	ldr.w	r7, [sp], #4
 800715a:	4770      	bx	lr

0800715c <LL_TIM_OC_SetCompareCH1>:
{
 800715c:	b480      	push	{r7}
 800715e:	b083      	sub	sp, #12
 8007160:	af00      	add	r7, sp, #0
 8007162:	6078      	str	r0, [r7, #4]
 8007164:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->CCR1, CompareValue);
 8007166:	687b      	ldr	r3, [r7, #4]
 8007168:	683a      	ldr	r2, [r7, #0]
 800716a:	635a      	str	r2, [r3, #52]	; 0x34
}
 800716c:	bf00      	nop
 800716e:	370c      	adds	r7, #12
 8007170:	46bd      	mov	sp, r7
 8007172:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007176:	4770      	bx	lr

08007178 <LL_TIM_OC_SetCompareCH2>:
{
 8007178:	b480      	push	{r7}
 800717a:	b083      	sub	sp, #12
 800717c:	af00      	add	r7, sp, #0
 800717e:	6078      	str	r0, [r7, #4]
 8007180:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->CCR2, CompareValue);
 8007182:	687b      	ldr	r3, [r7, #4]
 8007184:	683a      	ldr	r2, [r7, #0]
 8007186:	639a      	str	r2, [r3, #56]	; 0x38
}
 8007188:	bf00      	nop
 800718a:	370c      	adds	r7, #12
 800718c:	46bd      	mov	sp, r7
 800718e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007192:	4770      	bx	lr

08007194 <LL_TIM_OC_SetCompareCH3>:
{
 8007194:	b480      	push	{r7}
 8007196:	b083      	sub	sp, #12
 8007198:	af00      	add	r7, sp, #0
 800719a:	6078      	str	r0, [r7, #4]
 800719c:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->CCR3, CompareValue);
 800719e:	687b      	ldr	r3, [r7, #4]
 80071a0:	683a      	ldr	r2, [r7, #0]
 80071a2:	63da      	str	r2, [r3, #60]	; 0x3c
}
 80071a4:	bf00      	nop
 80071a6:	370c      	adds	r7, #12
 80071a8:	46bd      	mov	sp, r7
 80071aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80071ae:	4770      	bx	lr

080071b0 <LL_TIM_OC_SetCompareCH4>:
{
 80071b0:	b480      	push	{r7}
 80071b2:	b083      	sub	sp, #12
 80071b4:	af00      	add	r7, sp, #0
 80071b6:	6078      	str	r0, [r7, #4]
 80071b8:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->CCR4, CompareValue);
 80071ba:	687b      	ldr	r3, [r7, #4]
 80071bc:	683a      	ldr	r2, [r7, #0]
 80071be:	641a      	str	r2, [r3, #64]	; 0x40
}
 80071c0:	bf00      	nop
 80071c2:	370c      	adds	r7, #12
 80071c4:	46bd      	mov	sp, r7
 80071c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80071ca:	4770      	bx	lr

080071cc <LL_TIM_OC_SetCompareCH5>:
{
 80071cc:	b480      	push	{r7}
 80071ce:	b083      	sub	sp, #12
 80071d0:	af00      	add	r7, sp, #0
 80071d2:	6078      	str	r0, [r7, #4]
 80071d4:	6039      	str	r1, [r7, #0]
  MODIFY_REG(TIMx->CCR5, TIM_CCR5_CCR5, CompareValue);
 80071d6:	687b      	ldr	r3, [r7, #4]
 80071d8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80071da:	687b      	ldr	r3, [r7, #4]
 80071dc:	683a      	ldr	r2, [r7, #0]
 80071de:	659a      	str	r2, [r3, #88]	; 0x58
}
 80071e0:	bf00      	nop
 80071e2:	370c      	adds	r7, #12
 80071e4:	46bd      	mov	sp, r7
 80071e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80071ea:	4770      	bx	lr

080071ec <LL_TIM_OC_SetCompareCH6>:
{
 80071ec:	b480      	push	{r7}
 80071ee:	b083      	sub	sp, #12
 80071f0:	af00      	add	r7, sp, #0
 80071f2:	6078      	str	r0, [r7, #4]
 80071f4:	6039      	str	r1, [r7, #0]
  WRITE_REG(TIMx->CCR6, CompareValue);
 80071f6:	687b      	ldr	r3, [r7, #4]
 80071f8:	683a      	ldr	r2, [r7, #0]
 80071fa:	65da      	str	r2, [r3, #92]	; 0x5c
}
 80071fc:	bf00      	nop
 80071fe:	370c      	adds	r7, #12
 8007200:	46bd      	mov	sp, r7
 8007202:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007206:	4770      	bx	lr

08007208 <LL_TIM_GenerateEvent_UPDATE>:
  * @rmtoll EGR          UG            LL_TIM_GenerateEvent_UPDATE
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
{
 8007208:	b480      	push	{r7}
 800720a:	b083      	sub	sp, #12
 800720c:	af00      	add	r7, sp, #0
 800720e:	6078      	str	r0, [r7, #4]
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8007210:	687b      	ldr	r3, [r7, #4]
 8007212:	695b      	ldr	r3, [r3, #20]
 8007214:	f043 0201 	orr.w	r2, r3, #1
 8007218:	687b      	ldr	r3, [r7, #4]
 800721a:	615a      	str	r2, [r3, #20]
}
 800721c:	bf00      	nop
 800721e:	370c      	adds	r7, #12
 8007220:	46bd      	mov	sp, r7
 8007222:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007226:	4770      	bx	lr

08007228 <LL_TIM_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
ErrorStatus LL_TIM_Init(TIM_TypeDef *TIMx, const LL_TIM_InitTypeDef *TIM_InitStruct)
{
 8007228:	b580      	push	{r7, lr}
 800722a:	b084      	sub	sp, #16
 800722c:	af00      	add	r7, sp, #0
 800722e:	6078      	str	r0, [r7, #4]
 8007230:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(TIMx));
  assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
  assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));

  tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
 8007232:	687b      	ldr	r3, [r7, #4]
 8007234:	681b      	ldr	r3, [r3, #0]
 8007236:	60fb      	str	r3, [r7, #12]

  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007238:	687b      	ldr	r3, [r7, #4]
 800723a:	4a27      	ldr	r2, [pc, #156]	; (80072d8 <LL_TIM_Init+0xb0>)
 800723c:	4293      	cmp	r3, r2
 800723e:	d003      	beq.n	8007248 <LL_TIM_Init+0x20>
 8007240:	687b      	ldr	r3, [r7, #4]
 8007242:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8007246:	d106      	bne.n	8007256 <LL_TIM_Init+0x2e>
  {
    /* Select the Counter Mode */
    MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
 8007248:	68fb      	ldr	r3, [r7, #12]
 800724a:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 800724e:	683b      	ldr	r3, [r7, #0]
 8007250:	685b      	ldr	r3, [r3, #4]
 8007252:	4313      	orrs	r3, r2
 8007254:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8007256:	687b      	ldr	r3, [r7, #4]
 8007258:	4a1f      	ldr	r2, [pc, #124]	; (80072d8 <LL_TIM_Init+0xb0>)
 800725a:	4293      	cmp	r3, r2
 800725c:	d00b      	beq.n	8007276 <LL_TIM_Init+0x4e>
 800725e:	687b      	ldr	r3, [r7, #4]
 8007260:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8007264:	d007      	beq.n	8007276 <LL_TIM_Init+0x4e>
 8007266:	687b      	ldr	r3, [r7, #4]
 8007268:	4a1c      	ldr	r2, [pc, #112]	; (80072dc <LL_TIM_Init+0xb4>)
 800726a:	4293      	cmp	r3, r2
 800726c:	d003      	beq.n	8007276 <LL_TIM_Init+0x4e>
 800726e:	687b      	ldr	r3, [r7, #4]
 8007270:	4a1b      	ldr	r2, [pc, #108]	; (80072e0 <LL_TIM_Init+0xb8>)
 8007272:	4293      	cmp	r3, r2
 8007274:	d106      	bne.n	8007284 <LL_TIM_Init+0x5c>
  {
    /* Set the clock division */
    MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
 8007276:	68fb      	ldr	r3, [r7, #12]
 8007278:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 800727c:	683b      	ldr	r3, [r7, #0]
 800727e:	68db      	ldr	r3, [r3, #12]
 8007280:	4313      	orrs	r3, r2
 8007282:	60fb      	str	r3, [r7, #12]
  }

  /* Write to TIMx CR1 */
  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
 8007284:	687b      	ldr	r3, [r7, #4]
 8007286:	68fa      	ldr	r2, [r7, #12]
 8007288:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
 800728a:	683b      	ldr	r3, [r7, #0]
 800728c:	689b      	ldr	r3, [r3, #8]
 800728e:	4619      	mov	r1, r3
 8007290:	6878      	ldr	r0, [r7, #4]
 8007292:	f7ff ff47 	bl	8007124 <LL_TIM_SetAutoReload>

  /* Set the Prescaler value */
  LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
 8007296:	683b      	ldr	r3, [r7, #0]
 8007298:	881b      	ldrh	r3, [r3, #0]
 800729a:	4619      	mov	r1, r3
 800729c:	6878      	ldr	r0, [r7, #4]
 800729e:	f7ff ff33 	bl	8007108 <LL_TIM_SetPrescaler>

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80072a2:	687b      	ldr	r3, [r7, #4]
 80072a4:	4a0c      	ldr	r2, [pc, #48]	; (80072d8 <LL_TIM_Init+0xb0>)
 80072a6:	4293      	cmp	r3, r2
 80072a8:	d007      	beq.n	80072ba <LL_TIM_Init+0x92>
 80072aa:	687b      	ldr	r3, [r7, #4]
 80072ac:	4a0b      	ldr	r2, [pc, #44]	; (80072dc <LL_TIM_Init+0xb4>)
 80072ae:	4293      	cmp	r3, r2
 80072b0:	d003      	beq.n	80072ba <LL_TIM_Init+0x92>
 80072b2:	687b      	ldr	r3, [r7, #4]
 80072b4:	4a0a      	ldr	r2, [pc, #40]	; (80072e0 <LL_TIM_Init+0xb8>)
 80072b6:	4293      	cmp	r3, r2
 80072b8:	d105      	bne.n	80072c6 <LL_TIM_Init+0x9e>
  {
    /* Set the Repetition Counter value */
    LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
 80072ba:	683b      	ldr	r3, [r7, #0]
 80072bc:	691b      	ldr	r3, [r3, #16]
 80072be:	4619      	mov	r1, r3
 80072c0:	6878      	ldr	r0, [r7, #4]
 80072c2:	f7ff ff3d 	bl	8007140 <LL_TIM_SetRepetitionCounter>
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter value (if applicable) immediately */
  LL_TIM_GenerateEvent_UPDATE(TIMx);
 80072c6:	6878      	ldr	r0, [r7, #4]
 80072c8:	f7ff ff9e 	bl	8007208 <LL_TIM_GenerateEvent_UPDATE>

  return SUCCESS;
 80072cc:	2300      	movs	r3, #0
}
 80072ce:	4618      	mov	r0, r3
 80072d0:	3710      	adds	r7, #16
 80072d2:	46bd      	mov	sp, r7
 80072d4:	bd80      	pop	{r7, pc}
 80072d6:	bf00      	nop
 80072d8:	40012c00 	.word	0x40012c00
 80072dc:	40014400 	.word	0x40014400
 80072e0:	40014800 	.word	0x40014800

080072e4 <LL_TIM_OC_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx output channel is initialized
  *          - ERROR: TIMx output channel is not initialized
  */
ErrorStatus LL_TIM_OC_Init(TIM_TypeDef *TIMx, uint32_t Channel, const LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
{
 80072e4:	b580      	push	{r7, lr}
 80072e6:	b086      	sub	sp, #24
 80072e8:	af00      	add	r7, sp, #0
 80072ea:	60f8      	str	r0, [r7, #12]
 80072ec:	60b9      	str	r1, [r7, #8]
 80072ee:	607a      	str	r2, [r7, #4]
  ErrorStatus result = ERROR;
 80072f0:	2301      	movs	r3, #1
 80072f2:	75fb      	strb	r3, [r7, #23]

  switch (Channel)
 80072f4:	68bb      	ldr	r3, [r7, #8]
 80072f6:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80072fa:	d045      	beq.n	8007388 <LL_TIM_OC_Init+0xa4>
 80072fc:	68bb      	ldr	r3, [r7, #8]
 80072fe:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8007302:	d848      	bhi.n	8007396 <LL_TIM_OC_Init+0xb2>
 8007304:	68bb      	ldr	r3, [r7, #8]
 8007306:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800730a:	d036      	beq.n	800737a <LL_TIM_OC_Init+0x96>
 800730c:	68bb      	ldr	r3, [r7, #8]
 800730e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8007312:	d840      	bhi.n	8007396 <LL_TIM_OC_Init+0xb2>
 8007314:	68bb      	ldr	r3, [r7, #8]
 8007316:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800731a:	d027      	beq.n	800736c <LL_TIM_OC_Init+0x88>
 800731c:	68bb      	ldr	r3, [r7, #8]
 800731e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8007322:	d838      	bhi.n	8007396 <LL_TIM_OC_Init+0xb2>
 8007324:	68bb      	ldr	r3, [r7, #8]
 8007326:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800732a:	d018      	beq.n	800735e <LL_TIM_OC_Init+0x7a>
 800732c:	68bb      	ldr	r3, [r7, #8]
 800732e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007332:	d830      	bhi.n	8007396 <LL_TIM_OC_Init+0xb2>
 8007334:	68bb      	ldr	r3, [r7, #8]
 8007336:	2b01      	cmp	r3, #1
 8007338:	d003      	beq.n	8007342 <LL_TIM_OC_Init+0x5e>
 800733a:	68bb      	ldr	r3, [r7, #8]
 800733c:	2b10      	cmp	r3, #16
 800733e:	d007      	beq.n	8007350 <LL_TIM_OC_Init+0x6c>
      break;
    case LL_TIM_CHANNEL_CH6:
      result = OC6Config(TIMx, TIM_OC_InitStruct);
      break;
    default:
      break;
 8007340:	e029      	b.n	8007396 <LL_TIM_OC_Init+0xb2>
      result = OC1Config(TIMx, TIM_OC_InitStruct);
 8007342:	6879      	ldr	r1, [r7, #4]
 8007344:	68f8      	ldr	r0, [r7, #12]
 8007346:	f000 f8a7 	bl	8007498 <OC1Config>
 800734a:	4603      	mov	r3, r0
 800734c:	75fb      	strb	r3, [r7, #23]
      break;
 800734e:	e023      	b.n	8007398 <LL_TIM_OC_Init+0xb4>
      result = OC2Config(TIMx, TIM_OC_InitStruct);
 8007350:	6879      	ldr	r1, [r7, #4]
 8007352:	68f8      	ldr	r0, [r7, #12]
 8007354:	f000 f914 	bl	8007580 <OC2Config>
 8007358:	4603      	mov	r3, r0
 800735a:	75fb      	strb	r3, [r7, #23]
      break;
 800735c:	e01c      	b.n	8007398 <LL_TIM_OC_Init+0xb4>
      result = OC3Config(TIMx, TIM_OC_InitStruct);
 800735e:	6879      	ldr	r1, [r7, #4]
 8007360:	68f8      	ldr	r0, [r7, #12]
 8007362:	f000 f985 	bl	8007670 <OC3Config>
 8007366:	4603      	mov	r3, r0
 8007368:	75fb      	strb	r3, [r7, #23]
      break;
 800736a:	e015      	b.n	8007398 <LL_TIM_OC_Init+0xb4>
      result = OC4Config(TIMx, TIM_OC_InitStruct);
 800736c:	6879      	ldr	r1, [r7, #4]
 800736e:	68f8      	ldr	r0, [r7, #12]
 8007370:	f000 f9f6 	bl	8007760 <OC4Config>
 8007374:	4603      	mov	r3, r0
 8007376:	75fb      	strb	r3, [r7, #23]
      break;
 8007378:	e00e      	b.n	8007398 <LL_TIM_OC_Init+0xb4>
      result = OC5Config(TIMx, TIM_OC_InitStruct);
 800737a:	6879      	ldr	r1, [r7, #4]
 800737c:	68f8      	ldr	r0, [r7, #12]
 800737e:	f000 fa4f 	bl	8007820 <OC5Config>
 8007382:	4603      	mov	r3, r0
 8007384:	75fb      	strb	r3, [r7, #23]
      break;
 8007386:	e007      	b.n	8007398 <LL_TIM_OC_Init+0xb4>
      result = OC6Config(TIMx, TIM_OC_InitStruct);
 8007388:	6879      	ldr	r1, [r7, #4]
 800738a:	68f8      	ldr	r0, [r7, #12]
 800738c:	f000 faa0 	bl	80078d0 <OC6Config>
 8007390:	4603      	mov	r3, r0
 8007392:	75fb      	strb	r3, [r7, #23]
      break;
 8007394:	e000      	b.n	8007398 <LL_TIM_OC_Init+0xb4>
      break;
 8007396:	bf00      	nop
  }

  return result;
 8007398:	7dfb      	ldrb	r3, [r7, #23]
}
 800739a:	4618      	mov	r0, r3
 800739c:	3718      	adds	r7, #24
 800739e:	46bd      	mov	sp, r7
 80073a0:	bd80      	pop	{r7, pc}
	...

080073a4 <LL_TIM_BDTR_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: Break and Dead Time is initialized
  *          - ERROR: not applicable
  */
ErrorStatus LL_TIM_BDTR_Init(TIM_TypeDef *TIMx, const LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)
{
 80073a4:	b480      	push	{r7}
 80073a6:	b085      	sub	sp, #20
 80073a8:	af00      	add	r7, sp, #0
 80073aa:	6078      	str	r0, [r7, #4]
 80073ac:	6039      	str	r1, [r7, #0]
  uint32_t tmpbdtr = 0;
 80073ae:	2300      	movs	r3, #0
 80073b0:	60fb      	str	r3, [r7, #12]

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
  the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);
 80073b2:	68fb      	ldr	r3, [r7, #12]
 80073b4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80073b8:	683a      	ldr	r2, [r7, #0]
 80073ba:	7b12      	ldrb	r2, [r2, #12]
 80073bc:	4313      	orrs	r3, r2
 80073be:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
 80073c0:	68fb      	ldr	r3, [r7, #12]
 80073c2:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80073c6:	683b      	ldr	r3, [r7, #0]
 80073c8:	689b      	ldr	r3, [r3, #8]
 80073ca:	4313      	orrs	r3, r2
 80073cc:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);
 80073ce:	68fb      	ldr	r3, [r7, #12]
 80073d0:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 80073d4:	683b      	ldr	r3, [r7, #0]
 80073d6:	685b      	ldr	r3, [r3, #4]
 80073d8:	4313      	orrs	r3, r2
 80073da:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);
 80073dc:	68fb      	ldr	r3, [r7, #12]
 80073de:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 80073e2:	683b      	ldr	r3, [r7, #0]
 80073e4:	681b      	ldr	r3, [r3, #0]
 80073e6:	4313      	orrs	r3, r2
 80073e8:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);
 80073ea:	68fb      	ldr	r3, [r7, #12]
 80073ec:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80073f0:	683a      	ldr	r2, [r7, #0]
 80073f2:	89d2      	ldrh	r2, [r2, #14]
 80073f4:	4313      	orrs	r3, r2
 80073f6:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);
 80073f8:	68fb      	ldr	r3, [r7, #12]
 80073fa:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
 80073fe:	683b      	ldr	r3, [r7, #0]
 8007400:	691b      	ldr	r3, [r3, #16]
 8007402:	4313      	orrs	r3, r2
 8007404:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);
 8007406:	68fb      	ldr	r3, [r7, #12]
 8007408:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
 800740c:	683b      	ldr	r3, [r7, #0]
 800740e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007410:	4313      	orrs	r3, r2
 8007412:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);
 8007414:	68fb      	ldr	r3, [r7, #12]
 8007416:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 800741a:	683b      	ldr	r3, [r7, #0]
 800741c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800741e:	4313      	orrs	r3, r2
 8007420:	60fb      	str	r3, [r7, #12]
  assert_param(IS_LL_TIM_BREAK_FILTER(TIM_BDTRInitStruct->BreakFilter));
  assert_param(IS_LL_TIM_BREAK_AFMODE(TIM_BDTRInitStruct->BreakAFMode));
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, TIM_BDTRInitStruct->BreakFilter);
 8007422:	68fb      	ldr	r3, [r7, #12]
 8007424:	f423 2270 	bic.w	r2, r3, #983040	; 0xf0000
 8007428:	683b      	ldr	r3, [r7, #0]
 800742a:	695b      	ldr	r3, [r3, #20]
 800742c:	4313      	orrs	r3, r2
 800742e:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, TIM_BDTRInitStruct->BreakAFMode);
 8007430:	68fb      	ldr	r3, [r7, #12]
 8007432:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
 8007436:	683b      	ldr	r3, [r7, #0]
 8007438:	699b      	ldr	r3, [r3, #24]
 800743a:	4313      	orrs	r3, r2
 800743c:	60fb      	str	r3, [r7, #12]

  if (IS_TIM_BKIN2_INSTANCE(TIMx))
 800743e:	687b      	ldr	r3, [r7, #4]
 8007440:	4a14      	ldr	r2, [pc, #80]	; (8007494 <LL_TIM_BDTR_Init+0xf0>)
 8007442:	4293      	cmp	r3, r2
 8007444:	d11b      	bne.n	800747e <LL_TIM_BDTR_Init+0xda>
    assert_param(IS_LL_TIM_BREAK2_POLARITY(TIM_BDTRInitStruct->Break2Polarity));
    assert_param(IS_LL_TIM_BREAK2_FILTER(TIM_BDTRInitStruct->Break2Filter));
    assert_param(IS_LL_TIM_BREAK2_AFMODE(TIM_BDTRInitStruct->Break2AFMode));

    /* Set the BREAK2 input related BDTR bit-fields */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (TIM_BDTRInitStruct->Break2Filter));
 8007446:	68fb      	ldr	r3, [r7, #12]
 8007448:	f423 0270 	bic.w	r2, r3, #15728640	; 0xf00000
 800744c:	683b      	ldr	r3, [r7, #0]
 800744e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007450:	4313      	orrs	r3, r2
 8007452:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, TIM_BDTRInitStruct->Break2State);
 8007454:	68fb      	ldr	r3, [r7, #12]
 8007456:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
 800745a:	683b      	ldr	r3, [r7, #0]
 800745c:	69db      	ldr	r3, [r3, #28]
 800745e:	4313      	orrs	r3, r2
 8007460:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, TIM_BDTRInitStruct->Break2Polarity);
 8007462:	68fb      	ldr	r3, [r7, #12]
 8007464:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
 8007468:	683b      	ldr	r3, [r7, #0]
 800746a:	6a1b      	ldr	r3, [r3, #32]
 800746c:	4313      	orrs	r3, r2
 800746e:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, TIM_BDTRInitStruct->Break2AFMode);
 8007470:	68fb      	ldr	r3, [r7, #12]
 8007472:	f023 5200 	bic.w	r2, r3, #536870912	; 0x20000000
 8007476:	683b      	ldr	r3, [r7, #0]
 8007478:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800747a:	4313      	orrs	r3, r2
 800747c:	60fb      	str	r3, [r7, #12]
  }

  /* Set TIMx_BDTR */
  LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);
 800747e:	687b      	ldr	r3, [r7, #4]
 8007480:	68fa      	ldr	r2, [r7, #12]
 8007482:	645a      	str	r2, [r3, #68]	; 0x44

  return SUCCESS;
 8007484:	2300      	movs	r3, #0
}
 8007486:	4618      	mov	r0, r3
 8007488:	3714      	adds	r7, #20
 800748a:	46bd      	mov	sp, r7
 800748c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007490:	4770      	bx	lr
 8007492:	bf00      	nop
 8007494:	40012c00 	.word	0x40012c00

08007498 <OC1Config>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
static ErrorStatus OC1Config(TIM_TypeDef *TIMx, const LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
{
 8007498:	b580      	push	{r7, lr}
 800749a:	b086      	sub	sp, #24
 800749c:	af00      	add	r7, sp, #0
 800749e:	6078      	str	r0, [r7, #4]
 80074a0:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));

  /* Disable the Channel 1: Reset the CC1E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
 80074a2:	687b      	ldr	r3, [r7, #4]
 80074a4:	6a1b      	ldr	r3, [r3, #32]
 80074a6:	f023 0201 	bic.w	r2, r3, #1
 80074aa:	687b      	ldr	r3, [r7, #4]
 80074ac:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
 80074ae:	687b      	ldr	r3, [r7, #4]
 80074b0:	6a1b      	ldr	r3, [r3, #32]
 80074b2:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CR2 register value */
  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 80074b4:	687b      	ldr	r3, [r7, #4]
 80074b6:	685b      	ldr	r3, [r3, #4]
 80074b8:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
 80074ba:	687b      	ldr	r3, [r7, #4]
 80074bc:	699b      	ldr	r3, [r3, #24]
 80074be:	60fb      	str	r3, [r7, #12]

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
 80074c0:	68fb      	ldr	r3, [r7, #12]
 80074c2:	f023 0303 	bic.w	r3, r3, #3
 80074c6:	60fb      	str	r3, [r7, #12]

  /* Set the Output Compare Mode */
  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
 80074c8:	68fb      	ldr	r3, [r7, #12]
 80074ca:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80074ce:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80074d2:	683a      	ldr	r2, [r7, #0]
 80074d4:	6812      	ldr	r2, [r2, #0]
 80074d6:	4313      	orrs	r3, r2
 80074d8:	60fb      	str	r3, [r7, #12]

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
 80074da:	697b      	ldr	r3, [r7, #20]
 80074dc:	f023 0202 	bic.w	r2, r3, #2
 80074e0:	683b      	ldr	r3, [r7, #0]
 80074e2:	691b      	ldr	r3, [r3, #16]
 80074e4:	4313      	orrs	r3, r2
 80074e6:	617b      	str	r3, [r7, #20]

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
 80074e8:	697b      	ldr	r3, [r7, #20]
 80074ea:	f023 0201 	bic.w	r2, r3, #1
 80074ee:	683b      	ldr	r3, [r7, #0]
 80074f0:	685b      	ldr	r3, [r3, #4]
 80074f2:	4313      	orrs	r3, r2
 80074f4:	617b      	str	r3, [r7, #20]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80074f6:	687b      	ldr	r3, [r7, #4]
 80074f8:	4a1e      	ldr	r2, [pc, #120]	; (8007574 <OC1Config+0xdc>)
 80074fa:	4293      	cmp	r3, r2
 80074fc:	d007      	beq.n	800750e <OC1Config+0x76>
 80074fe:	687b      	ldr	r3, [r7, #4]
 8007500:	4a1d      	ldr	r2, [pc, #116]	; (8007578 <OC1Config+0xe0>)
 8007502:	4293      	cmp	r3, r2
 8007504:	d003      	beq.n	800750e <OC1Config+0x76>
 8007506:	687b      	ldr	r3, [r7, #4]
 8007508:	4a1c      	ldr	r2, [pc, #112]	; (800757c <OC1Config+0xe4>)
 800750a:	4293      	cmp	r3, r2
 800750c:	d11e      	bne.n	800754c <OC1Config+0xb4>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the complementary output Polarity */
    MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
 800750e:	697b      	ldr	r3, [r7, #20]
 8007510:	f023 0208 	bic.w	r2, r3, #8
 8007514:	683b      	ldr	r3, [r7, #0]
 8007516:	695b      	ldr	r3, [r3, #20]
 8007518:	009b      	lsls	r3, r3, #2
 800751a:	4313      	orrs	r3, r2
 800751c:	617b      	str	r3, [r7, #20]

    /* Set the complementary output State */
    MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
 800751e:	697b      	ldr	r3, [r7, #20]
 8007520:	f023 0204 	bic.w	r2, r3, #4
 8007524:	683b      	ldr	r3, [r7, #0]
 8007526:	689b      	ldr	r3, [r3, #8]
 8007528:	009b      	lsls	r3, r3, #2
 800752a:	4313      	orrs	r3, r2
 800752c:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
 800752e:	693b      	ldr	r3, [r7, #16]
 8007530:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8007534:	683b      	ldr	r3, [r7, #0]
 8007536:	699b      	ldr	r3, [r3, #24]
 8007538:	4313      	orrs	r3, r2
 800753a:	613b      	str	r3, [r7, #16]

    /* Set the complementary output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
 800753c:	693b      	ldr	r3, [r7, #16]
 800753e:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8007542:	683b      	ldr	r3, [r7, #0]
 8007544:	69db      	ldr	r3, [r3, #28]
 8007546:	005b      	lsls	r3, r3, #1
 8007548:	4313      	orrs	r3, r2
 800754a:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 800754c:	687b      	ldr	r3, [r7, #4]
 800754e:	693a      	ldr	r2, [r7, #16]
 8007550:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
 8007552:	687b      	ldr	r3, [r7, #4]
 8007554:	68fa      	ldr	r2, [r7, #12]
 8007556:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
 8007558:	683b      	ldr	r3, [r7, #0]
 800755a:	68db      	ldr	r3, [r3, #12]
 800755c:	4619      	mov	r1, r3
 800755e:	6878      	ldr	r0, [r7, #4]
 8007560:	f7ff fdfc 	bl	800715c <LL_TIM_OC_SetCompareCH1>

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 8007564:	687b      	ldr	r3, [r7, #4]
 8007566:	697a      	ldr	r2, [r7, #20]
 8007568:	621a      	str	r2, [r3, #32]

  return SUCCESS;
 800756a:	2300      	movs	r3, #0
}
 800756c:	4618      	mov	r0, r3
 800756e:	3718      	adds	r7, #24
 8007570:	46bd      	mov	sp, r7
 8007572:	bd80      	pop	{r7, pc}
 8007574:	40012c00 	.word	0x40012c00
 8007578:	40014400 	.word	0x40014400
 800757c:	40014800 	.word	0x40014800

08007580 <OC2Config>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
static ErrorStatus OC2Config(TIM_TypeDef *TIMx, const LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
{
 8007580:	b580      	push	{r7, lr}
 8007582:	b086      	sub	sp, #24
 8007584:	af00      	add	r7, sp, #0
 8007586:	6078      	str	r0, [r7, #4]
 8007588:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));

  /* Disable the Channel 2: Reset the CC2E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
 800758a:	687b      	ldr	r3, [r7, #4]
 800758c:	6a1b      	ldr	r3, [r3, #32]
 800758e:	f023 0210 	bic.w	r2, r3, #16
 8007592:	687b      	ldr	r3, [r7, #4]
 8007594:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
 8007596:	687b      	ldr	r3, [r7, #4]
 8007598:	6a1b      	ldr	r3, [r3, #32]
 800759a:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CR2 register value */
  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 800759c:	687b      	ldr	r3, [r7, #4]
 800759e:	685b      	ldr	r3, [r3, #4]
 80075a0:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
 80075a2:	687b      	ldr	r3, [r7, #4]
 80075a4:	699b      	ldr	r3, [r3, #24]
 80075a6:	60fb      	str	r3, [r7, #12]

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
 80075a8:	68fb      	ldr	r3, [r7, #12]
 80075aa:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80075ae:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
 80075b0:	68fb      	ldr	r3, [r7, #12]
 80075b2:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80075b6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80075ba:	683a      	ldr	r2, [r7, #0]
 80075bc:	6812      	ldr	r2, [r2, #0]
 80075be:	0212      	lsls	r2, r2, #8
 80075c0:	4313      	orrs	r3, r2
 80075c2:	60fb      	str	r3, [r7, #12]

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
 80075c4:	697b      	ldr	r3, [r7, #20]
 80075c6:	f023 0220 	bic.w	r2, r3, #32
 80075ca:	683b      	ldr	r3, [r7, #0]
 80075cc:	691b      	ldr	r3, [r3, #16]
 80075ce:	011b      	lsls	r3, r3, #4
 80075d0:	4313      	orrs	r3, r2
 80075d2:	617b      	str	r3, [r7, #20]

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
 80075d4:	697b      	ldr	r3, [r7, #20]
 80075d6:	f023 0210 	bic.w	r2, r3, #16
 80075da:	683b      	ldr	r3, [r7, #0]
 80075dc:	685b      	ldr	r3, [r3, #4]
 80075de:	011b      	lsls	r3, r3, #4
 80075e0:	4313      	orrs	r3, r2
 80075e2:	617b      	str	r3, [r7, #20]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80075e4:	687b      	ldr	r3, [r7, #4]
 80075e6:	4a1f      	ldr	r2, [pc, #124]	; (8007664 <OC2Config+0xe4>)
 80075e8:	4293      	cmp	r3, r2
 80075ea:	d007      	beq.n	80075fc <OC2Config+0x7c>
 80075ec:	687b      	ldr	r3, [r7, #4]
 80075ee:	4a1e      	ldr	r2, [pc, #120]	; (8007668 <OC2Config+0xe8>)
 80075f0:	4293      	cmp	r3, r2
 80075f2:	d003      	beq.n	80075fc <OC2Config+0x7c>
 80075f4:	687b      	ldr	r3, [r7, #4]
 80075f6:	4a1d      	ldr	r2, [pc, #116]	; (800766c <OC2Config+0xec>)
 80075f8:	4293      	cmp	r3, r2
 80075fa:	d11f      	bne.n	800763c <OC2Config+0xbc>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the complementary output Polarity */
    MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
 80075fc:	697b      	ldr	r3, [r7, #20]
 80075fe:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8007602:	683b      	ldr	r3, [r7, #0]
 8007604:	695b      	ldr	r3, [r3, #20]
 8007606:	019b      	lsls	r3, r3, #6
 8007608:	4313      	orrs	r3, r2
 800760a:	617b      	str	r3, [r7, #20]

    /* Set the complementary output State */
    MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
 800760c:	697b      	ldr	r3, [r7, #20]
 800760e:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 8007612:	683b      	ldr	r3, [r7, #0]
 8007614:	689b      	ldr	r3, [r3, #8]
 8007616:	019b      	lsls	r3, r3, #6
 8007618:	4313      	orrs	r3, r2
 800761a:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
 800761c:	693b      	ldr	r3, [r7, #16]
 800761e:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 8007622:	683b      	ldr	r3, [r7, #0]
 8007624:	699b      	ldr	r3, [r3, #24]
 8007626:	009b      	lsls	r3, r3, #2
 8007628:	4313      	orrs	r3, r2
 800762a:	613b      	str	r3, [r7, #16]

    /* Set the complementary output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
 800762c:	693b      	ldr	r3, [r7, #16]
 800762e:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 8007632:	683b      	ldr	r3, [r7, #0]
 8007634:	69db      	ldr	r3, [r3, #28]
 8007636:	00db      	lsls	r3, r3, #3
 8007638:	4313      	orrs	r3, r2
 800763a:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 800763c:	687b      	ldr	r3, [r7, #4]
 800763e:	693a      	ldr	r2, [r7, #16]
 8007640:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
 8007642:	687b      	ldr	r3, [r7, #4]
 8007644:	68fa      	ldr	r2, [r7, #12]
 8007646:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
 8007648:	683b      	ldr	r3, [r7, #0]
 800764a:	68db      	ldr	r3, [r3, #12]
 800764c:	4619      	mov	r1, r3
 800764e:	6878      	ldr	r0, [r7, #4]
 8007650:	f7ff fd92 	bl	8007178 <LL_TIM_OC_SetCompareCH2>

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 8007654:	687b      	ldr	r3, [r7, #4]
 8007656:	697a      	ldr	r2, [r7, #20]
 8007658:	621a      	str	r2, [r3, #32]

  return SUCCESS;
 800765a:	2300      	movs	r3, #0
}
 800765c:	4618      	mov	r0, r3
 800765e:	3718      	adds	r7, #24
 8007660:	46bd      	mov	sp, r7
 8007662:	bd80      	pop	{r7, pc}
 8007664:	40012c00 	.word	0x40012c00
 8007668:	40014400 	.word	0x40014400
 800766c:	40014800 	.word	0x40014800

08007670 <OC3Config>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
static ErrorStatus OC3Config(TIM_TypeDef *TIMx, const LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
{
 8007670:	b580      	push	{r7, lr}
 8007672:	b086      	sub	sp, #24
 8007674:	af00      	add	r7, sp, #0
 8007676:	6078      	str	r0, [r7, #4]
 8007678:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));

  /* Disable the Channel 3: Reset the CC3E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
 800767a:	687b      	ldr	r3, [r7, #4]
 800767c:	6a1b      	ldr	r3, [r3, #32]
 800767e:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8007682:	687b      	ldr	r3, [r7, #4]
 8007684:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
 8007686:	687b      	ldr	r3, [r7, #4]
 8007688:	6a1b      	ldr	r3, [r3, #32]
 800768a:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CR2 register value */
  tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
 800768c:	687b      	ldr	r3, [r7, #4]
 800768e:	685b      	ldr	r3, [r3, #4]
 8007690:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
 8007692:	687b      	ldr	r3, [r7, #4]
 8007694:	69db      	ldr	r3, [r3, #28]
 8007696:	60fb      	str	r3, [r7, #12]

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
 8007698:	68fb      	ldr	r3, [r7, #12]
 800769a:	f023 0303 	bic.w	r3, r3, #3
 800769e:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
 80076a0:	68fb      	ldr	r3, [r7, #12]
 80076a2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80076a6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80076aa:	683a      	ldr	r2, [r7, #0]
 80076ac:	6812      	ldr	r2, [r2, #0]
 80076ae:	4313      	orrs	r3, r2
 80076b0:	60fb      	str	r3, [r7, #12]

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
 80076b2:	697b      	ldr	r3, [r7, #20]
 80076b4:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 80076b8:	683b      	ldr	r3, [r7, #0]
 80076ba:	691b      	ldr	r3, [r3, #16]
 80076bc:	021b      	lsls	r3, r3, #8
 80076be:	4313      	orrs	r3, r2
 80076c0:	617b      	str	r3, [r7, #20]

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
 80076c2:	697b      	ldr	r3, [r7, #20]
 80076c4:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 80076c8:	683b      	ldr	r3, [r7, #0]
 80076ca:	685b      	ldr	r3, [r3, #4]
 80076cc:	021b      	lsls	r3, r3, #8
 80076ce:	4313      	orrs	r3, r2
 80076d0:	617b      	str	r3, [r7, #20]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80076d2:	687b      	ldr	r3, [r7, #4]
 80076d4:	4a1f      	ldr	r2, [pc, #124]	; (8007754 <OC3Config+0xe4>)
 80076d6:	4293      	cmp	r3, r2
 80076d8:	d007      	beq.n	80076ea <OC3Config+0x7a>
 80076da:	687b      	ldr	r3, [r7, #4]
 80076dc:	4a1e      	ldr	r2, [pc, #120]	; (8007758 <OC3Config+0xe8>)
 80076de:	4293      	cmp	r3, r2
 80076e0:	d003      	beq.n	80076ea <OC3Config+0x7a>
 80076e2:	687b      	ldr	r3, [r7, #4]
 80076e4:	4a1d      	ldr	r2, [pc, #116]	; (800775c <OC3Config+0xec>)
 80076e6:	4293      	cmp	r3, r2
 80076e8:	d11f      	bne.n	800772a <OC3Config+0xba>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the complementary output Polarity */
    MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
 80076ea:	697b      	ldr	r3, [r7, #20]
 80076ec:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 80076f0:	683b      	ldr	r3, [r7, #0]
 80076f2:	695b      	ldr	r3, [r3, #20]
 80076f4:	029b      	lsls	r3, r3, #10
 80076f6:	4313      	orrs	r3, r2
 80076f8:	617b      	str	r3, [r7, #20]

    /* Set the complementary output State */
    MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
 80076fa:	697b      	ldr	r3, [r7, #20]
 80076fc:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 8007700:	683b      	ldr	r3, [r7, #0]
 8007702:	689b      	ldr	r3, [r3, #8]
 8007704:	029b      	lsls	r3, r3, #10
 8007706:	4313      	orrs	r3, r2
 8007708:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
 800770a:	693b      	ldr	r3, [r7, #16]
 800770c:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8007710:	683b      	ldr	r3, [r7, #0]
 8007712:	699b      	ldr	r3, [r3, #24]
 8007714:	011b      	lsls	r3, r3, #4
 8007716:	4313      	orrs	r3, r2
 8007718:	613b      	str	r3, [r7, #16]

    /* Set the complementary output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
 800771a:	693b      	ldr	r3, [r7, #16]
 800771c:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
 8007720:	683b      	ldr	r3, [r7, #0]
 8007722:	69db      	ldr	r3, [r3, #28]
 8007724:	015b      	lsls	r3, r3, #5
 8007726:	4313      	orrs	r3, r2
 8007728:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 800772a:	687b      	ldr	r3, [r7, #4]
 800772c:	693a      	ldr	r2, [r7, #16]
 800772e:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
 8007730:	687b      	ldr	r3, [r7, #4]
 8007732:	68fa      	ldr	r2, [r7, #12]
 8007734:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
 8007736:	683b      	ldr	r3, [r7, #0]
 8007738:	68db      	ldr	r3, [r3, #12]
 800773a:	4619      	mov	r1, r3
 800773c:	6878      	ldr	r0, [r7, #4]
 800773e:	f7ff fd29 	bl	8007194 <LL_TIM_OC_SetCompareCH3>

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 8007742:	687b      	ldr	r3, [r7, #4]
 8007744:	697a      	ldr	r2, [r7, #20]
 8007746:	621a      	str	r2, [r3, #32]

  return SUCCESS;
 8007748:	2300      	movs	r3, #0
}
 800774a:	4618      	mov	r0, r3
 800774c:	3718      	adds	r7, #24
 800774e:	46bd      	mov	sp, r7
 8007750:	bd80      	pop	{r7, pc}
 8007752:	bf00      	nop
 8007754:	40012c00 	.word	0x40012c00
 8007758:	40014400 	.word	0x40014400
 800775c:	40014800 	.word	0x40014800

08007760 <OC4Config>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
static ErrorStatus OC4Config(TIM_TypeDef *TIMx, const LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
{
 8007760:	b580      	push	{r7, lr}
 8007762:	b086      	sub	sp, #24
 8007764:	af00      	add	r7, sp, #0
 8007766:	6078      	str	r0, [r7, #4]
 8007768:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));

  /* Disable the Channel 4: Reset the CC4E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
 800776a:	687b      	ldr	r3, [r7, #4]
 800776c:	6a1b      	ldr	r3, [r3, #32]
 800776e:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8007772:	687b      	ldr	r3, [r7, #4]
 8007774:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
 8007776:	687b      	ldr	r3, [r7, #4]
 8007778:	6a1b      	ldr	r3, [r3, #32]
 800777a:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
 800777c:	687b      	ldr	r3, [r7, #4]
 800777e:	685b      	ldr	r3, [r3, #4]
 8007780:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
 8007782:	687b      	ldr	r3, [r7, #4]
 8007784:	69db      	ldr	r3, [r3, #28]
 8007786:	60fb      	str	r3, [r7, #12]

  /* Reset Capture/Compare selection Bits */
  CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
 8007788:	68fb      	ldr	r3, [r7, #12]
 800778a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800778e:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
 8007790:	68fb      	ldr	r3, [r7, #12]
 8007792:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8007796:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800779a:	683a      	ldr	r2, [r7, #0]
 800779c:	6812      	ldr	r2, [r2, #0]
 800779e:	0212      	lsls	r2, r2, #8
 80077a0:	4313      	orrs	r3, r2
 80077a2:	60fb      	str	r3, [r7, #12]

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
 80077a4:	693b      	ldr	r3, [r7, #16]
 80077a6:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
 80077aa:	683b      	ldr	r3, [r7, #0]
 80077ac:	691b      	ldr	r3, [r3, #16]
 80077ae:	031b      	lsls	r3, r3, #12
 80077b0:	4313      	orrs	r3, r2
 80077b2:	613b      	str	r3, [r7, #16]

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
 80077b4:	693b      	ldr	r3, [r7, #16]
 80077b6:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 80077ba:	683b      	ldr	r3, [r7, #0]
 80077bc:	685b      	ldr	r3, [r3, #4]
 80077be:	031b      	lsls	r3, r3, #12
 80077c0:	4313      	orrs	r3, r2
 80077c2:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80077c4:	687b      	ldr	r3, [r7, #4]
 80077c6:	4a13      	ldr	r2, [pc, #76]	; (8007814 <OC4Config+0xb4>)
 80077c8:	4293      	cmp	r3, r2
 80077ca:	d007      	beq.n	80077dc <OC4Config+0x7c>
 80077cc:	687b      	ldr	r3, [r7, #4]
 80077ce:	4a12      	ldr	r2, [pc, #72]	; (8007818 <OC4Config+0xb8>)
 80077d0:	4293      	cmp	r3, r2
 80077d2:	d003      	beq.n	80077dc <OC4Config+0x7c>
 80077d4:	687b      	ldr	r3, [r7, #4]
 80077d6:	4a11      	ldr	r2, [pc, #68]	; (800781c <OC4Config+0xbc>)
 80077d8:	4293      	cmp	r3, r2
 80077da:	d107      	bne.n	80077ec <OC4Config+0x8c>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the Output Idle state */
    MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
 80077dc:	697b      	ldr	r3, [r7, #20]
 80077de:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
 80077e2:	683b      	ldr	r3, [r7, #0]
 80077e4:	699b      	ldr	r3, [r3, #24]
 80077e6:	019b      	lsls	r3, r3, #6
 80077e8:	4313      	orrs	r3, r2
 80077ea:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
 80077ec:	687b      	ldr	r3, [r7, #4]
 80077ee:	697a      	ldr	r2, [r7, #20]
 80077f0:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
 80077f2:	687b      	ldr	r3, [r7, #4]
 80077f4:	68fa      	ldr	r2, [r7, #12]
 80077f6:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
 80077f8:	683b      	ldr	r3, [r7, #0]
 80077fa:	68db      	ldr	r3, [r3, #12]
 80077fc:	4619      	mov	r1, r3
 80077fe:	6878      	ldr	r0, [r7, #4]
 8007800:	f7ff fcd6 	bl	80071b0 <LL_TIM_OC_SetCompareCH4>

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 8007804:	687b      	ldr	r3, [r7, #4]
 8007806:	693a      	ldr	r2, [r7, #16]
 8007808:	621a      	str	r2, [r3, #32]

  return SUCCESS;
 800780a:	2300      	movs	r3, #0
}
 800780c:	4618      	mov	r0, r3
 800780e:	3718      	adds	r7, #24
 8007810:	46bd      	mov	sp, r7
 8007812:	bd80      	pop	{r7, pc}
 8007814:	40012c00 	.word	0x40012c00
 8007818:	40014400 	.word	0x40014400
 800781c:	40014800 	.word	0x40014800

08007820 <OC5Config>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
static ErrorStatus OC5Config(TIM_TypeDef *TIMx, const LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
{
 8007820:	b580      	push	{r7, lr}
 8007822:	b084      	sub	sp, #16
 8007824:	af00      	add	r7, sp, #0
 8007826:	6078      	str	r0, [r7, #4]
 8007828:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));

  /* Disable the Channel 5: Reset the CC5E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC5E);
 800782a:	687b      	ldr	r3, [r7, #4]
 800782c:	6a1b      	ldr	r3, [r3, #32]
 800782e:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8007832:	687b      	ldr	r3, [r7, #4]
 8007834:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
 8007836:	687b      	ldr	r3, [r7, #4]
 8007838:	6a1b      	ldr	r3, [r3, #32]
 800783a:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx CCMR3 register value */
  tmpccmr3 = LL_TIM_ReadReg(TIMx, CCMR3);
 800783c:	687b      	ldr	r3, [r7, #4]
 800783e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007840:	60bb      	str	r3, [r7, #8]

  /* Select the Output Compare Mode */
  MODIFY_REG(tmpccmr3, TIM_CCMR3_OC5M, TIM_OCInitStruct->OCMode);
 8007842:	68bb      	ldr	r3, [r7, #8]
 8007844:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8007848:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800784c:	683a      	ldr	r2, [r7, #0]
 800784e:	6812      	ldr	r2, [r2, #0]
 8007850:	4313      	orrs	r3, r2
 8007852:	60bb      	str	r3, [r7, #8]

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC5P, TIM_OCInitStruct->OCPolarity << 16U);
 8007854:	68fb      	ldr	r3, [r7, #12]
 8007856:	f423 3200 	bic.w	r2, r3, #131072	; 0x20000
 800785a:	683b      	ldr	r3, [r7, #0]
 800785c:	691b      	ldr	r3, [r3, #16]
 800785e:	041b      	lsls	r3, r3, #16
 8007860:	4313      	orrs	r3, r2
 8007862:	60fb      	str	r3, [r7, #12]

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC5E, TIM_OCInitStruct->OCState << 16U);
 8007864:	68fb      	ldr	r3, [r7, #12]
 8007866:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 800786a:	683b      	ldr	r3, [r7, #0]
 800786c:	685b      	ldr	r3, [r3, #4]
 800786e:	041b      	lsls	r3, r3, #16
 8007870:	4313      	orrs	r3, r2
 8007872:	60fb      	str	r3, [r7, #12]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8007874:	687b      	ldr	r3, [r7, #4]
 8007876:	4a13      	ldr	r2, [pc, #76]	; (80078c4 <OC5Config+0xa4>)
 8007878:	4293      	cmp	r3, r2
 800787a:	d007      	beq.n	800788c <OC5Config+0x6c>
 800787c:	687b      	ldr	r3, [r7, #4]
 800787e:	4a12      	ldr	r2, [pc, #72]	; (80078c8 <OC5Config+0xa8>)
 8007880:	4293      	cmp	r3, r2
 8007882:	d003      	beq.n	800788c <OC5Config+0x6c>
 8007884:	687b      	ldr	r3, [r7, #4]
 8007886:	4a11      	ldr	r2, [pc, #68]	; (80078cc <OC5Config+0xac>)
 8007888:	4293      	cmp	r3, r2
 800788a:	d109      	bne.n	80078a0 <OC5Config+0x80>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the Output Idle state */
    MODIFY_REG(TIMx->CR2, TIM_CR2_OIS5, TIM_OCInitStruct->OCIdleState << 8U);
 800788c:	687b      	ldr	r3, [r7, #4]
 800788e:	685b      	ldr	r3, [r3, #4]
 8007890:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8007894:	683b      	ldr	r3, [r7, #0]
 8007896:	699b      	ldr	r3, [r3, #24]
 8007898:	021b      	lsls	r3, r3, #8
 800789a:	431a      	orrs	r2, r3
 800789c:	687b      	ldr	r3, [r7, #4]
 800789e:	605a      	str	r2, [r3, #4]

  }

  /* Write to TIMx CCMR3 */
  LL_TIM_WriteReg(TIMx, CCMR3, tmpccmr3);
 80078a0:	687b      	ldr	r3, [r7, #4]
 80078a2:	68ba      	ldr	r2, [r7, #8]
 80078a4:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH5(TIMx, TIM_OCInitStruct->CompareValue);
 80078a6:	683b      	ldr	r3, [r7, #0]
 80078a8:	68db      	ldr	r3, [r3, #12]
 80078aa:	4619      	mov	r1, r3
 80078ac:	6878      	ldr	r0, [r7, #4]
 80078ae:	f7ff fc8d 	bl	80071cc <LL_TIM_OC_SetCompareCH5>

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 80078b2:	687b      	ldr	r3, [r7, #4]
 80078b4:	68fa      	ldr	r2, [r7, #12]
 80078b6:	621a      	str	r2, [r3, #32]

  return SUCCESS;
 80078b8:	2300      	movs	r3, #0
}
 80078ba:	4618      	mov	r0, r3
 80078bc:	3710      	adds	r7, #16
 80078be:	46bd      	mov	sp, r7
 80078c0:	bd80      	pop	{r7, pc}
 80078c2:	bf00      	nop
 80078c4:	40012c00 	.word	0x40012c00
 80078c8:	40014400 	.word	0x40014400
 80078cc:	40014800 	.word	0x40014800

080078d0 <OC6Config>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
static ErrorStatus OC6Config(TIM_TypeDef *TIMx, const LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
{
 80078d0:	b580      	push	{r7, lr}
 80078d2:	b084      	sub	sp, #16
 80078d4:	af00      	add	r7, sp, #0
 80078d6:	6078      	str	r0, [r7, #4]
 80078d8:	6039      	str	r1, [r7, #0]
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
  assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
  assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));

  /* Disable the Channel 5: Reset the CC6E Bit */
  CLEAR_BIT(TIMx->CCER, TIM_CCER_CC6E);
 80078da:	687b      	ldr	r3, [r7, #4]
 80078dc:	6a1b      	ldr	r3, [r3, #32]
 80078de:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 80078e2:	687b      	ldr	r3, [r7, #4]
 80078e4:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = LL_TIM_ReadReg(TIMx, CCER);
 80078e6:	687b      	ldr	r3, [r7, #4]
 80078e8:	6a1b      	ldr	r3, [r3, #32]
 80078ea:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx CCMR3 register value */
  tmpccmr3 = LL_TIM_ReadReg(TIMx, CCMR3);
 80078ec:	687b      	ldr	r3, [r7, #4]
 80078ee:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80078f0:	60bb      	str	r3, [r7, #8]

  /* Select the Output Compare Mode */
  MODIFY_REG(tmpccmr3, TIM_CCMR3_OC6M, TIM_OCInitStruct->OCMode << 8U);
 80078f2:	68bb      	ldr	r3, [r7, #8]
 80078f4:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80078f8:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80078fc:	683a      	ldr	r2, [r7, #0]
 80078fe:	6812      	ldr	r2, [r2, #0]
 8007900:	0212      	lsls	r2, r2, #8
 8007902:	4313      	orrs	r3, r2
 8007904:	60bb      	str	r3, [r7, #8]

  /* Set the Output Compare Polarity */
  MODIFY_REG(tmpccer, TIM_CCER_CC6P, TIM_OCInitStruct->OCPolarity << 20U);
 8007906:	68fb      	ldr	r3, [r7, #12]
 8007908:	f423 1200 	bic.w	r2, r3, #2097152	; 0x200000
 800790c:	683b      	ldr	r3, [r7, #0]
 800790e:	691b      	ldr	r3, [r3, #16]
 8007910:	051b      	lsls	r3, r3, #20
 8007912:	4313      	orrs	r3, r2
 8007914:	60fb      	str	r3, [r7, #12]

  /* Set the Output State */
  MODIFY_REG(tmpccer, TIM_CCER_CC6E, TIM_OCInitStruct->OCState << 20U);
 8007916:	68fb      	ldr	r3, [r7, #12]
 8007918:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 800791c:	683b      	ldr	r3, [r7, #0]
 800791e:	685b      	ldr	r3, [r3, #4]
 8007920:	051b      	lsls	r3, r3, #20
 8007922:	4313      	orrs	r3, r2
 8007924:	60fb      	str	r3, [r7, #12]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8007926:	687b      	ldr	r3, [r7, #4]
 8007928:	4a12      	ldr	r2, [pc, #72]	; (8007974 <OC6Config+0xa4>)
 800792a:	4293      	cmp	r3, r2
 800792c:	d007      	beq.n	800793e <OC6Config+0x6e>
 800792e:	687b      	ldr	r3, [r7, #4]
 8007930:	4a11      	ldr	r2, [pc, #68]	; (8007978 <OC6Config+0xa8>)
 8007932:	4293      	cmp	r3, r2
 8007934:	d003      	beq.n	800793e <OC6Config+0x6e>
 8007936:	687b      	ldr	r3, [r7, #4]
 8007938:	4a10      	ldr	r2, [pc, #64]	; (800797c <OC6Config+0xac>)
 800793a:	4293      	cmp	r3, r2
 800793c:	d109      	bne.n	8007952 <OC6Config+0x82>
  {
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));

    /* Set the Output Idle state */
    MODIFY_REG(TIMx->CR2, TIM_CR2_OIS6, TIM_OCInitStruct->OCIdleState << 10U);
 800793e:	687b      	ldr	r3, [r7, #4]
 8007940:	685b      	ldr	r3, [r3, #4]
 8007942:	f423 2280 	bic.w	r2, r3, #262144	; 0x40000
 8007946:	683b      	ldr	r3, [r7, #0]
 8007948:	699b      	ldr	r3, [r3, #24]
 800794a:	029b      	lsls	r3, r3, #10
 800794c:	431a      	orrs	r2, r3
 800794e:	687b      	ldr	r3, [r7, #4]
 8007950:	605a      	str	r2, [r3, #4]
  }

  /* Write to TIMx CCMR3 */
  LL_TIM_WriteReg(TIMx, CCMR3, tmpccmr3);
 8007952:	687b      	ldr	r3, [r7, #4]
 8007954:	68ba      	ldr	r2, [r7, #8]
 8007956:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  LL_TIM_OC_SetCompareCH6(TIMx, TIM_OCInitStruct->CompareValue);
 8007958:	683b      	ldr	r3, [r7, #0]
 800795a:	68db      	ldr	r3, [r3, #12]
 800795c:	4619      	mov	r1, r3
 800795e:	6878      	ldr	r0, [r7, #4]
 8007960:	f7ff fc44 	bl	80071ec <LL_TIM_OC_SetCompareCH6>

  /* Write to TIMx CCER */
  LL_TIM_WriteReg(TIMx, CCER, tmpccer);
 8007964:	687b      	ldr	r3, [r7, #4]
 8007966:	68fa      	ldr	r2, [r7, #12]
 8007968:	621a      	str	r2, [r3, #32]

  return SUCCESS;
 800796a:	2300      	movs	r3, #0
}
 800796c:	4618      	mov	r0, r3
 800796e:	3710      	adds	r7, #16
 8007970:	46bd      	mov	sp, r7
 8007972:	bd80      	pop	{r7, pc}
 8007974:	40012c00 	.word	0x40012c00
 8007978:	40014400 	.word	0x40014400
 800797c:	40014800 	.word	0x40014800

08007980 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_TypeDef *USBx)
{
 8007980:	b480      	push	{r7}
 8007982:	b085      	sub	sp, #20
 8007984:	af00      	add	r7, sp, #0
 8007986:	6078      	str	r0, [r7, #4]
  uint32_t winterruptmask;

  /* Set winterruptmask variable */
  winterruptmask = USB_CNTR_CTRM  | USB_CNTR_WKUPM |
 8007988:	f64b 7380 	movw	r3, #49024	; 0xbf80
 800798c:	60fb      	str	r3, [r7, #12]
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Clear interrupt mask */
  USBx->CNTR &= (uint16_t)(~winterruptmask);
 800798e:	687b      	ldr	r3, [r7, #4]
 8007990:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8007994:	b29a      	uxth	r2, r3
 8007996:	68fb      	ldr	r3, [r7, #12]
 8007998:	b29b      	uxth	r3, r3
 800799a:	43db      	mvns	r3, r3
 800799c:	b29b      	uxth	r3, r3
 800799e:	4013      	ands	r3, r2
 80079a0:	b29a      	uxth	r2, r3
 80079a2:	687b      	ldr	r3, [r7, #4]
 80079a4:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
 80079a8:	2300      	movs	r3, #0
}
 80079aa:	4618      	mov	r0, r3
 80079ac:	3714      	adds	r7, #20
 80079ae:	46bd      	mov	sp, r7
 80079b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079b4:	4770      	bx	lr

080079b6 <USB_DevInit>:
  * @param  cfg  pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 80079b6:	b084      	sub	sp, #16
 80079b8:	b480      	push	{r7}
 80079ba:	b083      	sub	sp, #12
 80079bc:	af00      	add	r7, sp, #0
 80079be:	6078      	str	r0, [r7, #4]
 80079c0:	f107 0014 	add.w	r0, r7, #20
 80079c4:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  /* Prevent unused argument(s) compilation warning */
  UNUSED(cfg);

  /* Init Device */
  /* CNTR_FRES = 1 */
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;
 80079c8:	687b      	ldr	r3, [r7, #4]
 80079ca:	2201      	movs	r2, #1
 80079cc:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  /* CNTR_FRES = 0 */
  USBx->CNTR = 0U;
 80079d0:	687b      	ldr	r3, [r7, #4]
 80079d2:	2200      	movs	r2, #0
 80079d4:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40

  /* Clear pending interrupts */
  USBx->ISTR = 0U;
 80079d8:	687b      	ldr	r3, [r7, #4]
 80079da:	2200      	movs	r2, #0
 80079dc:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;
 80079e0:	687b      	ldr	r3, [r7, #4]
 80079e2:	2200      	movs	r2, #0
 80079e4:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50

  return HAL_OK;
 80079e8:	2300      	movs	r3, #0
}
 80079ea:	4618      	mov	r0, r3
 80079ec:	370c      	adds	r7, #12
 80079ee:	46bd      	mov	sp, r7
 80079f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079f4:	b004      	add	sp, #16
 80079f6:	4770      	bx	lr

080079f8 <MX_FileX_Init>:
  * @brief  Application FileX Initialization.
  * @param memory_ptr: memory pointer
  * @retval int
  */
UINT MX_FileX_Init(VOID *memory_ptr)
{
 80079f8:	b580      	push	{r7, lr}
 80079fa:	b08c      	sub	sp, #48	; 0x30
 80079fc:	af06      	add	r7, sp, #24
 80079fe:	6078      	str	r0, [r7, #4]
  UINT ret = FX_SUCCESS;
 8007a00:	2300      	movs	r3, #0
 8007a02:	617b      	str	r3, [r7, #20]

  TX_BYTE_POOL *byte_pool = (TX_BYTE_POOL*)memory_ptr;
 8007a04:	687b      	ldr	r3, [r7, #4]
 8007a06:	613b      	str	r3, [r7, #16]
  /* USER CODE BEGIN 0 */

  /* USER CODE END 0 */

  /*Allocate memory for the main thread's stack*/
  ret = tx_byte_allocate(byte_pool, &pointer, FX_APP_THREAD_STACK_SIZE, TX_NO_WAIT);
 8007a08:	f107 010c 	add.w	r1, r7, #12
 8007a0c:	2300      	movs	r3, #0
 8007a0e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8007a12:	6938      	ldr	r0, [r7, #16]
 8007a14:	f003 fc90 	bl	800b338 <_tx_byte_allocate>
 8007a18:	6178      	str	r0, [r7, #20]

  /* Check FX_APP_THREAD_STACK_SIZE allocation*/
  if (ret != FX_SUCCESS)
 8007a1a:	697b      	ldr	r3, [r7, #20]
 8007a1c:	2b00      	cmp	r3, #0
 8007a1e:	d001      	beq.n	8007a24 <MX_FileX_Init+0x2c>
  {
    return TX_POOL_ERROR;
 8007a20:	2302      	movs	r3, #2
 8007a22:	e01b      	b.n	8007a5c <MX_FileX_Init+0x64>
  }

  /* Create the main thread.  */
  ret = tx_thread_create(&fx_app_thread, FX_APP_THREAD_NAME, fx_app_thread_entry, 0, pointer, FX_APP_THREAD_STACK_SIZE,
 8007a24:	68fb      	ldr	r3, [r7, #12]
 8007a26:	2201      	movs	r2, #1
 8007a28:	9205      	str	r2, [sp, #20]
 8007a2a:	2200      	movs	r2, #0
 8007a2c:	9204      	str	r2, [sp, #16]
 8007a2e:	220a      	movs	r2, #10
 8007a30:	9203      	str	r2, [sp, #12]
 8007a32:	220a      	movs	r2, #10
 8007a34:	9202      	str	r2, [sp, #8]
 8007a36:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8007a3a:	9201      	str	r2, [sp, #4]
 8007a3c:	9300      	str	r3, [sp, #0]
 8007a3e:	2300      	movs	r3, #0
 8007a40:	4a08      	ldr	r2, [pc, #32]	; (8007a64 <MX_FileX_Init+0x6c>)
 8007a42:	4909      	ldr	r1, [pc, #36]	; (8007a68 <MX_FileX_Init+0x70>)
 8007a44:	4809      	ldr	r0, [pc, #36]	; (8007a6c <MX_FileX_Init+0x74>)
 8007a46:	f005 fbfd 	bl	800d244 <_tx_thread_create>
 8007a4a:	6178      	str	r0, [r7, #20]
                         FX_APP_THREAD_PRIO, FX_APP_PREEMPTION_THRESHOLD, FX_APP_THREAD_TIME_SLICE, FX_APP_THREAD_AUTO_START);

  /* Check main thread creation */
  if (ret != FX_SUCCESS)
 8007a4c:	697b      	ldr	r3, [r7, #20]
 8007a4e:	2b00      	cmp	r3, #0
 8007a50:	d001      	beq.n	8007a56 <MX_FileX_Init+0x5e>
  {
    return TX_THREAD_ERROR;
 8007a52:	230e      	movs	r3, #14
 8007a54:	e002      	b.n	8007a5c <MX_FileX_Init+0x64>
  /* USER CODE BEGIN MX_FileX_Init */

  /* USER CODE END MX_FileX_Init */

  /* Initialize FileX.  */
  fx_system_initialize();
 8007a56:	f001 faef 	bl	8009038 <_fx_system_initialize>

  /* USER CODE BEGIN MX_FileX_Init 1*/

  /* USER CODE END MX_FileX_Init 1*/

  return ret;
 8007a5a:	697b      	ldr	r3, [r7, #20]
}
 8007a5c:	4618      	mov	r0, r3
 8007a5e:	3718      	adds	r7, #24
 8007a60:	46bd      	mov	sp, r7
 8007a62:	bd80      	pop	{r7, pc}
 8007a64:	08007a71 	.word	0x08007a71
 8007a68:	08013370 	.word	0x08013370
 8007a6c:	20004518 	.word	0x20004518

08007a70 <fx_app_thread_entry>:
 * @brief  Main thread entry.
 * @param thread_input: ULONG user argument used by the thread entry
 * @retval none
 */
void fx_app_thread_entry(ULONG thread_input)
{
 8007a70:	b580      	push	{r7, lr}
 8007a72:	b08e      	sub	sp, #56	; 0x38
 8007a74:	af0a      	add	r7, sp, #40	; 0x28
 8007a76:	6078      	str	r0, [r7, #4]
  UINT sram_status = FX_SUCCESS;
 8007a78:	2300      	movs	r3, #0
 8007a7a:	60fb      	str	r3, [r7, #12]
  /* USER CODE BEGIN fx_app_thread_entry 0 */

  /* USER CODE END fx_app_thread_entry 0 */

  /* Format the SRAM_BASE memory as FAT */
  sram_status =  fx_media_format(&sram_disk,                              // RamDisk pointer
 8007a7c:	2301      	movs	r3, #1
 8007a7e:	9309      	str	r3, [sp, #36]	; 0x24
 8007a80:	2301      	movs	r3, #1
 8007a82:	9308      	str	r3, [sp, #32]
 8007a84:	2308      	movs	r3, #8
 8007a86:	9307      	str	r3, [sp, #28]
 8007a88:	f44f 7300 	mov.w	r3, #512	; 0x200
 8007a8c:	9306      	str	r3, [sp, #24]
 8007a8e:	2310      	movs	r3, #16
 8007a90:	9305      	str	r3, [sp, #20]
 8007a92:	2300      	movs	r3, #0
 8007a94:	9304      	str	r3, [sp, #16]
 8007a96:	2320      	movs	r3, #32
 8007a98:	9303      	str	r3, [sp, #12]
 8007a9a:	2301      	movs	r3, #1
 8007a9c:	9302      	str	r3, [sp, #8]
 8007a9e:	4b13      	ldr	r3, [pc, #76]	; (8007aec <fx_app_thread_entry+0x7c>)
 8007aa0:	9301      	str	r3, [sp, #4]
 8007aa2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8007aa6:	9300      	str	r3, [sp, #0]
 8007aa8:	4b11      	ldr	r3, [pc, #68]	; (8007af0 <fx_app_thread_entry+0x80>)
 8007aaa:	2200      	movs	r2, #0
 8007aac:	4911      	ldr	r1, [pc, #68]	; (8007af4 <fx_app_thread_entry+0x84>)
 8007aae:	4812      	ldr	r0, [pc, #72]	; (8007af8 <fx_app_thread_entry+0x88>)
 8007ab0:	f003 fb5a 	bl	800b168 <_fxe_media_format>
 8007ab4:	60f8      	str	r0, [r7, #12]
                                 8,                                       // Sectors per cluster
                                 1,                                       // Heads
                                 1);                                      // Sectors per track

  /* Check the format sram_status */
  if (sram_status != FX_SUCCESS)
 8007ab6:	68fb      	ldr	r3, [r7, #12]
 8007ab8:	2b00      	cmp	r3, #0
 8007aba:	d000      	beq.n	8007abe <fx_app_thread_entry+0x4e>
  {
    /* USER CODE BEGIN SRAM MEDIA format error */
    while(1);
 8007abc:	e7fe      	b.n	8007abc <fx_app_thread_entry+0x4c>
    /* USER CODE END SRAM MEDIA format error */
  }

  /* Open the sram_disk driver */
  sram_status =  fx_media_open(&sram_disk, FX_SRAM_VOLUME_NAME, fx_stm32_sram_driver, (VOID *)FX_NULL, (VOID *) fx_sram_media_memory, sizeof(fx_sram_media_memory));
 8007abe:	f242 43b8 	movw	r3, #9400	; 0x24b8
 8007ac2:	9302      	str	r3, [sp, #8]
 8007ac4:	f44f 7300 	mov.w	r3, #512	; 0x200
 8007ac8:	9301      	str	r3, [sp, #4]
 8007aca:	4b09      	ldr	r3, [pc, #36]	; (8007af0 <fx_app_thread_entry+0x80>)
 8007acc:	9300      	str	r3, [sp, #0]
 8007ace:	2300      	movs	r3, #0
 8007ad0:	4a08      	ldr	r2, [pc, #32]	; (8007af4 <fx_app_thread_entry+0x84>)
 8007ad2:	4906      	ldr	r1, [pc, #24]	; (8007aec <fx_app_thread_entry+0x7c>)
 8007ad4:	4808      	ldr	r0, [pc, #32]	; (8007af8 <fx_app_thread_entry+0x88>)
 8007ad6:	f003 fb93 	bl	800b200 <_fxe_media_open>
 8007ada:	60f8      	str	r0, [r7, #12]

  /* Check the media open sram_status */
  if (sram_status != FX_SUCCESS)
 8007adc:	68fb      	ldr	r3, [r7, #12]
 8007ade:	2b00      	cmp	r3, #0
 8007ae0:	d000      	beq.n	8007ae4 <fx_app_thread_entry+0x74>
  {
    /* USER CODE BEGIN SRAM DRIVER open error */
    while(1);
 8007ae2:	e7fe      	b.n	8007ae2 <fx_app_thread_entry+0x72>
  }

  /* USER CODE BEGIN fx_app_thread_entry 1 */

  /* USER CODE END fx_app_thread_entry 1 */
}
 8007ae4:	bf00      	nop
 8007ae6:	3710      	adds	r7, #16
 8007ae8:	46bd      	mov	sp, r7
 8007aea:	bd80      	pop	{r7, pc}
 8007aec:	08013384 	.word	0x08013384
 8007af0:	200045c8 	.word	0x200045c8
 8007af4:	08007afd 	.word	0x08007afd
 8007af8:	200047c8 	.word	0x200047c8

08007afc <fx_stm32_sram_driver>:
/* Include necessary system files.  */
#include "fx_stm32_sram_driver.h"

static UINT is_initialized = 0;
VOID  fx_stm32_sram_driver(FX_MEDIA *media_ptr)
{
 8007afc:	b580      	push	{r7, lr}
 8007afe:	b086      	sub	sp, #24
 8007b00:	af00      	add	r7, sp, #0
 8007b02:	6078      	str	r0, [r7, #4]
UCHAR *source_buffer;
UCHAR *destination_buffer;
UINT   bytes_per_sector;

    /* Process the driver request specified in the media control block.  */
    switch (media_ptr->fx_media_driver_request)
 8007b04:	687b      	ldr	r3, [r7, #4]
 8007b06:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8007b0a:	2b08      	cmp	r3, #8
 8007b0c:	f200 80aa 	bhi.w	8007c64 <fx_stm32_sram_driver+0x168>
 8007b10:	a201      	add	r2, pc, #4	; (adr r2, 8007b18 <fx_stm32_sram_driver+0x1c>)
 8007b12:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007b16:	bf00      	nop
 8007b18:	08007b6b 	.word	0x08007b6b
 8007b1c:	08007baf 	.word	0x08007baf
 8007b20:	08007bf3 	.word	0x08007bf3
 8007b24:	08007bfd 	.word	0x08007bfd
 8007b28:	08007b3d 	.word	0x08007b3d
 8007b2c:	08007c07 	.word	0x08007c07
 8007b30:	08007c65 	.word	0x08007c65
 8007b34:	08007c45 	.word	0x08007c45
 8007b38:	08007b61 	.word	0x08007b61
            /*
             * the FX_DRIVER_INIT can be requested either from the fx_media_format() or fx_media_open()
             * as the RAM memory should be always formatted before being used, by memset'ing it to '\0'
             * we need to avoid double initialization to keep the file system integrity.
             */
            if (is_initialized == 0)
 8007b3c:	4b4e      	ldr	r3, [pc, #312]	; (8007c78 <fx_stm32_sram_driver+0x17c>)
 8007b3e:	681b      	ldr	r3, [r3, #0]
 8007b40:	2b00      	cmp	r3, #0
 8007b42:	d108      	bne.n	8007b56 <fx_stm32_sram_driver+0x5a>
            {
                _fx_utility_memory_set((UCHAR *)FX_SRAM_DISK_BASE_ADDRESS, '\0', FX_SRAM_DISK_SIZE);
 8007b44:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8007b48:	2100      	movs	r1, #0
 8007b4a:	484c      	ldr	r0, [pc, #304]	; (8007c7c <fx_stm32_sram_driver+0x180>)
 8007b4c:	f003 faf3 	bl	800b136 <_fx_utility_memory_set>
                is_initialized = 1;
 8007b50:	4b49      	ldr	r3, [pc, #292]	; (8007c78 <fx_stm32_sram_driver+0x17c>)
 8007b52:	2201      	movs	r2, #1
 8007b54:	601a      	str	r2, [r3, #0]
            }
            media_ptr -> fx_media_driver_status =  FX_SUCCESS;
 8007b56:	687b      	ldr	r3, [r7, #4]
 8007b58:	2200      	movs	r2, #0
 8007b5a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            break;
 8007b5e:	e086      	b.n	8007c6e <fx_stm32_sram_driver+0x172>
        case FX_DRIVER_UNINIT:
        {
            /* there is nothing to do for FX_DRIVER_UNINIT request
             *  set the media driver status to FX_SUCCESS.
             */
            media_ptr -> fx_media_driver_status =  FX_SUCCESS;
 8007b60:	687b      	ldr	r3, [r7, #4]
 8007b62:	2200      	movs	r2, #0
 8007b64:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            break;
 8007b68:	e081      	b.n	8007c6e <fx_stm32_sram_driver+0x172>
        case FX_DRIVER_READ:
        {

            /* Calculate the RAM disk sector offset.*/
            source_buffer = ((UCHAR *)FX_SRAM_DISK_BASE_ADDRESS) +
                             ((media_ptr->fx_media_driver_logical_sector + media_ptr->fx_media_hidden_sectors) * media_ptr->fx_media_bytes_per_sector);
 8007b6a:	687b      	ldr	r3, [r7, #4]
 8007b6c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8007b70:	687b      	ldr	r3, [r7, #4]
 8007b72:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007b74:	4413      	add	r3, r2
 8007b76:	687a      	ldr	r2, [r7, #4]
 8007b78:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8007b7a:	fb02 f303 	mul.w	r3, r2, r3
            source_buffer = ((UCHAR *)FX_SRAM_DISK_BASE_ADDRESS) +
 8007b7e:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8007b82:	f503 3340 	add.w	r3, r3, #196608	; 0x30000
 8007b86:	613b      	str	r3, [r7, #16]

            /* Copy the RAM sector into the destination.  */
            _fx_utility_memory_copy(source_buffer, media_ptr -> fx_media_driver_buffer,
 8007b88:	687b      	ldr	r3, [r7, #4]
 8007b8a:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
                                     media_ptr->fx_media_driver_sectors * media_ptr->fx_media_bytes_per_sector);
 8007b8e:	687b      	ldr	r3, [r7, #4]
 8007b90:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8007b94:	687a      	ldr	r2, [r7, #4]
 8007b96:	6a92      	ldr	r2, [r2, #40]	; 0x28
            _fx_utility_memory_copy(source_buffer, media_ptr -> fx_media_driver_buffer,
 8007b98:	fb02 f303 	mul.w	r3, r2, r3
 8007b9c:	461a      	mov	r2, r3
 8007b9e:	6938      	ldr	r0, [r7, #16]
 8007ba0:	f003 faba 	bl	800b118 <_fx_utility_memory_copy>

            /* Successful driver request.  */
            media_ptr->fx_media_driver_status = FX_SUCCESS;
 8007ba4:	687b      	ldr	r3, [r7, #4]
 8007ba6:	2200      	movs	r2, #0
 8007ba8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            break;
 8007bac:	e05f      	b.n	8007c6e <fx_stm32_sram_driver+0x172>
        case FX_DRIVER_WRITE:
        {

            /* Calculate the RAM disk sector offset */
            destination_buffer =  (UCHAR *)FX_SRAM_DISK_BASE_ADDRESS +
                                  ((media_ptr->fx_media_driver_logical_sector +  media_ptr->fx_media_hidden_sectors) * media_ptr->fx_media_bytes_per_sector);
 8007bae:	687b      	ldr	r3, [r7, #4]
 8007bb0:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8007bb4:	687b      	ldr	r3, [r7, #4]
 8007bb6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007bb8:	4413      	add	r3, r2
 8007bba:	687a      	ldr	r2, [r7, #4]
 8007bbc:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8007bbe:	fb02 f303 	mul.w	r3, r2, r3
            destination_buffer =  (UCHAR *)FX_SRAM_DISK_BASE_ADDRESS +
 8007bc2:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8007bc6:	f503 3340 	add.w	r3, r3, #196608	; 0x30000
 8007bca:	617b      	str	r3, [r7, #20]

            /* Copy the source to the RAM sector.  */
            _fx_utility_memory_copy(media_ptr->fx_media_driver_buffer, destination_buffer,
 8007bcc:	687b      	ldr	r3, [r7, #4]
 8007bce:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
                                    media_ptr->fx_media_driver_sectors * media_ptr->fx_media_bytes_per_sector);
 8007bd2:	687b      	ldr	r3, [r7, #4]
 8007bd4:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8007bd8:	687a      	ldr	r2, [r7, #4]
 8007bda:	6a92      	ldr	r2, [r2, #40]	; 0x28
            _fx_utility_memory_copy(media_ptr->fx_media_driver_buffer, destination_buffer,
 8007bdc:	fb02 f303 	mul.w	r3, r2, r3
 8007be0:	461a      	mov	r2, r3
 8007be2:	6979      	ldr	r1, [r7, #20]
 8007be4:	f003 fa98 	bl	800b118 <_fx_utility_memory_copy>

            /* Successful driver request.  */
            media_ptr -> fx_media_driver_status =  FX_SUCCESS;
 8007be8:	687b      	ldr	r3, [r7, #4]
 8007bea:	2200      	movs	r2, #0
 8007bec:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            break;
 8007bf0:	e03d      	b.n	8007c6e <fx_stm32_sram_driver+0x172>
        {

            /*
             * Nothing to do for the FX_DRIVER_FLUSH Return driver success.
             */
            media_ptr->fx_media_driver_status =  FX_SUCCESS;
 8007bf2:	687b      	ldr	r3, [r7, #4]
 8007bf4:	2200      	movs	r2, #0
 8007bf6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            break;
 8007bfa:	e038      	b.n	8007c6e <fx_stm32_sram_driver+0x172>
        {

            /*
             * Nothing to do for the FX_DRIVER_ABORT Return driver success.
             */
            media_ptr->fx_media_driver_status =  FX_SUCCESS;
 8007bfc:	687b      	ldr	r3, [r7, #4]
 8007bfe:	2200      	movs	r2, #0
 8007c00:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            break;
 8007c04:	e033      	b.n	8007c6e <fx_stm32_sram_driver+0x172>
        {

            /* Calculate the RAM disk boot sector offset, which is at the very beginning of
             * the RAM disk.
             */
            source_buffer =  (UCHAR *)FX_SRAM_DISK_BASE_ADDRESS;
 8007c06:	4b1d      	ldr	r3, [pc, #116]	; (8007c7c <fx_stm32_sram_driver+0x180>)
 8007c08:	613b      	str	r3, [r7, #16]
            /* For RAM disk only, pickup the bytes per sector.*/

            bytes_per_sector =  _fx_utility_16_unsigned_read(&source_buffer[FX_BYTES_SECTOR]);
 8007c0a:	693b      	ldr	r3, [r7, #16]
 8007c0c:	330b      	adds	r3, #11
 8007c0e:	4618      	mov	r0, r3
 8007c10:	f001 fbc6 	bl	80093a0 <_fx_utility_16_unsigned_read>
 8007c14:	60f8      	str	r0, [r7, #12]

            /* Ensure this is less than the media memory size.  */
            if (bytes_per_sector > media_ptr->fx_media_memory_size)
 8007c16:	687b      	ldr	r3, [r7, #4]
 8007c18:	68db      	ldr	r3, [r3, #12]
 8007c1a:	68fa      	ldr	r2, [r7, #12]
 8007c1c:	429a      	cmp	r2, r3
 8007c1e:	d904      	bls.n	8007c2a <fx_stm32_sram_driver+0x12e>
            {
                media_ptr->fx_media_driver_status =  FX_BUFFER_ERROR;
 8007c20:	687b      	ldr	r3, [r7, #4]
 8007c22:	2221      	movs	r2, #33	; 0x21
 8007c24:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
                break;
 8007c28:	e021      	b.n	8007c6e <fx_stm32_sram_driver+0x172>
            }

            /* Copy the RAM boot sector into the destination.  */
            _fx_utility_memory_copy(source_buffer, media_ptr -> fx_media_driver_buffer,
 8007c2a:	687b      	ldr	r3, [r7, #4]
 8007c2c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007c30:	68fa      	ldr	r2, [r7, #12]
 8007c32:	4619      	mov	r1, r3
 8007c34:	6938      	ldr	r0, [r7, #16]
 8007c36:	f003 fa6f 	bl	800b118 <_fx_utility_memory_copy>
                                    bytes_per_sector);

            /* Successful driver request.  */
            media_ptr -> fx_media_driver_status =  FX_SUCCESS;
 8007c3a:	687b      	ldr	r3, [r7, #4]
 8007c3c:	2200      	movs	r2, #0
 8007c3e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            break;
 8007c42:	e014      	b.n	8007c6e <fx_stm32_sram_driver+0x172>
        {

            /* 
             * Calculate the RAM disk boot sector offset, which is at the very beginning of the RAM disk.
             */ 
            destination_buffer =  (UCHAR *)FX_SRAM_DISK_BASE_ADDRESS;
 8007c44:	4b0d      	ldr	r3, [pc, #52]	; (8007c7c <fx_stm32_sram_driver+0x180>)
 8007c46:	617b      	str	r3, [r7, #20]

            /* Copy the RAM boot sector into the destination.  */
            _fx_utility_memory_copy(media_ptr->fx_media_driver_buffer, destination_buffer,
 8007c48:	687b      	ldr	r3, [r7, #4]
 8007c4a:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
                                    media_ptr->fx_media_bytes_per_sector);
 8007c4e:	687b      	ldr	r3, [r7, #4]
 8007c50:	6a9b      	ldr	r3, [r3, #40]	; 0x28
            _fx_utility_memory_copy(media_ptr->fx_media_driver_buffer, destination_buffer,
 8007c52:	461a      	mov	r2, r3
 8007c54:	6979      	ldr	r1, [r7, #20]
 8007c56:	f003 fa5f 	bl	800b118 <_fx_utility_memory_copy>

            /* Successful driver request.  */
            media_ptr -> fx_media_driver_status =  FX_SUCCESS;
 8007c5a:	687b      	ldr	r3, [r7, #4]
 8007c5c:	2200      	movs	r2, #0
 8007c5e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            break;
 8007c62:	e004      	b.n	8007c6e <fx_stm32_sram_driver+0x172>
        }

        default:
        {
            /* Invalid driver request.  */
            media_ptr -> fx_media_driver_status =  FX_IO_ERROR;
 8007c64:	687b      	ldr	r3, [r7, #4]
 8007c66:	2290      	movs	r2, #144	; 0x90
 8007c68:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            break;
 8007c6c:	bf00      	nop
        }
    }
}
 8007c6e:	bf00      	nop
 8007c70:	3718      	adds	r7, #24
 8007c72:	46bd      	mov	sp, r7
 8007c74:	bd80      	pop	{r7, pc}
 8007c76:	bf00      	nop
 8007c78:	20006c80 	.word	0x20006c80
 8007c7c:	20030000 	.word	0x20030000

08007c80 <_fx_media_boot_info_extract>:
/*                                            check for bimap cache size, */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _fx_media_boot_info_extract(FX_MEDIA *media_ptr)
{
 8007c80:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8007c84:	b084      	sub	sp, #16
 8007c86:	af00      	add	r7, sp, #0
 8007c88:	6078      	str	r0, [r7, #4]

UCHAR *boot_sector;


    /* Move the buffer pointer into a local copy.  */
    boot_sector =  media_ptr -> fx_media_driver_buffer;
 8007c8a:	687b      	ldr	r3, [r7, #4]
 8007c8c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007c90:	60fb      	str	r3, [r7, #12]

    /* Extract the number of bytes per sector.  */
    media_ptr -> fx_media_bytes_per_sector =    _fx_utility_16_unsigned_read(&boot_sector[FX_BYTES_SECTOR]);
 8007c92:	68fb      	ldr	r3, [r7, #12]
 8007c94:	330b      	adds	r3, #11
 8007c96:	4618      	mov	r0, r3
 8007c98:	f001 fb82 	bl	80093a0 <_fx_utility_16_unsigned_read>
 8007c9c:	4602      	mov	r2, r0
 8007c9e:	687b      	ldr	r3, [r7, #4]
 8007ca0:	629a      	str	r2, [r3, #40]	; 0x28
    if (media_ptr -> fx_media_bytes_per_sector == 0)
 8007ca2:	687b      	ldr	r3, [r7, #4]
 8007ca4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007ca6:	2b00      	cmp	r3, #0
 8007ca8:	d101      	bne.n	8007cae <_fx_media_boot_info_extract+0x2e>
        return(_fx_utility_exFAT_geometry_check(media_ptr, boot_sector));
    }
    else
    {
#else
        return(FX_MEDIA_INVALID);
 8007caa:	2302      	movs	r3, #2
 8007cac:	e08c      	b.n	8007dc8 <_fx_media_boot_info_extract+0x148>
#endif /* FX_ENABLE_EXFAT */


        /* FAT12/16/32 volume.  */
        /* Extract the number of sectors per track.  */
        media_ptr -> fx_media_sectors_per_track =   _fx_utility_16_unsigned_read(&boot_sector[FX_SECTORS_PER_TRK]);
 8007cae:	68fb      	ldr	r3, [r7, #12]
 8007cb0:	3318      	adds	r3, #24
 8007cb2:	4618      	mov	r0, r3
 8007cb4:	f001 fb74 	bl	80093a0 <_fx_utility_16_unsigned_read>
 8007cb8:	4602      	mov	r2, r0
 8007cba:	687b      	ldr	r3, [r7, #4]
 8007cbc:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Extract the number of heads.  */
        media_ptr -> fx_media_heads =               _fx_utility_16_unsigned_read(&boot_sector[FX_HEADS]);
 8007cbe:	68fb      	ldr	r3, [r7, #12]
 8007cc0:	331a      	adds	r3, #26
 8007cc2:	4618      	mov	r0, r3
 8007cc4:	f001 fb6c 	bl	80093a0 <_fx_utility_16_unsigned_read>
 8007cc8:	4602      	mov	r2, r0
 8007cca:	687b      	ldr	r3, [r7, #4]
 8007ccc:	631a      	str	r2, [r3, #48]	; 0x30

        /* Extract the total number of sectors.  */
        media_ptr -> fx_media_total_sectors =       _fx_utility_16_unsigned_read(&boot_sector[FX_SECTORS]);
 8007cce:	68fb      	ldr	r3, [r7, #12]
 8007cd0:	3313      	adds	r3, #19
 8007cd2:	4618      	mov	r0, r3
 8007cd4:	f001 fb64 	bl	80093a0 <_fx_utility_16_unsigned_read>
 8007cd8:	4603      	mov	r3, r0
 8007cda:	2200      	movs	r2, #0
 8007cdc:	4698      	mov	r8, r3
 8007cde:	4691      	mov	r9, r2
 8007ce0:	687b      	ldr	r3, [r7, #4]
 8007ce2:	e9c3 890e 	strd	r8, r9, [r3, #56]	; 0x38
        if (media_ptr -> fx_media_total_sectors == 0)
 8007ce6:	687b      	ldr	r3, [r7, #4]
 8007ce8:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	; 0x38
 8007cec:	4313      	orrs	r3, r2
 8007cee:	d10b      	bne.n	8007d08 <_fx_media_boot_info_extract+0x88>
        {
            media_ptr -> fx_media_total_sectors = _fx_utility_32_unsigned_read(&boot_sector[FX_HUGE_SECTORS]);
 8007cf0:	68fb      	ldr	r3, [r7, #12]
 8007cf2:	3320      	adds	r3, #32
 8007cf4:	4618      	mov	r0, r3
 8007cf6:	f001 fb7b 	bl	80093f0 <_fx_utility_32_unsigned_read>
 8007cfa:	4603      	mov	r3, r0
 8007cfc:	2200      	movs	r2, #0
 8007cfe:	461c      	mov	r4, r3
 8007d00:	4615      	mov	r5, r2
 8007d02:	687b      	ldr	r3, [r7, #4]
 8007d04:	e9c3 450e 	strd	r4, r5, [r3, #56]	; 0x38
        }

        if (media_ptr -> fx_media_total_sectors == 0)
 8007d08:	687b      	ldr	r3, [r7, #4]
 8007d0a:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	; 0x38
 8007d0e:	4313      	orrs	r3, r2
 8007d10:	d101      	bne.n	8007d16 <_fx_media_boot_info_extract+0x96>
        {
            return(FX_MEDIA_INVALID);
 8007d12:	2302      	movs	r3, #2
 8007d14:	e058      	b.n	8007dc8 <_fx_media_boot_info_extract+0x148>
        }

        /* Extract the number of reserved sectors before the first FAT.  */
        media_ptr -> fx_media_reserved_sectors =    _fx_utility_16_unsigned_read(&boot_sector[FX_RESERVED_SECTORS]);
 8007d16:	68fb      	ldr	r3, [r7, #12]
 8007d18:	330e      	adds	r3, #14
 8007d1a:	4618      	mov	r0, r3
 8007d1c:	f001 fb40 	bl	80093a0 <_fx_utility_16_unsigned_read>
 8007d20:	4602      	mov	r2, r0
 8007d22:	687b      	ldr	r3, [r7, #4]
 8007d24:	645a      	str	r2, [r3, #68]	; 0x44
        if (media_ptr -> fx_media_reserved_sectors == 0)
 8007d26:	687b      	ldr	r3, [r7, #4]
 8007d28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007d2a:	2b00      	cmp	r3, #0
 8007d2c:	d101      	bne.n	8007d32 <_fx_media_boot_info_extract+0xb2>
        {
            return(FX_MEDIA_INVALID);
 8007d2e:	2302      	movs	r3, #2
 8007d30:	e04a      	b.n	8007dc8 <_fx_media_boot_info_extract+0x148>
        }

        /* Extract the number of sectors per cluster.  */
        media_ptr -> fx_media_sectors_per_cluster = ((UINT)boot_sector[FX_SECTORS_CLUSTER] & 0xFF);
 8007d32:	68fb      	ldr	r3, [r7, #12]
 8007d34:	330d      	adds	r3, #13
 8007d36:	781b      	ldrb	r3, [r3, #0]
 8007d38:	461a      	mov	r2, r3
 8007d3a:	687b      	ldr	r3, [r7, #4]
 8007d3c:	655a      	str	r2, [r3, #84]	; 0x54

        /* There should always be at least one reserved sector, representing the boot record itself.  */
        if (media_ptr -> fx_media_sectors_per_cluster == 0)
 8007d3e:	687b      	ldr	r3, [r7, #4]
 8007d40:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007d42:	2b00      	cmp	r3, #0
 8007d44:	d101      	bne.n	8007d4a <_fx_media_boot_info_extract+0xca>
        {
            return(FX_MEDIA_INVALID);
 8007d46:	2302      	movs	r3, #2
 8007d48:	e03e      	b.n	8007dc8 <_fx_media_boot_info_extract+0x148>
        }

        /* Extract the number of sectors per FAT.  */
        media_ptr -> fx_media_sectors_per_FAT =     _fx_utility_16_unsigned_read(&boot_sector[FX_SECTORS_PER_FAT]);
 8007d4a:	68fb      	ldr	r3, [r7, #12]
 8007d4c:	3316      	adds	r3, #22
 8007d4e:	4618      	mov	r0, r3
 8007d50:	f001 fb26 	bl	80093a0 <_fx_utility_16_unsigned_read>
 8007d54:	4602      	mov	r2, r0
 8007d56:	687b      	ldr	r3, [r7, #4]
 8007d58:	659a      	str	r2, [r3, #88]	; 0x58
        if (media_ptr -> fx_media_sectors_per_FAT == 0)
 8007d5a:	687b      	ldr	r3, [r7, #4]
 8007d5c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007d5e:	2b00      	cmp	r3, #0
 8007d60:	d107      	bne.n	8007d72 <_fx_media_boot_info_extract+0xf2>
        {
            media_ptr -> fx_media_sectors_per_FAT = _fx_utility_32_unsigned_read(&boot_sector[FX_SECTORS_PER_FAT_32]);
 8007d62:	68fb      	ldr	r3, [r7, #12]
 8007d64:	3324      	adds	r3, #36	; 0x24
 8007d66:	4618      	mov	r0, r3
 8007d68:	f001 fb42 	bl	80093f0 <_fx_utility_32_unsigned_read>
 8007d6c:	4602      	mov	r2, r0
 8007d6e:	687b      	ldr	r3, [r7, #4]
 8007d70:	659a      	str	r2, [r3, #88]	; 0x58
        }

        if (media_ptr -> fx_media_sectors_per_FAT == 0)
 8007d72:	687b      	ldr	r3, [r7, #4]
 8007d74:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007d76:	2b00      	cmp	r3, #0
 8007d78:	d101      	bne.n	8007d7e <_fx_media_boot_info_extract+0xfe>
        {
            return(FX_MEDIA_INVALID);
 8007d7a:	2302      	movs	r3, #2
 8007d7c:	e024      	b.n	8007dc8 <_fx_media_boot_info_extract+0x148>
        }

        /* Extract the number of FATs.  */
        media_ptr -> fx_media_number_of_FATs =      ((UINT)boot_sector[FX_NUMBER_OF_FATS] & 0xFF);
 8007d7e:	68fb      	ldr	r3, [r7, #12]
 8007d80:	3310      	adds	r3, #16
 8007d82:	781b      	ldrb	r3, [r3, #0]
 8007d84:	461a      	mov	r2, r3
 8007d86:	687b      	ldr	r3, [r7, #4]
 8007d88:	65da      	str	r2, [r3, #92]	; 0x5c
        if (media_ptr -> fx_media_number_of_FATs == 0)
 8007d8a:	687b      	ldr	r3, [r7, #4]
 8007d8c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8007d8e:	2b00      	cmp	r3, #0
 8007d90:	d101      	bne.n	8007d96 <_fx_media_boot_info_extract+0x116>
        {
            return(FX_BOOT_ERROR);
 8007d92:	2301      	movs	r3, #1
 8007d94:	e018      	b.n	8007dc8 <_fx_media_boot_info_extract+0x148>

        /* Extract the number of hidden sectors.  */
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_hidden_sectors =      _fx_utility_64_unsigned_read(&boot_sector[FX_HIDDEN_SECTORS]);
#else
        media_ptr -> fx_media_hidden_sectors =      _fx_utility_32_unsigned_read(&boot_sector[FX_HIDDEN_SECTORS]);
 8007d96:	68fb      	ldr	r3, [r7, #12]
 8007d98:	331c      	adds	r3, #28
 8007d9a:	4618      	mov	r0, r3
 8007d9c:	f001 fb28 	bl	80093f0 <_fx_utility_32_unsigned_read>
 8007da0:	4602      	mov	r2, r0
 8007da2:	687b      	ldr	r3, [r7, #4]
 8007da4:	671a      	str	r2, [r3, #112]	; 0x70
#endif
        /* Extract the number of root directory entries.  */
        media_ptr -> fx_media_root_directory_entries =  _fx_utility_16_unsigned_read(&boot_sector[FX_ROOT_DIR_ENTRIES]);
 8007da6:	68fb      	ldr	r3, [r7, #12]
 8007da8:	3311      	adds	r3, #17
 8007daa:	4618      	mov	r0, r3
 8007dac:	f001 faf8 	bl	80093a0 <_fx_utility_16_unsigned_read>
 8007db0:	4602      	mov	r2, r0
 8007db2:	687b      	ldr	r3, [r7, #4]
 8007db4:	679a      	str	r2, [r3, #120]	; 0x78

        /* Extract root directory starting cluster (32 bit only) and compute start sector */
        media_ptr -> fx_media_root_cluster_32 = _fx_utility_32_unsigned_read(&boot_sector[FX_ROOT_CLUSTER_32]);
 8007db6:	68fb      	ldr	r3, [r7, #12]
 8007db8:	332c      	adds	r3, #44	; 0x2c
 8007dba:	4618      	mov	r0, r3
 8007dbc:	f001 fb18 	bl	80093f0 <_fx_utility_32_unsigned_read>
 8007dc0:	4602      	mov	r2, r0
 8007dc2:	687b      	ldr	r3, [r7, #4]
 8007dc4:	675a      	str	r2, [r3, #116]	; 0x74
#ifdef FX_ENABLE_EXFAT
    }
#endif /* FX_ENABLE_EXFAT */

    /* Return a successful status.  */
    return(FX_SUCCESS);
 8007dc6:	2300      	movs	r3, #0
}
 8007dc8:	4618      	mov	r0, r3
 8007dca:	3710      	adds	r7, #16
 8007dcc:	46bd      	mov	sp, r7
 8007dce:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
	...

08007dd4 <_fx_media_format>:
/**************************************************************************/
UINT  _fx_media_format(FX_MEDIA *media_ptr, VOID (*driver)(FX_MEDIA *media), VOID *driver_info_ptr, UCHAR *memory_ptr, UINT memory_size,
                       CHAR *volume_name, UINT number_of_fats, UINT directory_entries, UINT hidden_sectors,
                       ULONG total_sectors, UINT bytes_per_sector, UINT sectors_per_cluster,
                       UINT heads, UINT sectors_per_track)
{
 8007dd4:	b580      	push	{r7, lr}
 8007dd6:	b08e      	sub	sp, #56	; 0x38
 8007dd8:	af00      	add	r7, sp, #0
 8007dda:	60f8      	str	r0, [r7, #12]
 8007ddc:	60b9      	str	r1, [r7, #8]
 8007dde:	607a      	str	r2, [r7, #4]
 8007de0:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_MEDIA_FORMAT, media_ptr, directory_entries, total_sectors, sectors_per_cluster, FX_TRACE_MEDIA_EVENTS, 0, 0)

    /* Validate bytes per sector value: greater than zero and no more than 4096.  */
    if((bytes_per_sector == 0) || (bytes_per_sector > 4096))
 8007de2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007de4:	2b00      	cmp	r3, #0
 8007de6:	d003      	beq.n	8007df0 <_fx_media_format+0x1c>
 8007de8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007dea:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8007dee:	d901      	bls.n	8007df4 <_fx_media_format+0x20>
        return(FX_SECTOR_INVALID);
 8007df0:	2389      	movs	r3, #137	; 0x89
 8007df2:	e3a0      	b.n	8008536 <_fx_media_format+0x762>

    /* Validate sectors per cluster value: greater than zero and no more than 128.  */
    if((sectors_per_cluster == 0) || (sectors_per_cluster > 128))
 8007df4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007df6:	2b00      	cmp	r3, #0
 8007df8:	d002      	beq.n	8007e00 <_fx_media_format+0x2c>
 8007dfa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007dfc:	2b80      	cmp	r3, #128	; 0x80
 8007dfe:	d901      	bls.n	8007e04 <_fx_media_format+0x30>
        return(FX_SECTOR_INVALID);
 8007e00:	2389      	movs	r3, #137	; 0x89
 8007e02:	e398      	b.n	8008536 <_fx_media_format+0x762>

    /* Setup driver pointer and memory information.  */
    media_ptr -> fx_media_driver_entry =                driver;
 8007e04:	68fb      	ldr	r3, [r7, #12]
 8007e06:	68ba      	ldr	r2, [r7, #8]
 8007e08:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
    media_ptr -> fx_media_memory_buffer =               (UCHAR *)memory_ptr;
 8007e0c:	68fb      	ldr	r3, [r7, #12]
 8007e0e:	683a      	ldr	r2, [r7, #0]
 8007e10:	609a      	str	r2, [r3, #8]
    media_ptr -> fx_media_memory_size =                 memory_size;
 8007e12:	68fb      	ldr	r3, [r7, #12]
 8007e14:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8007e16:	60da      	str	r2, [r3, #12]

    /* Store geometry information in media record - driver needs this.  */
    media_ptr -> fx_media_bytes_per_sector =            bytes_per_sector;
 8007e18:	68fb      	ldr	r3, [r7, #12]
 8007e1a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8007e1c:	629a      	str	r2, [r3, #40]	; 0x28
    media_ptr -> fx_media_sectors_per_track =           sectors_per_track;
 8007e1e:	68fb      	ldr	r3, [r7, #12]
 8007e20:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8007e22:	62da      	str	r2, [r3, #44]	; 0x2c
    media_ptr -> fx_media_heads =                       heads;
 8007e24:	68fb      	ldr	r3, [r7, #12]
 8007e26:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8007e28:	631a      	str	r2, [r3, #48]	; 0x30
    media_ptr -> fx_media_hidden_sectors =              hidden_sectors;
 8007e2a:	68fb      	ldr	r3, [r7, #12]
 8007e2c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8007e2e:	671a      	str	r2, [r3, #112]	; 0x70

    /* Initialize the supplied media I/O driver.  First, build the
       initialize driver request.  */
    media_ptr -> fx_media_driver_request =              FX_DRIVER_INIT;
 8007e30:	68fb      	ldr	r3, [r7, #12]
 8007e32:	2204      	movs	r2, #4
 8007e34:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    media_ptr -> fx_media_driver_status =               FX_IO_ERROR;
 8007e38:	68fb      	ldr	r3, [r7, #12]
 8007e3a:	2290      	movs	r2, #144	; 0x90
 8007e3c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    media_ptr -> fx_media_driver_info =                 driver_info_ptr;
 8007e40:	68fb      	ldr	r3, [r7, #12]
 8007e42:	687a      	ldr	r2, [r7, #4]
 8007e44:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    media_ptr -> fx_media_driver_write_protect =        FX_FALSE;
 8007e48:	68fb      	ldr	r3, [r7, #12]
 8007e4a:	2200      	movs	r2, #0
 8007e4c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
    media_ptr -> fx_media_driver_free_sector_update =   FX_FALSE;
 8007e50:	68fb      	ldr	r3, [r7, #12]
 8007e52:	2200      	movs	r2, #0
 8007e54:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
    media_ptr -> fx_media_driver_data_sector_read =     FX_FALSE;
 8007e58:	68fb      	ldr	r3, [r7, #12]
 8007e5a:	2200      	movs	r2, #0
 8007e5c:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_INIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Call the specified I/O driver with the initialize request.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 8007e60:	68fb      	ldr	r3, [r7, #12]
 8007e62:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8007e66:	68f8      	ldr	r0, [r7, #12]
 8007e68:	4798      	blx	r3

    /* Determine if the I/O driver initialized successfully.  */
    if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 8007e6a:	68fb      	ldr	r3, [r7, #12]
 8007e6c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8007e70:	2b00      	cmp	r3, #0
 8007e72:	d001      	beq.n	8007e78 <_fx_media_format+0xa4>
    {

        /* Return the driver error status.  */
        return(FX_IO_ERROR);
 8007e74:	2390      	movs	r3, #144	; 0x90
 8007e76:	e35e      	b.n	8008536 <_fx_media_format+0x762>
    }

    /* Setup driver buffer memory.  */
    media_ptr -> fx_media_driver_buffer =  memory_ptr;
 8007e78:	68fb      	ldr	r3, [r7, #12]
 8007e7a:	683a      	ldr	r2, [r7, #0]
 8007e7c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

    /* Move the buffer pointer into a local copy.  */
    byte_ptr =  media_ptr -> fx_media_driver_buffer;
 8007e80:	68fb      	ldr	r3, [r7, #12]
 8007e82:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007e86:	617b      	str	r3, [r7, #20]

#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    /* Clear the buffer record out, assuming it is large enough for one sector.   */
    for (i = 0; i < bytes_per_sector; i++)
 8007e88:	2300      	movs	r3, #0
 8007e8a:	633b      	str	r3, [r7, #48]	; 0x30
 8007e8c:	e007      	b.n	8007e9e <_fx_media_format+0xca>
    {

        /* Clear each byte of the boot record.  */
        byte_ptr[i] =  (UCHAR)0;
 8007e8e:	697a      	ldr	r2, [r7, #20]
 8007e90:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007e92:	4413      	add	r3, r2
 8007e94:	2200      	movs	r2, #0
 8007e96:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < bytes_per_sector; i++)
 8007e98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007e9a:	3301      	adds	r3, #1
 8007e9c:	633b      	str	r3, [r7, #48]	; 0x30
 8007e9e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8007ea0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007ea2:	429a      	cmp	r2, r3
 8007ea4:	d3f3      	bcc.n	8007e8e <_fx_media_format+0xba>
#else
    _fx_utility_memory_set(byte_ptr, 0, bytes_per_sector);
#endif /* FX_DISABLE_FORCE_MEMORY_OPERATION */

    /* Set jump instruction at the beginning of the sector.  */
    byte_ptr[0] =  (UCHAR)0xEB;
 8007ea6:	697b      	ldr	r3, [r7, #20]
 8007ea8:	22eb      	movs	r2, #235	; 0xeb
 8007eaa:	701a      	strb	r2, [r3, #0]
    byte_ptr[1] =  (UCHAR)0x34;
 8007eac:	697b      	ldr	r3, [r7, #20]
 8007eae:	3301      	adds	r3, #1
 8007eb0:	2234      	movs	r2, #52	; 0x34
 8007eb2:	701a      	strb	r2, [r3, #0]
    byte_ptr[2] =  (UCHAR)0x90;
 8007eb4:	697b      	ldr	r3, [r7, #20]
 8007eb6:	3302      	adds	r3, #2
 8007eb8:	2290      	movs	r2, #144	; 0x90
 8007eba:	701a      	strb	r2, [r3, #0]

    /* Set the OEM name in the boot record.  */
    for (i = 0; i < 8; i++)
 8007ebc:	2300      	movs	r3, #0
 8007ebe:	633b      	str	r3, [r7, #48]	; 0x30
 8007ec0:	e00b      	b.n	8007eda <_fx_media_format+0x106>
    {

        /* Copy a character from the OEM name.  */
        byte_ptr[i + 3] =  _fx_media_format_oem_name[i];
 8007ec2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007ec4:	3303      	adds	r3, #3
 8007ec6:	697a      	ldr	r2, [r7, #20]
 8007ec8:	4413      	add	r3, r2
 8007eca:	49ac      	ldr	r1, [pc, #688]	; (800817c <_fx_media_format+0x3a8>)
 8007ecc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8007ece:	440a      	add	r2, r1
 8007ed0:	7812      	ldrb	r2, [r2, #0]
 8007ed2:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < 8; i++)
 8007ed4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007ed6:	3301      	adds	r3, #1
 8007ed8:	633b      	str	r3, [r7, #48]	; 0x30
 8007eda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007edc:	2b07      	cmp	r3, #7
 8007ede:	d9f0      	bls.n	8007ec2 <_fx_media_format+0xee>
    }

    /* Set the media type in the boot record.  */
    byte_ptr[FX_MEDIA_TYPE] =  _fx_media_format_media_type;
 8007ee0:	697b      	ldr	r3, [r7, #20]
 8007ee2:	3315      	adds	r3, #21
 8007ee4:	4aa6      	ldr	r2, [pc, #664]	; (8008180 <_fx_media_format+0x3ac>)
 8007ee6:	7812      	ldrb	r2, [r2, #0]
 8007ee8:	701a      	strb	r2, [r3, #0]

    /* Set the number of bytes per sector.  */
    _fx_utility_16_unsigned_write(&byte_ptr[FX_BYTES_SECTOR], bytes_per_sector);
 8007eea:	697b      	ldr	r3, [r7, #20]
 8007eec:	330b      	adds	r3, #11
 8007eee:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8007ef0:	4618      	mov	r0, r3
 8007ef2:	f001 fa68 	bl	80093c6 <_fx_utility_16_unsigned_write>

    /* Set the number of sectors per track.  */
    _fx_utility_16_unsigned_write(&byte_ptr[FX_SECTORS_PER_TRK], sectors_per_track);
 8007ef6:	697b      	ldr	r3, [r7, #20]
 8007ef8:	3318      	adds	r3, #24
 8007efa:	6e79      	ldr	r1, [r7, #100]	; 0x64
 8007efc:	4618      	mov	r0, r3
 8007efe:	f001 fa62 	bl	80093c6 <_fx_utility_16_unsigned_write>

    /* Set the number of heads.  */
    _fx_utility_16_unsigned_write(&byte_ptr[FX_HEADS], heads);
 8007f02:	697b      	ldr	r3, [r7, #20]
 8007f04:	331a      	adds	r3, #26
 8007f06:	6e39      	ldr	r1, [r7, #96]	; 0x60
 8007f08:	4618      	mov	r0, r3
 8007f0a:	f001 fa5c 	bl	80093c6 <_fx_utility_16_unsigned_write>
        reserved_sectors =  1;
    }
#else

    /* The boot sector is the only reserved sector.  */
    reserved_sectors =  1;
 8007f0e:	2301      	movs	r3, #1
 8007f10:	637b      	str	r3, [r7, #52]	; 0x34
#endif


    /* Calculate the maximum clusters.... This is actually greater than the actual since the FAT
       sectors have yet to be accounted for.  */
    total_clusters =  (total_sectors - reserved_sectors - ((directory_entries * FX_DIR_ENTRY_SIZE) + (bytes_per_sector - 1)) / bytes_per_sector) / sectors_per_cluster;
 8007f12:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8007f14:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007f16:	1ad2      	subs	r2, r2, r3
 8007f18:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007f1a:	0159      	lsls	r1, r3, #5
 8007f1c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007f1e:	440b      	add	r3, r1
 8007f20:	1e59      	subs	r1, r3, #1
 8007f22:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007f24:	fbb1 f3f3 	udiv	r3, r1, r3
 8007f28:	1ad2      	subs	r2, r2, r3
 8007f2a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007f2c:	fbb2 f3f3 	udiv	r3, r2, r3
 8007f30:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Calculate the maximum number of FAT sectors necessary for FAT12.  */
    if (total_clusters % 2)
 8007f32:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007f34:	f003 0301 	and.w	r3, r3, #1
 8007f38:	2b00      	cmp	r3, #0
 8007f3a:	d006      	beq.n	8007f4a <_fx_media_format+0x176>
    {
        bytes_needed = (total_clusters + total_clusters / 2) + 1;
 8007f3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007f3e:	085a      	lsrs	r2, r3, #1
 8007f40:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007f42:	4413      	add	r3, r2
 8007f44:	3301      	adds	r3, #1
 8007f46:	627b      	str	r3, [r7, #36]	; 0x24
 8007f48:	e004      	b.n	8007f54 <_fx_media_format+0x180>
    }
    else
    {
        bytes_needed = (total_clusters + total_clusters / 2);
 8007f4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007f4c:	085b      	lsrs	r3, r3, #1
 8007f4e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007f50:	4413      	add	r3, r2
 8007f52:	627b      	str	r3, [r7, #36]	; 0x24
    }
    sectors_per_fat =  bytes_needed / bytes_per_sector;
 8007f54:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8007f56:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007f58:	fbb2 f3f3 	udiv	r3, r2, r3
 8007f5c:	623b      	str	r3, [r7, #32]
    if (bytes_needed % bytes_per_sector)
 8007f5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007f60:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8007f62:	fbb3 f2f2 	udiv	r2, r3, r2
 8007f66:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8007f68:	fb01 f202 	mul.w	r2, r1, r2
 8007f6c:	1a9b      	subs	r3, r3, r2
 8007f6e:	2b00      	cmp	r3, #0
 8007f70:	d002      	beq.n	8007f78 <_fx_media_format+0x1a4>
    {
        sectors_per_fat++;
 8007f72:	6a3b      	ldr	r3, [r7, #32]
 8007f74:	3301      	adds	r3, #1
 8007f76:	623b      	str	r3, [r7, #32]
    }

    /* Now adjust the total clusters by the number of sectors per FAT.  */
    total_clusters =  total_clusters - ((sectors_per_fat * number_of_fats) + (sectors_per_cluster - 1)) / sectors_per_cluster;
 8007f78:	6a3b      	ldr	r3, [r7, #32]
 8007f7a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007f7c:	fb03 f202 	mul.w	r2, r3, r2
 8007f80:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007f82:	4413      	add	r3, r2
 8007f84:	1e5a      	subs	r2, r3, #1
 8007f86:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007f88:	fbb2 f3f3 	udiv	r3, r2, r3
 8007f8c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007f8e:	1ad3      	subs	r3, r2, r3
 8007f90:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Is the total cluster count greater than the FAT12 maximum?  */
    if (total_clusters >= FX_12_BIT_FAT_SIZE)
 8007f92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007f94:	f640 72f5 	movw	r2, #4085	; 0xff5
 8007f98:	4293      	cmp	r3, r2
 8007f9a:	d97e      	bls.n	800809a <_fx_media_format+0x2c6>

        /* Yes, too big for FAT12, we need to evaluate for FAT16.  */

        /* Reset the maximum clusters.... This is actually greater than the actual since the FAT
           sectors have yet to be accounted for.  */
        total_clusters =  (total_sectors - reserved_sectors -  ((directory_entries * FX_DIR_ENTRY_SIZE) + (bytes_per_sector - 1)) / bytes_per_sector) / sectors_per_cluster;
 8007f9c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8007f9e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007fa0:	1ad2      	subs	r2, r2, r3
 8007fa2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007fa4:	0159      	lsls	r1, r3, #5
 8007fa6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007fa8:	440b      	add	r3, r1
 8007faa:	1e59      	subs	r1, r3, #1
 8007fac:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007fae:	fbb1 f3f3 	udiv	r3, r1, r3
 8007fb2:	1ad2      	subs	r2, r2, r3
 8007fb4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007fb6:	fbb2 f3f3 	udiv	r3, r2, r3
 8007fba:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Calculate 16-bit FAT is present. Each cluster requires a 2 byte entry in the FAT table.  */
        sectors_per_fat =  (total_clusters * 2) / bytes_per_sector;
 8007fbc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007fbe:	005a      	lsls	r2, r3, #1
 8007fc0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8007fc2:	fbb2 f3f3 	udiv	r3, r2, r3
 8007fc6:	623b      	str	r3, [r7, #32]
        if ((total_clusters * 2) % bytes_per_sector)
 8007fc8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007fca:	005b      	lsls	r3, r3, #1
 8007fcc:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8007fce:	fbb3 f2f2 	udiv	r2, r3, r2
 8007fd2:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8007fd4:	fb01 f202 	mul.w	r2, r1, r2
 8007fd8:	1a9b      	subs	r3, r3, r2
 8007fda:	2b00      	cmp	r3, #0
 8007fdc:	d002      	beq.n	8007fe4 <_fx_media_format+0x210>
        {
            sectors_per_fat++;
 8007fde:	6a3b      	ldr	r3, [r7, #32]
 8007fe0:	3301      	adds	r3, #1
 8007fe2:	623b      	str	r3, [r7, #32]
        }

        /* Now adjust the total clusters by the number of sectors per FAT.  */
        total_clusters =  total_clusters - ((sectors_per_fat * number_of_fats) + (sectors_per_cluster - 1)) / sectors_per_cluster;
 8007fe4:	6a3b      	ldr	r3, [r7, #32]
 8007fe6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8007fe8:	fb03 f202 	mul.w	r2, r3, r2
 8007fec:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007fee:	4413      	add	r3, r2
 8007ff0:	1e5a      	subs	r2, r3, #1
 8007ff2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8007ff4:	fbb2 f3f3 	udiv	r3, r2, r3
 8007ff8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8007ffa:	1ad3      	subs	r3, r2, r3
 8007ffc:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Is the total cluster count greater than the FAT16 maximum?  */
        if (total_clusters >= FX_16_BIT_FAT_SIZE)
 8007ffe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008000:	f64f 72f4 	movw	r2, #65524	; 0xfff4
 8008004:	4293      	cmp	r3, r2
 8008006:	d948      	bls.n	800809a <_fx_media_format+0x2c6>

            /* Yes, FAT32 is present.  */

            /* Allocate room for the FAT32 additional information sector. This contains useful information
               such as the number of available clusters between successive mounting of the media.  */
            if (bytes_per_sector == 512)
 8008008:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800800a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800800e:	d109      	bne.n	8008024 <_fx_media_format+0x250>
            {

                /* Write sector number 1 to the additional information sector.  */
                _fx_utility_16_unsigned_write(&byte_ptr[48], 1);
 8008010:	697b      	ldr	r3, [r7, #20]
 8008012:	3330      	adds	r3, #48	; 0x30
 8008014:	2101      	movs	r1, #1
 8008016:	4618      	mov	r0, r3
 8008018:	f001 f9d5 	bl	80093c6 <_fx_utility_16_unsigned_write>

                /* Increment the reserved sectors count, since this will count as a reserved sector.  */
                reserved_sectors++;
 800801c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800801e:	3301      	adds	r3, #1
 8008020:	637b      	str	r3, [r7, #52]	; 0x34
 8008022:	e006      	b.n	8008032 <_fx_media_format+0x25e>
            }
            else
            {

                /* Write value to indicate there is no additional information sector.  */
                _fx_utility_16_unsigned_write(&byte_ptr[48], 0xFFFF);
 8008024:	697b      	ldr	r3, [r7, #20]
 8008026:	3330      	adds	r3, #48	; 0x30
 8008028:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800802c:	4618      	mov	r0, r3
 800802e:	f001 f9ca 	bl	80093c6 <_fx_utility_16_unsigned_write>
            }

            /* Allocate the first cluster to the root directory.  */
            _fx_utility_32_unsigned_write(&byte_ptr[FX_ROOT_CLUSTER_32], FX_FAT_ENTRY_START);
 8008032:	697b      	ldr	r3, [r7, #20]
 8008034:	332c      	adds	r3, #44	; 0x2c
 8008036:	2102      	movs	r1, #2
 8008038:	4618      	mov	r0, r3
 800803a:	f001 f9f6 	bl	800942a <_fx_utility_32_unsigned_write>

            /* Determine if the number of root directory entries should be modified.  */
            directory_entries =  (sectors_per_cluster * bytes_per_sector) / FX_DIR_ENTRY_SIZE;
 800803e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8008040:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8008042:	fb02 f303 	mul.w	r3, r2, r3
 8008046:	095b      	lsrs	r3, r3, #5
 8008048:	64fb      	str	r3, [r7, #76]	; 0x4c

            /* Reset the total_clusters for the FAT32 calculation.  */
            total_clusters =  (total_sectors - reserved_sectors) / sectors_per_cluster;
 800804a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800804c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800804e:	1ad2      	subs	r2, r2, r3
 8008050:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8008052:	fbb2 f3f3 	udiv	r3, r2, r3
 8008056:	62bb      	str	r3, [r7, #40]	; 0x28

            /* 32-bit FAT is present. Each cluster requires a 4 byte entry in the FAT table.  */
            sectors_per_fat =  (total_clusters * 4) / bytes_per_sector;
 8008058:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800805a:	009a      	lsls	r2, r3, #2
 800805c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800805e:	fbb2 f3f3 	udiv	r3, r2, r3
 8008062:	623b      	str	r3, [r7, #32]
            if ((total_clusters * 4) % bytes_per_sector)
 8008064:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008066:	009b      	lsls	r3, r3, #2
 8008068:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800806a:	fbb3 f2f2 	udiv	r2, r3, r2
 800806e:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8008070:	fb01 f202 	mul.w	r2, r1, r2
 8008074:	1a9b      	subs	r3, r3, r2
 8008076:	2b00      	cmp	r3, #0
 8008078:	d002      	beq.n	8008080 <_fx_media_format+0x2ac>
            {
                sectors_per_fat++;
 800807a:	6a3b      	ldr	r3, [r7, #32]
 800807c:	3301      	adds	r3, #1
 800807e:	623b      	str	r3, [r7, #32]
            }

            /* Now adjust the total clusters by the number of sectors per FAT.  */
            total_clusters =  total_clusters - ((sectors_per_fat * number_of_fats) + (sectors_per_cluster - 1)) / sectors_per_cluster;
 8008080:	6a3b      	ldr	r3, [r7, #32]
 8008082:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8008084:	fb03 f202 	mul.w	r2, r3, r2
 8008088:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800808a:	4413      	add	r3, r2
 800808c:	1e5a      	subs	r2, r3, #1
 800808e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8008090:	fbb2 f3f3 	udiv	r3, r2, r3
 8008094:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8008096:	1ad3      	subs	r3, r2, r3
 8008098:	62bb      	str	r3, [r7, #40]	; 0x28
        }
    }

    /* Set sectors per FAT type.  */
    if (total_clusters < FX_16_BIT_FAT_SIZE)
 800809a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800809c:	f64f 72f4 	movw	r2, #65524	; 0xfff4
 80080a0:	4293      	cmp	r3, r2
 80080a2:	d812      	bhi.n	80080ca <_fx_media_format+0x2f6>
    {

        /* Set the number of sectors per FAT12/16.  */
        _fx_utility_16_unsigned_write(&byte_ptr[FX_SECTORS_PER_FAT], sectors_per_fat);
 80080a4:	697b      	ldr	r3, [r7, #20]
 80080a6:	3316      	adds	r3, #22
 80080a8:	6a39      	ldr	r1, [r7, #32]
 80080aa:	4618      	mov	r0, r3
 80080ac:	f001 f98b 	bl	80093c6 <_fx_utility_16_unsigned_write>

        /* Set the signature.  */
        byte_ptr[FX_BOOT_SIG] =  0x29;
 80080b0:	697b      	ldr	r3, [r7, #20]
 80080b2:	3326      	adds	r3, #38	; 0x26
 80080b4:	2229      	movs	r2, #41	; 0x29
 80080b6:	701a      	strb	r2, [r3, #0]

        /* Setup the volume ID.  */
        _fx_utility_32_unsigned_write(&byte_ptr[FX_VOLUME_ID], _fx_media_format_volume_id);
 80080b8:	697b      	ldr	r3, [r7, #20]
 80080ba:	3327      	adds	r3, #39	; 0x27
 80080bc:	4a31      	ldr	r2, [pc, #196]	; (8008184 <_fx_media_format+0x3b0>)
 80080be:	6812      	ldr	r2, [r2, #0]
 80080c0:	4611      	mov	r1, r2
 80080c2:	4618      	mov	r0, r3
 80080c4:	f001 f9b1 	bl	800942a <_fx_utility_32_unsigned_write>
 80080c8:	e011      	b.n	80080ee <_fx_media_format+0x31a>
    }
    else
    {

        /* Set the number of sectors per FAT32.  */
        _fx_utility_32_unsigned_write(&byte_ptr[FX_SECTORS_PER_FAT_32], sectors_per_fat);
 80080ca:	697b      	ldr	r3, [r7, #20]
 80080cc:	3324      	adds	r3, #36	; 0x24
 80080ce:	6a39      	ldr	r1, [r7, #32]
 80080d0:	4618      	mov	r0, r3
 80080d2:	f001 f9aa 	bl	800942a <_fx_utility_32_unsigned_write>

        /* Set the signature.  */
        byte_ptr[FX_BOOT_SIG_32] =  0x29;
 80080d6:	697b      	ldr	r3, [r7, #20]
 80080d8:	3342      	adds	r3, #66	; 0x42
 80080da:	2229      	movs	r2, #41	; 0x29
 80080dc:	701a      	strb	r2, [r3, #0]

        /* Setup the volume ID.  */
        _fx_utility_32_unsigned_write(&byte_ptr[FX_VOLUME_ID_32], _fx_media_format_volume_id);
 80080de:	697b      	ldr	r3, [r7, #20]
 80080e0:	3343      	adds	r3, #67	; 0x43
 80080e2:	4a28      	ldr	r2, [pc, #160]	; (8008184 <_fx_media_format+0x3b0>)
 80080e4:	6812      	ldr	r2, [r2, #0]
 80080e6:	4611      	mov	r1, r2
 80080e8:	4618      	mov	r0, r3
 80080ea:	f001 f99e 	bl	800942a <_fx_utility_32_unsigned_write>
    }

    /* Set the total number of sectors.  */
    if (total_sectors < (ULONG)0xFFFF)
 80080ee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80080f0:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 80080f4:	4293      	cmp	r3, r2
 80080f6:	d80c      	bhi.n	8008112 <_fx_media_format+0x33e>
    {

        /* Write the 16-bit total sector field.  */
        _fx_utility_16_unsigned_write(&byte_ptr[FX_SECTORS], (UINT)(total_sectors));
 80080f8:	697b      	ldr	r3, [r7, #20]
 80080fa:	3313      	adds	r3, #19
 80080fc:	6d79      	ldr	r1, [r7, #84]	; 0x54
 80080fe:	4618      	mov	r0, r3
 8008100:	f001 f961 	bl	80093c6 <_fx_utility_16_unsigned_write>

        /* Set the number of huge sectors.  */
        _fx_utility_32_unsigned_write(&byte_ptr[FX_HUGE_SECTORS], 0);
 8008104:	697b      	ldr	r3, [r7, #20]
 8008106:	3320      	adds	r3, #32
 8008108:	2100      	movs	r1, #0
 800810a:	4618      	mov	r0, r3
 800810c:	f001 f98d 	bl	800942a <_fx_utility_32_unsigned_write>
 8008110:	e00b      	b.n	800812a <_fx_media_format+0x356>
    }
    else
    {

        /* Write the 16-bit total sector field as 0.  */
        _fx_utility_16_unsigned_write(&byte_ptr[FX_SECTORS], (UINT)0);
 8008112:	697b      	ldr	r3, [r7, #20]
 8008114:	3313      	adds	r3, #19
 8008116:	2100      	movs	r1, #0
 8008118:	4618      	mov	r0, r3
 800811a:	f001 f954 	bl	80093c6 <_fx_utility_16_unsigned_write>

        /* Set the number of huge sectors.  */
        _fx_utility_32_unsigned_write(&byte_ptr[FX_HUGE_SECTORS], total_sectors);
 800811e:	697b      	ldr	r3, [r7, #20]
 8008120:	3320      	adds	r3, #32
 8008122:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8008124:	4618      	mov	r0, r3
 8008126:	f001 f980 	bl	800942a <_fx_utility_32_unsigned_write>
    }

    /* Set the number of reserved sectors.  */
    _fx_utility_16_unsigned_write(&byte_ptr[FX_RESERVED_SECTORS], reserved_sectors);
 800812a:	697b      	ldr	r3, [r7, #20]
 800812c:	330e      	adds	r3, #14
 800812e:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8008130:	4618      	mov	r0, r3
 8008132:	f001 f948 	bl	80093c6 <_fx_utility_16_unsigned_write>

    /* Set the number of sectors per cluster */
    byte_ptr[FX_SECTORS_CLUSTER] =  (UCHAR)sectors_per_cluster;
 8008136:	697b      	ldr	r3, [r7, #20]
 8008138:	330d      	adds	r3, #13
 800813a:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800813c:	b2d2      	uxtb	r2, r2
 800813e:	701a      	strb	r2, [r3, #0]

    /* Set the number of FATs.  */
    byte_ptr[FX_NUMBER_OF_FATS] =  (UCHAR)number_of_fats;
 8008140:	697b      	ldr	r3, [r7, #20]
 8008142:	3310      	adds	r3, #16
 8008144:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8008146:	b2d2      	uxtb	r2, r2
 8008148:	701a      	strb	r2, [r3, #0]

    /* Set the number of hidden sectors.  */
    _fx_utility_32_unsigned_write(&byte_ptr[FX_HIDDEN_SECTORS], hidden_sectors);
 800814a:	697b      	ldr	r3, [r7, #20]
 800814c:	331c      	adds	r3, #28
 800814e:	6d39      	ldr	r1, [r7, #80]	; 0x50
 8008150:	4618      	mov	r0, r3
 8008152:	f001 f96a 	bl	800942a <_fx_utility_32_unsigned_write>

    /* Determine if a FAT12 or FAT16 is present.  If FAT32 is present, these fields are left alone!   */
    if (total_clusters < FX_16_BIT_FAT_SIZE)
 8008156:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008158:	f64f 72f4 	movw	r2, #65524	; 0xfff4
 800815c:	4293      	cmp	r3, r2
 800815e:	d805      	bhi.n	800816c <_fx_media_format+0x398>
    {

        /* Yes, set the number of root directory entries.  */
        _fx_utility_16_unsigned_write(&byte_ptr[FX_ROOT_DIR_ENTRIES], directory_entries);
 8008160:	697b      	ldr	r3, [r7, #20]
 8008162:	3311      	adds	r3, #17
 8008164:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8008166:	4618      	mov	r0, r3
 8008168:	f001 f92d 	bl	80093c6 <_fx_utility_16_unsigned_write>
    }

    /* Now setup the volume label. */
    if (total_clusters < FX_16_BIT_FAT_SIZE)
 800816c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800816e:	f64f 72f4 	movw	r2, #65524	; 0xfff4
 8008172:	4293      	cmp	r3, r2
 8008174:	d808      	bhi.n	8008188 <_fx_media_format+0x3b4>
    {

        /* FAT12/16 volume label offset.  */
        j =  FX_VOLUME_LABEL;
 8008176:	232b      	movs	r3, #43	; 0x2b
 8008178:	62fb      	str	r3, [r7, #44]	; 0x2c
 800817a:	e007      	b.n	800818c <_fx_media_format+0x3b8>
 800817c:	20000024 	.word	0x20000024
 8008180:	2000002c 	.word	0x2000002c
 8008184:	20000030 	.word	0x20000030
    }
    else
    {

        /* FAT32 volume label offset.  */
        j =  FX_VOLUME_LABEL_32;
 8008188:	2347      	movs	r3, #71	; 0x47
 800818a:	62fb      	str	r3, [r7, #44]	; 0x2c
    }

    i = 0;
 800818c:	2300      	movs	r3, #0
 800818e:	633b      	str	r3, [r7, #48]	; 0x30
    while (i < 11)
 8008190:	e012      	b.n	80081b8 <_fx_media_format+0x3e4>
    {

        /* Determine if it is NULL.  */
        if (volume_name[i] == 0)
 8008192:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8008194:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008196:	4413      	add	r3, r2
 8008198:	781b      	ldrb	r3, [r3, #0]
 800819a:	2b00      	cmp	r3, #0
 800819c:	d010      	beq.n	80081c0 <_fx_media_format+0x3ec>
            /* Yes, the copying is finished.  */
            break;
        }

        /* Otherwise, copy byte of volume name into boot record.  */
        byte_ptr[j + i] =  (UCHAR)volume_name[i];
 800819e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80081a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081a2:	441a      	add	r2, r3
 80081a4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80081a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081a8:	440b      	add	r3, r1
 80081aa:	6979      	ldr	r1, [r7, #20]
 80081ac:	440b      	add	r3, r1
 80081ae:	7812      	ldrb	r2, [r2, #0]
 80081b0:	701a      	strb	r2, [r3, #0]

        /* Increment byte position.  */
        i++;
 80081b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081b4:	3301      	adds	r3, #1
 80081b6:	633b      	str	r3, [r7, #48]	; 0x30
    while (i < 11)
 80081b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081ba:	2b0a      	cmp	r3, #10
 80081bc:	d9e9      	bls.n	8008192 <_fx_media_format+0x3be>
 80081be:	e00b      	b.n	80081d8 <_fx_media_format+0x404>
            break;
 80081c0:	bf00      	nop
    }

    /* Now blank-pad the remainder of the volume name.  */
#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    while (i < 11)
 80081c2:	e009      	b.n	80081d8 <_fx_media_format+0x404>
    {

        byte_ptr[j + i] =  (UCHAR)' ';
 80081c4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80081c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081c8:	4413      	add	r3, r2
 80081ca:	697a      	ldr	r2, [r7, #20]
 80081cc:	4413      	add	r3, r2
 80081ce:	2220      	movs	r2, #32
 80081d0:	701a      	strb	r2, [r3, #0]
        i++;
 80081d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081d4:	3301      	adds	r3, #1
 80081d6:	633b      	str	r3, [r7, #48]	; 0x30
    while (i < 11)
 80081d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80081da:	2b0a      	cmp	r3, #10
 80081dc:	d9f2      	bls.n	80081c4 <_fx_media_format+0x3f0>
    byte_ptr[510] = 0x55;
    byte_ptr[511] = 0xAA;
#else

    /* Set bootrecord signature.  */
    byte_ptr[bytes_per_sector - 2] = 0x55;
 80081de:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80081e0:	3b02      	subs	r3, #2
 80081e2:	697a      	ldr	r2, [r7, #20]
 80081e4:	4413      	add	r3, r2
 80081e6:	2255      	movs	r2, #85	; 0x55
 80081e8:	701a      	strb	r2, [r3, #0]
    byte_ptr[bytes_per_sector - 1] = 0xAA;
 80081ea:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80081ec:	3b01      	subs	r3, #1
 80081ee:	697a      	ldr	r2, [r7, #20]
 80081f0:	4413      	add	r3, r2
 80081f2:	22aa      	movs	r2, #170	; 0xaa
 80081f4:	701a      	strb	r2, [r3, #0]
#endif

    /* Select the boot record write command.  */
    media_ptr -> fx_media_driver_request =       FX_DRIVER_BOOT_WRITE;
 80081f6:	68fb      	ldr	r3, [r7, #12]
 80081f8:	2207      	movs	r2, #7
 80081fa:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 80081fe:	68fb      	ldr	r3, [r7, #12]
 8008200:	2201      	movs	r2, #1
 8008202:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    media_ptr -> fx_media_driver_sectors =       1;
 8008206:	68fb      	ldr	r3, [r7, #12]
 8008208:	2201      	movs	r2, #1
 800820a:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    media_ptr -> fx_media_driver_sector_type =   FX_BOOT_SECTOR;
 800820e:	68fb      	ldr	r3, [r7, #12]
 8008210:	2201      	movs	r2, #1
 8008212:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_BOOT_WRITE, media_ptr, memory_ptr, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Write out the bootrecord */
    (driver)(media_ptr);
 8008216:	68bb      	ldr	r3, [r7, #8]
 8008218:	68f8      	ldr	r0, [r7, #12]
 800821a:	4798      	blx	r3

    /* Clear the write flag.  */
    media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800821c:	68fb      	ldr	r3, [r7, #12]
 800821e:	2200      	movs	r2, #0
 8008220:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

    /* Determine if it was successful.  */
    if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 8008224:	68fb      	ldr	r3, [r7, #12]
 8008226:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800822a:	2b00      	cmp	r3, #0
 800822c:	d001      	beq.n	8008232 <_fx_media_format+0x45e>
    {
        return(FX_IO_ERROR);
 800822e:	2390      	movs	r3, #144	; 0x90
 8008230:	e181      	b.n	8008536 <_fx_media_format+0x762>
    }

    /* Calculate the number of root sectors.  */
    root_sectors =    ((directory_entries * FX_DIR_ENTRY_SIZE) + bytes_per_sector - 1) / bytes_per_sector;
 8008232:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008234:	015a      	lsls	r2, r3, #5
 8008236:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8008238:	4413      	add	r3, r2
 800823a:	1e5a      	subs	r2, r3, #1
 800823c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800823e:	fbb2 f3f3 	udiv	r3, r2, r3
 8008242:	613b      	str	r3, [r7, #16]

    /* Determine if FAT32 is present AND if the bytes per sector is large enough to have
       a FSINFO sector.  */
    if ((total_clusters >= FX_16_BIT_FAT_SIZE) && (bytes_per_sector == 512))
 8008244:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008246:	f64f 72f4 	movw	r2, #65524	; 0xfff4
 800824a:	4293      	cmp	r3, r2
 800824c:	d971      	bls.n	8008332 <_fx_media_format+0x55e>
 800824e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8008250:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008254:	d16d      	bne.n	8008332 <_fx_media_format+0x55e>
    {

#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
        /* Clear sector buffer.  */
        for (i = 0; i < bytes_per_sector; i++)
 8008256:	2300      	movs	r3, #0
 8008258:	633b      	str	r3, [r7, #48]	; 0x30
 800825a:	e007      	b.n	800826c <_fx_media_format+0x498>
        {
            byte_ptr[i] =  (CHAR)0;
 800825c:	697a      	ldr	r2, [r7, #20]
 800825e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008260:	4413      	add	r3, r2
 8008262:	2200      	movs	r2, #0
 8008264:	701a      	strb	r2, [r3, #0]
        for (i = 0; i < bytes_per_sector; i++)
 8008266:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008268:	3301      	adds	r3, #1
 800826a:	633b      	str	r3, [r7, #48]	; 0x30
 800826c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800826e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8008270:	429a      	cmp	r2, r3
 8008272:	d3f3      	bcc.n	800825c <_fx_media_format+0x488>
#endif /* FX_DISABLE_FORCE_MEMORY_OPERATION */

        /* Build the FSINFO fields.  */

        /* Build first signature word, used to help verify this is a FSINFO sector.  */
        byte_ptr[0] =  0x52;
 8008274:	697b      	ldr	r3, [r7, #20]
 8008276:	2252      	movs	r2, #82	; 0x52
 8008278:	701a      	strb	r2, [r3, #0]
        byte_ptr[1] =  0x52;
 800827a:	697b      	ldr	r3, [r7, #20]
 800827c:	3301      	adds	r3, #1
 800827e:	2252      	movs	r2, #82	; 0x52
 8008280:	701a      	strb	r2, [r3, #0]
        byte_ptr[2] =  0x61;
 8008282:	697b      	ldr	r3, [r7, #20]
 8008284:	3302      	adds	r3, #2
 8008286:	2261      	movs	r2, #97	; 0x61
 8008288:	701a      	strb	r2, [r3, #0]
        byte_ptr[3] =  0x41;
 800828a:	697b      	ldr	r3, [r7, #20]
 800828c:	3303      	adds	r3, #3
 800828e:	2241      	movs	r2, #65	; 0x41
 8008290:	701a      	strb	r2, [r3, #0]

        /* Build the next signature word, this too is used to help verify that this is a FSINFO sector.  */
        byte_ptr[484] =  0x72;
 8008292:	697b      	ldr	r3, [r7, #20]
 8008294:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 8008298:	2272      	movs	r2, #114	; 0x72
 800829a:	701a      	strb	r2, [r3, #0]
        byte_ptr[485] =  0x72;
 800829c:	697b      	ldr	r3, [r7, #20]
 800829e:	f203 13e5 	addw	r3, r3, #485	; 0x1e5
 80082a2:	2272      	movs	r2, #114	; 0x72
 80082a4:	701a      	strb	r2, [r3, #0]
        byte_ptr[486] =  0x41;
 80082a6:	697b      	ldr	r3, [r7, #20]
 80082a8:	f503 73f3 	add.w	r3, r3, #486	; 0x1e6
 80082ac:	2241      	movs	r2, #65	; 0x41
 80082ae:	701a      	strb	r2, [r3, #0]
        byte_ptr[487] =  0x61;
 80082b0:	697b      	ldr	r3, [r7, #20]
 80082b2:	f203 13e7 	addw	r3, r3, #487	; 0x1e7
 80082b6:	2261      	movs	r2, #97	; 0x61
 80082b8:	701a      	strb	r2, [r3, #0]

        /* Build the final signature word, this too is used to help verify that this is a FSINFO sector.  */
        byte_ptr[508] =  0x55;
 80082ba:	697b      	ldr	r3, [r7, #20]
 80082bc:	f503 73fe 	add.w	r3, r3, #508	; 0x1fc
 80082c0:	2255      	movs	r2, #85	; 0x55
 80082c2:	701a      	strb	r2, [r3, #0]
        byte_ptr[509] =  0xAA;
 80082c4:	697b      	ldr	r3, [r7, #20]
 80082c6:	f203 13fd 	addw	r3, r3, #509	; 0x1fd
 80082ca:	22aa      	movs	r2, #170	; 0xaa
 80082cc:	701a      	strb	r2, [r3, #0]

        /* Setup the total available clusters on the media. We need to subtract 1 for the FAT32 root directory.  */
        _fx_utility_32_unsigned_write(&byte_ptr[488], (total_clusters - 1));
 80082ce:	697b      	ldr	r3, [r7, #20]
 80082d0:	f503 72f4 	add.w	r2, r3, #488	; 0x1e8
 80082d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80082d6:	3b01      	subs	r3, #1
 80082d8:	4619      	mov	r1, r3
 80082da:	4610      	mov	r0, r2
 80082dc:	f001 f8a5 	bl	800942a <_fx_utility_32_unsigned_write>

        /* Setup the starting free cluster to 3, since cluster 2 is reserved for the FAT32 root directory.  */
        _fx_utility_32_unsigned_write(&byte_ptr[492], 3);
 80082e0:	697b      	ldr	r3, [r7, #20]
 80082e2:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
 80082e6:	2103      	movs	r1, #3
 80082e8:	4618      	mov	r0, r3
 80082ea:	f001 f89e 	bl	800942a <_fx_utility_32_unsigned_write>

        /* Now write the FSINFO sector to the media.  */
        media_ptr -> fx_media_driver_logical_sector =  1;
 80082ee:	68fb      	ldr	r3, [r7, #12]
 80082f0:	2201      	movs	r2, #1
 80082f2:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
        media_ptr -> fx_media_driver_request =         FX_DRIVER_WRITE;
 80082f6:	68fb      	ldr	r3, [r7, #12]
 80082f8:	2201      	movs	r2, #1
 80082fa:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        media_ptr -> fx_media_driver_sectors =         1;
 80082fe:	68fb      	ldr	r3, [r7, #12]
 8008300:	2201      	movs	r2, #1
 8008302:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        media_ptr -> fx_media_driver_system_write =    FX_TRUE;
 8008306:	68fb      	ldr	r3, [r7, #12]
 8008308:	2201      	movs	r2, #1
 800830a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
        media_ptr -> fx_media_driver_sector_type =     FX_BOOT_SECTOR;
 800830e:	68fb      	ldr	r3, [r7, #12]
 8008310:	2201      	movs	r2, #1
 8008312:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, 1, 1, memory_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Write out the sector.  */
        (driver)(media_ptr);
 8008316:	68bb      	ldr	r3, [r7, #8]
 8008318:	68f8      	ldr	r0, [r7, #12]
 800831a:	4798      	blx	r3

        /* Clear the system write flag.  */
        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800831c:	68fb      	ldr	r3, [r7, #12]
 800831e:	2200      	movs	r2, #0
 8008320:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

        /* Determine if it was successful.  */
        if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 8008324:	68fb      	ldr	r3, [r7, #12]
 8008326:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800832a:	2b00      	cmp	r3, #0
 800832c:	d001      	beq.n	8008332 <_fx_media_format+0x55e>
        {
            return(FX_IO_ERROR);
 800832e:	2390      	movs	r3, #144	; 0x90
 8008330:	e101      	b.n	8008536 <_fx_media_format+0x762>
    }

    /* At this point we need set up first to FAT entries and clear the remaining FAT sectors area.  */

    /* Loop through number of FATs. The first is the only one used.  */
    for (f = 0; f < number_of_fats; f++)
 8008332:	2300      	movs	r3, #0
 8008334:	61fb      	str	r3, [r7, #28]
 8008336:	e0a7      	b.n	8008488 <_fx_media_format+0x6b4>
    {

        /* Loop through all the sectors in this FAT.  */
        for (s = 0; s < sectors_per_fat; s++)
 8008338:	2300      	movs	r3, #0
 800833a:	61bb      	str	r3, [r7, #24]
 800833c:	e09c      	b.n	8008478 <_fx_media_format+0x6a4>
        {

            if (s == 0)
 800833e:	69bb      	ldr	r3, [r7, #24]
 8008340:	2b00      	cmp	r3, #0
 8008342:	d15e      	bne.n	8008402 <_fx_media_format+0x62e>
            {

                /* Reserve the first two FAT table entries.  */
                if (total_clusters < FX_12_BIT_FAT_SIZE)
 8008344:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008346:	f640 72f5 	movw	r2, #4085	; 0xff5
 800834a:	4293      	cmp	r3, r2
 800834c:	d80e      	bhi.n	800836c <_fx_media_format+0x598>
                {

                    /* Reserve the first two FAT-12 entries.  */
                    byte_ptr[0] =  _fx_media_format_media_type;
 800834e:	4b7c      	ldr	r3, [pc, #496]	; (8008540 <_fx_media_format+0x76c>)
 8008350:	781a      	ldrb	r2, [r3, #0]
 8008352:	697b      	ldr	r3, [r7, #20]
 8008354:	701a      	strb	r2, [r3, #0]
                    byte_ptr[1] =  (UCHAR)0xFF;
 8008356:	697b      	ldr	r3, [r7, #20]
 8008358:	3301      	adds	r3, #1
 800835a:	22ff      	movs	r2, #255	; 0xff
 800835c:	701a      	strb	r2, [r3, #0]
                    byte_ptr[2] =  (UCHAR)0xFF;
 800835e:	697b      	ldr	r3, [r7, #20]
 8008360:	3302      	adds	r3, #2
 8008362:	22ff      	movs	r2, #255	; 0xff
 8008364:	701a      	strb	r2, [r3, #0]

                    /* Start clearing at FAT entry 3.  */
                    i =  3;
 8008366:	2303      	movs	r3, #3
 8008368:	633b      	str	r3, [r7, #48]	; 0x30
 800836a:	e055      	b.n	8008418 <_fx_media_format+0x644>
                }
                else if (total_clusters < FX_16_BIT_FAT_SIZE)
 800836c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800836e:	f64f 72f4 	movw	r2, #65524	; 0xfff4
 8008372:	4293      	cmp	r3, r2
 8008374:	d812      	bhi.n	800839c <_fx_media_format+0x5c8>
                {

                    /* Reserve the first two FAT-16 entries.  */
                    byte_ptr[0] =  _fx_media_format_media_type;
 8008376:	4b72      	ldr	r3, [pc, #456]	; (8008540 <_fx_media_format+0x76c>)
 8008378:	781a      	ldrb	r2, [r3, #0]
 800837a:	697b      	ldr	r3, [r7, #20]
 800837c:	701a      	strb	r2, [r3, #0]
                    byte_ptr[1] =  (UCHAR)0xFF;
 800837e:	697b      	ldr	r3, [r7, #20]
 8008380:	3301      	adds	r3, #1
 8008382:	22ff      	movs	r2, #255	; 0xff
 8008384:	701a      	strb	r2, [r3, #0]
                    byte_ptr[2] =  (UCHAR)0xFF;
 8008386:	697b      	ldr	r3, [r7, #20]
 8008388:	3302      	adds	r3, #2
 800838a:	22ff      	movs	r2, #255	; 0xff
 800838c:	701a      	strb	r2, [r3, #0]
                    byte_ptr[3] =  (UCHAR)0xFF;
 800838e:	697b      	ldr	r3, [r7, #20]
 8008390:	3303      	adds	r3, #3
 8008392:	22ff      	movs	r2, #255	; 0xff
 8008394:	701a      	strb	r2, [r3, #0]

                    /* Start clearing at FAT entry 3.  */
                    i =  4;
 8008396:	2304      	movs	r3, #4
 8008398:	633b      	str	r3, [r7, #48]	; 0x30
 800839a:	e03d      	b.n	8008418 <_fx_media_format+0x644>
                }
                else
                {

                    /* Reserve the first two FAT-32 entries.   */
                    byte_ptr[0] =  _fx_media_format_media_type;
 800839c:	4b68      	ldr	r3, [pc, #416]	; (8008540 <_fx_media_format+0x76c>)
 800839e:	781a      	ldrb	r2, [r3, #0]
 80083a0:	697b      	ldr	r3, [r7, #20]
 80083a2:	701a      	strb	r2, [r3, #0]
                    byte_ptr[1] =  (UCHAR)0xFF;
 80083a4:	697b      	ldr	r3, [r7, #20]
 80083a6:	3301      	adds	r3, #1
 80083a8:	22ff      	movs	r2, #255	; 0xff
 80083aa:	701a      	strb	r2, [r3, #0]
                    byte_ptr[2] =  (UCHAR)0xFF;
 80083ac:	697b      	ldr	r3, [r7, #20]
 80083ae:	3302      	adds	r3, #2
 80083b0:	22ff      	movs	r2, #255	; 0xff
 80083b2:	701a      	strb	r2, [r3, #0]
                    byte_ptr[3] =  (UCHAR)0x0F;
 80083b4:	697b      	ldr	r3, [r7, #20]
 80083b6:	3303      	adds	r3, #3
 80083b8:	220f      	movs	r2, #15
 80083ba:	701a      	strb	r2, [r3, #0]
                    byte_ptr[4] =  (UCHAR)0xFF;
 80083bc:	697b      	ldr	r3, [r7, #20]
 80083be:	3304      	adds	r3, #4
 80083c0:	22ff      	movs	r2, #255	; 0xff
 80083c2:	701a      	strb	r2, [r3, #0]
                    byte_ptr[5] =  (UCHAR)0xFF;
 80083c4:	697b      	ldr	r3, [r7, #20]
 80083c6:	3305      	adds	r3, #5
 80083c8:	22ff      	movs	r2, #255	; 0xff
 80083ca:	701a      	strb	r2, [r3, #0]
                    byte_ptr[6] =  (UCHAR)0xFF;
 80083cc:	697b      	ldr	r3, [r7, #20]
 80083ce:	3306      	adds	r3, #6
 80083d0:	22ff      	movs	r2, #255	; 0xff
 80083d2:	701a      	strb	r2, [r3, #0]
                    byte_ptr[7] =  (UCHAR)0x0F;
 80083d4:	697b      	ldr	r3, [r7, #20]
 80083d6:	3307      	adds	r3, #7
 80083d8:	220f      	movs	r2, #15
 80083da:	701a      	strb	r2, [r3, #0]

                    /* Preallocate the first cluster for the root directory.  */
                    byte_ptr[8] =   (UCHAR)0xFF;
 80083dc:	697b      	ldr	r3, [r7, #20]
 80083de:	3308      	adds	r3, #8
 80083e0:	22ff      	movs	r2, #255	; 0xff
 80083e2:	701a      	strb	r2, [r3, #0]
                    byte_ptr[9] =   (UCHAR)0xFF;
 80083e4:	697b      	ldr	r3, [r7, #20]
 80083e6:	3309      	adds	r3, #9
 80083e8:	22ff      	movs	r2, #255	; 0xff
 80083ea:	701a      	strb	r2, [r3, #0]
                    byte_ptr[10] =  (UCHAR)0xFF;
 80083ec:	697b      	ldr	r3, [r7, #20]
 80083ee:	330a      	adds	r3, #10
 80083f0:	22ff      	movs	r2, #255	; 0xff
 80083f2:	701a      	strb	r2, [r3, #0]
                    byte_ptr[11] =  (UCHAR)0x0F;
 80083f4:	697b      	ldr	r3, [r7, #20]
 80083f6:	330b      	adds	r3, #11
 80083f8:	220f      	movs	r2, #15
 80083fa:	701a      	strb	r2, [r3, #0]

                    /* Start clearing at FAT entry 3.  */
                    i =  12;
 80083fc:	230c      	movs	r3, #12
 80083fe:	633b      	str	r3, [r7, #48]	; 0x30
 8008400:	e00a      	b.n	8008418 <_fx_media_format+0x644>
                }
            }
            else
            {
                i = 0;
 8008402:	2300      	movs	r3, #0
 8008404:	633b      	str	r3, [r7, #48]	; 0x30
            }

#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
            /* Clear remainder of sector buffer.  */
            for (; i < bytes_per_sector; i++)
 8008406:	e007      	b.n	8008418 <_fx_media_format+0x644>
            {
                byte_ptr[i] =  (CHAR)0;
 8008408:	697a      	ldr	r2, [r7, #20]
 800840a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800840c:	4413      	add	r3, r2
 800840e:	2200      	movs	r2, #0
 8008410:	701a      	strb	r2, [r3, #0]
            for (; i < bytes_per_sector; i++)
 8008412:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008414:	3301      	adds	r3, #1
 8008416:	633b      	str	r3, [r7, #48]	; 0x30
 8008418:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800841a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800841c:	429a      	cmp	r2, r3
 800841e:	d3f3      	bcc.n	8008408 <_fx_media_format+0x634>
#else
            _fx_utility_memory_set(&byte_ptr[i], 0, (bytes_per_sector - i));
#endif  /* FX_DISABLE_FORCE_MEMORY_OPERATION */

            /* Build sector write command.  */
            media_ptr -> fx_media_driver_logical_sector =  reserved_sectors + (f * sectors_per_fat) + s;
 8008420:	69fb      	ldr	r3, [r7, #28]
 8008422:	6a3a      	ldr	r2, [r7, #32]
 8008424:	fb03 f202 	mul.w	r2, r3, r2
 8008428:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800842a:	441a      	add	r2, r3
 800842c:	69bb      	ldr	r3, [r7, #24]
 800842e:	441a      	add	r2, r3
 8008430:	68fb      	ldr	r3, [r7, #12]
 8008432:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
            media_ptr -> fx_media_driver_request =         FX_DRIVER_WRITE;
 8008436:	68fb      	ldr	r3, [r7, #12]
 8008438:	2201      	movs	r2, #1
 800843a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            media_ptr -> fx_media_driver_sectors =         1;
 800843e:	68fb      	ldr	r3, [r7, #12]
 8008440:	2201      	movs	r2, #1
 8008442:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            media_ptr -> fx_media_driver_system_write =    FX_TRUE;
 8008446:	68fb      	ldr	r3, [r7, #12]
 8008448:	2201      	movs	r2, #1
 800844a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
            media_ptr -> fx_media_driver_sector_type =     FX_FAT_SECTOR;
 800844e:	68fb      	ldr	r3, [r7, #12]
 8008450:	2202      	movs	r2, #2
 8008452:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

            /* If trace is enabled, insert this event into the trace buffer.  */
            FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, media_ptr -> fx_media_driver_logical_sector, 1, memory_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

            /* Write out the sector.  */
            (driver)(media_ptr);
 8008456:	68bb      	ldr	r3, [r7, #8]
 8008458:	68f8      	ldr	r0, [r7, #12]
 800845a:	4798      	blx	r3

            /* Clear the system write flag.  */
            media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800845c:	68fb      	ldr	r3, [r7, #12]
 800845e:	2200      	movs	r2, #0
 8008460:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

            /* Determine if it was successful.  */
            if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 8008464:	68fb      	ldr	r3, [r7, #12]
 8008466:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800846a:	2b00      	cmp	r3, #0
 800846c:	d001      	beq.n	8008472 <_fx_media_format+0x69e>
            {
                return(FX_IO_ERROR);
 800846e:	2390      	movs	r3, #144	; 0x90
 8008470:	e061      	b.n	8008536 <_fx_media_format+0x762>
        for (s = 0; s < sectors_per_fat; s++)
 8008472:	69bb      	ldr	r3, [r7, #24]
 8008474:	3301      	adds	r3, #1
 8008476:	61bb      	str	r3, [r7, #24]
 8008478:	69ba      	ldr	r2, [r7, #24]
 800847a:	6a3b      	ldr	r3, [r7, #32]
 800847c:	429a      	cmp	r2, r3
 800847e:	f4ff af5e 	bcc.w	800833e <_fx_media_format+0x56a>
    for (f = 0; f < number_of_fats; f++)
 8008482:	69fb      	ldr	r3, [r7, #28]
 8008484:	3301      	adds	r3, #1
 8008486:	61fb      	str	r3, [r7, #28]
 8008488:	69fa      	ldr	r2, [r7, #28]
 800848a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800848c:	429a      	cmp	r2, r3
 800848e:	f4ff af53 	bcc.w	8008338 <_fx_media_format+0x564>
        }
    }

#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    /* Clear sector buffer.  */
    for (i = 0; i < bytes_per_sector; i++)
 8008492:	2300      	movs	r3, #0
 8008494:	633b      	str	r3, [r7, #48]	; 0x30
 8008496:	e007      	b.n	80084a8 <_fx_media_format+0x6d4>
    {
        byte_ptr[i] =  (CHAR)0;
 8008498:	697a      	ldr	r2, [r7, #20]
 800849a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800849c:	4413      	add	r3, r2
 800849e:	2200      	movs	r2, #0
 80084a0:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < bytes_per_sector; i++)
 80084a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80084a4:	3301      	adds	r3, #1
 80084a6:	633b      	str	r3, [r7, #48]	; 0x30
 80084a8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80084aa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80084ac:	429a      	cmp	r2, r3
 80084ae:	d3f3      	bcc.n	8008498 <_fx_media_format+0x6c4>
#else
    _fx_utility_memory_set(byte_ptr, 0, bytes_per_sector);
#endif /* FX_DISABLE_FORCE_MEMORY_OPERATION */

    /* Now clear the root directory sectors.  */
    for (s = 0; s < root_sectors; s++)
 80084b0:	2300      	movs	r3, #0
 80084b2:	61bb      	str	r3, [r7, #24]
 80084b4:	e02b      	b.n	800850e <_fx_media_format+0x73a>
    {

        /* Build sector write command.  */
        media_ptr -> fx_media_driver_logical_sector =  reserved_sectors + (number_of_fats * sectors_per_fat) + s;
 80084b6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80084b8:	6a3a      	ldr	r2, [r7, #32]
 80084ba:	fb03 f202 	mul.w	r2, r3, r2
 80084be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80084c0:	441a      	add	r2, r3
 80084c2:	69bb      	ldr	r3, [r7, #24]
 80084c4:	441a      	add	r2, r3
 80084c6:	68fb      	ldr	r3, [r7, #12]
 80084c8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
        media_ptr -> fx_media_driver_request =         FX_DRIVER_WRITE;
 80084cc:	68fb      	ldr	r3, [r7, #12]
 80084ce:	2201      	movs	r2, #1
 80084d0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        media_ptr -> fx_media_driver_sectors =         1;
 80084d4:	68fb      	ldr	r3, [r7, #12]
 80084d6:	2201      	movs	r2, #1
 80084d8:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        media_ptr -> fx_media_driver_system_write =    FX_TRUE;
 80084dc:	68fb      	ldr	r3, [r7, #12]
 80084de:	2201      	movs	r2, #1
 80084e0:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
        media_ptr -> fx_media_driver_sector_type =     FX_DIRECTORY_SECTOR;
 80084e4:	68fb      	ldr	r3, [r7, #12]
 80084e6:	2203      	movs	r2, #3
 80084e8:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, media_ptr -> fx_media_driver_logical_sector, 1, memory_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Write out the sector.  */
        (driver)(media_ptr);
 80084ec:	68bb      	ldr	r3, [r7, #8]
 80084ee:	68f8      	ldr	r0, [r7, #12]
 80084f0:	4798      	blx	r3

        /* Clear the write flag.  */
        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 80084f2:	68fb      	ldr	r3, [r7, #12]
 80084f4:	2200      	movs	r2, #0
 80084f6:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

        /* Determine if it was successful.  */
        if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 80084fa:	68fb      	ldr	r3, [r7, #12]
 80084fc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8008500:	2b00      	cmp	r3, #0
 8008502:	d001      	beq.n	8008508 <_fx_media_format+0x734>
        {
            return(FX_IO_ERROR);
 8008504:	2390      	movs	r3, #144	; 0x90
 8008506:	e016      	b.n	8008536 <_fx_media_format+0x762>
    for (s = 0; s < root_sectors; s++)
 8008508:	69bb      	ldr	r3, [r7, #24]
 800850a:	3301      	adds	r3, #1
 800850c:	61bb      	str	r3, [r7, #24]
 800850e:	69ba      	ldr	r2, [r7, #24]
 8008510:	693b      	ldr	r3, [r7, #16]
 8008512:	429a      	cmp	r2, r3
 8008514:	d3cf      	bcc.n	80084b6 <_fx_media_format+0x6e2>
        }
    }

    /* Build the "uninitialize" I/O driver request.  */
    media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8008516:	68fb      	ldr	r3, [r7, #12]
 8008518:	2208      	movs	r2, #8
 800851a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800851e:	68fb      	ldr	r3, [r7, #12]
 8008520:	2290      	movs	r2, #144	; 0x90
 8008522:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Call the specified I/O driver with the uninitialize request.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008526:	68fb      	ldr	r3, [r7, #12]
 8008528:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800852c:	68f8      	ldr	r0, [r7, #12]
 800852e:	4798      	blx	r3

    /* Return success!  */
    return(media_ptr -> fx_media_driver_status);
 8008530:	68fb      	ldr	r3, [r7, #12]
 8008532:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
}
 8008536:	4618      	mov	r0, r3
 8008538:	3738      	adds	r7, #56	; 0x38
 800853a:	46bd      	mov	sp, r7
 800853c:	bd80      	pop	{r7, pc}
 800853e:	bf00      	nop
 8008540:	2000002c 	.word	0x2000002c

08008544 <_fx_media_open>:
/*                                                                        */
/**************************************************************************/
UINT  _fx_media_open(FX_MEDIA *media_ptr, CHAR *media_name,
                     VOID (*media_driver)(FX_MEDIA *), VOID *driver_info_ptr,
                     VOID *memory_ptr, ULONG memory_size)
{
 8008544:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8008548:	b09a      	sub	sp, #104	; 0x68
 800854a:	af04      	add	r7, sp, #16
 800854c:	60f8      	str	r0, [r7, #12]
 800854e:	60b9      	str	r1, [r7, #8]
 8008550:	607a      	str	r2, [r7, #4]
 8008552:	603b      	str	r3, [r7, #0]
FX_INT_SAVE_AREA


#ifndef FX_DISABLE_BUILD_OPTIONS
    /* Reference the version ID and option words to ensure they are linked in.  */
    if ((_fx_system_build_options_1 | _fx_system_build_options_2 | _fx_system_build_options_3) == 0 ||
 8008554:	4bba      	ldr	r3, [pc, #744]	; (8008840 <_fx_media_open+0x2fc>)
 8008556:	681a      	ldr	r2, [r3, #0]
 8008558:	4bba      	ldr	r3, [pc, #744]	; (8008844 <_fx_media_open+0x300>)
 800855a:	681b      	ldr	r3, [r3, #0]
 800855c:	431a      	orrs	r2, r3
 800855e:	4bba      	ldr	r3, [pc, #744]	; (8008848 <_fx_media_open+0x304>)
 8008560:	681b      	ldr	r3, [r3, #0]
 8008562:	4313      	orrs	r3, r2
 8008564:	2b00      	cmp	r3, #0
 8008566:	d003      	beq.n	8008570 <_fx_media_open+0x2c>
        _fx_version_id[0] == 0)
 8008568:	4bb8      	ldr	r3, [pc, #736]	; (800884c <_fx_media_open+0x308>)
 800856a:	781b      	ldrb	r3, [r3, #0]
    if ((_fx_system_build_options_1 | _fx_system_build_options_2 | _fx_system_build_options_3) == 0 ||
 800856c:	2b00      	cmp	r3, #0
 800856e:	d102      	bne.n	8008576 <_fx_media_open+0x32>
    {

        /* We should never get here!  */
        return(FX_NOT_IMPLEMENTED);
 8008570:	2322      	movs	r3, #34	; 0x22
 8008572:	f000 bd53 	b.w	800901c <_fx_media_open+0xad8>
#ifdef FX_DISABLE_CACHE
    media_ptr -> fx_media_memory_buffer_sector = (ULONG64)-1;
#endif /* FX_DISABLE_CACHE */

    /* Save the basic information in the media control block.  */
    media_ptr -> fx_media_name =                        media_name;
 8008576:	68fb      	ldr	r3, [r7, #12]
 8008578:	68ba      	ldr	r2, [r7, #8]
 800857a:	605a      	str	r2, [r3, #4]
    media_ptr -> fx_media_driver_entry =                media_driver;
 800857c:	68fb      	ldr	r3, [r7, #12]
 800857e:	687a      	ldr	r2, [r7, #4]
 8008580:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
    media_ptr -> fx_media_memory_buffer =               (UCHAR *)memory_ptr;
 8008584:	68fb      	ldr	r3, [r7, #12]
 8008586:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8008588:	609a      	str	r2, [r3, #8]
    media_ptr -> fx_media_memory_size =                 memory_size;
 800858a:	68fb      	ldr	r3, [r7, #12]
 800858c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800858e:	60da      	str	r2, [r3, #12]
#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    media_ptr -> fx_media_disable_burst_cache =         FX_FALSE;
 8008590:	68fb      	ldr	r3, [r7, #12]
 8008592:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8008596:	461a      	mov	r2, r3
 8008598:	2300      	movs	r3, #0
 800859a:	f8c2 34a4 	str.w	r3, [r2, #1188]	; 0x4a4
    media_ptr -> fx_media_FAT_type =                    0;
 800859e:	68fb      	ldr	r3, [r7, #12]
 80085a0:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 80085a4:	2200      	movs	r2, #0
 80085a6:	f883 24b0 	strb.w	r2, [r3, #1200]	; 0x4b0
#endif /* FX_DISABLE_FORCE_MEMORY_OPERATION */

    /* Save the original memory pointer.  */
    original_memory_ptr =  (UCHAR *)memory_ptr;
 80085aa:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80085ac:	643b      	str	r3, [r7, #64]	; 0x40

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Clear the optional media statistics.  */
    media_ptr -> fx_media_directory_attributes_reads =  0;
 80085ae:	68fb      	ldr	r3, [r7, #12]
 80085b0:	2200      	movs	r2, #0
 80085b2:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
    media_ptr -> fx_media_directory_attributes_sets =  0;
 80085b6:	68fb      	ldr	r3, [r7, #12]
 80085b8:	2200      	movs	r2, #0
 80085ba:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    media_ptr -> fx_media_directory_creates =  0;
 80085be:	68fb      	ldr	r3, [r7, #12]
 80085c0:	2200      	movs	r2, #0
 80085c2:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    media_ptr -> fx_media_directory_default_gets =  0;
 80085c6:	68fb      	ldr	r3, [r7, #12]
 80085c8:	2200      	movs	r2, #0
 80085ca:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
    media_ptr -> fx_media_directory_default_sets =  0;
 80085ce:	68fb      	ldr	r3, [r7, #12]
 80085d0:	2200      	movs	r2, #0
 80085d2:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    media_ptr -> fx_media_directory_deletes =  0;
 80085d6:	68fb      	ldr	r3, [r7, #12]
 80085d8:	2200      	movs	r2, #0
 80085da:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
    media_ptr -> fx_media_directory_first_entry_finds =  0;
 80085de:	68fb      	ldr	r3, [r7, #12]
 80085e0:	2200      	movs	r2, #0
 80085e2:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    media_ptr -> fx_media_directory_first_full_entry_finds =  0;
 80085e6:	68fb      	ldr	r3, [r7, #12]
 80085e8:	2200      	movs	r2, #0
 80085ea:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    media_ptr -> fx_media_directory_information_gets =  0;
 80085ee:	68fb      	ldr	r3, [r7, #12]
 80085f0:	2200      	movs	r2, #0
 80085f2:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
    media_ptr -> fx_media_directory_local_path_clears =  0;
 80085f6:	68fb      	ldr	r3, [r7, #12]
 80085f8:	2200      	movs	r2, #0
 80085fa:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
    media_ptr -> fx_media_directory_local_path_gets =  0;
 80085fe:	68fb      	ldr	r3, [r7, #12]
 8008600:	2200      	movs	r2, #0
 8008602:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    media_ptr -> fx_media_directory_local_path_restores =  0;
 8008606:	68fb      	ldr	r3, [r7, #12]
 8008608:	2200      	movs	r2, #0
 800860a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    media_ptr -> fx_media_directory_local_path_sets =  0;
 800860e:	68fb      	ldr	r3, [r7, #12]
 8008610:	2200      	movs	r2, #0
 8008612:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    media_ptr -> fx_media_directory_name_tests =  0;
 8008616:	68fb      	ldr	r3, [r7, #12]
 8008618:	2200      	movs	r2, #0
 800861a:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    media_ptr -> fx_media_directory_next_entry_finds =  0;
 800861e:	68fb      	ldr	r3, [r7, #12]
 8008620:	2200      	movs	r2, #0
 8008622:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    media_ptr -> fx_media_directory_next_full_entry_finds =  0;
 8008626:	68fb      	ldr	r3, [r7, #12]
 8008628:	2200      	movs	r2, #0
 800862a:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    media_ptr -> fx_media_directory_renames =  0;
 800862e:	68fb      	ldr	r3, [r7, #12]
 8008630:	2200      	movs	r2, #0
 8008632:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    media_ptr -> fx_media_file_allocates =  0;
 8008636:	68fb      	ldr	r3, [r7, #12]
 8008638:	2200      	movs	r2, #0
 800863a:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
    media_ptr -> fx_media_file_attributes_reads =  0;
 800863e:	68fb      	ldr	r3, [r7, #12]
 8008640:	2200      	movs	r2, #0
 8008642:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    media_ptr -> fx_media_file_attributes_sets =  0;
 8008646:	68fb      	ldr	r3, [r7, #12]
 8008648:	2200      	movs	r2, #0
 800864a:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    media_ptr -> fx_media_file_best_effort_allocates =  0;
 800864e:	68fb      	ldr	r3, [r7, #12]
 8008650:	2200      	movs	r2, #0
 8008652:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    media_ptr -> fx_media_file_closes =  0;
 8008656:	68fb      	ldr	r3, [r7, #12]
 8008658:	2200      	movs	r2, #0
 800865a:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
    media_ptr -> fx_media_file_creates =  0;
 800865e:	68fb      	ldr	r3, [r7, #12]
 8008660:	2200      	movs	r2, #0
 8008662:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
    media_ptr -> fx_media_file_deletes =  0;
 8008666:	68fb      	ldr	r3, [r7, #12]
 8008668:	2200      	movs	r2, #0
 800866a:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
    media_ptr -> fx_media_file_opens =  0;
 800866e:	68fb      	ldr	r3, [r7, #12]
 8008670:	2200      	movs	r2, #0
 8008672:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
    media_ptr -> fx_media_file_reads =  0;
 8008676:	68fb      	ldr	r3, [r7, #12]
 8008678:	2200      	movs	r2, #0
 800867a:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
    media_ptr -> fx_media_file_relative_seeks =  0;
 800867e:	68fb      	ldr	r3, [r7, #12]
 8008680:	2200      	movs	r2, #0
 8008682:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    media_ptr -> fx_media_file_renames =  0;
 8008686:	68fb      	ldr	r3, [r7, #12]
 8008688:	2200      	movs	r2, #0
 800868a:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
    media_ptr -> fx_media_file_seeks =  0;
 800868e:	68fb      	ldr	r3, [r7, #12]
 8008690:	2200      	movs	r2, #0
 8008692:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    media_ptr -> fx_media_file_truncates =  0;
 8008696:	68fb      	ldr	r3, [r7, #12]
 8008698:	2200      	movs	r2, #0
 800869a:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c
    media_ptr -> fx_media_file_truncate_releases =  0;
 800869e:	68fb      	ldr	r3, [r7, #12]
 80086a0:	2200      	movs	r2, #0
 80086a2:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
    media_ptr -> fx_media_file_writes =  0;
 80086a6:	68fb      	ldr	r3, [r7, #12]
 80086a8:	2200      	movs	r2, #0
 80086aa:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154
    media_ptr -> fx_media_aborts =  0;
 80086ae:	68fb      	ldr	r3, [r7, #12]
 80086b0:	2200      	movs	r2, #0
 80086b2:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
    media_ptr -> fx_media_flushes =  0;
 80086b6:	68fb      	ldr	r3, [r7, #12]
 80086b8:	2200      	movs	r2, #0
 80086ba:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c
    media_ptr -> fx_media_reads =  0;
 80086be:	68fb      	ldr	r3, [r7, #12]
 80086c0:	2200      	movs	r2, #0
 80086c2:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
    media_ptr -> fx_media_writes =  0;
 80086c6:	68fb      	ldr	r3, [r7, #12]
 80086c8:	2200      	movs	r2, #0
 80086ca:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164
    media_ptr -> fx_media_directory_entry_reads =  0;
 80086ce:	68fb      	ldr	r3, [r7, #12]
 80086d0:	2200      	movs	r2, #0
 80086d2:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
    media_ptr -> fx_media_directory_entry_writes =  0;
 80086d6:	68fb      	ldr	r3, [r7, #12]
 80086d8:	2200      	movs	r2, #0
 80086da:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c
    media_ptr -> fx_media_directory_searches =  0;
 80086de:	68fb      	ldr	r3, [r7, #12]
 80086e0:	2200      	movs	r2, #0
 80086e2:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE
    media_ptr -> fx_media_directory_search_cache_hits =  0;
 80086e6:	68fb      	ldr	r3, [r7, #12]
 80086e8:	2200      	movs	r2, #0
 80086ea:	f8c3 21c4 	str.w	r2, [r3, #452]	; 0x1c4
#endif
    media_ptr -> fx_media_directory_free_searches =  0;
 80086ee:	68fb      	ldr	r3, [r7, #12]
 80086f0:	2200      	movs	r2, #0
 80086f2:	f8c3 2174 	str.w	r2, [r3, #372]	; 0x174
    media_ptr -> fx_media_fat_entry_reads =  0;
 80086f6:	68fb      	ldr	r3, [r7, #12]
 80086f8:	2200      	movs	r2, #0
 80086fa:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
    media_ptr -> fx_media_fat_entry_writes =  0;
 80086fe:	68fb      	ldr	r3, [r7, #12]
 8008700:	2200      	movs	r2, #0
 8008702:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
    media_ptr -> fx_media_fat_entry_cache_read_hits =  0;
 8008706:	68fb      	ldr	r3, [r7, #12]
 8008708:	2200      	movs	r2, #0
 800870a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    media_ptr -> fx_media_fat_entry_cache_read_misses =  0;
 800870e:	68fb      	ldr	r3, [r7, #12]
 8008710:	2200      	movs	r2, #0
 8008712:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    media_ptr -> fx_media_fat_entry_cache_write_hits =  0;
 8008716:	68fb      	ldr	r3, [r7, #12]
 8008718:	2200      	movs	r2, #0
 800871a:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    media_ptr -> fx_media_fat_entry_cache_write_misses =  0;
 800871e:	68fb      	ldr	r3, [r7, #12]
 8008720:	2200      	movs	r2, #0
 8008722:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
    media_ptr -> fx_media_fat_cache_flushes =  0;
 8008726:	68fb      	ldr	r3, [r7, #12]
 8008728:	2200      	movs	r2, #0
 800872a:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
    media_ptr -> fx_media_fat_sector_reads =  0;
 800872e:	68fb      	ldr	r3, [r7, #12]
 8008730:	2200      	movs	r2, #0
 8008732:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
    media_ptr -> fx_media_fat_sector_writes =  0;
 8008736:	68fb      	ldr	r3, [r7, #12]
 8008738:	2200      	movs	r2, #0
 800873a:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    media_ptr -> fx_media_logical_sector_reads =  0;
 800873e:	68fb      	ldr	r3, [r7, #12]
 8008740:	2200      	movs	r2, #0
 8008742:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
    media_ptr -> fx_media_logical_sector_writes =  0;
 8008746:	68fb      	ldr	r3, [r7, #12]
 8008748:	2200      	movs	r2, #0
 800874a:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
    media_ptr -> fx_media_logical_sector_cache_read_hits =  0;
 800874e:	68fb      	ldr	r3, [r7, #12]
 8008750:	2200      	movs	r2, #0
 8008752:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
    media_ptr -> fx_media_logical_sector_cache_read_misses =  0;
 8008756:	68fb      	ldr	r3, [r7, #12]
 8008758:	2200      	movs	r2, #0
 800875a:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
    media_ptr -> fx_media_driver_read_requests =  0;
 800875e:	68fb      	ldr	r3, [r7, #12]
 8008760:	2200      	movs	r2, #0
 8008762:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
    media_ptr -> fx_media_driver_write_requests =  0;
 8008766:	68fb      	ldr	r3, [r7, #12]
 8008768:	2200      	movs	r2, #0
 800876a:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
    media_ptr -> fx_media_driver_boot_read_requests =  0;
 800876e:	68fb      	ldr	r3, [r7, #12]
 8008770:	2200      	movs	r2, #0
 8008772:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
    media_ptr -> fx_media_driver_boot_write_requests =  0;
 8008776:	68fb      	ldr	r3, [r7, #12]
 8008778:	2200      	movs	r2, #0
 800877a:	f8c3 21b8 	str.w	r2, [r3, #440]	; 0x1b8
    media_ptr -> fx_media_driver_release_sectors_requests =  0;
 800877e:	68fb      	ldr	r3, [r7, #12]
 8008780:	2200      	movs	r2, #0
 8008782:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
    media_ptr -> fx_media_driver_flush_requests =  0;
 8008786:	68fb      	ldr	r3, [r7, #12]
 8008788:	2200      	movs	r2, #0
 800878a:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_MEDIA_OPEN, media_ptr, media_driver, memory_ptr, memory_size, FX_TRACE_MEDIA_EVENTS, 0, 0)

    /* Initialize the supplied media I/O driver.  First, build the
       initialize driver request.  */
    media_ptr -> fx_media_driver_request =              FX_DRIVER_INIT;
 800878e:	68fb      	ldr	r3, [r7, #12]
 8008790:	2204      	movs	r2, #4
 8008792:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    media_ptr -> fx_media_driver_status =               FX_IO_ERROR;
 8008796:	68fb      	ldr	r3, [r7, #12]
 8008798:	2290      	movs	r2, #144	; 0x90
 800879a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    media_ptr -> fx_media_driver_info =                 driver_info_ptr;
 800879e:	68fb      	ldr	r3, [r7, #12]
 80087a0:	683a      	ldr	r2, [r7, #0]
 80087a2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    media_ptr -> fx_media_driver_write_protect =        FX_FALSE;
 80087a6:	68fb      	ldr	r3, [r7, #12]
 80087a8:	2200      	movs	r2, #0
 80087aa:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
    media_ptr -> fx_media_driver_free_sector_update =   FX_FALSE;
 80087ae:	68fb      	ldr	r3, [r7, #12]
 80087b0:	2200      	movs	r2, #0
 80087b2:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
    media_ptr -> fx_media_driver_data_sector_read =     FX_FALSE;
 80087b6:	68fb      	ldr	r3, [r7, #12]
 80087b8:	2200      	movs	r2, #0
 80087ba:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_INIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Call the specified I/O driver with the initialize request.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 80087be:	68fb      	ldr	r3, [r7, #12]
 80087c0:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 80087c4:	68f8      	ldr	r0, [r7, #12]
 80087c6:	4798      	blx	r3

    /* Determine if the I/O driver initialized successfully.  */
    if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 80087c8:	68fb      	ldr	r3, [r7, #12]
 80087ca:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80087ce:	2b00      	cmp	r3, #0
 80087d0:	d002      	beq.n	80087d8 <_fx_media_open+0x294>
    {

        /* Return the driver error status.  */
        return(FX_IO_ERROR);
 80087d2:	2390      	movs	r3, #144	; 0x90
 80087d4:	f000 bc22 	b.w	800901c <_fx_media_open+0xad8>
    }

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of driver boot read requests.  */
    media_ptr -> fx_media_driver_boot_read_requests++;
 80087d8:	68fb      	ldr	r3, [r7, #12]
 80087da:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
 80087de:	1c5a      	adds	r2, r3, #1
 80087e0:	68fb      	ldr	r3, [r7, #12]
 80087e2:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
#endif

    /* Read the boot sector from the device.  Build the read boot sector
       command.  */
    media_ptr -> fx_media_driver_request =          FX_DRIVER_BOOT_READ;
 80087e6:	68fb      	ldr	r3, [r7, #12]
 80087e8:	2205      	movs	r2, #5
 80087ea:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80087ee:	68fb      	ldr	r3, [r7, #12]
 80087f0:	2290      	movs	r2, #144	; 0x90
 80087f2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    media_ptr -> fx_media_driver_buffer =           memory_ptr;
 80087f6:	68fb      	ldr	r3, [r7, #12]
 80087f8:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80087fa:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    media_ptr -> fx_media_driver_sectors =          1;
 80087fe:	68fb      	ldr	r3, [r7, #12]
 8008800:	2201      	movs	r2, #1
 8008802:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    media_ptr -> fx_media_driver_sector_type =      FX_BOOT_SECTOR;
 8008806:	68fb      	ldr	r3, [r7, #12]
 8008808:	2201      	movs	r2, #1
 800880a:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_BOOT_READ, media_ptr, memory_ptr, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Invoke the driver to read the boot sector.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800880e:	68fb      	ldr	r3, [r7, #12]
 8008810:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8008814:	68f8      	ldr	r0, [r7, #12]
 8008816:	4798      	blx	r3

    /* Determine if the boot sector was read correctly. */
    if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 8008818:	68fb      	ldr	r3, [r7, #12]
 800881a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800881e:	2b00      	cmp	r3, #0
 8008820:	d016      	beq.n	8008850 <_fx_media_open+0x30c>
    {

        /* Build the "uninitialize" I/O driver request.  */
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8008822:	68fb      	ldr	r3, [r7, #12]
 8008824:	2208      	movs	r2, #8
 8008826:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800882a:	68fb      	ldr	r3, [r7, #12]
 800882c:	2290      	movs	r2, #144	; 0x90
 800882e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Call the specified I/O driver with the uninitialize request.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008832:	68fb      	ldr	r3, [r7, #12]
 8008834:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8008838:	68f8      	ldr	r0, [r7, #12]
 800883a:	4798      	blx	r3

        /* Return the boot sector error status.  */
        return(FX_BOOT_ERROR);
 800883c:	2301      	movs	r3, #1
 800883e:	e3ed      	b.n	800901c <_fx_media_open+0xad8>
 8008840:	20006c9c 	.word	0x20006c9c
 8008844:	20006ca0 	.word	0x20006ca0
 8008848:	20006ca4 	.word	0x20006ca4
 800884c:	20000034 	.word	0x20000034
    }

    /* Extract and validate the media parameters from the boot sector.  */
    if (_fx_media_boot_info_extract(media_ptr) != FX_SUCCESS)
 8008850:	68f8      	ldr	r0, [r7, #12]
 8008852:	f7ff fa15 	bl	8007c80 <_fx_media_boot_info_extract>
 8008856:	4603      	mov	r3, r0
 8008858:	2b00      	cmp	r3, #0
 800885a:	d00e      	beq.n	800887a <_fx_media_open+0x336>
    {

        /* Build the "uninitialize" I/O driver request.  */
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 800885c:	68fb      	ldr	r3, [r7, #12]
 800885e:	2208      	movs	r2, #8
 8008860:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 8008864:	68fb      	ldr	r3, [r7, #12]
 8008866:	2290      	movs	r2, #144	; 0x90
 8008868:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Call the specified I/O driver with the uninitialize request.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800886c:	68fb      	ldr	r3, [r7, #12]
 800886e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8008872:	68f8      	ldr	r0, [r7, #12]
 8008874:	4798      	blx	r3

        /* Return the invalid media error status.  */
        return(FX_MEDIA_INVALID);
 8008876:	2302      	movs	r3, #2
 8008878:	e3d0      	b.n	800901c <_fx_media_open+0xad8>
    }

    /* Pickup the additional info sector number. This will only be used in FAT32 situations.  */
    additional_info_sector =  _fx_utility_16_unsigned_read(&media_ptr -> fx_media_driver_buffer[48]);
 800887a:	68fb      	ldr	r3, [r7, #12]
 800887c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8008880:	3330      	adds	r3, #48	; 0x30
 8008882:	4618      	mov	r0, r3
 8008884:	f000 fd8c 	bl	80093a0 <_fx_utility_16_unsigned_read>
 8008888:	63f8      	str	r0, [r7, #60]	; 0x3c

    /* Is there at least one?  */
    if (memory_size < media_ptr -> fx_media_bytes_per_sector)
 800888a:	68fb      	ldr	r3, [r7, #12]
 800888c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800888e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8008890:	429a      	cmp	r2, r3
 8008892:	d20e      	bcs.n	80088b2 <_fx_media_open+0x36e>
    {

        /* Build the "uninitialize" I/O driver request.  */
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8008894:	68fb      	ldr	r3, [r7, #12]
 8008896:	2208      	movs	r2, #8
 8008898:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800889c:	68fb      	ldr	r3, [r7, #12]
 800889e:	2290      	movs	r2, #144	; 0x90
 80088a0:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Call the specified I/O driver with the uninitialize request.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 80088a4:	68fb      	ldr	r3, [r7, #12]
 80088a6:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 80088aa:	68f8      	ldr	r0, [r7, #12]
 80088ac:	4798      	blx	r3

        /* Error in the buffer size supplied by user.  */
        return(FX_BUFFER_ERROR);
 80088ae:	2321      	movs	r3, #33	; 0x21
 80088b0:	e3b4      	b.n	800901c <_fx_media_open+0xad8>
    }

#ifndef FX_DISABLE_CACHE
    /* Determine how many logical sectors can be cached with user's supplied
       buffer area - there must be at least enough for one sector!  */
    media_ptr -> fx_media_sector_cache_size =  memory_size / media_ptr -> fx_media_bytes_per_sector;
 80088b2:	68fb      	ldr	r3, [r7, #12]
 80088b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80088b6:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80088b8:	fbb2 f2f3 	udiv	r2, r2, r3
 80088bc:	68fb      	ldr	r3, [r7, #12]
 80088be:	615a      	str	r2, [r3, #20]
    /* If trace is enabled, register this object.  */
    FX_TRACE_OBJECT_REGISTER(FX_TRACE_OBJECT_TYPE_MEDIA, media_ptr, media_name, FX_MAX_FAT_CACHE, media_ptr -> fx_media_sector_cache_size)
    
    /* Adjust the internal cache to fit the fixed number of sector cache control blocks
       built into the media control block.  */
    if (media_ptr -> fx_media_sector_cache_size > FX_MAX_SECTOR_CACHE)
 80088c0:	68fb      	ldr	r3, [r7, #12]
 80088c2:	695b      	ldr	r3, [r3, #20]
 80088c4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80088c8:	d903      	bls.n	80088d2 <_fx_media_open+0x38e>
    {

        /* Adjust the number of cache sectors downward.  If this is insufficient,
           the FX_MAX_SECTOR_CACHE constant in FX_API.H must be changed and the FileX
           library must be rebuilt.  */
        media_ptr -> fx_media_sector_cache_size =  FX_MAX_SECTOR_CACHE;
 80088ca:	68fb      	ldr	r3, [r7, #12]
 80088cc:	f44f 7280 	mov.w	r2, #256	; 0x100
 80088d0:	615a      	str	r2, [r3, #20]
    }

    /* Otherwise, everything is okay.  Initialize the data structures for managing the
       logical sector cache.  */
    i =  (UINT)media_ptr -> fx_media_sector_cache_size;
 80088d2:	68fb      	ldr	r3, [r7, #12]
 80088d4:	695b      	ldr	r3, [r3, #20]
 80088d6:	64fb      	str	r3, [r7, #76]	; 0x4c
    cache_entry_ptr =  media_ptr -> fx_media_sector_cache;
 80088d8:	68fb      	ldr	r3, [r7, #12]
 80088da:	f503 634a 	add.w	r3, r3, #3232	; 0xca0
 80088de:	647b      	str	r3, [r7, #68]	; 0x44
    while (i--)
 80088e0:	e01c      	b.n	800891c <_fx_media_open+0x3d8>
    {

        /* Initialize each of the cache entries.  */
        cache_entry_ptr -> fx_cached_sector_memory_buffer =  (UCHAR *)memory_ptr;
 80088e2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80088e4:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80088e6:	601a      	str	r2, [r3, #0]
        cache_entry_ptr -> fx_cached_sector =                (~(ULONG64)0);
 80088e8:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80088ea:	f04f 32ff 	mov.w	r2, #4294967295
 80088ee:	f04f 33ff 	mov.w	r3, #4294967295
 80088f2:	e9c1 2302 	strd	r2, r3, [r1, #8]
        cache_entry_ptr -> fx_cached_sector_buffer_dirty =   FX_FALSE;
 80088f6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80088f8:	2200      	movs	r2, #0
 80088fa:	741a      	strb	r2, [r3, #16]
        cache_entry_ptr -> fx_cached_sector_valid =          FX_FALSE;
 80088fc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80088fe:	2200      	movs	r2, #0
 8008900:	745a      	strb	r2, [r3, #17]
        cache_entry_ptr -> fx_cached_sector_next_used =      cache_entry_ptr + 1;
 8008902:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008904:	f103 0218 	add.w	r2, r3, #24
 8008908:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800890a:	615a      	str	r2, [r3, #20]

        /* Move to the next cache sector entry.  */
        cache_entry_ptr++;
 800890c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800890e:	3318      	adds	r3, #24
 8008910:	647b      	str	r3, [r7, #68]	; 0x44

        /* Update the memory pointer to the next buffer slot.  */
        memory_ptr =  (VOID *)(((UCHAR *)memory_ptr) + media_ptr -> fx_media_bytes_per_sector);
 8008912:	68fb      	ldr	r3, [r7, #12]
 8008914:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008916:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8008918:	4413      	add	r3, r2
 800891a:	67bb      	str	r3, [r7, #120]	; 0x78
    while (i--)
 800891c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800891e:	1e5a      	subs	r2, r3, #1
 8008920:	64fa      	str	r2, [r7, #76]	; 0x4c
 8008922:	2b00      	cmp	r3, #0
 8008924:	d1dd      	bne.n	80088e2 <_fx_media_open+0x39e>
    }

    /* Backup to the last cache entry to set its next pointer to NULL.  */
    cache_entry_ptr--;
 8008926:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8008928:	3b18      	subs	r3, #24
 800892a:	647b      	str	r3, [r7, #68]	; 0x44
    cache_entry_ptr -> fx_cached_sector_next_used =  FX_NULL;
 800892c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800892e:	2200      	movs	r2, #0
 8008930:	615a      	str	r2, [r3, #20]

    /* Remember the last memory address used by the caching logic.  */
    media_ptr -> fx_media_sector_cache_end =  ((UCHAR *)memory_ptr) - 1;
 8008932:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8008934:	1e5a      	subs	r2, r3, #1
 8008936:	68fb      	ldr	r3, [r7, #12]
 8008938:	619a      	str	r2, [r3, #24]

    /* Setup the head pointer of the list.  */
    media_ptr -> fx_media_sector_cache_list_ptr =  media_ptr -> fx_media_sector_cache;
 800893a:	68fb      	ldr	r3, [r7, #12]
 800893c:	f503 624a 	add.w	r2, r3, #3232	; 0xca0
 8008940:	68fb      	ldr	r3, [r7, #12]
 8008942:	61da      	str	r2, [r3, #28]

    /* Setup the bit map that keeps track of the valid hashed cache logical sectors.  */
    media_ptr -> fx_media_sector_cache_hashed_sector_valid =  0;
 8008944:	68fb      	ldr	r3, [r7, #12]
 8008946:	2200      	movs	r2, #0
 8008948:	621a      	str	r2, [r3, #32]

    /* Clear the counter of the number of outstanding dirty sectors.  */
    media_ptr -> fx_media_sector_cache_dirty_count =  0;
 800894a:	68fb      	ldr	r3, [r7, #12]
 800894c:	2200      	movs	r2, #0
 800894e:	625a      	str	r2, [r3, #36]	; 0x24

    /* Determine if the logical sector cache should be managed by the hash function
       instead of the linear search. The cache must be a power of 2 that is between the
       minimum and maximum cache size.  */
    if ((media_ptr -> fx_media_sector_cache_size >= FX_SECTOR_CACHE_HASH_ENABLE) &&
 8008950:	68fb      	ldr	r3, [r7, #12]
 8008952:	695b      	ldr	r3, [r3, #20]
 8008954:	2b0f      	cmp	r3, #15
 8008956:	d91a      	bls.n	800898e <_fx_media_open+0x44a>
        ((media_ptr -> fx_media_sector_cache_size ^ (media_ptr -> fx_media_sector_cache_size - 1)) ==
 8008958:	68fb      	ldr	r3, [r7, #12]
 800895a:	695a      	ldr	r2, [r3, #20]
 800895c:	68fb      	ldr	r3, [r7, #12]
 800895e:	695b      	ldr	r3, [r3, #20]
 8008960:	3b01      	subs	r3, #1
 8008962:	405a      	eors	r2, r3
         (media_ptr -> fx_media_sector_cache_size | (media_ptr -> fx_media_sector_cache_size - 1))))
 8008964:	68fb      	ldr	r3, [r7, #12]
 8008966:	6959      	ldr	r1, [r3, #20]
 8008968:	68fb      	ldr	r3, [r7, #12]
 800896a:	695b      	ldr	r3, [r3, #20]
 800896c:	3b01      	subs	r3, #1
 800896e:	430b      	orrs	r3, r1
    if ((media_ptr -> fx_media_sector_cache_size >= FX_SECTOR_CACHE_HASH_ENABLE) &&
 8008970:	429a      	cmp	r2, r3
 8008972:	d10c      	bne.n	800898e <_fx_media_open+0x44a>
    {


        /* Set the logical sector cache hash flag. When this flag is set, the logical
           sector cache is accessed with a hash function instead of a linear search.  */
        media_ptr -> fx_media_sector_cache_hashed =  FX_TRUE;
 8008974:	68fb      	ldr	r3, [r7, #12]
 8008976:	2201      	movs	r2, #1
 8008978:	611a      	str	r2, [r3, #16]
        media_ptr -> fx_media_sector_cache_hash_mask =
            ((media_ptr -> fx_media_sector_cache_size / FX_SECTOR_CACHE_DEPTH) - 1);
 800897a:	68fb      	ldr	r3, [r7, #12]
 800897c:	695b      	ldr	r3, [r3, #20]
 800897e:	089b      	lsrs	r3, r3, #2
 8008980:	3b01      	subs	r3, #1
        media_ptr -> fx_media_sector_cache_hash_mask =
 8008982:	68fa      	ldr	r2, [r7, #12]
 8008984:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
 8008988:	f8c2 34a0 	str.w	r3, [r2, #1184]	; 0x4a0
 800898c:	e002      	b.n	8008994 <_fx_media_open+0x450>
    }
    else
    {

        /* Clear the logical sector cache flag.  */
        media_ptr -> fx_media_sector_cache_hashed =  FX_FALSE;
 800898e:	68fb      	ldr	r3, [r7, #12]
 8008990:	2200      	movs	r2, #0
 8008992:	611a      	str	r2, [r3, #16]
    media_ptr -> fx_media_memory_buffer = memory_ptr;
#endif /* FX_DISABLE_CACHE */

#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    /* Initialize the FAT cache entry array.  */
    for (i = 0; i < FX_MAX_FAT_CACHE; i++)
 8008994:	2300      	movs	r3, #0
 8008996:	64fb      	str	r3, [r7, #76]	; 0x4c
 8008998:	e023      	b.n	80089e2 <_fx_media_open+0x49e>
    {

        /* Clear entry in the FAT cache.  */
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 800899a:	68f9      	ldr	r1, [r7, #12]
 800899c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800899e:	4613      	mov	r3, r2
 80089a0:	005b      	lsls	r3, r3, #1
 80089a2:	4413      	add	r3, r2
 80089a4:	009b      	lsls	r3, r3, #2
 80089a6:	440b      	add	r3, r1
 80089a8:	f503 63eb 	add.w	r3, r3, #1880	; 0x758
 80089ac:	2200      	movs	r2, #0
 80089ae:	601a      	str	r2, [r3, #0]
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 80089b0:	68f9      	ldr	r1, [r7, #12]
 80089b2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80089b4:	4613      	mov	r3, r2
 80089b6:	005b      	lsls	r3, r3, #1
 80089b8:	4413      	add	r3, r2
 80089ba:	009b      	lsls	r3, r3, #2
 80089bc:	440b      	add	r3, r1
 80089be:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 80089c2:	2200      	movs	r2, #0
 80089c4:	601a      	str	r2, [r3, #0]
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 80089c6:	68f9      	ldr	r1, [r7, #12]
 80089c8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80089ca:	4613      	mov	r3, r2
 80089cc:	005b      	lsls	r3, r3, #1
 80089ce:	4413      	add	r3, r2
 80089d0:	009b      	lsls	r3, r3, #2
 80089d2:	440b      	add	r3, r1
 80089d4:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 80089d8:	2200      	movs	r2, #0
 80089da:	601a      	str	r2, [r3, #0]
    for (i = 0; i < FX_MAX_FAT_CACHE; i++)
 80089dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80089de:	3301      	adds	r3, #1
 80089e0:	64fb      	str	r3, [r7, #76]	; 0x4c
 80089e2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80089e4:	2b0f      	cmp	r3, #15
 80089e6:	d9d8      	bls.n	800899a <_fx_media_open+0x456>
    }

    /* Initialize the secondary FAT update map.  */
    for (i = 0; i < FX_FAT_MAP_SIZE; i++)
 80089e8:	2300      	movs	r3, #0
 80089ea:	64fb      	str	r3, [r7, #76]	; 0x4c
 80089ec:	e009      	b.n	8008a02 <_fx_media_open+0x4be>
    {

        /* Clear bit map entry for secondary FAT update.  */
        media_ptr -> fx_media_fat_secondary_update_map[i] =  0;
 80089ee:	68fa      	ldr	r2, [r7, #12]
 80089f0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80089f2:	4413      	add	r3, r2
 80089f4:	f603 0318 	addw	r3, r3, #2072	; 0x818
 80089f8:	2200      	movs	r2, #0
 80089fa:	701a      	strb	r2, [r3, #0]
    for (i = 0; i < FX_FAT_MAP_SIZE; i++)
 80089fc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80089fe:	3301      	adds	r3, #1
 8008a00:	64fb      	str	r3, [r7, #76]	; 0x4c
 8008a02:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008a04:	2b7f      	cmp	r3, #127	; 0x7f
 8008a06:	d9f2      	bls.n	80089ee <_fx_media_open+0x4aa>
    if (media_ptr -> fx_media_FAT_type != FX_exFAT)
    {
#endif /* FX_ENABLE_EXFAT */

        /* Root_sector_start has been computed */
        media_ptr -> fx_media_root_sector_start =  media_ptr -> fx_media_reserved_sectors +
 8008a08:	68fb      	ldr	r3, [r7, #12]
 8008a0a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
            (media_ptr -> fx_media_number_of_FATs *
 8008a0c:	68fb      	ldr	r3, [r7, #12]
 8008a0e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
             media_ptr -> fx_media_sectors_per_FAT);
 8008a10:	68f9      	ldr	r1, [r7, #12]
 8008a12:	6d89      	ldr	r1, [r1, #88]	; 0x58
            (media_ptr -> fx_media_number_of_FATs *
 8008a14:	fb01 f303 	mul.w	r3, r1, r3
        media_ptr -> fx_media_root_sector_start =  media_ptr -> fx_media_reserved_sectors +
 8008a18:	441a      	add	r2, r3
 8008a1a:	68fb      	ldr	r3, [r7, #12]
 8008a1c:	649a      	str	r2, [r3, #72]	; 0x48

        /* Calculate the number of directory sectors.  */
        media_ptr -> fx_media_root_sectors =
            ((media_ptr -> fx_media_root_directory_entries * FX_DIR_ENTRY_SIZE) +
 8008a1e:	68fb      	ldr	r3, [r7, #12]
 8008a20:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008a22:	015a      	lsls	r2, r3, #5
             media_ptr -> fx_media_bytes_per_sector - 1) /
 8008a24:	68fb      	ldr	r3, [r7, #12]
 8008a26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
            ((media_ptr -> fx_media_root_directory_entries * FX_DIR_ENTRY_SIZE) +
 8008a28:	4413      	add	r3, r2
             media_ptr -> fx_media_bytes_per_sector - 1) /
 8008a2a:	1e5a      	subs	r2, r3, #1
            media_ptr -> fx_media_bytes_per_sector;
 8008a2c:	68fb      	ldr	r3, [r7, #12]
 8008a2e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
             media_ptr -> fx_media_bytes_per_sector - 1) /
 8008a30:	fbb2 f2f3 	udiv	r2, r2, r3
        media_ptr -> fx_media_root_sectors =
 8008a34:	68fb      	ldr	r3, [r7, #12]
 8008a36:	64da      	str	r2, [r3, #76]	; 0x4c

        /* Calculate the starting data sector.  */
        media_ptr -> fx_media_data_sector_start =  media_ptr -> fx_media_root_sector_start +
 8008a38:	68fb      	ldr	r3, [r7, #12]
 8008a3a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
            media_ptr -> fx_media_root_sectors;
 8008a3c:	68fb      	ldr	r3, [r7, #12]
 8008a3e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
        media_ptr -> fx_media_data_sector_start =  media_ptr -> fx_media_root_sector_start +
 8008a40:	441a      	add	r2, r3
 8008a42:	68fb      	ldr	r3, [r7, #12]
 8008a44:	651a      	str	r2, [r3, #80]	; 0x50

        /* Calculate the total number of clusters.  */
        media_ptr -> fx_media_total_clusters =  (ULONG)((media_ptr -> fx_media_total_sectors - media_ptr -> fx_media_data_sector_start) /
 8008a46:	68fb      	ldr	r3, [r7, #12]
 8008a48:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	; 0x38
 8008a4c:	68f9      	ldr	r1, [r7, #12]
 8008a4e:	6d09      	ldr	r1, [r1, #80]	; 0x50
 8008a50:	2000      	movs	r0, #0
 8008a52:	460c      	mov	r4, r1
 8008a54:	4605      	mov	r5, r0
 8008a56:	ebb2 0804 	subs.w	r8, r2, r4
 8008a5a:	eb63 0905 	sbc.w	r9, r3, r5
                                                            media_ptr -> fx_media_sectors_per_cluster);
 8008a5e:	68fb      	ldr	r3, [r7, #12]
 8008a60:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008a62:	2200      	movs	r2, #0
 8008a64:	469a      	mov	sl, r3
 8008a66:	4693      	mov	fp, r2
        media_ptr -> fx_media_total_clusters =  (ULONG)((media_ptr -> fx_media_total_sectors - media_ptr -> fx_media_data_sector_start) /
 8008a68:	4652      	mov	r2, sl
 8008a6a:	465b      	mov	r3, fp
 8008a6c:	4640      	mov	r0, r8
 8008a6e:	4649      	mov	r1, r9
 8008a70:	f7f7 fcaa 	bl	80003c8 <__aeabi_uldivmod>
 8008a74:	4602      	mov	r2, r0
 8008a76:	460b      	mov	r3, r1
 8008a78:	68fb      	ldr	r3, [r7, #12]
 8008a7a:	641a      	str	r2, [r3, #64]	; 0x40

        /* Determine if a 12-bit FAT is in use.  */
        if (media_ptr -> fx_media_total_clusters < FX_12_BIT_FAT_SIZE)
 8008a7c:	68fb      	ldr	r3, [r7, #12]
 8008a7e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008a80:	f640 72f5 	movw	r2, #4085	; 0xff5
 8008a84:	4293      	cmp	r3, r2
 8008a86:	d819      	bhi.n	8008abc <_fx_media_open+0x578>
        {

            /* Yes, 12-bit FAT is present.  Set flag accordingly.  */
            media_ptr -> fx_media_12_bit_FAT = FX_TRUE;
 8008a88:	68fb      	ldr	r3, [r7, #12]
 8008a8a:	2201      	movs	r2, #1
 8008a8c:	661a      	str	r2, [r3, #96]	; 0x60
            media_ptr -> fx_media_32_bit_FAT = FX_FALSE;
 8008a8e:	68fb      	ldr	r3, [r7, #12]
 8008a90:	2200      	movs	r2, #0
 8008a92:	665a      	str	r2, [r3, #100]	; 0x64
#ifdef FX_ENABLE_EXFAT
            media_ptr -> fx_media_FAT_type = FX_FAT12;
#endif /* FX_ENABLE_EXFAT */

            /* No additional information sector in FAT12.  */
            media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 8008a94:	68fb      	ldr	r3, [r7, #12]
 8008a96:	2200      	movs	r2, #0
 8008a98:	669a      	str	r2, [r3, #104]	; 0x68

            /* Set FAT last and FAT reserved. */
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1;
 8008a9a:	68fb      	ldr	r3, [r7, #12]
 8008a9c:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8008aa0:	461a      	mov	r2, r3
 8008aa2:	f64f 73f0 	movw	r3, #65520	; 0xfff0
 8008aa6:	f8c2 34a8 	str.w	r3, [r2, #1192]	; 0x4a8
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2;
 8008aaa:	68fb      	ldr	r3, [r7, #12]
 8008aac:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8008ab0:	461a      	mov	r2, r3
 8008ab2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008ab6:	f8c2 34ac 	str.w	r3, [r2, #1196]	; 0x4ac
 8008aba:	e037      	b.n	8008b2c <_fx_media_open+0x5e8>
        }
        else if (media_ptr -> fx_media_total_clusters < FX_16_BIT_FAT_SIZE)
 8008abc:	68fb      	ldr	r3, [r7, #12]
 8008abe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008ac0:	f64f 72f4 	movw	r2, #65524	; 0xfff4
 8008ac4:	4293      	cmp	r3, r2
 8008ac6:	d819      	bhi.n	8008afc <_fx_media_open+0x5b8>
        {

            /* A 16-bit FAT is present.  Set flag accordingly.  */
            media_ptr -> fx_media_12_bit_FAT =  FX_FALSE;
 8008ac8:	68fb      	ldr	r3, [r7, #12]
 8008aca:	2200      	movs	r2, #0
 8008acc:	661a      	str	r2, [r3, #96]	; 0x60
            media_ptr -> fx_media_32_bit_FAT =  FX_FALSE;
 8008ace:	68fb      	ldr	r3, [r7, #12]
 8008ad0:	2200      	movs	r2, #0
 8008ad2:	665a      	str	r2, [r3, #100]	; 0x64
#ifdef FX_ENABLE_EXFAT
            media_ptr -> fx_media_FAT_type = FX_FAT16;
#endif /* FX_ENABLE_EXFAT */

            /* No additional information sector in FAT16.  */
            media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 8008ad4:	68fb      	ldr	r3, [r7, #12]
 8008ad6:	2200      	movs	r2, #0
 8008ad8:	669a      	str	r2, [r3, #104]	; 0x68

            /* Set FAT last and FAT reserved. */
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1;
 8008ada:	68fb      	ldr	r3, [r7, #12]
 8008adc:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8008ae0:	461a      	mov	r2, r3
 8008ae2:	f64f 73f0 	movw	r3, #65520	; 0xfff0
 8008ae6:	f8c2 34a8 	str.w	r3, [r2, #1192]	; 0x4a8
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2;
 8008aea:	68fb      	ldr	r3, [r7, #12]
 8008aec:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8008af0:	461a      	mov	r2, r3
 8008af2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8008af6:	f8c2 34ac 	str.w	r3, [r2, #1196]	; 0x4ac
 8008afa:	e017      	b.n	8008b2c <_fx_media_open+0x5e8>
        }
        else
        {

            /* Yes, a 32-bit FAT is present.  */
            media_ptr -> fx_media_12_bit_FAT =  FX_FALSE;
 8008afc:	68fb      	ldr	r3, [r7, #12]
 8008afe:	2200      	movs	r2, #0
 8008b00:	661a      	str	r2, [r3, #96]	; 0x60
            media_ptr -> fx_media_32_bit_FAT =  FX_TRUE;
 8008b02:	68fb      	ldr	r3, [r7, #12]
 8008b04:	2201      	movs	r2, #1
 8008b06:	665a      	str	r2, [r3, #100]	; 0x64
            media_ptr -> fx_media_FAT_type = FX_FAT32;
#endif /* FX_ENABLE_EXFAT */

            /* Save the additional information sector FAT32. This was read from the boot
               sector earlier in this routine. */
            media_ptr -> fx_media_FAT32_additional_info_sector =  additional_info_sector;
 8008b08:	68fb      	ldr	r3, [r7, #12]
 8008b0a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8008b0c:	669a      	str	r2, [r3, #104]	; 0x68

            /* Set FAT last and FAT reserved. */
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1_32;
 8008b0e:	68fb      	ldr	r3, [r7, #12]
 8008b10:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8008b14:	461a      	mov	r2, r3
 8008b16:	4b95      	ldr	r3, [pc, #596]	; (8008d6c <_fx_media_open+0x828>)
 8008b18:	f8c2 34a8 	str.w	r3, [r2, #1192]	; 0x4a8
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2_32;
 8008b1c:	68fb      	ldr	r3, [r7, #12]
 8008b1e:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8008b22:	461a      	mov	r2, r3
 8008b24:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
 8008b28:	f8c2 34ac 	str.w	r3, [r2, #1196]	; 0x4ac
       it is variable in FAT32.  */
#ifdef FX_ENABLE_EXFAT
    if (media_ptr -> fx_media_32_bit_FAT == FX_TRUE || 
        (media_ptr -> fx_media_FAT_type == FX_exFAT))
#else
    if (media_ptr -> fx_media_32_bit_FAT == FX_TRUE)
 8008b2c:	68fb      	ldr	r3, [r7, #12]
 8008b2e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8008b30:	2b01      	cmp	r3, #1
 8008b32:	d15f      	bne.n	8008bf4 <_fx_media_open+0x6b0>
        if (media_ptr -> fx_media_32_bit_FAT == FX_TRUE)
        {
#endif /* FX_ENABLE_EXFAT */

            /* Root First cluster starts from at least cluster 2, or higher. */
            if (media_ptr -> fx_media_root_cluster_32 < FX_FAT_ENTRY_START)
 8008b34:	68fb      	ldr	r3, [r7, #12]
 8008b36:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008b38:	2b01      	cmp	r3, #1
 8008b3a:	d801      	bhi.n	8008b40 <_fx_media_open+0x5fc>
            {
                return(FX_MEDIA_INVALID);
 8008b3c:	2302      	movs	r3, #2
 8008b3e:	e26d      	b.n	800901c <_fx_media_open+0xad8>
            }

            /* Calculate logical number of root dir sector.  */
            media_ptr -> fx_media_root_sector_start = media_ptr -> fx_media_data_sector_start +
 8008b40:	68fb      	ldr	r3, [r7, #12]
 8008b42:	6d1a      	ldr	r2, [r3, #80]	; 0x50
                (media_ptr -> fx_media_root_cluster_32 - FX_FAT_ENTRY_START) *
 8008b44:	68fb      	ldr	r3, [r7, #12]
 8008b46:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008b48:	3b02      	subs	r3, #2
                media_ptr -> fx_media_sectors_per_cluster;
 8008b4a:	68f9      	ldr	r1, [r7, #12]
 8008b4c:	6d49      	ldr	r1, [r1, #84]	; 0x54
                (media_ptr -> fx_media_root_cluster_32 - FX_FAT_ENTRY_START) *
 8008b4e:	fb01 f303 	mul.w	r3, r1, r3
            media_ptr -> fx_media_root_sector_start = media_ptr -> fx_media_data_sector_start +
 8008b52:	441a      	add	r2, r3
 8008b54:	68fb      	ldr	r3, [r7, #12]
 8008b56:	649a      	str	r2, [r3, #72]	; 0x48
#ifdef FX_ENABLE_EXFAT
        }
#endif /* FX_ENABLE_EXFAT */

        /* Calculate maximum possible value for fx_media_root_directory_entries */
        i = 0;
 8008b58:	2300      	movs	r3, #0
 8008b5a:	64fb      	str	r3, [r7, #76]	; 0x4c
        for (cluster_number = media_ptr -> fx_media_root_cluster_32;;)
 8008b5c:	68fb      	ldr	r3, [r7, #12]
 8008b5e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008b60:	657b      	str	r3, [r7, #84]	; 0x54
        {

            status =  _fx_utility_FAT_entry_read(media_ptr, cluster_number, &FAT_entry);
 8008b62:	f107 0310 	add.w	r3, r7, #16
 8008b66:	461a      	mov	r2, r3
 8008b68:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8008b6a:	68f8      	ldr	r0, [r7, #12]
 8008b6c:	f000 fc7e 	bl	800946c <_fx_utility_FAT_entry_read>
 8008b70:	63b8      	str	r0, [r7, #56]	; 0x38
            i++;
 8008b72:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008b74:	3301      	adds	r3, #1
 8008b76:	64fb      	str	r3, [r7, #76]	; 0x4c
            /* Determine if the read was successful.  */
            if (status != FX_SUCCESS)
 8008b78:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008b7a:	2b00      	cmp	r3, #0
 8008b7c:	d00e      	beq.n	8008b9c <_fx_media_open+0x658>
            {

                /* Build the "uninitialize" I/O driver request.  */
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8008b7e:	68fb      	ldr	r3, [r7, #12]
 8008b80:	2208      	movs	r2, #8
 8008b82:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 8008b86:	68fb      	ldr	r3, [r7, #12]
 8008b88:	2290      	movs	r2, #144	; 0x90
 8008b8a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Call the specified I/O driver with the uninitialize request.  */
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008b8e:	68fb      	ldr	r3, [r7, #12]
 8008b90:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8008b94:	68f8      	ldr	r0, [r7, #12]
 8008b96:	4798      	blx	r3

                return(FX_FAT_READ_ERROR);
 8008b98:	2303      	movs	r3, #3
 8008b9a:	e23f      	b.n	800901c <_fx_media_open+0xad8>
            }

            if ((cluster_number == FAT_entry) || (i > media_ptr -> fx_media_total_clusters))
 8008b9c:	693b      	ldr	r3, [r7, #16]
 8008b9e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8008ba0:	429a      	cmp	r2, r3
 8008ba2:	d004      	beq.n	8008bae <_fx_media_open+0x66a>
 8008ba4:	68fb      	ldr	r3, [r7, #12]
 8008ba6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008ba8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008baa:	429a      	cmp	r2, r3
 8008bac:	d90e      	bls.n	8008bcc <_fx_media_open+0x688>
            {

                /* Build the "uninitialize" I/O driver request.  */
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8008bae:	68fb      	ldr	r3, [r7, #12]
 8008bb0:	2208      	movs	r2, #8
 8008bb2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 8008bb6:	68fb      	ldr	r3, [r7, #12]
 8008bb8:	2290      	movs	r2, #144	; 0x90
 8008bba:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Call the specified I/O driver with the uninitialize request.  */
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008bbe:	68fb      	ldr	r3, [r7, #12]
 8008bc0:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8008bc4:	68f8      	ldr	r0, [r7, #12]
 8008bc6:	4798      	blx	r3

                return(FX_FAT_READ_ERROR);
 8008bc8:	2303      	movs	r3, #3
 8008bca:	e227      	b.n	800901c <_fx_media_open+0xad8>
            }
            if (FAT_entry >= FX_RESERVED_1_32)
 8008bcc:	693b      	ldr	r3, [r7, #16]
 8008bce:	4a68      	ldr	r2, [pc, #416]	; (8008d70 <_fx_media_open+0x82c>)
 8008bd0:	4293      	cmp	r3, r2
 8008bd2:	d802      	bhi.n	8008bda <_fx_media_open+0x696>
            {
                break;
            }
            cluster_number = FAT_entry;
 8008bd4:	693b      	ldr	r3, [r7, #16]
 8008bd6:	657b      	str	r3, [r7, #84]	; 0x54
            status =  _fx_utility_FAT_entry_read(media_ptr, cluster_number, &FAT_entry);
 8008bd8:	e7c3      	b.n	8008b62 <_fx_media_open+0x61e>
                break;
 8008bda:	bf00      	nop
        }

        /* Calculate the number of directory entries.  */
        media_ptr -> fx_media_root_directory_entries =  (i * media_ptr -> fx_media_sectors_per_cluster *
 8008bdc:	68fb      	ldr	r3, [r7, #12]
 8008bde:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008be0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008be2:	fb02 f303 	mul.w	r3, r2, r3
                                                         media_ptr -> fx_media_bytes_per_sector) / FX_DIR_ENTRY_SIZE;
 8008be6:	68fa      	ldr	r2, [r7, #12]
 8008be8:	6a92      	ldr	r2, [r2, #40]	; 0x28
        media_ptr -> fx_media_root_directory_entries =  (i * media_ptr -> fx_media_sectors_per_cluster *
 8008bea:	fb02 f303 	mul.w	r3, r2, r3
                                                         media_ptr -> fx_media_bytes_per_sector) / FX_DIR_ENTRY_SIZE;
 8008bee:	095a      	lsrs	r2, r3, #5
        media_ptr -> fx_media_root_directory_entries =  (i * media_ptr -> fx_media_sectors_per_cluster *
 8008bf0:	68fb      	ldr	r3, [r7, #12]
 8008bf2:	679a      	str	r2, [r3, #120]	; 0x78
    }

#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    /* Calculate the number of available clusters.  */
    media_ptr -> fx_media_available_clusters =  0;
 8008bf4:	68fb      	ldr	r3, [r7, #12]
 8008bf6:	2200      	movs	r2, #0
 8008bf8:	67da      	str	r2, [r3, #124]	; 0x7c

    /* Set the cluster search start to an invalid value.  */
    media_ptr -> fx_media_cluster_search_start =  0;
 8008bfa:	68fb      	ldr	r3, [r7, #12]
 8008bfc:	2200      	movs	r2, #0
 8008bfe:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#endif /* FX_DISABLE_FORCE_MEMORY_OPERATION */

    /* Determine if there is 32-bit FAT additional information sector. */
    if (media_ptr -> fx_media_FAT32_additional_info_sector)
 8008c02:	68fb      	ldr	r3, [r7, #12]
 8008c04:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8008c06:	2b00      	cmp	r3, #0
 8008c08:	f000 808e 	beq.w	8008d28 <_fx_media_open+0x7e4>
        /* Yes, read the FAT32 additional information sector to get the available cluster count and
           the hint for the first available cluster.  */

#ifndef FX_DISABLE_CACHE
        /* Setup a pointer to the first cached entry's buffer.  */
        buffer_ptr =  (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_memory_buffer;
 8008c0c:	68fb      	ldr	r3, [r7, #12]
 8008c0e:	69db      	ldr	r3, [r3, #28]
 8008c10:	681b      	ldr	r3, [r3, #0]
 8008c12:	637b      	str	r3, [r7, #52]	; 0x34

        /* Invalidate this cache entry.  */
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector =  (~((ULONG64) 0));
 8008c14:	68fb      	ldr	r3, [r7, #12]
 8008c16:	69d9      	ldr	r1, [r3, #28]
 8008c18:	f04f 32ff 	mov.w	r2, #4294967295
 8008c1c:	f04f 33ff 	mov.w	r3, #4294967295
 8008c20:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_valid =  FX_FALSE;
 8008c24:	68fb      	ldr	r3, [r7, #12]
 8008c26:	69db      	ldr	r3, [r3, #28]
 8008c28:	2200      	movs	r2, #0
 8008c2a:	745a      	strb	r2, [r3, #17]
        buffer_ptr =  media_ptr -> fx_media_memory_buffer;
        media_ptr -> fx_media_memory_buffer_sector = (ULONG64)-1;
#endif /* FX_DISABLE_CACHE */

        /* Read the FAT32 additional information sector from the device.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 8008c2c:	68fb      	ldr	r3, [r7, #12]
 8008c2e:	2200      	movs	r2, #0
 8008c30:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8008c34:	68fb      	ldr	r3, [r7, #12]
 8008c36:	2290      	movs	r2, #144	; 0x90
 8008c38:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 8008c3c:	68fb      	ldr	r3, [r7, #12]
 8008c3e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008c40:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 8008c44:	68fb      	ldr	r3, [r7, #12]
 8008c46:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 8008c48:	68fb      	ldr	r3, [r7, #12]
 8008c4a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
        media_ptr -> fx_media_driver_sectors =          1;
 8008c4e:	68fb      	ldr	r3, [r7, #12]
 8008c50:	2201      	movs	r2, #1
 8008c52:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 8008c56:	68fb      	ldr	r3, [r7, #12]
 8008c58:	2203      	movs	r2, #3
 8008c5a:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver read sector(s) requests.  */
        media_ptr -> fx_media_driver_read_requests++;
 8008c5e:	68fb      	ldr	r3, [r7, #12]
 8008c60:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 8008c64:	1c5a      	adds	r2, r3, #1
 8008c66:	68fb      	ldr	r3, [r7, #12]
 8008c68:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, media_ptr -> fx_media_FAT32_additional_info_sector, 1, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to read the FAT32 additional information sector.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008c6c:	68fb      	ldr	r3, [r7, #12]
 8008c6e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8008c72:	68f8      	ldr	r0, [r7, #12]
 8008c74:	4798      	blx	r3

        /* Determine if the FAT32 sector was read correctly. */
        if (media_ptr -> fx_media_driver_status == FX_SUCCESS)
 8008c76:	68fb      	ldr	r3, [r7, #12]
 8008c78:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8008c7c:	2b00      	cmp	r3, #0
 8008c7e:	d150      	bne.n	8008d22 <_fx_media_open+0x7de>
        {

            /* Yes, setup a pointer into the FAT32 additional information sector.  */
            buffer_ptr =  media_ptr -> fx_media_driver_buffer;
 8008c80:	68fb      	ldr	r3, [r7, #12]
 8008c82:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8008c86:	637b      	str	r3, [r7, #52]	; 0x34

            /* Pickup the first signature long word.  */
            signature =  _fx_utility_32_unsigned_read(&buffer_ptr[0]);
 8008c88:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8008c8a:	f000 fbb1 	bl	80093f0 <_fx_utility_32_unsigned_read>
 8008c8e:	6338      	str	r0, [r7, #48]	; 0x30

            /* Determine if the signature is correct.  */
            if (signature == 0x41615252)
 8008c90:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008c92:	4a38      	ldr	r2, [pc, #224]	; (8008d74 <_fx_media_open+0x830>)
 8008c94:	4293      	cmp	r3, r2
 8008c96:	d140      	bne.n	8008d1a <_fx_media_open+0x7d6>
            {

                /* Yes, the first signature is correct, now pickup the next signature.  */
                signature =  _fx_utility_32_unsigned_read(&buffer_ptr[484]);
 8008c98:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008c9a:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
 8008c9e:	4618      	mov	r0, r3
 8008ca0:	f000 fba6 	bl	80093f0 <_fx_utility_32_unsigned_read>
 8008ca4:	6338      	str	r0, [r7, #48]	; 0x30

                /* Determine if this signature is correct.  */
                if (signature == 0x61417272)
 8008ca6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8008ca8:	4a33      	ldr	r2, [pc, #204]	; (8008d78 <_fx_media_open+0x834>)
 8008caa:	4293      	cmp	r3, r2
 8008cac:	d131      	bne.n	8008d12 <_fx_media_open+0x7ce>
                {

                    /* Yes, we have a good FAT32 additional information sector.  */

                    /* Pickup the current available cluster count on the media.  */
                    media_ptr -> fx_media_available_clusters =  _fx_utility_32_unsigned_read(&buffer_ptr[488]);
 8008cae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008cb0:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
 8008cb4:	4618      	mov	r0, r3
 8008cb6:	f000 fb9b 	bl	80093f0 <_fx_utility_32_unsigned_read>
 8008cba:	4602      	mov	r2, r0
 8008cbc:	68fb      	ldr	r3, [r7, #12]
 8008cbe:	67da      	str	r2, [r3, #124]	; 0x7c

                    /* Initialize the last reported available cluster count to the same value.  */
                    media_ptr -> fx_media_FAT32_additional_info_last_available =  media_ptr -> fx_media_available_clusters;
 8008cc0:	68fb      	ldr	r3, [r7, #12]
 8008cc2:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 8008cc4:	68fb      	ldr	r3, [r7, #12]
 8008cc6:	66da      	str	r2, [r3, #108]	; 0x6c

                    /* Pickup the hint for the starting free cluster search.  */
                    media_ptr -> fx_media_cluster_search_start =  _fx_utility_32_unsigned_read(&buffer_ptr[492]);
 8008cc8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008cca:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
 8008cce:	4618      	mov	r0, r3
 8008cd0:	f000 fb8e 	bl	80093f0 <_fx_utility_32_unsigned_read>
 8008cd4:	4602      	mov	r2, r0
 8008cd6:	68fb      	ldr	r3, [r7, #12]
 8008cd8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

                    /* Perform a quick sanity check on the available cluster count and the starting free
                       cluster search.  */
                    if ((media_ptr -> fx_media_available_clusters > media_ptr -> fx_media_total_clusters) ||
 8008cdc:	68fb      	ldr	r3, [r7, #12]
 8008cde:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 8008ce0:	68fb      	ldr	r3, [r7, #12]
 8008ce2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008ce4:	429a      	cmp	r2, r3
 8008ce6:	d80c      	bhi.n	8008d02 <_fx_media_open+0x7be>
                        (media_ptr -> fx_media_cluster_search_start > media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START) ||
 8008ce8:	68fb      	ldr	r3, [r7, #12]
 8008cea:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8008cee:	68fb      	ldr	r3, [r7, #12]
 8008cf0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008cf2:	3302      	adds	r3, #2
                    if ((media_ptr -> fx_media_available_clusters > media_ptr -> fx_media_total_clusters) ||
 8008cf4:	429a      	cmp	r2, r3
 8008cf6:	d804      	bhi.n	8008d02 <_fx_media_open+0x7be>
                        (media_ptr -> fx_media_cluster_search_start < FX_FAT_ENTRY_START))
 8008cf8:	68fb      	ldr	r3, [r7, #12]
 8008cfa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
                        (media_ptr -> fx_media_cluster_search_start > media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START) ||
 8008cfe:	2b01      	cmp	r3, #1
 8008d00:	d812      	bhi.n	8008d28 <_fx_media_open+0x7e4>
                    {

                        /* Something is wrong, clear the available cluster count and search so the regular processing
                           is used.  */
                        media_ptr -> fx_media_available_clusters =    0;
 8008d02:	68fb      	ldr	r3, [r7, #12]
 8008d04:	2200      	movs	r2, #0
 8008d06:	67da      	str	r2, [r3, #124]	; 0x7c
                        media_ptr -> fx_media_cluster_search_start =  0;
 8008d08:	68fb      	ldr	r3, [r7, #12]
 8008d0a:	2200      	movs	r2, #0
 8008d0c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
 8008d10:	e00a      	b.n	8008d28 <_fx_media_open+0x7e4>
                }
                else
                {

                    /* Signature is bad, invalidate the additional info sector.  */
                    media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 8008d12:	68fb      	ldr	r3, [r7, #12]
 8008d14:	2200      	movs	r2, #0
 8008d16:	669a      	str	r2, [r3, #104]	; 0x68
 8008d18:	e006      	b.n	8008d28 <_fx_media_open+0x7e4>
            }
            else
            {

                /* Signature is bad, invalidate the additional info sector.  */
                media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 8008d1a:	68fb      	ldr	r3, [r7, #12]
 8008d1c:	2200      	movs	r2, #0
 8008d1e:	669a      	str	r2, [r3, #104]	; 0x68
 8008d20:	e002      	b.n	8008d28 <_fx_media_open+0x7e4>
        }
        else
        {

            /* IO error trying to read additional information sector, invalidate the additional info sector.  */
            media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 8008d22:	68fb      	ldr	r3, [r7, #12]
 8008d24:	2200      	movs	r2, #0
 8008d26:	669a      	str	r2, [r3, #104]	; 0x68

    /* Search the media to find the first available cluster as well as the total
       available clusters.  */

    /* Determine what type of FAT is present.  */
    if (media_ptr -> fx_media_12_bit_FAT)
 8008d28:	68fb      	ldr	r3, [r7, #12]
 8008d2a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8008d2c:	2b00      	cmp	r3, #0
 8008d2e:	d040      	beq.n	8008db2 <_fx_media_open+0x86e>

        /* A 12-bit FAT is present.  Utilize the FAT entry read utility to pickup
           each FAT entry's contents.  */

        /* Loop to read each cluster entry in the first FAT.  */
        for (cluster_number =  FX_FAT_ENTRY_START;
 8008d30:	2302      	movs	r3, #2
 8008d32:	657b      	str	r3, [r7, #84]	; 0x54
 8008d34:	e036      	b.n	8008da4 <_fx_media_open+0x860>
             cluster_number < (media_ptr -> fx_media_total_clusters) + FX_FAT_ENTRY_START;
             cluster_number++)
        {

            /* Read a FAT entry.  */
            status =  _fx_utility_FAT_entry_read(media_ptr, cluster_number, &FAT_entry);
 8008d36:	f107 0310 	add.w	r3, r7, #16
 8008d3a:	461a      	mov	r2, r3
 8008d3c:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8008d3e:	68f8      	ldr	r0, [r7, #12]
 8008d40:	f000 fb94 	bl	800946c <_fx_utility_FAT_entry_read>
 8008d44:	63b8      	str	r0, [r7, #56]	; 0x38

            /* Determine if the read was successful.  */
            if (status != FX_SUCCESS)
 8008d46:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008d48:	2b00      	cmp	r3, #0
 8008d4a:	d017      	beq.n	8008d7c <_fx_media_open+0x838>
            {

                /* Build the "uninitialize" I/O driver request.  */
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8008d4c:	68fb      	ldr	r3, [r7, #12]
 8008d4e:	2208      	movs	r2, #8
 8008d50:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 8008d54:	68fb      	ldr	r3, [r7, #12]
 8008d56:	2290      	movs	r2, #144	; 0x90
 8008d58:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Call the specified I/O driver with the uninitialize request.  */
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008d5c:	68fb      	ldr	r3, [r7, #12]
 8008d5e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8008d62:	68f8      	ldr	r0, [r7, #12]
 8008d64:	4798      	blx	r3

                return(FX_FAT_READ_ERROR);
 8008d66:	2303      	movs	r3, #3
 8008d68:	e158      	b.n	800901c <_fx_media_open+0xad8>
 8008d6a:	bf00      	nop
 8008d6c:	0ffffff0 	.word	0x0ffffff0
 8008d70:	0fffffef 	.word	0x0fffffef
 8008d74:	41615252 	.word	0x41615252
 8008d78:	61417272 	.word	0x61417272
            }

            /* Now determine if the FAT entry is available.  */
            if (FAT_entry == FX_FREE_CLUSTER)
 8008d7c:	693b      	ldr	r3, [r7, #16]
 8008d7e:	2b00      	cmp	r3, #0
 8008d80:	d10d      	bne.n	8008d9e <_fx_media_open+0x85a>
            {

                /* Increment the number of available clusters.  */
                media_ptr -> fx_media_available_clusters++;
 8008d82:	68fb      	ldr	r3, [r7, #12]
 8008d84:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008d86:	1c5a      	adds	r2, r3, #1
 8008d88:	68fb      	ldr	r3, [r7, #12]
 8008d8a:	67da      	str	r2, [r3, #124]	; 0x7c

                /* Determine if the starting free cluster has been found yet.  */
                if (media_ptr -> fx_media_cluster_search_start == 0)
 8008d8c:	68fb      	ldr	r3, [r7, #12]
 8008d8e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008d92:	2b00      	cmp	r3, #0
 8008d94:	d103      	bne.n	8008d9e <_fx_media_open+0x85a>
                {

                    /* Remember the first free cluster to start further searches from.  */
                    media_ptr -> fx_media_cluster_search_start =  cluster_number;
 8008d96:	68fb      	ldr	r3, [r7, #12]
 8008d98:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8008d9a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
             cluster_number++)
 8008d9e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008da0:	3301      	adds	r3, #1
 8008da2:	657b      	str	r3, [r7, #84]	; 0x54
             cluster_number < (media_ptr -> fx_media_total_clusters) + FX_FAT_ENTRY_START;
 8008da4:	68fb      	ldr	r3, [r7, #12]
 8008da6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008da8:	3302      	adds	r3, #2
 8008daa:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8008dac:	429a      	cmp	r2, r3
 8008dae:	d3c2      	bcc.n	8008d36 <_fx_media_open+0x7f2>
 8008db0:	e0b4      	b.n	8008f1c <_fx_media_open+0x9d8>
    }
#ifdef FX_ENABLE_EXFAT
    else if ((media_ptr -> fx_media_available_clusters == 0)
             && (media_ptr -> fx_media_FAT_type != FX_exFAT))
#else
    else if (media_ptr -> fx_media_available_clusters == 0)
 8008db2:	68fb      	ldr	r3, [r7, #12]
 8008db4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008db6:	2b00      	cmp	r3, #0
 8008db8:	f040 80b0 	bne.w	8008f1c <_fx_media_open+0x9d8>
        /* A 16 or 32-bit FAT is present. Read directly into the logical sector
           cache memory to optimize I/O on larger devices. Since we are looking for
           values of zero, endian issues are not important.  */

        /* Invalidate the current logical sector cache.  */
        _fx_utility_logical_sector_flush(media_ptr, ((ULONG64) 1), (ULONG64) (media_ptr -> fx_media_total_sectors), FX_TRUE);
 8008dbc:	68fb      	ldr	r3, [r7, #12]
 8008dbe:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	; 0x38
 8008dc2:	2101      	movs	r1, #1
 8008dc4:	9102      	str	r1, [sp, #8]
 8008dc6:	e9cd 2300 	strd	r2, r3, [sp]
 8008dca:	f04f 0201 	mov.w	r2, #1
 8008dce:	f04f 0300 	mov.w	r3, #0
 8008dd2:	68f8      	ldr	r0, [r7, #12]
 8008dd4:	f001 fb8e 	bl	800a4f4 <_fx_utility_logical_sector_flush>

        /* Reset the memory pointer.  */
        media_ptr -> fx_media_memory_buffer =  original_memory_ptr;
 8008dd8:	68fb      	ldr	r3, [r7, #12]
 8008dda:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8008ddc:	609a      	str	r2, [r3, #8]

        /* Loop through all FAT sectors in the primary FAT.  The first two entries are
           examined in this loop, but they are always unavailable.  */
        cluster_number =  0;
 8008dde:	2300      	movs	r3, #0
 8008de0:	657b      	str	r3, [r7, #84]	; 0x54
#ifndef FX_DISABLE_CACHE
        for (i = 0; i < media_ptr -> fx_media_sectors_per_FAT; i = i + media_ptr -> fx_media_sector_cache_size)
 8008de2:	2300      	movs	r3, #0
 8008de4:	64fb      	str	r3, [r7, #76]	; 0x4c
 8008de6:	e093      	b.n	8008f10 <_fx_media_open+0x9cc>
        {

            /* Calculate the starting next FAT sector.  */
            FAT_sector =  media_ptr -> fx_media_reserved_sectors + i;
 8008de8:	68fb      	ldr	r3, [r7, #12]
 8008dea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008dec:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008dee:	4413      	add	r3, r2
 8008df0:	62fb      	str	r3, [r7, #44]	; 0x2c

            /* Calculate how many sectors to read.  */
            FAT_read_sectors =  media_ptr -> fx_media_sectors_per_FAT - i;
 8008df2:	68fb      	ldr	r3, [r7, #12]
 8008df4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8008df6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008df8:	1ad3      	subs	r3, r2, r3
 8008dfa:	653b      	str	r3, [r7, #80]	; 0x50

            /* Determine if there is not enough memory to read the remaining FAT sectors.  */
            if (FAT_read_sectors > media_ptr -> fx_media_sector_cache_size)
 8008dfc:	68fb      	ldr	r3, [r7, #12]
 8008dfe:	695b      	ldr	r3, [r3, #20]
 8008e00:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8008e02:	429a      	cmp	r2, r3
 8008e04:	d902      	bls.n	8008e0c <_fx_media_open+0x8c8>
            {
                FAT_read_sectors =  media_ptr -> fx_media_sector_cache_size;
 8008e06:	68fb      	ldr	r3, [r7, #12]
 8008e08:	695b      	ldr	r3, [r3, #20]
 8008e0a:	653b      	str	r3, [r7, #80]	; 0x50
            /* Calculate how many sectors to read.  */
            FAT_read_sectors =  1;
#endif /* FX_DISABLE_CACHE */

            /* Read the FAT sectors directly from the driver.  */
            media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 8008e0c:	68fb      	ldr	r3, [r7, #12]
 8008e0e:	2200      	movs	r2, #0
 8008e10:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8008e14:	68fb      	ldr	r3, [r7, #12]
 8008e16:	2290      	movs	r2, #144	; 0x90
 8008e18:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            media_ptr -> fx_media_driver_buffer =           media_ptr -> fx_media_memory_buffer;
 8008e1c:	68fb      	ldr	r3, [r7, #12]
 8008e1e:	689a      	ldr	r2, [r3, #8]
 8008e20:	68fb      	ldr	r3, [r7, #12]
 8008e22:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
            media_ptr -> fx_media_driver_logical_sector =   FAT_sector;
 8008e26:	68fb      	ldr	r3, [r7, #12]
 8008e28:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8008e2a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
            media_ptr -> fx_media_driver_sectors =          FAT_read_sectors;
 8008e2e:	68fb      	ldr	r3, [r7, #12]
 8008e30:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8008e32:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            media_ptr -> fx_media_driver_sector_type =      FX_FAT_SECTOR;
 8008e36:	68fb      	ldr	r3, [r7, #12]
 8008e38:	2202      	movs	r2, #2
 8008e3a:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

            /* If trace is enabled, insert this event into the trace buffer.  */
            FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, FAT_sector, FAT_read_sectors, media_ptr -> fx_media_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

            /* Invoke the driver to read the FAT sectors.  */
            (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008e3e:	68fb      	ldr	r3, [r7, #12]
 8008e40:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8008e44:	68f8      	ldr	r0, [r7, #12]
 8008e46:	4798      	blx	r3

            /* Determine if the read was successful.  */
            if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 8008e48:	68fb      	ldr	r3, [r7, #12]
 8008e4a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8008e4e:	2b00      	cmp	r3, #0
 8008e50:	d00e      	beq.n	8008e70 <_fx_media_open+0x92c>
            {

                /* Build the "uninitialize" I/O driver request.  */
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8008e52:	68fb      	ldr	r3, [r7, #12]
 8008e54:	2208      	movs	r2, #8
 8008e56:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 8008e5a:	68fb      	ldr	r3, [r7, #12]
 8008e5c:	2290      	movs	r2, #144	; 0x90
 8008e5e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

                /* If trace is enabled, insert this event into the trace buffer.  */
                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                /* Call the specified I/O driver with the uninitialize request.  */
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008e62:	68fb      	ldr	r3, [r7, #12]
 8008e64:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8008e68:	68f8      	ldr	r0, [r7, #12]
 8008e6a:	4798      	blx	r3

                return(FX_FAT_READ_ERROR);
 8008e6c:	2303      	movs	r3, #3
 8008e6e:	e0d5      	b.n	800901c <_fx_media_open+0xad8>
            }

            /* Calculate the number of bytes in the buffer.  */
            bytes_in_buffer =  (media_ptr -> fx_media_bytes_per_sector * FAT_read_sectors);
 8008e70:	68fb      	ldr	r3, [r7, #12]
 8008e72:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8008e74:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008e76:	fb02 f303 	mul.w	r3, r2, r3
 8008e7a:	62bb      	str	r3, [r7, #40]	; 0x28

            /* Walk through the sector cache memory to search for available clusters and the first
               available if not already found.  */
            for (j = 0; j < bytes_in_buffer;)
 8008e7c:	2300      	movs	r3, #0
 8008e7e:	64bb      	str	r3, [r7, #72]	; 0x48
 8008e80:	e03d      	b.n	8008efe <_fx_media_open+0x9ba>
            {

                /* Check for a 32-bit FAT.  */
                if (media_ptr -> fx_media_32_bit_FAT)
 8008e82:	68fb      	ldr	r3, [r7, #12]
 8008e84:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8008e86:	2b00      	cmp	r3, #0
 8008e88:	d009      	beq.n	8008e9e <_fx_media_open+0x95a>
                {

                    /* Pickup 32-bit FAT entry.  */
                    FAT_entry =  *((ULONG *)&(media_ptr -> fx_media_memory_buffer[j]));
 8008e8a:	68fb      	ldr	r3, [r7, #12]
 8008e8c:	689a      	ldr	r2, [r3, #8]
 8008e8e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8008e90:	4413      	add	r3, r2
 8008e92:	681b      	ldr	r3, [r3, #0]
 8008e94:	613b      	str	r3, [r7, #16]

                    /* Advance to next FAT entry.  */
                    j = j + 4;
 8008e96:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8008e98:	3304      	adds	r3, #4
 8008e9a:	64bb      	str	r3, [r7, #72]	; 0x48
 8008e9c:	e011      	b.n	8008ec2 <_fx_media_open+0x97e>
                }
                else
                {

                    /* Process a 16-bit FAT entry.  */
                    FAT_entry =  (((ULONG)(media_ptr -> fx_media_memory_buffer[j])) & 0xFF) |
 8008e9e:	68fb      	ldr	r3, [r7, #12]
 8008ea0:	689a      	ldr	r2, [r3, #8]
 8008ea2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8008ea4:	4413      	add	r3, r2
 8008ea6:	781b      	ldrb	r3, [r3, #0]
 8008ea8:	4619      	mov	r1, r3
                        ((((ULONG)(media_ptr -> fx_media_memory_buffer[j + 1])) & 0xFF) << 8);
 8008eaa:	68fb      	ldr	r3, [r7, #12]
 8008eac:	689a      	ldr	r2, [r3, #8]
 8008eae:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8008eb0:	3301      	adds	r3, #1
 8008eb2:	4413      	add	r3, r2
 8008eb4:	781b      	ldrb	r3, [r3, #0]
 8008eb6:	021b      	lsls	r3, r3, #8
                    FAT_entry =  (((ULONG)(media_ptr -> fx_media_memory_buffer[j])) & 0xFF) |
 8008eb8:	430b      	orrs	r3, r1
 8008eba:	613b      	str	r3, [r7, #16]

                    /* Advance to next FAT entry.  */
                    j =  j + 2;
 8008ebc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8008ebe:	3302      	adds	r3, #2
 8008ec0:	64bb      	str	r3, [r7, #72]	; 0x48
                }

                /* Determine if the FAT entry is free.  */
                if (FAT_entry == FX_FREE_CLUSTER)
 8008ec2:	693b      	ldr	r3, [r7, #16]
 8008ec4:	2b00      	cmp	r3, #0
 8008ec6:	d10d      	bne.n	8008ee4 <_fx_media_open+0x9a0>
                {

                    /* Entry is free, increment available clusters.  */
                    media_ptr -> fx_media_available_clusters++;
 8008ec8:	68fb      	ldr	r3, [r7, #12]
 8008eca:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008ecc:	1c5a      	adds	r2, r3, #1
 8008ece:	68fb      	ldr	r3, [r7, #12]
 8008ed0:	67da      	str	r2, [r3, #124]	; 0x7c

                    /* Determine if the starting free cluster has been found yet.  */
                    if (media_ptr -> fx_media_cluster_search_start == 0)
 8008ed2:	68fb      	ldr	r3, [r7, #12]
 8008ed4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008ed8:	2b00      	cmp	r3, #0
 8008eda:	d103      	bne.n	8008ee4 <_fx_media_open+0x9a0>
                    {

                        /* Remember the first free cluster to start further searches from.  */
                        media_ptr -> fx_media_cluster_search_start =  cluster_number;
 8008edc:	68fb      	ldr	r3, [r7, #12]
 8008ede:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8008ee0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                    }
                }

                /* Increment the cluster number.  */
                cluster_number++;
 8008ee4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8008ee6:	3301      	adds	r3, #1
 8008ee8:	657b      	str	r3, [r7, #84]	; 0x54

                /* Determine if we have reviewed all FAT entries.  */
                if (cluster_number >= (media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START))
 8008eea:	68fb      	ldr	r3, [r7, #12]
 8008eec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008eee:	3302      	adds	r3, #2
 8008ef0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8008ef2:	429a      	cmp	r2, r3
 8008ef4:	d303      	bcc.n	8008efe <_fx_media_open+0x9ba>
                {

                    /* Yes, we have looked at all the FAT entries.  */

                    /* Ensure that the outer loop terminates as well.  */
                    i = media_ptr -> fx_media_sectors_per_FAT;
 8008ef6:	68fb      	ldr	r3, [r7, #12]
 8008ef8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008efa:	64fb      	str	r3, [r7, #76]	; 0x4c
                    break;
 8008efc:	e003      	b.n	8008f06 <_fx_media_open+0x9c2>
            for (j = 0; j < bytes_in_buffer;)
 8008efe:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8008f00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008f02:	429a      	cmp	r2, r3
 8008f04:	d3bd      	bcc.n	8008e82 <_fx_media_open+0x93e>
        for (i = 0; i < media_ptr -> fx_media_sectors_per_FAT; i = i + media_ptr -> fx_media_sector_cache_size)
 8008f06:	68fb      	ldr	r3, [r7, #12]
 8008f08:	695b      	ldr	r3, [r3, #20]
 8008f0a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008f0c:	4413      	add	r3, r2
 8008f0e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8008f10:	68fb      	ldr	r3, [r7, #12]
 8008f12:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008f14:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8008f16:	429a      	cmp	r2, r3
 8008f18:	f4ff af66 	bcc.w	8008de8 <_fx_media_open+0x8a4>
    }
#endif /* FX_ENABLE_EXFAT */

    /* If there were no free clusters, just set the search pointer to the
       first cluster number.  */
    if (media_ptr -> fx_media_cluster_search_start == 0)
 8008f1c:	68fb      	ldr	r3, [r7, #12]
 8008f1e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008f22:	2b00      	cmp	r3, #0
 8008f24:	d103      	bne.n	8008f2e <_fx_media_open+0x9ea>
    {
        media_ptr -> fx_media_cluster_search_start =  FX_FAT_ENTRY_START;
 8008f26:	68fb      	ldr	r3, [r7, #12]
 8008f28:	2202      	movs	r2, #2
 8008f2a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }

    /* Setup the current working directory fields to default to the root
       directory.  */
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name =
        media_ptr -> fx_media_default_path.fx_path_name_buffer;
 8008f2e:	68fb      	ldr	r3, [r7, #12]
 8008f30:	f503 62ca 	add.w	r2, r3, #1616	; 0x650
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name =
 8008f34:	68fb      	ldr	r3, [r7, #12]
 8008f36:	f8c3 24e0 	str.w	r2, [r3, #1248]	; 0x4e0
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_short_name[0] =  0;
 8008f3a:	68fb      	ldr	r3, [r7, #12]
 8008f3c:	2200      	movs	r2, #0
 8008f3e:	f883 24e4 	strb.w	r2, [r3, #1252]	; 0x4e4
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name[0] =        0;
 8008f42:	68fb      	ldr	r3, [r7, #12]
 8008f44:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	; 0x4e0
 8008f48:	2200      	movs	r2, #0
 8008f4a:	701a      	strb	r2, [r3, #0]
    media_ptr -> fx_media_default_path.fx_path_string[0] =                      (CHAR)0;
 8008f4c:	68fb      	ldr	r3, [r7, #12]
 8008f4e:	2200      	movs	r2, #0
 8008f50:	f883 2550 	strb.w	r2, [r3, #1360]	; 0x550
    media_ptr -> fx_media_default_path.fx_path_string[FX_MAXIMUM_PATH - 1] =      (CHAR)0;
 8008f54:	68fb      	ldr	r3, [r7, #12]
 8008f56:	2200      	movs	r2, #0
 8008f58:	f883 264f 	strb.w	r2, [r3, #1615]	; 0x64f
    media_ptr -> fx_media_default_path.fx_path_current_entry =                         0;
 8008f5c:	68fb      	ldr	r3, [r7, #12]
 8008f5e:	2200      	movs	r2, #0
 8008f60:	f8c3 2750 	str.w	r2, [r3, #1872]	; 0x750

#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE

    /* Invalidate the previously found directory entry.  */
    media_ptr -> fx_media_last_found_name[0] =  0;
 8008f64:	68fb      	ldr	r3, [r7, #12]
 8008f66:	2200      	movs	r2, #0
 8008f68:	f883 23e0 	strb.w	r2, [r3, #992]	; 0x3e0
#endif

#ifndef FX_DISABLE_FORCE_MEMORY_OPERATION
    /* Initialize the opened file linked list and associated counter.  */
    media_ptr -> fx_media_opened_file_list =      FX_NULL;
 8008f6c:	68fb      	ldr	r3, [r7, #12]
 8008f6e:	2200      	movs	r2, #0
 8008f70:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    media_ptr -> fx_media_opened_file_count =     0;
 8008f74:	68fb      	ldr	r3, [r7, #12]
 8008f76:	2200      	movs	r2, #0
 8008f78:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
#ifndef FX_SINGLE_THREAD

#ifndef FX_DONT_CREATE_MUTEX

    /* Create ThreadX mutex for protection.  */
    tx_mutex_create(&(media_ptr -> fx_media_protect), "FileX Media Mutex", TX_NO_INHERIT);
 8008f7c:	68fb      	ldr	r3, [r7, #12]
 8008f7e:	f503 73e4 	add.w	r3, r3, #456	; 0x1c8
 8008f82:	2200      	movs	r2, #0
 8008f84:	4928      	ldr	r1, [pc, #160]	; (8009028 <_fx_media_open+0xae4>)
 8008f86:	4618      	mov	r0, r3
 8008f88:	f003 fa0c 	bl	800c3a4 <_tx_mutex_create>
{
unsigned int posture;
#ifdef TX_PORT_USE_BASEPRI
    __asm__ volatile ("MRS  %0, BASEPRI ": "=r" (posture));
#else
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 8008f8c:	f3ef 8310 	mrs	r3, PRIMASK
 8008f90:	61fb      	str	r3, [r7, #28]
#endif
    return(posture);
 8008f92:	69fb      	ldr	r3, [r7, #28]

__attribute__( ( always_inline ) ) static inline unsigned int __disable_interrupts(void)
{
unsigned int int_posture;

    int_posture = __get_interrupt_posture();
 8008f94:	61bb      	str	r3, [r7, #24]

#ifdef TX_PORT_USE_BASEPRI
    __set_basepri_value(TX_PORT_BASEPRI);
#else
    __asm__ volatile ("CPSID i" : : : "memory");
 8008f96:	b672      	cpsid	i
#endif
    return(int_posture);
 8008f98:	69bb      	ldr	r3, [r7, #24]
    /* Protect against other threads accessing the media.  */
    FX_PROTECT
#endif

    /* Lockout interrupts.  */
    FX_DISABLE_INTS
 8008f9a:	627b      	str	r3, [r7, #36]	; 0x24

    /* At this point, the media has been opened successfully.  Place the
       media on the linked list of currently opened media.  */

    /* Load the media ID field in the media control block.  */
    media_ptr -> fx_media_id =  (ULONG)FX_MEDIA_ID;
 8008f9c:	68fb      	ldr	r3, [r7, #12]
 8008f9e:	4a23      	ldr	r2, [pc, #140]	; (800902c <_fx_media_open+0xae8>)
 8008fa0:	601a      	str	r2, [r3, #0]

    /* Place the thread on the list of opened media.  First,
       check for an empty list.  */
    if (_fx_system_media_opened_ptr)
 8008fa2:	4b23      	ldr	r3, [pc, #140]	; (8009030 <_fx_media_open+0xaec>)
 8008fa4:	681b      	ldr	r3, [r3, #0]
 8008fa6:	2b00      	cmp	r3, #0
 8008fa8:	d017      	beq.n	8008fda <_fx_media_open+0xa96>
    {

        /* Pickup tail pointer.  */
        tail_ptr =  _fx_system_media_opened_ptr -> fx_media_opened_previous;
 8008faa:	4b21      	ldr	r3, [pc, #132]	; (8009030 <_fx_media_open+0xaec>)
 8008fac:	681b      	ldr	r3, [r3, #0]
 8008fae:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8008fb2:	623b      	str	r3, [r7, #32]

        /* Place the new media in the list.  */
        _fx_system_media_opened_ptr -> fx_media_opened_previous =  media_ptr;
 8008fb4:	4b1e      	ldr	r3, [pc, #120]	; (8009030 <_fx_media_open+0xaec>)
 8008fb6:	681b      	ldr	r3, [r3, #0]
 8008fb8:	68fa      	ldr	r2, [r7, #12]
 8008fba:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
        tail_ptr -> fx_media_opened_next =  media_ptr;
 8008fbe:	6a3b      	ldr	r3, [r7, #32]
 8008fc0:	68fa      	ldr	r2, [r7, #12]
 8008fc2:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0

        /* Setup this media's opened links.  */
        media_ptr -> fx_media_opened_previous =  tail_ptr;
 8008fc6:	68fb      	ldr	r3, [r7, #12]
 8008fc8:	6a3a      	ldr	r2, [r7, #32]
 8008fca:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
        media_ptr -> fx_media_opened_next =      _fx_system_media_opened_ptr;
 8008fce:	4b18      	ldr	r3, [pc, #96]	; (8009030 <_fx_media_open+0xaec>)
 8008fd0:	681a      	ldr	r2, [r3, #0]
 8008fd2:	68fb      	ldr	r3, [r7, #12]
 8008fd4:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
 8008fd8:	e00a      	b.n	8008ff0 <_fx_media_open+0xaac>
    }
    else
    {

        /* The opened media list is empty.  Add the media to empty list.  */
        _fx_system_media_opened_ptr =           media_ptr;
 8008fda:	4a15      	ldr	r2, [pc, #84]	; (8009030 <_fx_media_open+0xaec>)
 8008fdc:	68fb      	ldr	r3, [r7, #12]
 8008fde:	6013      	str	r3, [r2, #0]
        media_ptr -> fx_media_opened_next =     media_ptr;
 8008fe0:	68fb      	ldr	r3, [r7, #12]
 8008fe2:	68fa      	ldr	r2, [r7, #12]
 8008fe4:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
        media_ptr -> fx_media_opened_previous = media_ptr;
 8008fe8:	68fb      	ldr	r3, [r7, #12]
 8008fea:	68fa      	ldr	r2, [r7, #12]
 8008fec:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
    }

    /* Increment the opened media counter.  */
    _fx_system_media_opened_count++;
 8008ff0:	4b10      	ldr	r3, [pc, #64]	; (8009034 <_fx_media_open+0xaf0>)
 8008ff2:	681b      	ldr	r3, [r3, #0]
 8008ff4:	3301      	adds	r3, #1
 8008ff6:	4a0f      	ldr	r2, [pc, #60]	; (8009034 <_fx_media_open+0xaf0>)
 8008ff8:	6013      	str	r3, [r2, #0]

    /* Invoke media open callback. */
    if (media_ptr -> fx_media_open_notify)
 8008ffa:	68fb      	ldr	r3, [r7, #12]
 8008ffc:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 8009000:	2b00      	cmp	r3, #0
 8009002:	d004      	beq.n	800900e <_fx_media_open+0xaca>
    {
        media_ptr -> fx_media_open_notify(media_ptr);
 8009004:	68fb      	ldr	r3, [r7, #12]
 8009006:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 800900a:	68f8      	ldr	r0, [r7, #12]
 800900c:	4798      	blx	r3
 800900e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009010:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 8009012:	697b      	ldr	r3, [r7, #20]
 8009014:	f383 8810 	msr	PRIMASK, r3
}
 8009018:	bf00      	nop
    /* Release media protection.  */
    FX_UNPROTECT
#endif

    /* Return a successful status.  */
    return(FX_SUCCESS);
 800901a:	2300      	movs	r3, #0
}
 800901c:	4618      	mov	r0, r3
 800901e:	3758      	adds	r7, #88	; 0x58
 8009020:	46bd      	mov	sp, r7
 8009022:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8009026:	bf00      	nop
 8009028:	08013394 	.word	0x08013394
 800902c:	4d454449 	.word	0x4d454449
 8009030:	20006c84 	.word	0x20006c84
 8009034:	20006c88 	.word	0x20006c88

08009038 <_fx_system_initialize>:
/*                                            disable build options,      */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _fx_system_initialize(VOID)
{
 8009038:	b580      	push	{r7, lr}
 800903a:	b084      	sub	sp, #16
 800903c:	af04      	add	r7, sp, #16
    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_SYSTEM_INITIALIZE, 0, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Initialize the head pointer of the opened media list and the
       number of opened media.  */
    _fx_system_media_opened_ptr =       FX_NULL;
 800903e:	4b28      	ldr	r3, [pc, #160]	; (80090e0 <_fx_system_initialize+0xa8>)
 8009040:	2200      	movs	r2, #0
 8009042:	601a      	str	r2, [r3, #0]
    _fx_system_media_opened_count =     0;
 8009044:	4b27      	ldr	r3, [pc, #156]	; (80090e4 <_fx_system_initialize+0xac>)
 8009046:	2200      	movs	r2, #0
 8009048:	601a      	str	r2, [r3, #0]

    /* Initialize the time and date fields with their default values.  */
    _fx_system_date =   FX_INITIAL_DATE;
 800904a:	4b27      	ldr	r3, [pc, #156]	; (80090e8 <_fx_system_initialize+0xb0>)
 800904c:	f644 2221 	movw	r2, #18977	; 0x4a21
 8009050:	601a      	str	r2, [r3, #0]
    _fx_system_time =   FX_INITIAL_TIME;
 8009052:	4b26      	ldr	r3, [pc, #152]	; (80090ec <_fx_system_initialize+0xb4>)
 8009054:	2200      	movs	r2, #0
 8009056:	601a      	str	r2, [r3, #0]

    /* Initialize the sector and FAT cache sizes.  */
    _fx_system_media_max_sector_cache =  FX_MAX_SECTOR_CACHE;
 8009058:	4b25      	ldr	r3, [pc, #148]	; (80090f0 <_fx_system_initialize+0xb8>)
 800905a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800905e:	601a      	str	r2, [r3, #0]
    _fx_system_media_max_fat_cache =     FX_MAX_FAT_CACHE;
 8009060:	4b24      	ldr	r3, [pc, #144]	; (80090f4 <_fx_system_initialize+0xbc>)
 8009062:	2210      	movs	r2, #16
 8009064:	601a      	str	r2, [r3, #0]
       FX_UPDATE_RATE_IN_TICKS.  Note that the timer is not necessary for
       regular FileX operation - it is only needed for accurate system
       date and time stamps on files.  */

#ifndef FX_NO_TIMER
    tx_timer_create(&_fx_system_timer, "FileX System Timer", _fx_system_timer_entry, FX_TIMER_ID,
 8009066:	2301      	movs	r3, #1
 8009068:	9302      	str	r3, [sp, #8]
 800906a:	f242 7310 	movw	r3, #10000	; 0x2710
 800906e:	9301      	str	r3, [sp, #4]
 8009070:	f242 7310 	movw	r3, #10000	; 0x2710
 8009074:	9300      	str	r3, [sp, #0]
 8009076:	4b20      	ldr	r3, [pc, #128]	; (80090f8 <_fx_system_initialize+0xc0>)
 8009078:	4a20      	ldr	r2, [pc, #128]	; (80090fc <_fx_system_initialize+0xc4>)
 800907a:	4921      	ldr	r1, [pc, #132]	; (8009100 <_fx_system_initialize+0xc8>)
 800907c:	4821      	ldr	r0, [pc, #132]	; (8009104 <_fx_system_initialize+0xcc>)
 800907e:	f005 fac3 	bl	800e608 <_tx_timer_create>
    /* Setup the build options variables.  */

    /* Setup the first build options variable.  */
    if (FX_MAX_LONG_NAME_LEN > 0xFF)
    {
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)0xFF) << 24);
 8009082:	4b21      	ldr	r3, [pc, #132]	; (8009108 <_fx_system_initialize+0xd0>)
 8009084:	681b      	ldr	r3, [r3, #0]
 8009086:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 800908a:	4a1f      	ldr	r2, [pc, #124]	; (8009108 <_fx_system_initialize+0xd0>)
 800908c:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)(FX_MAX_LONG_NAME_LEN & 0xFF)) << 24);
    }
    if (FX_MAX_LAST_NAME_LEN > 0xFF)
    {
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)0xFF) << 16);
 800908e:	4b1e      	ldr	r3, [pc, #120]	; (8009108 <_fx_system_initialize+0xd0>)
 8009090:	681b      	ldr	r3, [r3, #0]
 8009092:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 8009096:	4a1c      	ldr	r2, [pc, #112]	; (8009108 <_fx_system_initialize+0xd0>)
 8009098:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | (((ULONG)0xFFFF) << 16);
    }
    else
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | (((ULONG)FX_MAX_SECTOR_CACHE) << 16);
 800909a:	4b1c      	ldr	r3, [pc, #112]	; (800910c <_fx_system_initialize+0xd4>)
 800909c:	681b      	ldr	r3, [r3, #0]
 800909e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80090a2:	4a1a      	ldr	r2, [pc, #104]	; (800910c <_fx_system_initialize+0xd4>)
 80090a4:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | (((ULONG)0xFF) << 8);
    }
    else
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | (((ULONG)FX_FAT_MAP_SIZE) << 8);
 80090a6:	4b19      	ldr	r3, [pc, #100]	; (800910c <_fx_system_initialize+0xd4>)
 80090a8:	681b      	ldr	r3, [r3, #0]
 80090aa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80090ae:	4a17      	ldr	r2, [pc, #92]	; (800910c <_fx_system_initialize+0xd4>)
 80090b0:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | ((ULONG)0xFF);
    }
    else
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | ((ULONG)FX_MAX_FAT_CACHE);
 80090b2:	4b16      	ldr	r3, [pc, #88]	; (800910c <_fx_system_initialize+0xd4>)
 80090b4:	681b      	ldr	r3, [r3, #0]
 80090b6:	f043 0310 	orr.w	r3, r3, #16
 80090ba:	4a14      	ldr	r2, [pc, #80]	; (800910c <_fx_system_initialize+0xd4>)
 80090bc:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_3 =  _fx_system_build_options_3 | (((ULONG)0xFF) << 16);
    }
    else
    {
        _fx_system_build_options_3 =  _fx_system_build_options_3 | (((ULONG)FX_UPDATE_RATE_IN_SECONDS) << 16);
 80090be:	4b14      	ldr	r3, [pc, #80]	; (8009110 <_fx_system_initialize+0xd8>)
 80090c0:	681b      	ldr	r3, [r3, #0]
 80090c2:	f443 2320 	orr.w	r3, r3, #655360	; 0xa0000
 80090c6:	4a12      	ldr	r2, [pc, #72]	; (8009110 <_fx_system_initialize+0xd8>)
 80090c8:	6013      	str	r3, [r2, #0]
    {
        _fx_system_build_options_3 =  _fx_system_build_options_3 | ((ULONG)0xFFFF);
    }
    else
    {
        _fx_system_build_options_3 =  _fx_system_build_options_3 | ((ULONG)FX_UPDATE_RATE_IN_TICKS);
 80090ca:	4b11      	ldr	r3, [pc, #68]	; (8009110 <_fx_system_initialize+0xd8>)
 80090cc:	681b      	ldr	r3, [r3, #0]
 80090ce:	f443 531c 	orr.w	r3, r3, #9984	; 0x2700
 80090d2:	f043 0310 	orr.w	r3, r3, #16
 80090d6:	4a0e      	ldr	r2, [pc, #56]	; (8009110 <_fx_system_initialize+0xd8>)
 80090d8:	6013      	str	r3, [r2, #0]
    }
#endif /* FX_DISABLE_BUILD_OPTIONS */
}
 80090da:	bf00      	nop
 80090dc:	46bd      	mov	sp, r7
 80090de:	bd80      	pop	{r7, pc}
 80090e0:	20006c84 	.word	0x20006c84
 80090e4:	20006c88 	.word	0x20006c88
 80090e8:	20006c8c 	.word	0x20006c8c
 80090ec:	20006c90 	.word	0x20006c90
 80090f0:	20006c94 	.word	0x20006c94
 80090f4:	20006c98 	.word	0x20006c98
 80090f8:	46585359 	.word	0x46585359
 80090fc:	08009115 	.word	0x08009115
 8009100:	080133a8 	.word	0x080133a8
 8009104:	20006ca8 	.word	0x20006ca8
 8009108:	20006c9c 	.word	0x20006c9c
 800910c:	20006ca0 	.word	0x20006ca0
 8009110:	20006ca4 	.word	0x20006ca4

08009114 <_fx_system_timer_entry>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID    _fx_system_timer_entry(ULONG id)
{
 8009114:	b480      	push	{r7}
 8009116:	b089      	sub	sp, #36	; 0x24
 8009118:	af00      	add	r7, sp, #0
 800911a:	6078      	str	r0, [r7, #4]
UINT month;
UINT year;


    /* Determine if the ID is valid.  */
    if (id == FX_TIMER_ID)
 800911c:	687b      	ldr	r3, [r7, #4]
 800911e:	4a9c      	ldr	r2, [pc, #624]	; (8009390 <_fx_system_timer_entry+0x27c>)
 8009120:	4293      	cmp	r3, r2
 8009122:	f040 8130 	bne.w	8009386 <_fx_system_timer_entry+0x272>
    {

        /* Break the current date time into separate fields for easier work!  */
        second =  (_fx_system_time & FX_SECOND_MASK) * 2;
 8009126:	4b9b      	ldr	r3, [pc, #620]	; (8009394 <_fx_system_timer_entry+0x280>)
 8009128:	681b      	ldr	r3, [r3, #0]
 800912a:	f003 031f 	and.w	r3, r3, #31
 800912e:	005b      	lsls	r3, r3, #1
 8009130:	61fb      	str	r3, [r7, #28]
        minute =  (_fx_system_time >> FX_MINUTE_SHIFT) & FX_MINUTE_MASK;
 8009132:	4b98      	ldr	r3, [pc, #608]	; (8009394 <_fx_system_timer_entry+0x280>)
 8009134:	681b      	ldr	r3, [r3, #0]
 8009136:	095b      	lsrs	r3, r3, #5
 8009138:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800913c:	61bb      	str	r3, [r7, #24]
        hour =    (_fx_system_time >> FX_HOUR_SHIFT) & FX_HOUR_MASK;
 800913e:	4b95      	ldr	r3, [pc, #596]	; (8009394 <_fx_system_timer_entry+0x280>)
 8009140:	681b      	ldr	r3, [r3, #0]
 8009142:	0adb      	lsrs	r3, r3, #11
 8009144:	f003 031f 	and.w	r3, r3, #31
 8009148:	617b      	str	r3, [r7, #20]
        day =     _fx_system_date & FX_DAY_MASK;
 800914a:	4b93      	ldr	r3, [pc, #588]	; (8009398 <_fx_system_timer_entry+0x284>)
 800914c:	681b      	ldr	r3, [r3, #0]
 800914e:	f003 031f 	and.w	r3, r3, #31
 8009152:	613b      	str	r3, [r7, #16]
        month =   (_fx_system_date >> FX_MONTH_SHIFT) & FX_MONTH_MASK;
 8009154:	4b90      	ldr	r3, [pc, #576]	; (8009398 <_fx_system_timer_entry+0x284>)
 8009156:	681b      	ldr	r3, [r3, #0]
 8009158:	095b      	lsrs	r3, r3, #5
 800915a:	f003 030f 	and.w	r3, r3, #15
 800915e:	60fb      	str	r3, [r7, #12]
        year =    ((_fx_system_date >> FX_YEAR_SHIFT) & FX_YEAR_MASK) + FX_BASE_YEAR;
 8009160:	4b8d      	ldr	r3, [pc, #564]	; (8009398 <_fx_system_timer_entry+0x284>)
 8009162:	681b      	ldr	r3, [r3, #0]
 8009164:	0a5b      	lsrs	r3, r3, #9
 8009166:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800916a:	f203 73bc 	addw	r3, r3, #1980	; 0x7bc
 800916e:	60bb      	str	r3, [r7, #8]

        /* Now apply the "second" update.  */
        second =  second + FX_UPDATE_RATE_IN_SECONDS;
 8009170:	69fb      	ldr	r3, [r7, #28]
 8009172:	330a      	adds	r3, #10
 8009174:	61fb      	str	r3, [r7, #28]

        /* Determine if we need to adjust the minute field.  */
        if (second > FX_MAXIMUM_SECOND)
 8009176:	69fb      	ldr	r3, [r7, #28]
 8009178:	2b3b      	cmp	r3, #59	; 0x3b
 800917a:	f240 80eb 	bls.w	8009354 <_fx_system_timer_entry+0x240>
        {

            /* Yes, we need to adjust the minute field.  */
            minute =  minute + second / 60;
 800917e:	69fb      	ldr	r3, [r7, #28]
 8009180:	4a86      	ldr	r2, [pc, #536]	; (800939c <_fx_system_timer_entry+0x288>)
 8009182:	fba2 2303 	umull	r2, r3, r2, r3
 8009186:	095b      	lsrs	r3, r3, #5
 8009188:	69ba      	ldr	r2, [r7, #24]
 800918a:	4413      	add	r3, r2
 800918c:	61bb      	str	r3, [r7, #24]
            second =  second % 60;
 800918e:	69fa      	ldr	r2, [r7, #28]
 8009190:	4b82      	ldr	r3, [pc, #520]	; (800939c <_fx_system_timer_entry+0x288>)
 8009192:	fba3 1302 	umull	r1, r3, r3, r2
 8009196:	0959      	lsrs	r1, r3, #5
 8009198:	460b      	mov	r3, r1
 800919a:	011b      	lsls	r3, r3, #4
 800919c:	1a5b      	subs	r3, r3, r1
 800919e:	009b      	lsls	r3, r3, #2
 80091a0:	1ad3      	subs	r3, r2, r3
 80091a2:	61fb      	str	r3, [r7, #28]

            /* Determine if we need to adjust the hour field.  */
            if (minute > FX_MAXIMUM_MINUTE)
 80091a4:	69bb      	ldr	r3, [r7, #24]
 80091a6:	2b3b      	cmp	r3, #59	; 0x3b
 80091a8:	f240 80d4 	bls.w	8009354 <_fx_system_timer_entry+0x240>
            {

                /* Yes, we need to adjust the hour field.  */
                hour =    hour + minute / 60;
 80091ac:	69bb      	ldr	r3, [r7, #24]
 80091ae:	4a7b      	ldr	r2, [pc, #492]	; (800939c <_fx_system_timer_entry+0x288>)
 80091b0:	fba2 2303 	umull	r2, r3, r2, r3
 80091b4:	095b      	lsrs	r3, r3, #5
 80091b6:	697a      	ldr	r2, [r7, #20]
 80091b8:	4413      	add	r3, r2
 80091ba:	617b      	str	r3, [r7, #20]
                minute =  minute % 60;
 80091bc:	69ba      	ldr	r2, [r7, #24]
 80091be:	4b77      	ldr	r3, [pc, #476]	; (800939c <_fx_system_timer_entry+0x288>)
 80091c0:	fba3 1302 	umull	r1, r3, r3, r2
 80091c4:	0959      	lsrs	r1, r3, #5
 80091c6:	460b      	mov	r3, r1
 80091c8:	011b      	lsls	r3, r3, #4
 80091ca:	1a5b      	subs	r3, r3, r1
 80091cc:	009b      	lsls	r3, r3, #2
 80091ce:	1ad3      	subs	r3, r2, r3
 80091d0:	61bb      	str	r3, [r7, #24]

                /* Determine if we need to adjust the day field.  */
                if (hour > FX_MAXIMUM_HOUR)
 80091d2:	697b      	ldr	r3, [r7, #20]
 80091d4:	2b17      	cmp	r3, #23
 80091d6:	f240 80bd 	bls.w	8009354 <_fx_system_timer_entry+0x240>
                {

                    /* Yes, we need to adjust the day field.  */
                    hour =  0;
 80091da:	2300      	movs	r3, #0
 80091dc:	617b      	str	r3, [r7, #20]
                    day++;
 80091de:	693b      	ldr	r3, [r7, #16]
 80091e0:	3301      	adds	r3, #1
 80091e2:	613b      	str	r3, [r7, #16]

                    /* Determine if we need to adjust the month field.  */
                    switch (month)
 80091e4:	68fb      	ldr	r3, [r7, #12]
 80091e6:	3b01      	subs	r3, #1
 80091e8:	2b0b      	cmp	r3, #11
 80091ea:	f200 80c9 	bhi.w	8009380 <_fx_system_timer_entry+0x26c>
 80091ee:	a201      	add	r2, pc, #4	; (adr r2, 80091f4 <_fx_system_timer_entry+0xe0>)
 80091f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80091f4:	08009225 	.word	0x08009225
 80091f8:	08009237 	.word	0x08009237
 80091fc:	08009265 	.word	0x08009265
 8009200:	08009277 	.word	0x08009277
 8009204:	08009289 	.word	0x08009289
 8009208:	0800929b 	.word	0x0800929b
 800920c:	080092ad 	.word	0x080092ad
 8009210:	080092bf 	.word	0x080092bf
 8009214:	080092d1 	.word	0x080092d1
 8009218:	080092e3 	.word	0x080092e3
 800921c:	080092f5 	.word	0x080092f5
 8009220:	08009307 	.word	0x08009307

                    case 1:                 /* January  */
                    {

                        /* Check for end of the month.  */
                        if (day > 31)
 8009224:	693b      	ldr	r3, [r7, #16]
 8009226:	2b1f      	cmp	r3, #31
 8009228:	d97d      	bls.n	8009326 <_fx_system_timer_entry+0x212>
                        {

                            /* Move to next month.  */
                            day = 1;
 800922a:	2301      	movs	r3, #1
 800922c:	613b      	str	r3, [r7, #16]
                            month++;
 800922e:	68fb      	ldr	r3, [r7, #12]
 8009230:	3301      	adds	r3, #1
 8009232:	60fb      	str	r3, [r7, #12]
                        }
                        break;
 8009234:	e077      	b.n	8009326 <_fx_system_timer_entry+0x212>
                    {

                        /* Check for leap year.  We don't need to check for leap
                           century her (century years divisible by 400) since 2000
                           is and this FAT format only supports years to 2107. */
                        if ((year % 4) == 0)
 8009236:	68bb      	ldr	r3, [r7, #8]
 8009238:	f003 0303 	and.w	r3, r3, #3
 800923c:	2b00      	cmp	r3, #0
 800923e:	d108      	bne.n	8009252 <_fx_system_timer_entry+0x13e>
                        {

                            /* Leap year in February... check for 29 days
                               instead of 28.  */
                            if (day > 29)
 8009240:	693b      	ldr	r3, [r7, #16]
 8009242:	2b1d      	cmp	r3, #29
 8009244:	d971      	bls.n	800932a <_fx_system_timer_entry+0x216>
                            {

                                /* Adjust the month.  */
                                day =  1;
 8009246:	2301      	movs	r3, #1
 8009248:	613b      	str	r3, [r7, #16]
                                month++;
 800924a:	68fb      	ldr	r3, [r7, #12]
 800924c:	3301      	adds	r3, #1
 800924e:	60fb      	str	r3, [r7, #12]
                                /* Adjust the month.  */
                                day = 1;
                                month++;
                            }
                        }
                        break;
 8009250:	e06b      	b.n	800932a <_fx_system_timer_entry+0x216>
                            if (day > 28)
 8009252:	693b      	ldr	r3, [r7, #16]
 8009254:	2b1c      	cmp	r3, #28
 8009256:	d968      	bls.n	800932a <_fx_system_timer_entry+0x216>
                                day = 1;
 8009258:	2301      	movs	r3, #1
 800925a:	613b      	str	r3, [r7, #16]
                                month++;
 800925c:	68fb      	ldr	r3, [r7, #12]
 800925e:	3301      	adds	r3, #1
 8009260:	60fb      	str	r3, [r7, #12]
                        break;
 8009262:	e062      	b.n	800932a <_fx_system_timer_entry+0x216>

                    case 3:                 /* March  */
                    {

                        /* Check for end of the month.  */
                        if (day > 31)
 8009264:	693b      	ldr	r3, [r7, #16]
 8009266:	2b1f      	cmp	r3, #31
 8009268:	d961      	bls.n	800932e <_fx_system_timer_entry+0x21a>
                        {

                            /* Move to next month.  */
                            day = 1;
 800926a:	2301      	movs	r3, #1
 800926c:	613b      	str	r3, [r7, #16]
                            month++;
 800926e:	68fb      	ldr	r3, [r7, #12]
 8009270:	3301      	adds	r3, #1
 8009272:	60fb      	str	r3, [r7, #12]
                        }
                        break;
 8009274:	e05b      	b.n	800932e <_fx_system_timer_entry+0x21a>

                    case 4:                 /* April  */
                    {

                        /* Check for end of the month.  */
                        if (day > 30)
 8009276:	693b      	ldr	r3, [r7, #16]
 8009278:	2b1e      	cmp	r3, #30
 800927a:	d95a      	bls.n	8009332 <_fx_system_timer_entry+0x21e>
                        {

                            /* Move to next month.  */
                            day = 1;
 800927c:	2301      	movs	r3, #1
 800927e:	613b      	str	r3, [r7, #16]
                            month++;
 8009280:	68fb      	ldr	r3, [r7, #12]
 8009282:	3301      	adds	r3, #1
 8009284:	60fb      	str	r3, [r7, #12]
                        }
                        break;
 8009286:	e054      	b.n	8009332 <_fx_system_timer_entry+0x21e>

                    case 5:                 /* May  */
                    {

                        /* Check for end of the month.  */
                        if (day > 31)
 8009288:	693b      	ldr	r3, [r7, #16]
 800928a:	2b1f      	cmp	r3, #31
 800928c:	d953      	bls.n	8009336 <_fx_system_timer_entry+0x222>
                        {

                            /* Move to next month.  */
                            day = 1;
 800928e:	2301      	movs	r3, #1
 8009290:	613b      	str	r3, [r7, #16]
                            month++;
 8009292:	68fb      	ldr	r3, [r7, #12]
 8009294:	3301      	adds	r3, #1
 8009296:	60fb      	str	r3, [r7, #12]
                        }
                        break;
 8009298:	e04d      	b.n	8009336 <_fx_system_timer_entry+0x222>

                    case 6:                 /* June */
                    {

                        /* Check for end of the month.  */
                        if (day > 30)
 800929a:	693b      	ldr	r3, [r7, #16]
 800929c:	2b1e      	cmp	r3, #30
 800929e:	d94c      	bls.n	800933a <_fx_system_timer_entry+0x226>
                        {

                            /* Move to next month.  */
                            day = 1;
 80092a0:	2301      	movs	r3, #1
 80092a2:	613b      	str	r3, [r7, #16]
                            month++;
 80092a4:	68fb      	ldr	r3, [r7, #12]
 80092a6:	3301      	adds	r3, #1
 80092a8:	60fb      	str	r3, [r7, #12]
                        }
                        break;
 80092aa:	e046      	b.n	800933a <_fx_system_timer_entry+0x226>

                    case 7:                 /* July */
                    {

                        /* Check for end of the month.  */
                        if (day > 31)
 80092ac:	693b      	ldr	r3, [r7, #16]
 80092ae:	2b1f      	cmp	r3, #31
 80092b0:	d945      	bls.n	800933e <_fx_system_timer_entry+0x22a>
                        {

                            /* Move to next month.  */
                            day = 1;
 80092b2:	2301      	movs	r3, #1
 80092b4:	613b      	str	r3, [r7, #16]
                            month++;
 80092b6:	68fb      	ldr	r3, [r7, #12]
 80092b8:	3301      	adds	r3, #1
 80092ba:	60fb      	str	r3, [r7, #12]
                        }
                        break;
 80092bc:	e03f      	b.n	800933e <_fx_system_timer_entry+0x22a>

                    case 8:                 /* August */
                    {

                        /* Check for end of the month.  */
                        if (day > 31)
 80092be:	693b      	ldr	r3, [r7, #16]
 80092c0:	2b1f      	cmp	r3, #31
 80092c2:	d93e      	bls.n	8009342 <_fx_system_timer_entry+0x22e>
                        {

                            /* Move to next month.  */
                            day = 1;
 80092c4:	2301      	movs	r3, #1
 80092c6:	613b      	str	r3, [r7, #16]
                            month++;
 80092c8:	68fb      	ldr	r3, [r7, #12]
 80092ca:	3301      	adds	r3, #1
 80092cc:	60fb      	str	r3, [r7, #12]
                        }
                        break;
 80092ce:	e038      	b.n	8009342 <_fx_system_timer_entry+0x22e>

                    case 9:                 /* September */
                    {

                        /* Check for end of the month.  */
                        if (day > 30)
 80092d0:	693b      	ldr	r3, [r7, #16]
 80092d2:	2b1e      	cmp	r3, #30
 80092d4:	d937      	bls.n	8009346 <_fx_system_timer_entry+0x232>
                        {

                            /* Move to next month.  */
                            day = 1;
 80092d6:	2301      	movs	r3, #1
 80092d8:	613b      	str	r3, [r7, #16]
                            month++;
 80092da:	68fb      	ldr	r3, [r7, #12]
 80092dc:	3301      	adds	r3, #1
 80092de:	60fb      	str	r3, [r7, #12]
                        }
                        break;
 80092e0:	e031      	b.n	8009346 <_fx_system_timer_entry+0x232>

                    case 10:                /* October */
                    {

                        /* Check for end of the month.  */
                        if (day > 31)
 80092e2:	693b      	ldr	r3, [r7, #16]
 80092e4:	2b1f      	cmp	r3, #31
 80092e6:	d930      	bls.n	800934a <_fx_system_timer_entry+0x236>
                        {

                            /* Move to next month.  */
                            day = 1;
 80092e8:	2301      	movs	r3, #1
 80092ea:	613b      	str	r3, [r7, #16]
                            month++;
 80092ec:	68fb      	ldr	r3, [r7, #12]
 80092ee:	3301      	adds	r3, #1
 80092f0:	60fb      	str	r3, [r7, #12]
                        }
                        break;
 80092f2:	e02a      	b.n	800934a <_fx_system_timer_entry+0x236>

                    case 11:                /* November */
                    {

                        /* Check for end of the month.  */
                        if (day > 30)
 80092f4:	693b      	ldr	r3, [r7, #16]
 80092f6:	2b1e      	cmp	r3, #30
 80092f8:	d929      	bls.n	800934e <_fx_system_timer_entry+0x23a>
                        {

                            /* Move to next month.  */
                            day = 1;
 80092fa:	2301      	movs	r3, #1
 80092fc:	613b      	str	r3, [r7, #16]
                            month++;
 80092fe:	68fb      	ldr	r3, [r7, #12]
 8009300:	3301      	adds	r3, #1
 8009302:	60fb      	str	r3, [r7, #12]
                        }
                        break;
 8009304:	e023      	b.n	800934e <_fx_system_timer_entry+0x23a>

                    case 12:                /* December */
                    {

                        /* Check for end of the month.  */
                        if (day > 31)
 8009306:	693b      	ldr	r3, [r7, #16]
 8009308:	2b1f      	cmp	r3, #31
 800930a:	d922      	bls.n	8009352 <_fx_system_timer_entry+0x23e>
                        {

                            /* Move to next month.  */
                            day = 1;
 800930c:	2301      	movs	r3, #1
 800930e:	613b      	str	r3, [r7, #16]
                            month = 1;
 8009310:	2301      	movs	r3, #1
 8009312:	60fb      	str	r3, [r7, #12]

                            /* Also move to next year.  */
                            year++;
 8009314:	68bb      	ldr	r3, [r7, #8]
 8009316:	3301      	adds	r3, #1
 8009318:	60bb      	str	r3, [r7, #8]

                            /* Check for a year that exceeds the representation
                               in this format.  */
                            if (year > FX_MAXIMUM_YEAR)
 800931a:	68bb      	ldr	r3, [r7, #8]
 800931c:	f640 023b 	movw	r2, #2107	; 0x83b
 8009320:	4293      	cmp	r3, r2
 8009322:	d82f      	bhi.n	8009384 <_fx_system_timer_entry+0x270>
                            {
                                return;
                            }
                        }
                        break;
 8009324:	e015      	b.n	8009352 <_fx_system_timer_entry+0x23e>
                        break;
 8009326:	bf00      	nop
 8009328:	e014      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 800932a:	bf00      	nop
 800932c:	e012      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 800932e:	bf00      	nop
 8009330:	e010      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 8009332:	bf00      	nop
 8009334:	e00e      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 8009336:	bf00      	nop
 8009338:	e00c      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 800933a:	bf00      	nop
 800933c:	e00a      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 800933e:	bf00      	nop
 8009340:	e008      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 8009342:	bf00      	nop
 8009344:	e006      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 8009346:	bf00      	nop
 8009348:	e004      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 800934a:	bf00      	nop
 800934c:	e002      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 800934e:	bf00      	nop
 8009350:	e000      	b.n	8009354 <_fx_system_timer_entry+0x240>
                        break;
 8009352:	bf00      	nop
        }

        /* Now apply the new setting to the internal representation.  */

        /* Set the system date.  */
        _fx_system_date =  ((year - FX_BASE_YEAR) << FX_YEAR_SHIFT) |
 8009354:	68bb      	ldr	r3, [r7, #8]
 8009356:	f2a3 73bc 	subw	r3, r3, #1980	; 0x7bc
 800935a:	025a      	lsls	r2, r3, #9
                            (month << FX_MONTH_SHIFT) | day;
 800935c:	68fb      	ldr	r3, [r7, #12]
 800935e:	015b      	lsls	r3, r3, #5
        _fx_system_date =  ((year - FX_BASE_YEAR) << FX_YEAR_SHIFT) |
 8009360:	431a      	orrs	r2, r3
                            (month << FX_MONTH_SHIFT) | day;
 8009362:	693b      	ldr	r3, [r7, #16]
 8009364:	4313      	orrs	r3, r2
        _fx_system_date =  ((year - FX_BASE_YEAR) << FX_YEAR_SHIFT) |
 8009366:	4a0c      	ldr	r2, [pc, #48]	; (8009398 <_fx_system_timer_entry+0x284>)
 8009368:	6013      	str	r3, [r2, #0]

        /* Set the new system time.  */
        _fx_system_time  =  (hour << FX_HOUR_SHIFT) |
 800936a:	697b      	ldr	r3, [r7, #20]
 800936c:	02da      	lsls	r2, r3, #11
                            (minute << FX_MINUTE_SHIFT) | (second / 2);
 800936e:	69bb      	ldr	r3, [r7, #24]
 8009370:	015b      	lsls	r3, r3, #5
        _fx_system_time  =  (hour << FX_HOUR_SHIFT) |
 8009372:	431a      	orrs	r2, r3
                            (minute << FX_MINUTE_SHIFT) | (second / 2);
 8009374:	69fb      	ldr	r3, [r7, #28]
 8009376:	085b      	lsrs	r3, r3, #1
 8009378:	4313      	orrs	r3, r2
        _fx_system_time  =  (hour << FX_HOUR_SHIFT) |
 800937a:	4a06      	ldr	r2, [pc, #24]	; (8009394 <_fx_system_timer_entry+0x280>)
 800937c:	6013      	str	r3, [r2, #0]
 800937e:	e002      	b.n	8009386 <_fx_system_timer_entry+0x272>
                        return;             /* Skip updating date/time!  */
 8009380:	bf00      	nop
 8009382:	e000      	b.n	8009386 <_fx_system_timer_entry+0x272>
                                return;
 8009384:	bf00      	nop
    }
}
 8009386:	3724      	adds	r7, #36	; 0x24
 8009388:	46bd      	mov	sp, r7
 800938a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800938e:	4770      	bx	lr
 8009390:	46585359 	.word	0x46585359
 8009394:	20006c90 	.word	0x20006c90
 8009398:	20006c8c 	.word	0x20006c8c
 800939c:	88888889 	.word	0x88888889

080093a0 <_fx_utility_16_unsigned_read>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_16_unsigned_read(UCHAR *source_ptr)
{
 80093a0:	b480      	push	{r7}
 80093a2:	b085      	sub	sp, #20
 80093a4:	af00      	add	r7, sp, #0
 80093a6:	6078      	str	r0, [r7, #4]

UINT value;

    /* Pickup the UINT from the destination with endian-awareness.  */
    value =  ((((UINT)*(source_ptr + 1)) & 0xFF) << 8) |
 80093a8:	687b      	ldr	r3, [r7, #4]
 80093aa:	3301      	adds	r3, #1
 80093ac:	781b      	ldrb	r3, [r3, #0]
 80093ae:	021b      	lsls	r3, r3, #8
              ((UINT)*(source_ptr) & 0xFF);
 80093b0:	687a      	ldr	r2, [r7, #4]
 80093b2:	7812      	ldrb	r2, [r2, #0]
    value =  ((((UINT)*(source_ptr + 1)) & 0xFF) << 8) |
 80093b4:	4313      	orrs	r3, r2
 80093b6:	60fb      	str	r3, [r7, #12]

    /* Return value to caller.  */
    return(value);
 80093b8:	68fb      	ldr	r3, [r7, #12]
}
 80093ba:	4618      	mov	r0, r3
 80093bc:	3714      	adds	r7, #20
 80093be:	46bd      	mov	sp, r7
 80093c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80093c4:	4770      	bx	lr

080093c6 <_fx_utility_16_unsigned_write>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _fx_utility_16_unsigned_write(UCHAR *dest_ptr, UINT value)
{
 80093c6:	b480      	push	{r7}
 80093c8:	b083      	sub	sp, #12
 80093ca:	af00      	add	r7, sp, #0
 80093cc:	6078      	str	r0, [r7, #4]
 80093ce:	6039      	str	r1, [r7, #0]

    /* Store the UINT into the destination with endian-awareness.  */
    *(dest_ptr) =       (UCHAR)(value & 0xFF);
 80093d0:	683b      	ldr	r3, [r7, #0]
 80093d2:	b2da      	uxtb	r2, r3
 80093d4:	687b      	ldr	r3, [r7, #4]
 80093d6:	701a      	strb	r2, [r3, #0]
    *(dest_ptr + 1) =   (UCHAR)((value >> 8) & 0xFF);
 80093d8:	683b      	ldr	r3, [r7, #0]
 80093da:	0a1a      	lsrs	r2, r3, #8
 80093dc:	687b      	ldr	r3, [r7, #4]
 80093de:	3301      	adds	r3, #1
 80093e0:	b2d2      	uxtb	r2, r2
 80093e2:	701a      	strb	r2, [r3, #0]
}
 80093e4:	bf00      	nop
 80093e6:	370c      	adds	r7, #12
 80093e8:	46bd      	mov	sp, r7
 80093ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80093ee:	4770      	bx	lr

080093f0 <_fx_utility_32_unsigned_read>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG  _fx_utility_32_unsigned_read(UCHAR *source_ptr)
{
 80093f0:	b480      	push	{r7}
 80093f2:	b085      	sub	sp, #20
 80093f4:	af00      	add	r7, sp, #0
 80093f6:	6078      	str	r0, [r7, #4]

ULONG value;

    /* Pickup the UINT from the destination with endian-awareness.  */
    value =  ((((ULONG) *(source_ptr+3)) & 0xFF) << 24) |
 80093f8:	687b      	ldr	r3, [r7, #4]
 80093fa:	3303      	adds	r3, #3
 80093fc:	781b      	ldrb	r3, [r3, #0]
 80093fe:	061a      	lsls	r2, r3, #24
             ((((ULONG) *(source_ptr+2)) & 0xFF) << 16) |
 8009400:	687b      	ldr	r3, [r7, #4]
 8009402:	3302      	adds	r3, #2
 8009404:	781b      	ldrb	r3, [r3, #0]
 8009406:	041b      	lsls	r3, r3, #16
    value =  ((((ULONG) *(source_ptr+3)) & 0xFF) << 24) |
 8009408:	431a      	orrs	r2, r3
             ((((ULONG) *(source_ptr+1)) & 0xFF) << 8)  |
 800940a:	687b      	ldr	r3, [r7, #4]
 800940c:	3301      	adds	r3, #1
 800940e:	781b      	ldrb	r3, [r3, #0]
 8009410:	021b      	lsls	r3, r3, #8
             ((((ULONG) *(source_ptr+2)) & 0xFF) << 16) |
 8009412:	4313      	orrs	r3, r2
              (((ULONG) *(source_ptr)) & 0xFF);
 8009414:	687a      	ldr	r2, [r7, #4]
 8009416:	7812      	ldrb	r2, [r2, #0]
    value =  ((((ULONG) *(source_ptr+3)) & 0xFF) << 24) |
 8009418:	4313      	orrs	r3, r2
 800941a:	60fb      	str	r3, [r7, #12]

    /* Return value to caller.  */
    return(value);
 800941c:	68fb      	ldr	r3, [r7, #12]
}
 800941e:	4618      	mov	r0, r3
 8009420:	3714      	adds	r7, #20
 8009422:	46bd      	mov	sp, r7
 8009424:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009428:	4770      	bx	lr

0800942a <_fx_utility_32_unsigned_write>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _fx_utility_32_unsigned_write(UCHAR *dest_ptr, ULONG value)
{
 800942a:	b480      	push	{r7}
 800942c:	b083      	sub	sp, #12
 800942e:	af00      	add	r7, sp, #0
 8009430:	6078      	str	r0, [r7, #4]
 8009432:	6039      	str	r1, [r7, #0]

    /* Store the UINT into the destination with endian-awareness.  */
    *(dest_ptr) =       (UCHAR)(value & 0xFF);
 8009434:	683b      	ldr	r3, [r7, #0]
 8009436:	b2da      	uxtb	r2, r3
 8009438:	687b      	ldr	r3, [r7, #4]
 800943a:	701a      	strb	r2, [r3, #0]
    *(dest_ptr + 1) =   (UCHAR)((value >> 8) & 0xFF);
 800943c:	683b      	ldr	r3, [r7, #0]
 800943e:	0a1a      	lsrs	r2, r3, #8
 8009440:	687b      	ldr	r3, [r7, #4]
 8009442:	3301      	adds	r3, #1
 8009444:	b2d2      	uxtb	r2, r2
 8009446:	701a      	strb	r2, [r3, #0]
    *(dest_ptr + 2) =   (UCHAR)((value >> 16) & 0xFF);
 8009448:	683b      	ldr	r3, [r7, #0]
 800944a:	0c1a      	lsrs	r2, r3, #16
 800944c:	687b      	ldr	r3, [r7, #4]
 800944e:	3302      	adds	r3, #2
 8009450:	b2d2      	uxtb	r2, r2
 8009452:	701a      	strb	r2, [r3, #0]
    *(dest_ptr + 3) =   (UCHAR)((value >> 24) & 0xFF);
 8009454:	683b      	ldr	r3, [r7, #0]
 8009456:	0e1a      	lsrs	r2, r3, #24
 8009458:	687b      	ldr	r3, [r7, #4]
 800945a:	3303      	adds	r3, #3
 800945c:	b2d2      	uxtb	r2, r2
 800945e:	701a      	strb	r2, [r3, #0]
}
 8009460:	bf00      	nop
 8009462:	370c      	adds	r7, #12
 8009464:	46bd      	mov	sp, r7
 8009466:	f85d 7b04 	ldr.w	r7, [sp], #4
 800946a:	4770      	bx	lr

0800946c <_fx_utility_FAT_entry_read>:
/*                                            fixed compiler warning,     */
/*                                            resulting in version 6.2.0  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_FAT_entry_read(FX_MEDIA *media_ptr, ULONG cluster, ULONG *entry_ptr)
{
 800946c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8009470:	b098      	sub	sp, #96	; 0x60
 8009472:	af04      	add	r7, sp, #16
 8009474:	61f8      	str	r0, [r7, #28]
 8009476:	61b9      	str	r1, [r7, #24]
 8009478:	617a      	str	r2, [r7, #20]
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

#ifndef FX_MEDIA_STATISTICS_DISABLE
    /* Increment the number of FAT entry reads and cache hits.  */
    media_ptr -> fx_media_fat_entry_reads++;
 800947a:	69fb      	ldr	r3, [r7, #28]
 800947c:	f8d3 3178 	ldr.w	r3, [r3, #376]	; 0x178
 8009480:	1c5a      	adds	r2, r3, #1
 8009482:	69fb      	ldr	r3, [r7, #28]
 8009484:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
    media_ptr -> fx_media_fat_entry_cache_read_hits++;
 8009488:	69fb      	ldr	r3, [r7, #28]
 800948a:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 800948e:	1c5a      	adds	r2, r3, #1
 8009490:	69fb      	ldr	r3, [r7, #28]
 8009492:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180

    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_FAT_ENTRY_READ_EXTENSION

    /* Calculate the area of the cache for this FAT entry.  */
    index =  (cluster & FX_FAT_CACHE_HASH_MASK) * FX_FAT_CACHE_DEPTH;
 8009496:	69bb      	ldr	r3, [r7, #24]
 8009498:	f003 0303 	and.w	r3, r3, #3
 800949c:	009b      	lsls	r3, r3, #2
 800949e:	647b      	str	r3, [r7, #68]	; 0x44

    /* Build a pointer to the cache entry.  */
    cache_entry_ptr =  &media_ptr -> fx_media_fat_cache[index];
 80094a0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80094a2:	4613      	mov	r3, r2
 80094a4:	005b      	lsls	r3, r3, #1
 80094a6:	4413      	add	r3, r2
 80094a8:	009b      	lsls	r3, r3, #2
 80094aa:	f503 63eb 	add.w	r3, r3, #1880	; 0x758
 80094ae:	69fa      	ldr	r2, [r7, #28]
 80094b0:	4413      	add	r3, r2
 80094b2:	643b      	str	r3, [r7, #64]	; 0x40

#ifndef FX_DISABLE_FAT_ENTRY_REFRESH
    /* Determine if the FAT entry is in the cache - assuming the depth of the FAT cache is
       4 entries.  */
    if ((cache_entry_ptr -> fx_fat_cache_entry_cluster) == cluster)
 80094b4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80094b6:	681b      	ldr	r3, [r3, #0]
 80094b8:	69ba      	ldr	r2, [r7, #24]
 80094ba:	429a      	cmp	r2, r3
 80094bc:	d105      	bne.n	80094ca <_fx_utility_FAT_entry_read+0x5e>
    {

        /* Yes, return the cached value.  */
        *entry_ptr =  cache_entry_ptr -> fx_fat_cache_entry_value;
 80094be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80094c0:	685a      	ldr	r2, [r3, #4]
 80094c2:	697b      	ldr	r3, [r7, #20]
 80094c4:	601a      	str	r2, [r3, #0]

        /* Don't move anything since we found the entry.  */

        /* Return a successful status.  */
        return(FX_SUCCESS);
 80094c6:	2300      	movs	r3, #0
 80094c8:	e1f4      	b.n	80098b4 <_fx_utility_FAT_entry_read+0x448>
    }
    else if (((cache_entry_ptr + 1) -> fx_fat_cache_entry_cluster) == cluster)
 80094ca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80094cc:	330c      	adds	r3, #12
 80094ce:	681b      	ldr	r3, [r3, #0]
 80094d0:	69ba      	ldr	r2, [r7, #24]
 80094d2:	429a      	cmp	r2, r3
 80094d4:	d11d      	bne.n	8009512 <_fx_utility_FAT_entry_read+0xa6>
    {

        /* Yes, return the cached value.  */
        *entry_ptr =  (cache_entry_ptr + 1) -> fx_fat_cache_entry_value;
 80094d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80094d8:	330c      	adds	r3, #12
 80094da:	685a      	ldr	r2, [r3, #4]
 80094dc:	697b      	ldr	r3, [r7, #20]
 80094de:	601a      	str	r2, [r3, #0]

        /* Just swap the first and second entry.  */
        temp_cache_entry =        *(cache_entry_ptr);
 80094e0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80094e2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80094e6:	ca07      	ldmia	r2, {r0, r1, r2}
 80094e8:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        *(cache_entry_ptr) =      *(cache_entry_ptr + 1);
 80094ec:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80094ee:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80094f0:	4614      	mov	r4, r2
 80094f2:	330c      	adds	r3, #12
 80094f4:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80094f8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 1) =  temp_cache_entry;
 80094fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80094fe:	330c      	adds	r3, #12
 8009500:	461c      	mov	r4, r3
 8009502:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009506:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800950a:	e884 0007 	stmia.w	r4, {r0, r1, r2}

        /* Return a successful status.  */
        return(FX_SUCCESS);
 800950e:	2300      	movs	r3, #0
 8009510:	e1d0      	b.n	80098b4 <_fx_utility_FAT_entry_read+0x448>
    }
    else if (((cache_entry_ptr + 2) -> fx_fat_cache_entry_cluster) == cluster)
 8009512:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009514:	3318      	adds	r3, #24
 8009516:	681b      	ldr	r3, [r3, #0]
 8009518:	69ba      	ldr	r2, [r7, #24]
 800951a:	429a      	cmp	r2, r3
 800951c:	d127      	bne.n	800956e <_fx_utility_FAT_entry_read+0x102>
    {

        /* Yes, return the cached value.  */
        *entry_ptr =  (cache_entry_ptr + 2) -> fx_fat_cache_entry_value;
 800951e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009520:	3318      	adds	r3, #24
 8009522:	685a      	ldr	r2, [r3, #4]
 8009524:	697b      	ldr	r3, [r7, #20]
 8009526:	601a      	str	r2, [r3, #0]

        /* Move the third entry to the top and the first two entries down.  */
        temp_cache_entry =        *(cache_entry_ptr);
 8009528:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800952a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800952e:	ca07      	ldmia	r2, {r0, r1, r2}
 8009530:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        *(cache_entry_ptr) =      *(cache_entry_ptr + 2);
 8009534:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8009536:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009538:	4614      	mov	r4, r2
 800953a:	3318      	adds	r3, #24
 800953c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8009540:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 8009544:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009546:	f103 0218 	add.w	r2, r3, #24
 800954a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800954c:	4614      	mov	r4, r2
 800954e:	330c      	adds	r3, #12
 8009550:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8009554:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 1) =  temp_cache_entry;
 8009558:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800955a:	330c      	adds	r3, #12
 800955c:	461c      	mov	r4, r3
 800955e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009562:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8009566:	e884 0007 	stmia.w	r4, {r0, r1, r2}

        /* Return a successful status.  */
        return(FX_SUCCESS);
 800956a:	2300      	movs	r3, #0
 800956c:	e1a2      	b.n	80098b4 <_fx_utility_FAT_entry_read+0x448>
    }
    else if (((cache_entry_ptr + 3) -> fx_fat_cache_entry_cluster) == cluster)
 800956e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009570:	3324      	adds	r3, #36	; 0x24
 8009572:	681b      	ldr	r3, [r3, #0]
 8009574:	69ba      	ldr	r2, [r7, #24]
 8009576:	429a      	cmp	r2, r3
 8009578:	d131      	bne.n	80095de <_fx_utility_FAT_entry_read+0x172>
    {

        /* Yes, return the cached value.  */
        *entry_ptr =  (cache_entry_ptr + 3) -> fx_fat_cache_entry_value;
 800957a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800957c:	3324      	adds	r3, #36	; 0x24
 800957e:	685a      	ldr	r2, [r3, #4]
 8009580:	697b      	ldr	r3, [r7, #20]
 8009582:	601a      	str	r2, [r3, #0]

        /* Move the last entry to the top and the first three entries down.  */
        temp_cache_entry =        *(cache_entry_ptr);
 8009584:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8009586:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800958a:	ca07      	ldmia	r2, {r0, r1, r2}
 800958c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        *(cache_entry_ptr) =      *(cache_entry_ptr + 3);
 8009590:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8009592:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009594:	4614      	mov	r4, r2
 8009596:	3324      	adds	r3, #36	; 0x24
 8009598:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800959c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 80095a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80095a2:	f103 0224 	add.w	r2, r3, #36	; 0x24
 80095a6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80095a8:	4614      	mov	r4, r2
 80095aa:	3318      	adds	r3, #24
 80095ac:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80095b0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 80095b4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80095b6:	f103 0218 	add.w	r2, r3, #24
 80095ba:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80095bc:	4614      	mov	r4, r2
 80095be:	330c      	adds	r3, #12
 80095c0:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80095c4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        *(cache_entry_ptr + 1) =  temp_cache_entry;
 80095c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80095ca:	330c      	adds	r3, #12
 80095cc:	461c      	mov	r4, r3
 80095ce:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80095d2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80095d6:	e884 0007 	stmia.w	r4, {r0, r1, r2}

        /* Return a successful status.  */
        return(FX_SUCCESS);
 80095da:	2300      	movs	r3, #0
 80095dc:	e16a      	b.n	80098b4 <_fx_utility_FAT_entry_read+0x448>
    }
#endif /* FX_DISABLE_FAT_ENTRY_REFRESH */

    /* Determine if the oldest entry was modified, i.e. whether or not it is
       dirty.  */
    if (media_ptr -> fx_media_fat_cache[index + 3].fx_fat_cache_entry_dirty)
 80095de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80095e0:	1cda      	adds	r2, r3, #3
 80095e2:	69f9      	ldr	r1, [r7, #28]
 80095e4:	4613      	mov	r3, r2
 80095e6:	005b      	lsls	r3, r3, #1
 80095e8:	4413      	add	r3, r2
 80095ea:	009b      	lsls	r3, r3, #2
 80095ec:	440b      	add	r3, r1
 80095ee:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 80095f2:	681b      	ldr	r3, [r3, #0]
 80095f4:	2b00      	cmp	r3, #0
 80095f6:	d008      	beq.n	800960a <_fx_utility_FAT_entry_read+0x19e>
    {

        /* Yes, the entry is dirty and needs to be flushed out.  */
        status = _fx_utility_FAT_flush(media_ptr);
 80095f8:	69f8      	ldr	r0, [r7, #28]
 80095fa:	f000 f960 	bl	80098be <_fx_utility_FAT_flush>
 80095fe:	63f8      	str	r0, [r7, #60]	; 0x3c

        /* Check for completion status.  */
        if (status != FX_SUCCESS)
 8009600:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009602:	2b00      	cmp	r3, #0
 8009604:	d001      	beq.n	800960a <_fx_utility_FAT_entry_read+0x19e>
        {

            /* Return error status.  */
            return(status);
 8009606:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009608:	e154      	b.n	80098b4 <_fx_utility_FAT_entry_read+0x448>
       actually read the FAT entry.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Decrement the number of cache hits.  */
    media_ptr -> fx_media_fat_entry_cache_read_hits--;
 800960a:	69fb      	ldr	r3, [r7, #28]
 800960c:	f8d3 3180 	ldr.w	r3, [r3, #384]	; 0x180
 8009610:	1e5a      	subs	r2, r3, #1
 8009612:	69fb      	ldr	r3, [r7, #28]
 8009614:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180

    /* Increment the number of cache misses.  */
    media_ptr -> fx_media_fat_entry_cache_read_misses++;
 8009618:	69fb      	ldr	r3, [r7, #28]
 800961a:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
 800961e:	1c5a      	adds	r2, r3, #1
 8009620:	69fb      	ldr	r3, [r7, #28]
 8009622:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
#endif

    /* Determine which type of FAT is present.  */
    if (media_ptr -> fx_media_12_bit_FAT)
 8009626:	69fb      	ldr	r3, [r7, #28]
 8009628:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800962a:	2b00      	cmp	r3, #0
 800962c:	f000 80a7 	beq.w	800977e <_fx_utility_FAT_entry_read+0x312>
    {

        /* Calculate the byte offset to the cluster entry.  */
        byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 8009630:	69bb      	ldr	r3, [r7, #24]
 8009632:	005a      	lsls	r2, r3, #1
 8009634:	69bb      	ldr	r3, [r7, #24]
 8009636:	4413      	add	r3, r2
 8009638:	085b      	lsrs	r3, r3, #1
 800963a:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Calculate the FAT sector the requested FAT entry resides in.  */
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800963c:	69fb      	ldr	r3, [r7, #28]
 800963e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009640:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8009642:	fbb2 f2f3 	udiv	r2, r2, r3
            (ULONG)media_ptr -> fx_media_reserved_sectors;
 8009646:	69fb      	ldr	r3, [r7, #28]
 8009648:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800964a:	4413      	add	r3, r2
 800964c:	637b      	str	r3, [r7, #52]	; 0x34

        /* Read the sector in.  */
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800964e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009650:	2200      	movs	r2, #0
 8009652:	60bb      	str	r3, [r7, #8]
 8009654:	60fa      	str	r2, [r7, #12]
                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 8009656:	69fb      	ldr	r3, [r7, #28]
 8009658:	689b      	ldr	r3, [r3, #8]
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800965a:	2202      	movs	r2, #2
 800965c:	9202      	str	r2, [sp, #8]
 800965e:	2201      	movs	r2, #1
 8009660:	9201      	str	r2, [sp, #4]
 8009662:	9300      	str	r3, [sp, #0]
 8009664:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8009668:	69f8      	ldr	r0, [r7, #28]
 800966a:	f001 f959 	bl	800a920 <_fx_utility_logical_sector_read>
 800966e:	63f8      	str	r0, [r7, #60]	; 0x3c

        /* Determine if an error occurred.  */
        if (status != FX_SUCCESS)
 8009670:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009672:	2b00      	cmp	r3, #0
 8009674:	d001      	beq.n	800967a <_fx_utility_FAT_entry_read+0x20e>
        {
            /* Return the error status.  */
            return(status);
 8009676:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009678:	e11c      	b.n	80098b4 <_fx_utility_FAT_entry_read+0x448>
        }

        /* Now calculate the byte offset into this FAT sector.  */
        byte_offset =  byte_offset -
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 800967a:	69fb      	ldr	r3, [r7, #28]
 800967c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800967e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009680:	1ad3      	subs	r3, r2, r3
             media_ptr -> fx_media_bytes_per_sector);
 8009682:	69fa      	ldr	r2, [r7, #28]
 8009684:	6a92      	ldr	r2, [r2, #40]	; 0x28
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8009686:	fb02 f303 	mul.w	r3, r2, r3
        byte_offset =  byte_offset -
 800968a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800968c:	1ad3      	subs	r3, r2, r3
 800968e:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Setup a pointer into the buffer.  */
        FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 8009690:	69fb      	ldr	r3, [r7, #28]
 8009692:	689a      	ldr	r2, [r3, #8]
 8009694:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009696:	4413      	add	r3, r2
 8009698:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Determine if the cluster entry is odd or even.  */
        if (cluster & 1)
 800969a:	69bb      	ldr	r3, [r7, #24]
 800969c:	f003 0301 	and.w	r3, r3, #1
 80096a0:	2b00      	cmp	r3, #0
 80096a2:	d030      	beq.n	8009706 <_fx_utility_FAT_entry_read+0x29a>
        {

            /* Odd cluster number.  */

            /* Pickup the lower nibble of the FAT entry.  */
            entry =  (((UINT)*FAT_ptr) & 0xF0) >> 4;
 80096a4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80096a6:	781b      	ldrb	r3, [r3, #0]
 80096a8:	091b      	lsrs	r3, r3, #4
 80096aa:	b2db      	uxtb	r3, r3
 80096ac:	64bb      	str	r3, [r7, #72]	; 0x48

            /* Move to the next byte of the FAT entry.  */
            FAT_ptr++;
 80096ae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80096b0:	3301      	adds	r3, #1
 80096b2:	64fb      	str	r3, [r7, #76]	; 0x4c

            /* Determine if we are now past the end of the FAT buffer in memory.  */
            if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 80096b4:	69fb      	ldr	r3, [r7, #28]
 80096b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80096b8:	3b01      	subs	r3, #1
 80096ba:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80096bc:	429a      	cmp	r2, r3
 80096be:	d11b      	bne.n	80096f8 <_fx_utility_FAT_entry_read+0x28c>
            {

                /* Yes, we need to read the next sector.  */
                FAT_sector++;
 80096c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80096c2:	3301      	adds	r3, #1
 80096c4:	637b      	str	r3, [r7, #52]	; 0x34
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 80096c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80096c8:	2200      	movs	r2, #0
 80096ca:	603b      	str	r3, [r7, #0]
 80096cc:	607a      	str	r2, [r7, #4]
                                                          media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 80096ce:	69fb      	ldr	r3, [r7, #28]
 80096d0:	689b      	ldr	r3, [r3, #8]
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 80096d2:	2202      	movs	r2, #2
 80096d4:	9202      	str	r2, [sp, #8]
 80096d6:	2201      	movs	r2, #1
 80096d8:	9201      	str	r2, [sp, #4]
 80096da:	9300      	str	r3, [sp, #0]
 80096dc:	e9d7 2300 	ldrd	r2, r3, [r7]
 80096e0:	69f8      	ldr	r0, [r7, #28]
 80096e2:	f001 f91d 	bl	800a920 <_fx_utility_logical_sector_read>
 80096e6:	63f8      	str	r0, [r7, #60]	; 0x3c

                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 80096e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80096ea:	2b00      	cmp	r3, #0
 80096ec:	d001      	beq.n	80096f2 <_fx_utility_FAT_entry_read+0x286>
                {

                    /* Return the error status.  */
                    return(status);
 80096ee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80096f0:	e0e0      	b.n	80098b4 <_fx_utility_FAT_entry_read+0x448>
                }

                /* Setup a pointer into the buffer.  */
                FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer;
 80096f2:	69fb      	ldr	r3, [r7, #28]
 80096f4:	689b      	ldr	r3, [r3, #8]
 80096f6:	64fb      	str	r3, [r7, #76]	; 0x4c
            }

            /* Pickup the upper 8 bits of the FAT entry.  */
            entry =  entry | (((UINT)*FAT_ptr) << 4);
 80096f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80096fa:	781b      	ldrb	r3, [r3, #0]
 80096fc:	011b      	lsls	r3, r3, #4
 80096fe:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8009700:	4313      	orrs	r3, r2
 8009702:	64bb      	str	r3, [r7, #72]	; 0x48
 8009704:	e02f      	b.n	8009766 <_fx_utility_FAT_entry_read+0x2fa>
        {

            /* Even cluster number.  */

            /* Pickup the lower byte of the FAT entry.  */
            entry =  (UINT)(((UINT)*FAT_ptr) & 0xFF);
 8009706:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8009708:	781b      	ldrb	r3, [r3, #0]
 800970a:	64bb      	str	r3, [r7, #72]	; 0x48

            /* Move to the next nibble of the FAT entry.  */
            FAT_ptr++;
 800970c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800970e:	3301      	adds	r3, #1
 8009710:	64fb      	str	r3, [r7, #76]	; 0x4c

            /* Determine if we are now past the end of the FAT buffer in memory.  */
            if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 8009712:	69fb      	ldr	r3, [r7, #28]
 8009714:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009716:	3b01      	subs	r3, #1
 8009718:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800971a:	429a      	cmp	r2, r3
 800971c:	d11b      	bne.n	8009756 <_fx_utility_FAT_entry_read+0x2ea>
            {

                /* Yes, we need to read the next sector.  */
                FAT_sector++;
 800971e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009720:	3301      	adds	r3, #1
 8009722:	637b      	str	r3, [r7, #52]	; 0x34
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8009724:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009726:	2200      	movs	r2, #0
 8009728:	469a      	mov	sl, r3
 800972a:	4693      	mov	fp, r2
                                                          media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800972c:	69fb      	ldr	r3, [r7, #28]
 800972e:	689b      	ldr	r3, [r3, #8]
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8009730:	2202      	movs	r2, #2
 8009732:	9202      	str	r2, [sp, #8]
 8009734:	2201      	movs	r2, #1
 8009736:	9201      	str	r2, [sp, #4]
 8009738:	9300      	str	r3, [sp, #0]
 800973a:	4652      	mov	r2, sl
 800973c:	465b      	mov	r3, fp
 800973e:	69f8      	ldr	r0, [r7, #28]
 8009740:	f001 f8ee 	bl	800a920 <_fx_utility_logical_sector_read>
 8009744:	63f8      	str	r0, [r7, #60]	; 0x3c

                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 8009746:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009748:	2b00      	cmp	r3, #0
 800974a:	d001      	beq.n	8009750 <_fx_utility_FAT_entry_read+0x2e4>
                {
                    return(status);
 800974c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800974e:	e0b1      	b.n	80098b4 <_fx_utility_FAT_entry_read+0x448>
                }

                /* Setup a pointer into the buffer.  */
                FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer;
 8009750:	69fb      	ldr	r3, [r7, #28]
 8009752:	689b      	ldr	r3, [r3, #8]
 8009754:	64fb      	str	r3, [r7, #76]	; 0x4c
            }

            /* Pickup the upper 4 bits of the FAT entry.  */
            entry =  entry | ((((UINT)*FAT_ptr) & 0x0F) << 8);
 8009756:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8009758:	781b      	ldrb	r3, [r3, #0]
 800975a:	021b      	lsls	r3, r3, #8
 800975c:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8009760:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8009762:	4313      	orrs	r3, r2
 8009764:	64bb      	str	r3, [r7, #72]	; 0x48
        }

        /* Determine if we need to do sign extension on the 12-bit eof value.  */
        if (entry >= FX_MAX_12BIT_CLUST)
 8009766:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8009768:	f5b3 6f7f 	cmp.w	r3, #4080	; 0xff0
 800976c:	d303      	bcc.n	8009776 <_fx_utility_FAT_entry_read+0x30a>
        {

            /* Yes, we need to sign extend.  */
            entry =  entry | FX_SIGN_EXTEND;
 800976e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8009770:	f443 4370 	orr.w	r3, r3, #61440	; 0xf000
 8009774:	64bb      	str	r3, [r7, #72]	; 0x48
        }

        *entry_ptr =  entry;
 8009776:	697b      	ldr	r3, [r7, #20]
 8009778:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800977a:	601a      	str	r2, [r3, #0]
 800977c:	e078      	b.n	8009870 <_fx_utility_FAT_entry_read+0x404>

    /* Check for a 16-bit FAT.  */
#ifdef FX_ENABLE_EXFAT
    else if (FX_FAT16  == media_ptr -> fx_media_FAT_type)
#else
    else if (!media_ptr -> fx_media_32_bit_FAT)
 800977e:	69fb      	ldr	r3, [r7, #28]
 8009780:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8009782:	2b00      	cmp	r3, #0
 8009784:	d139      	bne.n	80097fa <_fx_utility_FAT_entry_read+0x38e>
    {

        /* 16-bit FAT is present.  */

        /* Calculate the byte offset to the cluster entry.  */
        byte_offset =  (((ULONG)cluster) * 2);
 8009786:	69bb      	ldr	r3, [r7, #24]
 8009788:	005b      	lsls	r3, r3, #1
 800978a:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Calculate the FAT sector the requested FAT entry resides in.  */
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800978c:	69fb      	ldr	r3, [r7, #28]
 800978e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009790:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8009792:	fbb2 f2f3 	udiv	r2, r2, r3
            (ULONG)media_ptr -> fx_media_reserved_sectors;
 8009796:	69fb      	ldr	r3, [r7, #28]
 8009798:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800979a:	4413      	add	r3, r2
 800979c:	637b      	str	r3, [r7, #52]	; 0x34

        /* Read the FAT sector.  */
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800979e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80097a0:	2200      	movs	r2, #0
 80097a2:	4698      	mov	r8, r3
 80097a4:	4691      	mov	r9, r2
                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 80097a6:	69fb      	ldr	r3, [r7, #28]
 80097a8:	689b      	ldr	r3, [r3, #8]
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 80097aa:	2202      	movs	r2, #2
 80097ac:	9202      	str	r2, [sp, #8]
 80097ae:	2201      	movs	r2, #1
 80097b0:	9201      	str	r2, [sp, #4]
 80097b2:	9300      	str	r3, [sp, #0]
 80097b4:	4642      	mov	r2, r8
 80097b6:	464b      	mov	r3, r9
 80097b8:	69f8      	ldr	r0, [r7, #28]
 80097ba:	f001 f8b1 	bl	800a920 <_fx_utility_logical_sector_read>
 80097be:	63f8      	str	r0, [r7, #60]	; 0x3c

        /* Determine if an error occurred.  */
        if (status != FX_SUCCESS)
 80097c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80097c2:	2b00      	cmp	r3, #0
 80097c4:	d001      	beq.n	80097ca <_fx_utility_FAT_entry_read+0x35e>
        {

            /* Return the error code.  */
            return(status);
 80097c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80097c8:	e074      	b.n	80098b4 <_fx_utility_FAT_entry_read+0x448>
        }

        /* Now calculate the byte offset into this FAT sector.  */
        byte_offset =  byte_offset -
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 80097ca:	69fb      	ldr	r3, [r7, #28]
 80097cc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80097ce:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80097d0:	1ad3      	subs	r3, r2, r3
             media_ptr -> fx_media_bytes_per_sector);
 80097d2:	69fa      	ldr	r2, [r7, #28]
 80097d4:	6a92      	ldr	r2, [r2, #40]	; 0x28
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 80097d6:	fb02 f303 	mul.w	r3, r2, r3
        byte_offset =  byte_offset -
 80097da:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80097dc:	1ad3      	subs	r3, r2, r3
 80097de:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Setup a pointer into the buffer.  */
        FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 80097e0:	69fb      	ldr	r3, [r7, #28]
 80097e2:	689a      	ldr	r2, [r3, #8]
 80097e4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80097e6:	4413      	add	r3, r2
 80097e8:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Pickup the FAT entry.  */
        entry =  _fx_utility_16_unsigned_read(FAT_ptr);
 80097ea:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80097ec:	f7ff fdd8 	bl	80093a0 <_fx_utility_16_unsigned_read>
 80097f0:	64b8      	str	r0, [r7, #72]	; 0x48

        *entry_ptr =  entry;
 80097f2:	697b      	ldr	r3, [r7, #20]
 80097f4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80097f6:	601a      	str	r2, [r3, #0]
 80097f8:	e03a      	b.n	8009870 <_fx_utility_FAT_entry_read+0x404>
    else
#endif /* FX_ENABLE_EXFAT */
    {

        /* Otherwise, a 32 bit FAT present.  */
        byte_offset =  (((ULONG)cluster) * 4);
 80097fa:	69bb      	ldr	r3, [r7, #24]
 80097fc:	009b      	lsls	r3, r3, #2
 80097fe:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Calculate the FAT sector the requested FAT entry resides in.  */
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009800:	69fb      	ldr	r3, [r7, #28]
 8009802:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009804:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8009806:	fbb2 f2f3 	udiv	r2, r2, r3
            (ULONG)media_ptr -> fx_media_reserved_sectors;
 800980a:	69fb      	ldr	r3, [r7, #28]
 800980c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 800980e:	4413      	add	r3, r2
 8009810:	637b      	str	r3, [r7, #52]	; 0x34

        /* Calculate the byte offset to the FAT entry.  */
        byte_offset = (byte_offset % media_ptr -> fx_media_bytes_per_sector);
 8009812:	69fb      	ldr	r3, [r7, #28]
 8009814:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009816:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009818:	fbb3 f1f2 	udiv	r1, r3, r2
 800981c:	fb01 f202 	mul.w	r2, r1, r2
 8009820:	1a9b      	subs	r3, r3, r2
 8009822:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Read the appropriate FAT sector.  */
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8009824:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009826:	2200      	movs	r2, #0
 8009828:	461c      	mov	r4, r3
 800982a:	4615      	mov	r5, r2
                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 800982c:	69fb      	ldr	r3, [r7, #28]
 800982e:	689b      	ldr	r3, [r3, #8]
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8009830:	2202      	movs	r2, #2
 8009832:	9202      	str	r2, [sp, #8]
 8009834:	2201      	movs	r2, #1
 8009836:	9201      	str	r2, [sp, #4]
 8009838:	9300      	str	r3, [sp, #0]
 800983a:	4622      	mov	r2, r4
 800983c:	462b      	mov	r3, r5
 800983e:	69f8      	ldr	r0, [r7, #28]
 8009840:	f001 f86e 	bl	800a920 <_fx_utility_logical_sector_read>
 8009844:	63f8      	str	r0, [r7, #60]	; 0x3c

        /* Determine if an error occurred.  */
        if (status != FX_SUCCESS)
 8009846:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009848:	2b00      	cmp	r3, #0
 800984a:	d001      	beq.n	8009850 <_fx_utility_FAT_entry_read+0x3e4>
        {

            /* Return the error code.  */
            return(status);
 800984c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800984e:	e031      	b.n	80098b4 <_fx_utility_FAT_entry_read+0x448>
        }

        /* Setup a pointer into the buffer.  */
        FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (ULONG)byte_offset;
 8009850:	69fb      	ldr	r3, [r7, #28]
 8009852:	689a      	ldr	r2, [r3, #8]
 8009854:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009856:	4413      	add	r3, r2
 8009858:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Pickup the FAT entry.  */
        entry32 =  _fx_utility_32_unsigned_read(FAT_ptr);
 800985a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800985c:	f7ff fdc8 	bl	80093f0 <_fx_utility_32_unsigned_read>
 8009860:	6338      	str	r0, [r7, #48]	; 0x30
        if (media_ptr -> fx_media_FAT_type == FX_FAT32)
        {
#endif /* FX_ENABLE_EXFAT */

            /* Clear upper nibble.  */
            entry32 = entry32 & 0x0FFFFFFF;
 8009862:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009864:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8009868:	633b      	str	r3, [r7, #48]	; 0x30
#ifdef FX_ENABLE_EXFAT
        }
#endif /* FX_ENABLE_EXFAT */

        *entry_ptr =  entry32;
 800986a:	697b      	ldr	r3, [r7, #20]
 800986c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800986e:	601a      	str	r2, [r3, #0]
    }

    /* Move all the cache entries down so the oldest is at the bottom.  */
    *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 8009870:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009872:	f103 0224 	add.w	r2, r3, #36	; 0x24
 8009876:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009878:	4614      	mov	r4, r2
 800987a:	3318      	adds	r3, #24
 800987c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8009880:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 8009884:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009886:	f103 0218 	add.w	r2, r3, #24
 800988a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800988c:	4614      	mov	r4, r2
 800988e:	330c      	adds	r3, #12
 8009890:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8009894:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    *(cache_entry_ptr + 1) =  *(cache_entry_ptr);
 8009898:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800989a:	330c      	adds	r3, #12
 800989c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800989e:	ca07      	ldmia	r2, {r0, r1, r2}
 80098a0:	e883 0007 	stmia.w	r3, {r0, r1, r2}

    /* Setup the new FAT entry in the cache.  */
    cache_entry_ptr -> fx_fat_cache_entry_cluster =  cluster;
 80098a4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80098a6:	69ba      	ldr	r2, [r7, #24]
 80098a8:	601a      	str	r2, [r3, #0]
    cache_entry_ptr -> fx_fat_cache_entry_value   =  *entry_ptr;
 80098aa:	697b      	ldr	r3, [r7, #20]
 80098ac:	681a      	ldr	r2, [r3, #0]
 80098ae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80098b0:	605a      	str	r2, [r3, #4]

    /* Return success to the caller.  */
    return(FX_SUCCESS);
 80098b2:	2300      	movs	r3, #0
}
 80098b4:	4618      	mov	r0, r3
 80098b6:	3750      	adds	r7, #80	; 0x50
 80098b8:	46bd      	mov	sp, r7
 80098ba:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

080098be <_fx_utility_FAT_flush>:
/*                                            FAT secondary update map,   */
/*                                            resulting in version 6.1.2  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_FAT_flush(FX_MEDIA *media_ptr)
{
 80098be:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80098c2:	b09a      	sub	sp, #104	; 0x68
 80098c4:	af04      	add	r7, sp, #16
 80098c6:	61f8      	str	r0, [r7, #28]
INT    multi_sector_entry;
ULONG  sector;

#ifndef FX_MEDIA_STATISTICS_DISABLE
    /* Increment the number of cache flush requests.  */
    media_ptr -> fx_media_fat_cache_flushes++;
 80098c8:	69fb      	ldr	r3, [r7, #28]
 80098ca:	f8d3 3190 	ldr.w	r3, [r3, #400]	; 0x190
 80098ce:	1c5a      	adds	r2, r3, #1
 80098d0:	69fb      	ldr	r3, [r7, #28]
 80098d2:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
#endif

    /* Loop through the media's FAT cache and flush out dirty entries.  */
    for (index = 0; index < FX_MAX_FAT_CACHE; index++)
 80098d6:	2300      	movs	r3, #0
 80098d8:	64fb      	str	r3, [r7, #76]	; 0x4c
 80098da:	e337      	b.n	8009f4c <_fx_utility_FAT_flush+0x68e>
    {

        /* Determine if the entry is dirty.  */
        if ((media_ptr -> fx_media_fat_cache[index].fx_fat_cache_entry_dirty) == 0)
 80098dc:	69f9      	ldr	r1, [r7, #28]
 80098de:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80098e0:	4613      	mov	r3, r2
 80098e2:	005b      	lsls	r3, r3, #1
 80098e4:	4413      	add	r3, r2
 80098e6:	009b      	lsls	r3, r3, #2
 80098e8:	440b      	add	r3, r1
 80098ea:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 80098ee:	681b      	ldr	r3, [r3, #0]
 80098f0:	2b00      	cmp	r3, #0
 80098f2:	f000 8325 	beq.w	8009f40 <_fx_utility_FAT_flush+0x682>

        /* Otherwise, the entry is indeed dirty and must be flushed out.  Process
           relative to the type of FAT that is being used.  */

        /* Pickup the contents of the FAT cache entry.  */
        cluster =       media_ptr -> fx_media_fat_cache[index].fx_fat_cache_entry_cluster;
 80098f6:	69f9      	ldr	r1, [r7, #28]
 80098f8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80098fa:	4613      	mov	r3, r2
 80098fc:	005b      	lsls	r3, r3, #1
 80098fe:	4413      	add	r3, r2
 8009900:	009b      	lsls	r3, r3, #2
 8009902:	440b      	add	r3, r1
 8009904:	f503 63eb 	add.w	r3, r3, #1880	; 0x758
 8009908:	681b      	ldr	r3, [r3, #0]
 800990a:	643b      	str	r3, [r7, #64]	; 0x40

        /* Determine which type of FAT is present.  */
#ifdef FX_ENABLE_EXFAT
        if (media_ptr -> fx_media_FAT_type == FX_FAT12)
#else
        if (media_ptr -> fx_media_12_bit_FAT)
 800990c:	69fb      	ldr	r3, [r7, #28]
 800990e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8009910:	2b00      	cmp	r3, #0
 8009912:	f000 816c 	beq.w	8009bee <_fx_utility_FAT_flush+0x330>
#endif /* FX_ENABLE_EXFAT */
        {

            /* Calculate the byte offset to the cluster entry.  */
            byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 8009916:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009918:	005a      	lsls	r2, r3, #1
 800991a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800991c:	4413      	add	r3, r2
 800991e:	085b      	lsrs	r3, r3, #1
 8009920:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Calculate the FAT sector the requested FAT entry resides in.  */
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009922:	69fb      	ldr	r3, [r7, #28]
 8009924:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009926:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009928:	fbb2 f2f3 	udiv	r2, r2, r3
                (ULONG)media_ptr -> fx_media_reserved_sectors;
 800992c:	69fb      	ldr	r3, [r7, #28]
 800992e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009930:	4413      	add	r3, r2
 8009932:	657b      	str	r3, [r7, #84]	; 0x54

            /* Initialize as not written.  */
            multi_sector_entry = -1;
 8009934:	f04f 33ff 	mov.w	r3, #4294967295
 8009938:	647b      	str	r3, [r7, #68]	; 0x44

            for (;;)
            {

                /* Pickup the FAT sector.  */
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800993a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800993c:	2200      	movs	r2, #0
 800993e:	461c      	mov	r4, r3
 8009940:	4615      	mov	r5, r2
                                                          media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 8009942:	69fb      	ldr	r3, [r7, #28]
 8009944:	689a      	ldr	r2, [r3, #8]
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8009946:	2302      	movs	r3, #2
 8009948:	9302      	str	r3, [sp, #8]
 800994a:	2301      	movs	r3, #1
 800994c:	9301      	str	r3, [sp, #4]
 800994e:	9200      	str	r2, [sp, #0]
 8009950:	4622      	mov	r2, r4
 8009952:	462b      	mov	r3, r5
 8009954:	69f8      	ldr	r0, [r7, #28]
 8009956:	f000 ffe3 	bl	800a920 <_fx_utility_logical_sector_read>
 800995a:	63b8      	str	r0, [r7, #56]	; 0x38

                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 800995c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800995e:	2b00      	cmp	r3, #0
 8009960:	d001      	beq.n	8009966 <_fx_utility_FAT_flush+0xa8>
                {

                    /* Return the error status.  */
                    return(status);
 8009962:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009964:	e2f7      	b.n	8009f56 <_fx_utility_FAT_flush+0x698>
                }

                /* Determine if a mulit-sector FAT update is present.  */
                if (multi_sector_entry != -1)
 8009966:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8009968:	f1b3 3fff 	cmp.w	r3, #4294967295
 800996c:	d037      	beq.n	80099de <_fx_utility_FAT_flush+0x120>

                    /* Yes, store the remaining portion of the new FAT entry in the
                       next FAT sector.  */

                    /* Setup a pointer into the buffer.  */
                    FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer;
 800996e:	69fb      	ldr	r3, [r7, #28]
 8009970:	689b      	ldr	r3, [r3, #8]
 8009972:	62fb      	str	r3, [r7, #44]	; 0x2c

                    /* Pickup the cluster and next cluster.  */
                    cluster = (media_ptr -> fx_media_fat_cache[multi_sector_entry].fx_fat_cache_entry_cluster);
 8009974:	69f9      	ldr	r1, [r7, #28]
 8009976:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8009978:	4613      	mov	r3, r2
 800997a:	005b      	lsls	r3, r3, #1
 800997c:	4413      	add	r3, r2
 800997e:	009b      	lsls	r3, r3, #2
 8009980:	440b      	add	r3, r1
 8009982:	f503 63eb 	add.w	r3, r3, #1880	; 0x758
 8009986:	681b      	ldr	r3, [r3, #0]
 8009988:	643b      	str	r3, [r7, #64]	; 0x40
                    next_cluster = media_ptr -> fx_media_fat_cache[multi_sector_entry].fx_fat_cache_entry_value;
 800998a:	69f9      	ldr	r1, [r7, #28]
 800998c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800998e:	4613      	mov	r3, r2
 8009990:	005b      	lsls	r3, r3, #1
 8009992:	4413      	add	r3, r2
 8009994:	009b      	lsls	r3, r3, #2
 8009996:	440b      	add	r3, r1
 8009998:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 800999c:	681b      	ldr	r3, [r3, #0]
 800999e:	62bb      	str	r3, [r7, #40]	; 0x28

                    /* Determine if the cluster entry is odd or even.  */
                    if (cluster & 1)
 80099a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80099a2:	f003 0301 	and.w	r3, r3, #1
 80099a6:	2b00      	cmp	r3, #0
 80099a8:	d005      	beq.n	80099b6 <_fx_utility_FAT_flush+0xf8>
                    {

                        /* Store the upper 8 bits of the FAT entry.  */
                        *FAT_ptr =  (UCHAR)((next_cluster >> 4) & 0xFF);
 80099aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80099ac:	091b      	lsrs	r3, r3, #4
 80099ae:	b2db      	uxtb	r3, r3
 80099b0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80099b2:	7013      	strb	r3, [r2, #0]
 80099b4:	e010      	b.n	80099d8 <_fx_utility_FAT_flush+0x11a>
                    }
                    else
                    {

                        /* Store the upper 4 bits of the FAT entry.  */
                        temp =  ((UINT)*FAT_ptr) & 0xF0;
 80099b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80099b8:	781b      	ldrb	r3, [r3, #0]
 80099ba:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80099be:	627b      	str	r3, [r7, #36]	; 0x24
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster >> 8) & 0xF));
 80099c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80099c2:	b2da      	uxtb	r2, r3
 80099c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80099c6:	0a1b      	lsrs	r3, r3, #8
 80099c8:	b2db      	uxtb	r3, r3
 80099ca:	f003 030f 	and.w	r3, r3, #15
 80099ce:	b2db      	uxtb	r3, r3
 80099d0:	4313      	orrs	r3, r2
 80099d2:	b2db      	uxtb	r3, r3
 80099d4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80099d6:	7013      	strb	r3, [r2, #0]
                    }

                    /* Clear the multi-sector flag.  */
                    multi_sector_entry = -1;
 80099d8:	f04f 33ff 	mov.w	r3, #4294967295
 80099dc:	647b      	str	r3, [r7, #68]	; 0x44
                }

                /* Loop through the remainder of the cache to check for multiple entries
                   within the same FAT sector being written out.  */
                for (i = index; i < FX_MAX_FAT_CACHE; i++)
 80099de:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80099e0:	653b      	str	r3, [r7, #80]	; 0x50
 80099e2:	e0a0      	b.n	8009b26 <_fx_utility_FAT_flush+0x268>
                {

                    /* Is the cache entry dirty?  */
                    if ((media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty) == 0)
 80099e4:	69f9      	ldr	r1, [r7, #28]
 80099e6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80099e8:	4613      	mov	r3, r2
 80099ea:	005b      	lsls	r3, r3, #1
 80099ec:	4413      	add	r3, r2
 80099ee:	009b      	lsls	r3, r3, #2
 80099f0:	440b      	add	r3, r1
 80099f2:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 80099f6:	681b      	ldr	r3, [r3, #0]
 80099f8:	2b00      	cmp	r3, #0
 80099fa:	f000 808a 	beq.w	8009b12 <_fx_utility_FAT_flush+0x254>
                        /* Not dirty, does not need to be flushed.  */
                        continue;
                    }

                    /* Isolate the cluster.  */
                    cluster = (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster);
 80099fe:	69f9      	ldr	r1, [r7, #28]
 8009a00:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009a02:	4613      	mov	r3, r2
 8009a04:	005b      	lsls	r3, r3, #1
 8009a06:	4413      	add	r3, r2
 8009a08:	009b      	lsls	r3, r3, #2
 8009a0a:	440b      	add	r3, r1
 8009a0c:	f503 63eb 	add.w	r3, r3, #1880	; 0x758
 8009a10:	681b      	ldr	r3, [r3, #0]
 8009a12:	643b      	str	r3, [r7, #64]	; 0x40

                    /* Calculate the byte offset to the cluster entry.  */
                    byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 8009a14:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009a16:	005a      	lsls	r2, r3, #1
 8009a18:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009a1a:	4413      	add	r3, r2
 8009a1c:	085b      	lsrs	r3, r3, #1
 8009a1e:	63fb      	str	r3, [r7, #60]	; 0x3c

                    /* Pickup the sector.  */
                    sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009a20:	69fb      	ldr	r3, [r7, #28]
 8009a22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009a24:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009a26:	fbb2 f2f3 	udiv	r2, r2, r3
                        (ULONG)media_ptr -> fx_media_reserved_sectors;
 8009a2a:	69fb      	ldr	r3, [r7, #28]
 8009a2c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
                    sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009a2e:	4413      	add	r3, r2
 8009a30:	633b      	str	r3, [r7, #48]	; 0x30

                    /* Is it the current FAT sector?  */
                    if (sector != FAT_sector)
 8009a32:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009a34:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009a36:	429a      	cmp	r2, r3
 8009a38:	d16d      	bne.n	8009b16 <_fx_utility_FAT_flush+0x258>
                        /* Different FAT sector - not in this pass of the loop.  */
                        continue;
                    }

                    /* Pickup new value for this FAT entry.  */
                    next_cluster =  media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value;
 8009a3a:	69f9      	ldr	r1, [r7, #28]
 8009a3c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009a3e:	4613      	mov	r3, r2
 8009a40:	005b      	lsls	r3, r3, #1
 8009a42:	4413      	add	r3, r2
 8009a44:	009b      	lsls	r3, r3, #2
 8009a46:	440b      	add	r3, r1
 8009a48:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 8009a4c:	681b      	ldr	r3, [r3, #0]
 8009a4e:	62bb      	str	r3, [r7, #40]	; 0x28

                    /* Now calculate the byte offset into this FAT sector.  */
                    byte_offset =  byte_offset -
                        ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8009a50:	69fb      	ldr	r3, [r7, #28]
 8009a52:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009a54:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8009a56:	1ad2      	subs	r2, r2, r3
                         media_ptr -> fx_media_bytes_per_sector);
 8009a58:	69fb      	ldr	r3, [r7, #28]
 8009a5a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                        ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8009a5c:	fb02 f303 	mul.w	r3, r2, r3
                    byte_offset =  byte_offset -
 8009a60:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009a62:	1ad3      	subs	r3, r2, r3
 8009a64:	63fb      	str	r3, [r7, #60]	; 0x3c

                    /* Determine if we are now past the end of the FAT buffer in memory.  */
                    if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 8009a66:	69fb      	ldr	r3, [r7, #28]
 8009a68:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009a6a:	3b01      	subs	r3, #1
 8009a6c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009a6e:	429a      	cmp	r2, r3
 8009a70:	d101      	bne.n	8009a76 <_fx_utility_FAT_flush+0x1b8>
                    {

                        /* Yes, we need to read the next sector */
                        multi_sector_entry = (INT)i;
 8009a72:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009a74:	647b      	str	r3, [r7, #68]	; 0x44
                    }

                    /* Setup a pointer into the buffer.  */
                    FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 8009a76:	69fb      	ldr	r3, [r7, #28]
 8009a78:	689a      	ldr	r2, [r3, #8]
 8009a7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009a7c:	4413      	add	r3, r2
 8009a7e:	62fb      	str	r3, [r7, #44]	; 0x2c

                    /* Clear the dirty flag.  */
                    media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty = 0;
 8009a80:	69f9      	ldr	r1, [r7, #28]
 8009a82:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009a84:	4613      	mov	r3, r2
 8009a86:	005b      	lsls	r3, r3, #1
 8009a88:	4413      	add	r3, r2
 8009a8a:	009b      	lsls	r3, r3, #2
 8009a8c:	440b      	add	r3, r1
 8009a8e:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 8009a92:	2200      	movs	r2, #0
 8009a94:	601a      	str	r2, [r3, #0]

                    /* Determine if the cluster entry is odd or even.  */
                    if (cluster & 1)
 8009a96:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009a98:	f003 0301 	and.w	r3, r3, #1
 8009a9c:	2b00      	cmp	r3, #0
 8009a9e:	d01b      	beq.n	8009ad8 <_fx_utility_FAT_flush+0x21a>
                        /* Odd cluster number.  */

                        /* Pickup the upper nibble of the FAT entry.  */

                        /* First, set the lower nibble of the FAT entry.  */
                        temp =      (((UINT)*FAT_ptr) & 0x0F);
 8009aa0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009aa2:	781b      	ldrb	r3, [r3, #0]
 8009aa4:	f003 030f 	and.w	r3, r3, #15
 8009aa8:	627b      	str	r3, [r7, #36]	; 0x24
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster << 4) & 0xF0));
 8009aaa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009aac:	b2da      	uxtb	r2, r3
 8009aae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009ab0:	b2db      	uxtb	r3, r3
 8009ab2:	011b      	lsls	r3, r3, #4
 8009ab4:	b2db      	uxtb	r3, r3
 8009ab6:	4313      	orrs	r3, r2
 8009ab8:	b2db      	uxtb	r3, r3
 8009aba:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009abc:	7013      	strb	r3, [r2, #0]

                        /* Determine if this is a mulit-sector entry.  */
                        if ((multi_sector_entry) == (INT)i)
 8009abe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009ac0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8009ac2:	429a      	cmp	r2, r3
 8009ac4:	d029      	beq.n	8009b1a <_fx_utility_FAT_flush+0x25c>
                            /* Yes, requires multiple sector - will write rest of the part later.  */
                            continue;
                        }

                        /* Move to the next byte of the FAT entry.  */
                        FAT_ptr++;
 8009ac6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009ac8:	3301      	adds	r3, #1
 8009aca:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Store the upper 8 bits of the FAT entry.  */
                        *FAT_ptr =  (UCHAR)((next_cluster >> 4) & 0xFF);
 8009acc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009ace:	091b      	lsrs	r3, r3, #4
 8009ad0:	b2db      	uxtb	r3, r3
 8009ad2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009ad4:	7013      	strb	r3, [r2, #0]
 8009ad6:	e023      	b.n	8009b20 <_fx_utility_FAT_flush+0x262>
                    {

                        /* Even cluster number.  */

                        /* Store the lower byte of the FAT entry.  */
                        *FAT_ptr =  (UCHAR)(next_cluster & 0xFF);
 8009ad8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009ada:	b2db      	uxtb	r3, r3
 8009adc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009ade:	7013      	strb	r3, [r2, #0]

                        /* Determine if this is a mulit-sector entry.  */
                        if ((multi_sector_entry) == (INT)i)
 8009ae0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009ae2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8009ae4:	429a      	cmp	r2, r3
 8009ae6:	d01a      	beq.n	8009b1e <_fx_utility_FAT_flush+0x260>
                            /* Yes, requires multiple sector - will write rest of the part later.  */
                            continue;
                        }

                        /* Move to the next nibble of the FAT entry.  */
                        FAT_ptr++;
 8009ae8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009aea:	3301      	adds	r3, #1
 8009aec:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Store the upper 4 bits of the FAT entry.  */
                        temp =  ((UINT)*FAT_ptr) & 0xF0;
 8009aee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009af0:	781b      	ldrb	r3, [r3, #0]
 8009af2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8009af6:	627b      	str	r3, [r7, #36]	; 0x24
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster >> 8) & 0xF));
 8009af8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009afa:	b2da      	uxtb	r2, r3
 8009afc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009afe:	0a1b      	lsrs	r3, r3, #8
 8009b00:	b2db      	uxtb	r3, r3
 8009b02:	f003 030f 	and.w	r3, r3, #15
 8009b06:	b2db      	uxtb	r3, r3
 8009b08:	4313      	orrs	r3, r2
 8009b0a:	b2db      	uxtb	r3, r3
 8009b0c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009b0e:	7013      	strb	r3, [r2, #0]
 8009b10:	e006      	b.n	8009b20 <_fx_utility_FAT_flush+0x262>
                        continue;
 8009b12:	bf00      	nop
 8009b14:	e004      	b.n	8009b20 <_fx_utility_FAT_flush+0x262>
                        continue;
 8009b16:	bf00      	nop
 8009b18:	e002      	b.n	8009b20 <_fx_utility_FAT_flush+0x262>
                            continue;
 8009b1a:	bf00      	nop
 8009b1c:	e000      	b.n	8009b20 <_fx_utility_FAT_flush+0x262>
                            continue;
 8009b1e:	bf00      	nop
                for (i = index; i < FX_MAX_FAT_CACHE; i++)
 8009b20:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009b22:	3301      	adds	r3, #1
 8009b24:	653b      	str	r3, [r7, #80]	; 0x50
 8009b26:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009b28:	2b0f      	cmp	r3, #15
 8009b2a:	f67f af5b 	bls.w	80099e4 <_fx_utility_FAT_flush+0x126>
                    }
                }

                /* First, write out the current sector. */
                status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 8009b2e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009b30:	2200      	movs	r2, #0
 8009b32:	4698      	mov	r8, r3
 8009b34:	4691      	mov	r9, r2
                                                           media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 8009b36:	69fb      	ldr	r3, [r7, #28]
 8009b38:	689a      	ldr	r2, [r3, #8]
                status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 8009b3a:	2302      	movs	r3, #2
 8009b3c:	9302      	str	r3, [sp, #8]
 8009b3e:	2301      	movs	r3, #1
 8009b40:	9301      	str	r3, [sp, #4]
 8009b42:	9200      	str	r2, [sp, #0]
 8009b44:	4642      	mov	r2, r8
 8009b46:	464b      	mov	r3, r9
 8009b48:	69f8      	ldr	r0, [r7, #28]
 8009b4a:	f001 f97d 	bl	800ae48 <_fx_utility_logical_sector_write>
 8009b4e:	63b8      	str	r0, [r7, #56]	; 0x38
                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 8009b50:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009b52:	2b00      	cmp	r3, #0
 8009b54:	d001      	beq.n	8009b5a <_fx_utility_FAT_flush+0x29c>
                {

                    /* Return the error status.  */
                    return(status);
 8009b56:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009b58:	e1fd      	b.n	8009f56 <_fx_utility_FAT_flush+0x698>
                }

                /* Mark the FAT sector update bit map to indicate this sector has been written.  */
                if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 8009b5a:	69fb      	ldr	r3, [r7, #28]
 8009b5c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009b5e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8009b62:	2b00      	cmp	r3, #0
 8009b64:	d105      	bne.n	8009b72 <_fx_utility_FAT_flush+0x2b4>
                {
                    sectors_per_bit =  (UCHAR)((UINT)media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3));
 8009b66:	69fb      	ldr	r3, [r7, #28]
 8009b68:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009b6a:	0a9b      	lsrs	r3, r3, #10
 8009b6c:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
 8009b70:	e006      	b.n	8009b80 <_fx_utility_FAT_flush+0x2c2>
                }
                else
                {
                    sectors_per_bit =  (UCHAR)((UINT)media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3) + 1);
 8009b72:	69fb      	ldr	r3, [r7, #28]
 8009b74:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009b76:	0a9b      	lsrs	r3, r3, #10
 8009b78:	b2db      	uxtb	r3, r3
 8009b7a:	3301      	adds	r3, #1
 8009b7c:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
                }

                /* Check for invalid value.  */
                if (sectors_per_bit == 0)
 8009b80:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8009b84:	2b00      	cmp	r3, #0
 8009b86:	d101      	bne.n	8009b8c <_fx_utility_FAT_flush+0x2ce>
                {

                    /* Invalid media, return error.  */
                    return(FX_MEDIA_INVALID);
 8009b88:	2302      	movs	r3, #2
 8009b8a:	e1e4      	b.n	8009f56 <_fx_utility_FAT_flush+0x698>
                }

                ind = ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) >> 3;
 8009b8c:	69fb      	ldr	r3, [r7, #28]
 8009b8e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009b90:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8009b92:	1ad2      	subs	r2, r2, r3
 8009b94:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8009b98:	fbb2 f3f3 	udiv	r3, r2, r3
 8009b9c:	08db      	lsrs	r3, r3, #3
 8009b9e:	637b      	str	r3, [r7, #52]	; 0x34
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
                    (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 8009ba0:	69fa      	ldr	r2, [r7, #28]
 8009ba2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009ba4:	4413      	add	r3, r2
 8009ba6:	f603 0318 	addw	r3, r3, #2072	; 0x818
 8009baa:	781b      	ldrb	r3, [r3, #0]
 8009bac:	b259      	sxtb	r1, r3
                    | (1 <<(((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) & 7)));
 8009bae:	69fb      	ldr	r3, [r7, #28]
 8009bb0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009bb2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009bb4:	1a9a      	subs	r2, r3, r2
 8009bb6:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8009bba:	fbb2 f3f3 	udiv	r3, r2, r3
 8009bbe:	f003 0207 	and.w	r2, r3, #7
 8009bc2:	2301      	movs	r3, #1
 8009bc4:	4093      	lsls	r3, r2
 8009bc6:	b25b      	sxtb	r3, r3
 8009bc8:	430b      	orrs	r3, r1
 8009bca:	b25b      	sxtb	r3, r3
                    (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 8009bcc:	b2d9      	uxtb	r1, r3
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
 8009bce:	69fa      	ldr	r2, [r7, #28]
 8009bd0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009bd2:	4413      	add	r3, r2
 8009bd4:	f603 0218 	addw	r2, r3, #2072	; 0x818
 8009bd8:	460b      	mov	r3, r1
 8009bda:	7013      	strb	r3, [r2, #0]

                /* Determine if the multi-sector flag is set.  */
                if (multi_sector_entry != -1)
 8009bdc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8009bde:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009be2:	f000 81af 	beq.w	8009f44 <_fx_utility_FAT_flush+0x686>
                {

                    /* Yes, position to the next sector and read it in.  */
                    FAT_sector++;
 8009be6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009be8:	3301      	adds	r3, #1
 8009bea:	657b      	str	r3, [r7, #84]	; 0x54
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8009bec:	e6a5      	b.n	800993a <_fx_utility_FAT_flush+0x7c>
            }
        }
#ifdef FX_ENABLE_EXFAT
        else if (media_ptr -> fx_media_FAT_type == FX_FAT16)
#else
        else if (!media_ptr -> fx_media_32_bit_FAT)
 8009bee:	69fb      	ldr	r3, [r7, #28]
 8009bf0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8009bf2:	2b00      	cmp	r3, #0
 8009bf4:	f040 80d2 	bne.w	8009d9c <_fx_utility_FAT_flush+0x4de>
        {

            /* 16-bit FAT is present.  */

            /* Calculate the byte offset to the cluster entry.  */
            byte_offset =  (((ULONG)cluster) << 1);
 8009bf8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009bfa:	005b      	lsls	r3, r3, #1
 8009bfc:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Calculate the FAT sector the requested FAT entry resides in.  */
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009bfe:	69fb      	ldr	r3, [r7, #28]
 8009c00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009c02:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009c04:	fbb2 f2f3 	udiv	r2, r2, r3
                (ULONG)media_ptr -> fx_media_reserved_sectors;
 8009c08:	69fb      	ldr	r3, [r7, #28]
 8009c0a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009c0c:	4413      	add	r3, r2
 8009c0e:	657b      	str	r3, [r7, #84]	; 0x54

            /* Read the FAT sector.  */
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8009c10:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009c12:	2200      	movs	r2, #0
 8009c14:	469a      	mov	sl, r3
 8009c16:	4693      	mov	fp, r2
                                                      media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 8009c18:	69fb      	ldr	r3, [r7, #28]
 8009c1a:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8009c1c:	2302      	movs	r3, #2
 8009c1e:	9302      	str	r3, [sp, #8]
 8009c20:	2301      	movs	r3, #1
 8009c22:	9301      	str	r3, [sp, #4]
 8009c24:	9200      	str	r2, [sp, #0]
 8009c26:	4652      	mov	r2, sl
 8009c28:	465b      	mov	r3, fp
 8009c2a:	69f8      	ldr	r0, [r7, #28]
 8009c2c:	f000 fe78 	bl	800a920 <_fx_utility_logical_sector_read>
 8009c30:	63b8      	str	r0, [r7, #56]	; 0x38

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 8009c32:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009c34:	2b00      	cmp	r3, #0
 8009c36:	d001      	beq.n	8009c3c <_fx_utility_FAT_flush+0x37e>
            {

                /* Return the error status.  */
                return(status);
 8009c38:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009c3a:	e18c      	b.n	8009f56 <_fx_utility_FAT_flush+0x698>
            }

            /* Loop through the remainder of the cache to check for multiple entries
               within the same FAT sector being written out.  */
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 8009c3c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8009c3e:	653b      	str	r3, [r7, #80]	; 0x50
 8009c40:	e057      	b.n	8009cf2 <_fx_utility_FAT_flush+0x434>
            {

                /* Determine if the entry is dirty.  */
                if (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty == 0)
 8009c42:	69f9      	ldr	r1, [r7, #28]
 8009c44:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009c46:	4613      	mov	r3, r2
 8009c48:	005b      	lsls	r3, r3, #1
 8009c4a:	4413      	add	r3, r2
 8009c4c:	009b      	lsls	r3, r3, #2
 8009c4e:	440b      	add	r3, r1
 8009c50:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 8009c54:	681b      	ldr	r3, [r3, #0]
 8009c56:	2b00      	cmp	r3, #0
 8009c58:	d045      	beq.n	8009ce6 <_fx_utility_FAT_flush+0x428>
                    /* Not dirty, does not need to be flushed.  */
                    continue;
                }

                /* Isolate the cluster.  */
                cluster = (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster);
 8009c5a:	69f9      	ldr	r1, [r7, #28]
 8009c5c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009c5e:	4613      	mov	r3, r2
 8009c60:	005b      	lsls	r3, r3, #1
 8009c62:	4413      	add	r3, r2
 8009c64:	009b      	lsls	r3, r3, #2
 8009c66:	440b      	add	r3, r1
 8009c68:	f503 63eb 	add.w	r3, r3, #1880	; 0x758
 8009c6c:	681b      	ldr	r3, [r3, #0]
 8009c6e:	643b      	str	r3, [r7, #64]	; 0x40

                /* Calculate the byte offset to the cluster entry.  */
                byte_offset =  (((ULONG)cluster) * 2);
 8009c70:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009c72:	005b      	lsls	r3, r3, #1
 8009c74:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Pickup the sector.  */
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009c76:	69fb      	ldr	r3, [r7, #28]
 8009c78:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009c7a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009c7c:	fbb2 f2f3 	udiv	r2, r2, r3
                    (ULONG)media_ptr -> fx_media_reserved_sectors;
 8009c80:	69fb      	ldr	r3, [r7, #28]
 8009c82:	6c5b      	ldr	r3, [r3, #68]	; 0x44
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009c84:	4413      	add	r3, r2
 8009c86:	633b      	str	r3, [r7, #48]	; 0x30

                /* Is it the current FAT sector?  */
                if (sector != FAT_sector)
 8009c88:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009c8a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009c8c:	429a      	cmp	r2, r3
 8009c8e:	d12c      	bne.n	8009cea <_fx_utility_FAT_flush+0x42c>
                    continue;
                }

                /* Now calculate the byte offset into this FAT sector.  */
                byte_offset =  byte_offset -
                    ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8009c90:	69fb      	ldr	r3, [r7, #28]
 8009c92:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009c94:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8009c96:	1ad2      	subs	r2, r2, r3
                     media_ptr -> fx_media_bytes_per_sector);
 8009c98:	69fb      	ldr	r3, [r7, #28]
 8009c9a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                    ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8009c9c:	fb02 f303 	mul.w	r3, r2, r3
                byte_offset =  byte_offset -
 8009ca0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009ca2:	1ad3      	subs	r3, r2, r3
 8009ca4:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Setup a pointer into the buffer.  */
                FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 8009ca6:	69fb      	ldr	r3, [r7, #28]
 8009ca8:	689a      	ldr	r2, [r3, #8]
 8009caa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009cac:	4413      	add	r3, r2
 8009cae:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Pickup new value for this FAT entry.  */
                next_cluster =  media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value;
 8009cb0:	69f9      	ldr	r1, [r7, #28]
 8009cb2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009cb4:	4613      	mov	r3, r2
 8009cb6:	005b      	lsls	r3, r3, #1
 8009cb8:	4413      	add	r3, r2
 8009cba:	009b      	lsls	r3, r3, #2
 8009cbc:	440b      	add	r3, r1
 8009cbe:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 8009cc2:	681b      	ldr	r3, [r3, #0]
 8009cc4:	62bb      	str	r3, [r7, #40]	; 0x28

                /* Store the FAT entry.  */
                _fx_utility_16_unsigned_write(FAT_ptr, (UINT)next_cluster);
 8009cc6:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009cc8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009cca:	f7ff fb7c 	bl	80093c6 <_fx_utility_16_unsigned_write>

                /* Clear the dirty flag.  */
                media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty = 0;
 8009cce:	69f9      	ldr	r1, [r7, #28]
 8009cd0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009cd2:	4613      	mov	r3, r2
 8009cd4:	005b      	lsls	r3, r3, #1
 8009cd6:	4413      	add	r3, r2
 8009cd8:	009b      	lsls	r3, r3, #2
 8009cda:	440b      	add	r3, r1
 8009cdc:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 8009ce0:	2200      	movs	r2, #0
 8009ce2:	601a      	str	r2, [r3, #0]
 8009ce4:	e002      	b.n	8009cec <_fx_utility_FAT_flush+0x42e>
                    continue;
 8009ce6:	bf00      	nop
 8009ce8:	e000      	b.n	8009cec <_fx_utility_FAT_flush+0x42e>
                    continue;
 8009cea:	bf00      	nop
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 8009cec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009cee:	3301      	adds	r3, #1
 8009cf0:	653b      	str	r3, [r7, #80]	; 0x50
 8009cf2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009cf4:	2b0f      	cmp	r3, #15
 8009cf6:	d9a4      	bls.n	8009c42 <_fx_utility_FAT_flush+0x384>
            }

            /* Write the last written FAT sector out.  */
            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 8009cf8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009cfa:	2200      	movs	r2, #0
 8009cfc:	613b      	str	r3, [r7, #16]
 8009cfe:	617a      	str	r2, [r7, #20]
                                                       media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 8009d00:	69fb      	ldr	r3, [r7, #28]
 8009d02:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 8009d04:	2302      	movs	r3, #2
 8009d06:	9302      	str	r3, [sp, #8]
 8009d08:	2301      	movs	r3, #1
 8009d0a:	9301      	str	r3, [sp, #4]
 8009d0c:	9200      	str	r2, [sp, #0]
 8009d0e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8009d12:	69f8      	ldr	r0, [r7, #28]
 8009d14:	f001 f898 	bl	800ae48 <_fx_utility_logical_sector_write>
 8009d18:	63b8      	str	r0, [r7, #56]	; 0x38

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 8009d1a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009d1c:	2b00      	cmp	r3, #0
 8009d1e:	d001      	beq.n	8009d24 <_fx_utility_FAT_flush+0x466>
            {
                /* Return the error status.  */
                return(status);
 8009d20:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009d22:	e118      	b.n	8009f56 <_fx_utility_FAT_flush+0x698>
            }

            /* Mark the FAT sector update bit map to indicate this sector has been
               written.  */
            if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 8009d24:	69fb      	ldr	r3, [r7, #28]
 8009d26:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009d28:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8009d2c:	2b00      	cmp	r3, #0
 8009d2e:	d105      	bne.n	8009d3c <_fx_utility_FAT_flush+0x47e>
            {
                sectors_per_bit =  (UCHAR)(media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3));
 8009d30:	69fb      	ldr	r3, [r7, #28]
 8009d32:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009d34:	0a9b      	lsrs	r3, r3, #10
 8009d36:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
 8009d3a:	e006      	b.n	8009d4a <_fx_utility_FAT_flush+0x48c>
            }
            else
            {
                sectors_per_bit =  (UCHAR)((media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3)) + 1);
 8009d3c:	69fb      	ldr	r3, [r7, #28]
 8009d3e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009d40:	0a9b      	lsrs	r3, r3, #10
 8009d42:	b2db      	uxtb	r3, r3
 8009d44:	3301      	adds	r3, #1
 8009d46:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
            }
            ind = ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) >> 3;
 8009d4a:	69fb      	ldr	r3, [r7, #28]
 8009d4c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009d4e:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8009d50:	1ad2      	subs	r2, r2, r3
 8009d52:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8009d56:	fbb2 f3f3 	udiv	r3, r2, r3
 8009d5a:	08db      	lsrs	r3, r3, #3
 8009d5c:	637b      	str	r3, [r7, #52]	; 0x34
            media_ptr -> fx_media_fat_secondary_update_map[ind] = 
                (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 8009d5e:	69fa      	ldr	r2, [r7, #28]
 8009d60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009d62:	4413      	add	r3, r2
 8009d64:	f603 0318 	addw	r3, r3, #2072	; 0x818
 8009d68:	781b      	ldrb	r3, [r3, #0]
 8009d6a:	b259      	sxtb	r1, r3
                | (1 <<(((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) & 7)));
 8009d6c:	69fb      	ldr	r3, [r7, #28]
 8009d6e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009d70:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009d72:	1a9a      	subs	r2, r3, r2
 8009d74:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8009d78:	fbb2 f3f3 	udiv	r3, r2, r3
 8009d7c:	f003 0207 	and.w	r2, r3, #7
 8009d80:	2301      	movs	r3, #1
 8009d82:	4093      	lsls	r3, r2
 8009d84:	b25b      	sxtb	r3, r3
 8009d86:	430b      	orrs	r3, r1
 8009d88:	b25b      	sxtb	r3, r3
                (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 8009d8a:	b2d9      	uxtb	r1, r3
            media_ptr -> fx_media_fat_secondary_update_map[ind] = 
 8009d8c:	69fa      	ldr	r2, [r7, #28]
 8009d8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009d90:	4413      	add	r3, r2
 8009d92:	f603 0218 	addw	r2, r3, #2072	; 0x818
 8009d96:	460b      	mov	r3, r1
 8009d98:	7013      	strb	r3, [r2, #0]
 8009d9a:	e0d4      	b.n	8009f46 <_fx_utility_FAT_flush+0x688>
        {

            /* 32-bit FAT or exFAT are present.  */

            /* Calculate the byte offset to the cluster entry.  */
            byte_offset =  (((ULONG)cluster) * 4);
 8009d9c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009d9e:	009b      	lsls	r3, r3, #2
 8009da0:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Calculate the FAT sector the requested FAT entry resides in.  */
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009da2:	69fb      	ldr	r3, [r7, #28]
 8009da4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009da6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009da8:	fbb2 f2f3 	udiv	r2, r2, r3
                (ULONG)media_ptr -> fx_media_reserved_sectors;
 8009dac:	69fb      	ldr	r3, [r7, #28]
 8009dae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009db0:	4413      	add	r3, r2
 8009db2:	657b      	str	r3, [r7, #84]	; 0x54

            /* Read the FAT sector.  */
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8009db4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009db6:	2200      	movs	r2, #0
 8009db8:	60bb      	str	r3, [r7, #8]
 8009dba:	60fa      	str	r2, [r7, #12]
                                                      media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 8009dbc:	69fb      	ldr	r3, [r7, #28]
 8009dbe:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8009dc0:	2302      	movs	r3, #2
 8009dc2:	9302      	str	r3, [sp, #8]
 8009dc4:	2301      	movs	r3, #1
 8009dc6:	9301      	str	r3, [sp, #4]
 8009dc8:	9200      	str	r2, [sp, #0]
 8009dca:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8009dce:	69f8      	ldr	r0, [r7, #28]
 8009dd0:	f000 fda6 	bl	800a920 <_fx_utility_logical_sector_read>
 8009dd4:	63b8      	str	r0, [r7, #56]	; 0x38

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 8009dd6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009dd8:	2b00      	cmp	r3, #0
 8009dda:	d001      	beq.n	8009de0 <_fx_utility_FAT_flush+0x522>
            {

                /* Return the error status.  */
                return(status);
 8009ddc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009dde:	e0ba      	b.n	8009f56 <_fx_utility_FAT_flush+0x698>
            }

            /* Loop through the remainder of the cache to check for multiple entries
               within the same FAT sector being written out.  */
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 8009de0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8009de2:	653b      	str	r3, [r7, #80]	; 0x50
 8009de4:	e057      	b.n	8009e96 <_fx_utility_FAT_flush+0x5d8>
            {

                /* Determine if the entry is dirty.  */
                if (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty == 0)
 8009de6:	69f9      	ldr	r1, [r7, #28]
 8009de8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009dea:	4613      	mov	r3, r2
 8009dec:	005b      	lsls	r3, r3, #1
 8009dee:	4413      	add	r3, r2
 8009df0:	009b      	lsls	r3, r3, #2
 8009df2:	440b      	add	r3, r1
 8009df4:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 8009df8:	681b      	ldr	r3, [r3, #0]
 8009dfa:	2b00      	cmp	r3, #0
 8009dfc:	d045      	beq.n	8009e8a <_fx_utility_FAT_flush+0x5cc>
                    /* Not dirty, does not need to be flushed.  */
                    continue;
                }

                /* Isolate the cluster.  */
                cluster = (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster);
 8009dfe:	69f9      	ldr	r1, [r7, #28]
 8009e00:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009e02:	4613      	mov	r3, r2
 8009e04:	005b      	lsls	r3, r3, #1
 8009e06:	4413      	add	r3, r2
 8009e08:	009b      	lsls	r3, r3, #2
 8009e0a:	440b      	add	r3, r1
 8009e0c:	f503 63eb 	add.w	r3, r3, #1880	; 0x758
 8009e10:	681b      	ldr	r3, [r3, #0]
 8009e12:	643b      	str	r3, [r7, #64]	; 0x40

                /* Calculate the byte offset to the cluster entry.  */
                byte_offset =  (((ULONG)cluster) * 4);
 8009e14:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009e16:	009b      	lsls	r3, r3, #2
 8009e18:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Pickup the sector.  */
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009e1a:	69fb      	ldr	r3, [r7, #28]
 8009e1c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009e1e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009e20:	fbb2 f2f3 	udiv	r2, r2, r3
                    (ULONG)media_ptr -> fx_media_reserved_sectors;
 8009e24:	69fb      	ldr	r3, [r7, #28]
 8009e26:	6c5b      	ldr	r3, [r3, #68]	; 0x44
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8009e28:	4413      	add	r3, r2
 8009e2a:	633b      	str	r3, [r7, #48]	; 0x30

                /* Is it the current FAT sector?  */
                if (sector != FAT_sector)
 8009e2c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009e2e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009e30:	429a      	cmp	r2, r3
 8009e32:	d12c      	bne.n	8009e8e <_fx_utility_FAT_flush+0x5d0>
                    continue;
                }

                /* Now calculate the byte offset into this FAT sector.  */
                byte_offset =  byte_offset -
                    ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8009e34:	69fb      	ldr	r3, [r7, #28]
 8009e36:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009e38:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8009e3a:	1ad2      	subs	r2, r2, r3
                     media_ptr -> fx_media_bytes_per_sector);
 8009e3c:	69fb      	ldr	r3, [r7, #28]
 8009e3e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                    ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8009e40:	fb02 f303 	mul.w	r3, r2, r3
                byte_offset =  byte_offset -
 8009e44:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8009e46:	1ad3      	subs	r3, r2, r3
 8009e48:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Setup a pointer into the buffer.  */
                FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 8009e4a:	69fb      	ldr	r3, [r7, #28]
 8009e4c:	689a      	ldr	r2, [r3, #8]
 8009e4e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009e50:	4413      	add	r3, r2
 8009e52:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Pickup new value for this FAT entry.  */
                next_cluster =  media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value;
 8009e54:	69f9      	ldr	r1, [r7, #28]
 8009e56:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009e58:	4613      	mov	r3, r2
 8009e5a:	005b      	lsls	r3, r3, #1
 8009e5c:	4413      	add	r3, r2
 8009e5e:	009b      	lsls	r3, r3, #2
 8009e60:	440b      	add	r3, r1
 8009e62:	f203 735c 	addw	r3, r3, #1884	; 0x75c
 8009e66:	681b      	ldr	r3, [r3, #0]
 8009e68:	62bb      	str	r3, [r7, #40]	; 0x28

                /* Store the FAT entry.  */
                _fx_utility_32_unsigned_write(FAT_ptr, next_cluster);
 8009e6a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009e6c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8009e6e:	f7ff fadc 	bl	800942a <_fx_utility_32_unsigned_write>

                /* Clear the dirty flag.  */
                media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty = 0;
 8009e72:	69f9      	ldr	r1, [r7, #28]
 8009e74:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009e76:	4613      	mov	r3, r2
 8009e78:	005b      	lsls	r3, r3, #1
 8009e7a:	4413      	add	r3, r2
 8009e7c:	009b      	lsls	r3, r3, #2
 8009e7e:	440b      	add	r3, r1
 8009e80:	f503 63ec 	add.w	r3, r3, #1888	; 0x760
 8009e84:	2200      	movs	r2, #0
 8009e86:	601a      	str	r2, [r3, #0]
 8009e88:	e002      	b.n	8009e90 <_fx_utility_FAT_flush+0x5d2>
                    continue;
 8009e8a:	bf00      	nop
 8009e8c:	e000      	b.n	8009e90 <_fx_utility_FAT_flush+0x5d2>
                    continue;
 8009e8e:	bf00      	nop
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 8009e90:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009e92:	3301      	adds	r3, #1
 8009e94:	653b      	str	r3, [r7, #80]	; 0x50
 8009e96:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009e98:	2b0f      	cmp	r3, #15
 8009e9a:	d9a4      	bls.n	8009de6 <_fx_utility_FAT_flush+0x528>
            }

            /* Write the last written FAT sector out.  */
            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 8009e9c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009e9e:	2200      	movs	r2, #0
 8009ea0:	603b      	str	r3, [r7, #0]
 8009ea2:	607a      	str	r2, [r7, #4]
                                                       media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);
 8009ea4:	69fb      	ldr	r3, [r7, #28]
 8009ea6:	689a      	ldr	r2, [r3, #8]
            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 8009ea8:	2302      	movs	r3, #2
 8009eaa:	9302      	str	r3, [sp, #8]
 8009eac:	2301      	movs	r3, #1
 8009eae:	9301      	str	r3, [sp, #4]
 8009eb0:	9200      	str	r2, [sp, #0]
 8009eb2:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009eb6:	69f8      	ldr	r0, [r7, #28]
 8009eb8:	f000 ffc6 	bl	800ae48 <_fx_utility_logical_sector_write>
 8009ebc:	63b8      	str	r0, [r7, #56]	; 0x38

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 8009ebe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009ec0:	2b00      	cmp	r3, #0
 8009ec2:	d001      	beq.n	8009ec8 <_fx_utility_FAT_flush+0x60a>
            {

                /* Return the error status.  */
                return(status);
 8009ec4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009ec6:	e046      	b.n	8009f56 <_fx_utility_FAT_flush+0x698>
            {
#endif /* FX_ENABLE_EXFAT */

                /* Mark the FAT sector update bit map to indicate this sector has been
                   written.  */
                if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 8009ec8:	69fb      	ldr	r3, [r7, #28]
 8009eca:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009ecc:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8009ed0:	2b00      	cmp	r3, #0
 8009ed2:	d105      	bne.n	8009ee0 <_fx_utility_FAT_flush+0x622>
                {
                    sectors_per_bit =  (UCHAR)(media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3));
 8009ed4:	69fb      	ldr	r3, [r7, #28]
 8009ed6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009ed8:	0a9b      	lsrs	r3, r3, #10
 8009eda:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
 8009ede:	e006      	b.n	8009eee <_fx_utility_FAT_flush+0x630>
                }
                else
                {
                    sectors_per_bit =  (UCHAR)((media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3)) + 1);
 8009ee0:	69fb      	ldr	r3, [r7, #28]
 8009ee2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009ee4:	0a9b      	lsrs	r3, r3, #10
 8009ee6:	b2db      	uxtb	r3, r3
 8009ee8:	3301      	adds	r3, #1
 8009eea:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
                }
                ind = ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) >> 3;
 8009eee:	69fb      	ldr	r3, [r7, #28]
 8009ef0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009ef2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8009ef4:	1ad2      	subs	r2, r2, r3
 8009ef6:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8009efa:	fbb2 f3f3 	udiv	r3, r2, r3
 8009efe:	08db      	lsrs	r3, r3, #3
 8009f00:	637b      	str	r3, [r7, #52]	; 0x34
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
                    (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 8009f02:	69fa      	ldr	r2, [r7, #28]
 8009f04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009f06:	4413      	add	r3, r2
 8009f08:	f603 0318 	addw	r3, r3, #2072	; 0x818
 8009f0c:	781b      	ldrb	r3, [r3, #0]
 8009f0e:	b259      	sxtb	r1, r3
                    | (1 <<(((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) & 7)));
 8009f10:	69fb      	ldr	r3, [r7, #28]
 8009f12:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009f14:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009f16:	1a9a      	subs	r2, r3, r2
 8009f18:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8009f1c:	fbb2 f3f3 	udiv	r3, r2, r3
 8009f20:	f003 0207 	and.w	r2, r3, #7
 8009f24:	2301      	movs	r3, #1
 8009f26:	4093      	lsls	r3, r2
 8009f28:	b25b      	sxtb	r3, r3
 8009f2a:	430b      	orrs	r3, r1
 8009f2c:	b25b      	sxtb	r3, r3
                    (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
 8009f2e:	b2d9      	uxtb	r1, r3
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
 8009f30:	69fa      	ldr	r2, [r7, #28]
 8009f32:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009f34:	4413      	add	r3, r2
 8009f36:	f603 0218 	addw	r2, r3, #2072	; 0x818
 8009f3a:	460b      	mov	r3, r1
 8009f3c:	7013      	strb	r3, [r2, #0]
 8009f3e:	e002      	b.n	8009f46 <_fx_utility_FAT_flush+0x688>
            continue;
 8009f40:	bf00      	nop
 8009f42:	e000      	b.n	8009f46 <_fx_utility_FAT_flush+0x688>
                    break;
 8009f44:	bf00      	nop
    for (index = 0; index < FX_MAX_FAT_CACHE; index++)
 8009f46:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8009f48:	3301      	adds	r3, #1
 8009f4a:	64fb      	str	r3, [r7, #76]	; 0x4c
 8009f4c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8009f4e:	2b0f      	cmp	r3, #15
 8009f50:	f67f acc4 	bls.w	80098dc <_fx_utility_FAT_flush+0x1e>
        media_ptr -> fx_media_fault_tolerant_cached_FAT_sector = 0;
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Return successful status.  */
    return(FX_SUCCESS);
 8009f54:	2300      	movs	r3, #0
}
 8009f56:	4618      	mov	r0, r3
 8009f58:	3758      	adds	r7, #88	; 0x58
 8009f5a:	46bd      	mov	sp, r7
 8009f5c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08009f60 <_fx_utility_logical_sector_cache_entry_read>:
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
FX_CACHED_SECTOR  *_fx_utility_logical_sector_cache_entry_read(FX_MEDIA *media_ptr, ULONG64 logical_sector,
                                                               FX_CACHED_SECTOR **previous_cache_entry)
{
 8009f60:	b480      	push	{r7}
 8009f62:	b08f      	sub	sp, #60	; 0x3c
 8009f64:	af00      	add	r7, sp, #0
 8009f66:	60f8      	str	r0, [r7, #12]
 8009f68:	e9c7 2300 	strd	r2, r3, [r7]
ULONG             cache_size;
ULONG             index;


    /* Determine if the logical sector cache access should use the hash function.  */
    if (media_ptr -> fx_media_sector_cache_hashed)
 8009f6c:	68fb      	ldr	r3, [r7, #12]
 8009f6e:	691b      	ldr	r3, [r3, #16]
 8009f70:	2b00      	cmp	r3, #0
 8009f72:	f000 8275 	beq.w	800a460 <_fx_utility_logical_sector_cache_entry_read+0x500>

        /* Calculate the area of the cache for this logical sector.  */

        /* First compute the hashed value of this index by simply using the lower bits of
           the sector number.  */
        index =  (ULONG)(logical_sector & media_ptr -> fx_media_sector_cache_hash_mask);
 8009f76:	683a      	ldr	r2, [r7, #0]
 8009f78:	68fb      	ldr	r3, [r7, #12]
 8009f7a:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 8009f7e:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 8009f82:	4013      	ands	r3, r2
 8009f84:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Set the bit indicating there is one or more valid sectors at this cache index.  */
        media_ptr -> fx_media_sector_cache_hashed_sector_valid |=  ((ULONG)1) << (index % 32);
 8009f86:	68fb      	ldr	r3, [r7, #12]
 8009f88:	6a1a      	ldr	r2, [r3, #32]
 8009f8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009f8c:	f003 031f 	and.w	r3, r3, #31
 8009f90:	2101      	movs	r1, #1
 8009f92:	fa01 f303 	lsl.w	r3, r1, r3
 8009f96:	431a      	orrs	r2, r3
 8009f98:	68fb      	ldr	r3, [r7, #12]
 8009f9a:	621a      	str	r2, [r3, #32]

        /* Compute the actual array index by multiplying by the cache depth.  */
        index =  index * FX_SECTOR_CACHE_DEPTH;
 8009f9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009f9e:	009b      	lsls	r3, r3, #2
 8009fa0:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Build a pointer to the cache entry.  */
        cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 8009fa2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009fa4:	4613      	mov	r3, r2
 8009fa6:	005b      	lsls	r3, r3, #1
 8009fa8:	4413      	add	r3, r2
 8009faa:	00db      	lsls	r3, r3, #3
 8009fac:	f503 634a 	add.w	r3, r3, #3232	; 0xca0
 8009fb0:	68fa      	ldr	r2, [r7, #12]
 8009fb2:	4413      	add	r3, r2
 8009fb4:	637b      	str	r3, [r7, #52]	; 0x34

        /* Determine if the logical sector is in the cache - assuming the depth of the
           sector cache is 4 entries.  */
        if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 8009fb6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009fb8:	7c5b      	ldrb	r3, [r3, #17]
 8009fba:	2b00      	cmp	r3, #0
 8009fbc:	d015      	beq.n	8009fea <_fx_utility_logical_sector_cache_entry_read+0x8a>
 8009fbe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009fc0:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8009fc4:	e9d7 0100 	ldrd	r0, r1, [r7]
 8009fc8:	4299      	cmp	r1, r3
 8009fca:	bf08      	it	eq
 8009fcc:	4290      	cmpeq	r0, r2
 8009fce:	d10c      	bne.n	8009fea <_fx_utility_logical_sector_cache_entry_read+0x8a>
        {

            /* Yes, we found a match.  Simply setup the pointer to this
               buffer and return.  */
            media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 8009fd0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009fd2:	681a      	ldr	r2, [r3, #0]
 8009fd4:	68fb      	ldr	r3, [r7, #12]
 8009fd6:	609a      	str	r2, [r3, #8]

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of logical sectors cache read hits.  */
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 8009fd8:	68fb      	ldr	r3, [r7, #12]
 8009fda:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8009fde:	1c5a      	adds	r2, r3, #1
 8009fe0:	68fb      	ldr	r3, [r7, #12]
 8009fe2:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
#endif
            /* Success, return to caller immediately!  */
            return(FX_NULL);
 8009fe6:	2300      	movs	r3, #0
 8009fe8:	e27e      	b.n	800a4e8 <_fx_utility_logical_sector_cache_entry_read+0x588>
        }
        else if (((cache_entry + 1) -> fx_cached_sector_valid) && ((cache_entry + 1) -> fx_cached_sector == logical_sector))
 8009fea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009fec:	3318      	adds	r3, #24
 8009fee:	7c5b      	ldrb	r3, [r3, #17]
 8009ff0:	2b00      	cmp	r3, #0
 8009ff2:	d060      	beq.n	800a0b6 <_fx_utility_logical_sector_cache_entry_read+0x156>
 8009ff4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009ff6:	3318      	adds	r3, #24
 8009ff8:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8009ffc:	e9d7 0100 	ldrd	r0, r1, [r7]
 800a000:	4299      	cmp	r1, r3
 800a002:	bf08      	it	eq
 800a004:	4290      	cmpeq	r0, r2
 800a006:	d156      	bne.n	800a0b6 <_fx_utility_logical_sector_cache_entry_read+0x156>
        {

            /* Yes, we found a match.  Simply setup the pointer to this
               buffer and return.  */
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a008:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a00a:	3318      	adds	r3, #24
 800a00c:	681a      	ldr	r2, [r3, #0]
 800a00e:	68fb      	ldr	r3, [r7, #12]
 800a010:	609a      	str	r2, [r3, #8]

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of logical sectors cache read hits.  */
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a012:	68fb      	ldr	r3, [r7, #12]
 800a014:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800a018:	1c5a      	adds	r2, r3, #1
 800a01a:	68fb      	ldr	r3, [r7, #12]
 800a01c:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
#endif

            /* Swap the first and second cache entries to keep the most recently used
               at the top.  */
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a020:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a022:	681b      	ldr	r3, [r3, #0]
 800a024:	613b      	str	r3, [r7, #16]
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800a026:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a028:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a02c:	e9c7 2306 	strd	r2, r3, [r7, #24]
            temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry) -> fx_cached_sector_buffer_dirty;
 800a030:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a032:	7c1b      	ldrb	r3, [r3, #16]
 800a034:	f887 3020 	strb.w	r3, [r7, #32]
            temp_storage.fx_cached_sector_valid =                   (cache_entry) -> fx_cached_sector_valid;
 800a038:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a03a:	7c5b      	ldrb	r3, [r3, #17]
 800a03c:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
            temp_storage.fx_cached_sector_type =                    (cache_entry) -> fx_cached_sector_type;
 800a040:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a042:	7c9b      	ldrb	r3, [r3, #18]
 800a044:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

            (cache_entry) -> fx_cached_sector_memory_buffer =       (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a048:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a04a:	3318      	adds	r3, #24
 800a04c:	681a      	ldr	r2, [r3, #0]
 800a04e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a050:	601a      	str	r2, [r3, #0]
            (cache_entry) -> fx_cached_sector =                     (cache_entry + 1) -> fx_cached_sector;
 800a052:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a054:	3318      	adds	r3, #24
 800a056:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a05a:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800a05c:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry) -> fx_cached_sector_buffer_dirty =        (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a060:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a062:	3318      	adds	r3, #24
 800a064:	7c1a      	ldrb	r2, [r3, #16]
 800a066:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a068:	741a      	strb	r2, [r3, #16]
            (cache_entry) -> fx_cached_sector_valid =               (cache_entry + 1) -> fx_cached_sector_valid;
 800a06a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a06c:	3318      	adds	r3, #24
 800a06e:	7c5a      	ldrb	r2, [r3, #17]
 800a070:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a072:	745a      	strb	r2, [r3, #17]
            (cache_entry) -> fx_cached_sector_type =                (cache_entry + 1) -> fx_cached_sector_type;
 800a074:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a076:	3318      	adds	r3, #24
 800a078:	7c9a      	ldrb	r2, [r3, #18]
 800a07a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a07c:	749a      	strb	r2, [r3, #18]

            (cache_entry + 1) -> fx_cached_sector_memory_buffer =   temp_storage.fx_cached_sector_memory_buffer;
 800a07e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a080:	3318      	adds	r3, #24
 800a082:	693a      	ldr	r2, [r7, #16]
 800a084:	601a      	str	r2, [r3, #0]
            (cache_entry + 1) -> fx_cached_sector =                 temp_storage.fx_cached_sector;
 800a086:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a088:	f103 0118 	add.w	r1, r3, #24
 800a08c:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800a090:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    temp_storage.fx_cached_sector_buffer_dirty;
 800a094:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a096:	3318      	adds	r3, #24
 800a098:	f897 2020 	ldrb.w	r2, [r7, #32]
 800a09c:	741a      	strb	r2, [r3, #16]
            (cache_entry + 1) -> fx_cached_sector_valid =           temp_storage.fx_cached_sector_valid;
 800a09e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a0a0:	3318      	adds	r3, #24
 800a0a2:	f897 2021 	ldrb.w	r2, [r7, #33]	; 0x21
 800a0a6:	745a      	strb	r2, [r3, #17]
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;
 800a0a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a0aa:	3318      	adds	r3, #24
 800a0ac:	f897 2022 	ldrb.w	r2, [r7, #34]	; 0x22
 800a0b0:	749a      	strb	r2, [r3, #18]

            /* Success, return to caller immediately!  */
            return(FX_NULL);
 800a0b2:	2300      	movs	r3, #0
 800a0b4:	e218      	b.n	800a4e8 <_fx_utility_logical_sector_cache_entry_read+0x588>
        }
        else if (((cache_entry + 2) -> fx_cached_sector_valid) && ((cache_entry + 2) -> fx_cached_sector == logical_sector))
 800a0b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a0b8:	3330      	adds	r3, #48	; 0x30
 800a0ba:	7c5b      	ldrb	r3, [r3, #17]
 800a0bc:	2b00      	cmp	r3, #0
 800a0be:	f000 8086 	beq.w	800a1ce <_fx_utility_logical_sector_cache_entry_read+0x26e>
 800a0c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a0c4:	3330      	adds	r3, #48	; 0x30
 800a0c6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a0ca:	e9d7 0100 	ldrd	r0, r1, [r7]
 800a0ce:	4299      	cmp	r1, r3
 800a0d0:	bf08      	it	eq
 800a0d2:	4290      	cmpeq	r0, r2
 800a0d4:	d17b      	bne.n	800a1ce <_fx_utility_logical_sector_cache_entry_read+0x26e>
        {

            /* Yes, we found a match.  Simply setup the pointer to this
               buffer and return.  */
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a0d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a0d8:	3330      	adds	r3, #48	; 0x30
 800a0da:	681a      	ldr	r2, [r3, #0]
 800a0dc:	68fb      	ldr	r3, [r7, #12]
 800a0de:	609a      	str	r2, [r3, #8]

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of logical sectors cache read hits.  */
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a0e0:	68fb      	ldr	r3, [r7, #12]
 800a0e2:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800a0e6:	1c5a      	adds	r2, r3, #1
 800a0e8:	68fb      	ldr	r3, [r7, #12]
 800a0ea:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
#endif

            /* Move the third entry to the top and the first two entries down.  */
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a0ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a0f0:	681b      	ldr	r3, [r3, #0]
 800a0f2:	613b      	str	r3, [r7, #16]
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800a0f4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a0f6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a0fa:	e9c7 2306 	strd	r2, r3, [r7, #24]
            temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry) -> fx_cached_sector_buffer_dirty;
 800a0fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a100:	7c1b      	ldrb	r3, [r3, #16]
 800a102:	f887 3020 	strb.w	r3, [r7, #32]
            temp_storage.fx_cached_sector_valid =                   (cache_entry) -> fx_cached_sector_valid;
 800a106:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a108:	7c5b      	ldrb	r3, [r3, #17]
 800a10a:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
            temp_storage.fx_cached_sector_type =                    (cache_entry) -> fx_cached_sector_type;
 800a10e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a110:	7c9b      	ldrb	r3, [r3, #18]
 800a112:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

            (cache_entry) -> fx_cached_sector_memory_buffer =       (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a116:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a118:	3330      	adds	r3, #48	; 0x30
 800a11a:	681a      	ldr	r2, [r3, #0]
 800a11c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a11e:	601a      	str	r2, [r3, #0]
            (cache_entry) -> fx_cached_sector =                     (cache_entry + 2) -> fx_cached_sector;
 800a120:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a122:	3330      	adds	r3, #48	; 0x30
 800a124:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a128:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800a12a:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry) -> fx_cached_sector_buffer_dirty =        (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800a12e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a130:	3330      	adds	r3, #48	; 0x30
 800a132:	7c1a      	ldrb	r2, [r3, #16]
 800a134:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a136:	741a      	strb	r2, [r3, #16]
            (cache_entry) -> fx_cached_sector_valid =               (cache_entry + 2) -> fx_cached_sector_valid;
 800a138:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a13a:	3330      	adds	r3, #48	; 0x30
 800a13c:	7c5a      	ldrb	r2, [r3, #17]
 800a13e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a140:	745a      	strb	r2, [r3, #17]
            (cache_entry) -> fx_cached_sector_type =                (cache_entry + 2) -> fx_cached_sector_type;
 800a142:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a144:	3330      	adds	r3, #48	; 0x30
 800a146:	7c9a      	ldrb	r2, [r3, #18]
 800a148:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a14a:	749a      	strb	r2, [r3, #18]

            (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a14c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a14e:	f103 0218 	add.w	r2, r3, #24
 800a152:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a154:	3330      	adds	r3, #48	; 0x30
 800a156:	6812      	ldr	r2, [r2, #0]
 800a158:	601a      	str	r2, [r3, #0]
            (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800a15a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a15c:	3318      	adds	r3, #24
 800a15e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a160:	f102 0130 	add.w	r1, r2, #48	; 0x30
 800a164:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a168:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a16c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a16e:	f103 0218 	add.w	r2, r3, #24
 800a172:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a174:	3330      	adds	r3, #48	; 0x30
 800a176:	7c12      	ldrb	r2, [r2, #16]
 800a178:	741a      	strb	r2, [r3, #16]
            (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800a17a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a17c:	f103 0218 	add.w	r2, r3, #24
 800a180:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a182:	3330      	adds	r3, #48	; 0x30
 800a184:	7c52      	ldrb	r2, [r2, #17]
 800a186:	745a      	strb	r2, [r3, #17]
            (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800a188:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a18a:	f103 0218 	add.w	r2, r3, #24
 800a18e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a190:	3330      	adds	r3, #48	; 0x30
 800a192:	7c92      	ldrb	r2, [r2, #18]
 800a194:	749a      	strb	r2, [r3, #18]

            (cache_entry + 1) -> fx_cached_sector_memory_buffer =   temp_storage.fx_cached_sector_memory_buffer;
 800a196:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a198:	3318      	adds	r3, #24
 800a19a:	693a      	ldr	r2, [r7, #16]
 800a19c:	601a      	str	r2, [r3, #0]
            (cache_entry + 1) -> fx_cached_sector =                 temp_storage.fx_cached_sector;
 800a19e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a1a0:	f103 0118 	add.w	r1, r3, #24
 800a1a4:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800a1a8:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    temp_storage.fx_cached_sector_buffer_dirty;
 800a1ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a1ae:	3318      	adds	r3, #24
 800a1b0:	f897 2020 	ldrb.w	r2, [r7, #32]
 800a1b4:	741a      	strb	r2, [r3, #16]
            (cache_entry + 1) -> fx_cached_sector_valid =           temp_storage.fx_cached_sector_valid;
 800a1b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a1b8:	3318      	adds	r3, #24
 800a1ba:	f897 2021 	ldrb.w	r2, [r7, #33]	; 0x21
 800a1be:	745a      	strb	r2, [r3, #17]
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;
 800a1c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a1c2:	3318      	adds	r3, #24
 800a1c4:	f897 2022 	ldrb.w	r2, [r7, #34]	; 0x22
 800a1c8:	749a      	strb	r2, [r3, #18]

            /* Success, return to caller immediately!  */
            return(FX_NULL);
 800a1ca:	2300      	movs	r3, #0
 800a1cc:	e18c      	b.n	800a4e8 <_fx_utility_logical_sector_cache_entry_read+0x588>
        }
        else if (((cache_entry + 3) -> fx_cached_sector_valid) && ((cache_entry + 3) -> fx_cached_sector == logical_sector))
 800a1ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a1d0:	3348      	adds	r3, #72	; 0x48
 800a1d2:	7c5b      	ldrb	r3, [r3, #17]
 800a1d4:	2b00      	cmp	r3, #0
 800a1d6:	f000 80ac 	beq.w	800a332 <_fx_utility_logical_sector_cache_entry_read+0x3d2>
 800a1da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a1dc:	3348      	adds	r3, #72	; 0x48
 800a1de:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a1e2:	e9d7 0100 	ldrd	r0, r1, [r7]
 800a1e6:	4299      	cmp	r1, r3
 800a1e8:	bf08      	it	eq
 800a1ea:	4290      	cmpeq	r0, r2
 800a1ec:	f040 80a1 	bne.w	800a332 <_fx_utility_logical_sector_cache_entry_read+0x3d2>
        {

            /* Yes, we found a match.  Simply setup the pointer to this
               buffer and return.  */
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 3) -> fx_cached_sector_memory_buffer;
 800a1f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a1f2:	3348      	adds	r3, #72	; 0x48
 800a1f4:	681a      	ldr	r2, [r3, #0]
 800a1f6:	68fb      	ldr	r3, [r7, #12]
 800a1f8:	609a      	str	r2, [r3, #8]

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of logical sectors cache read hits.  */
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a1fa:	68fb      	ldr	r3, [r7, #12]
 800a1fc:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800a200:	1c5a      	adds	r2, r3, #1
 800a202:	68fb      	ldr	r3, [r7, #12]
 800a204:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
#endif

            /* Move the last entry to the top and the first three entries down.  */
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a208:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a20a:	681b      	ldr	r3, [r3, #0]
 800a20c:	613b      	str	r3, [r7, #16]
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800a20e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a210:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a214:	e9c7 2306 	strd	r2, r3, [r7, #24]
            temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry) -> fx_cached_sector_buffer_dirty;
 800a218:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a21a:	7c1b      	ldrb	r3, [r3, #16]
 800a21c:	f887 3020 	strb.w	r3, [r7, #32]
            temp_storage.fx_cached_sector_valid =                   (cache_entry) -> fx_cached_sector_valid;
 800a220:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a222:	7c5b      	ldrb	r3, [r3, #17]
 800a224:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
            temp_storage.fx_cached_sector_type =                    (cache_entry) -> fx_cached_sector_type;
 800a228:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a22a:	7c9b      	ldrb	r3, [r3, #18]
 800a22c:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

            (cache_entry) -> fx_cached_sector_memory_buffer =       (cache_entry + 3) -> fx_cached_sector_memory_buffer;
 800a230:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a232:	3348      	adds	r3, #72	; 0x48
 800a234:	681a      	ldr	r2, [r3, #0]
 800a236:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a238:	601a      	str	r2, [r3, #0]
            (cache_entry) -> fx_cached_sector =                     (cache_entry + 3) -> fx_cached_sector;
 800a23a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a23c:	3348      	adds	r3, #72	; 0x48
 800a23e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a242:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800a244:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry) -> fx_cached_sector_buffer_dirty =        (cache_entry + 3) -> fx_cached_sector_buffer_dirty;
 800a248:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a24a:	3348      	adds	r3, #72	; 0x48
 800a24c:	7c1a      	ldrb	r2, [r3, #16]
 800a24e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a250:	741a      	strb	r2, [r3, #16]
            (cache_entry) -> fx_cached_sector_valid =               (cache_entry + 3) -> fx_cached_sector_valid;
 800a252:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a254:	3348      	adds	r3, #72	; 0x48
 800a256:	7c5a      	ldrb	r2, [r3, #17]
 800a258:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a25a:	745a      	strb	r2, [r3, #17]
            (cache_entry) -> fx_cached_sector_type =                (cache_entry + 3) -> fx_cached_sector_type;
 800a25c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a25e:	3348      	adds	r3, #72	; 0x48
 800a260:	7c9a      	ldrb	r2, [r3, #18]
 800a262:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a264:	749a      	strb	r2, [r3, #18]

            (cache_entry + 3) -> fx_cached_sector_memory_buffer =   (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a266:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a268:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800a26c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a26e:	3348      	adds	r3, #72	; 0x48
 800a270:	6812      	ldr	r2, [r2, #0]
 800a272:	601a      	str	r2, [r3, #0]
            (cache_entry + 3) -> fx_cached_sector =                 (cache_entry + 2) -> fx_cached_sector;
 800a274:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a276:	3330      	adds	r3, #48	; 0x30
 800a278:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a27a:	f102 0148 	add.w	r1, r2, #72	; 0x48
 800a27e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a282:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 3) -> fx_cached_sector_buffer_dirty =    (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800a286:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a288:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800a28c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a28e:	3348      	adds	r3, #72	; 0x48
 800a290:	7c12      	ldrb	r2, [r2, #16]
 800a292:	741a      	strb	r2, [r3, #16]
            (cache_entry + 3) -> fx_cached_sector_valid =           (cache_entry + 2) -> fx_cached_sector_valid;
 800a294:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a296:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800a29a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a29c:	3348      	adds	r3, #72	; 0x48
 800a29e:	7c52      	ldrb	r2, [r2, #17]
 800a2a0:	745a      	strb	r2, [r3, #17]
            (cache_entry + 3) -> fx_cached_sector_type =            (cache_entry + 2) -> fx_cached_sector_type;
 800a2a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2a4:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800a2a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2aa:	3348      	adds	r3, #72	; 0x48
 800a2ac:	7c92      	ldrb	r2, [r2, #18]
 800a2ae:	749a      	strb	r2, [r3, #18]

            (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a2b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2b2:	f103 0218 	add.w	r2, r3, #24
 800a2b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2b8:	3330      	adds	r3, #48	; 0x30
 800a2ba:	6812      	ldr	r2, [r2, #0]
 800a2bc:	601a      	str	r2, [r3, #0]
            (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800a2be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2c0:	3318      	adds	r3, #24
 800a2c2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a2c4:	f102 0130 	add.w	r1, r2, #48	; 0x30
 800a2c8:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a2cc:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a2d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2d2:	f103 0218 	add.w	r2, r3, #24
 800a2d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2d8:	3330      	adds	r3, #48	; 0x30
 800a2da:	7c12      	ldrb	r2, [r2, #16]
 800a2dc:	741a      	strb	r2, [r3, #16]
            (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800a2de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2e0:	f103 0218 	add.w	r2, r3, #24
 800a2e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2e6:	3330      	adds	r3, #48	; 0x30
 800a2e8:	7c52      	ldrb	r2, [r2, #17]
 800a2ea:	745a      	strb	r2, [r3, #17]
            (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800a2ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2ee:	f103 0218 	add.w	r2, r3, #24
 800a2f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2f4:	3330      	adds	r3, #48	; 0x30
 800a2f6:	7c92      	ldrb	r2, [r2, #18]
 800a2f8:	749a      	strb	r2, [r3, #18]

            (cache_entry + 1) -> fx_cached_sector_memory_buffer =   temp_storage.fx_cached_sector_memory_buffer;
 800a2fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a2fc:	3318      	adds	r3, #24
 800a2fe:	693a      	ldr	r2, [r7, #16]
 800a300:	601a      	str	r2, [r3, #0]
            (cache_entry + 1) -> fx_cached_sector =                 temp_storage.fx_cached_sector;
 800a302:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a304:	f103 0118 	add.w	r1, r3, #24
 800a308:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800a30c:	e9c1 2302 	strd	r2, r3, [r1, #8]
            (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    temp_storage.fx_cached_sector_buffer_dirty;
 800a310:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a312:	3318      	adds	r3, #24
 800a314:	f897 2020 	ldrb.w	r2, [r7, #32]
 800a318:	741a      	strb	r2, [r3, #16]
            (cache_entry + 1) -> fx_cached_sector_valid =           temp_storage.fx_cached_sector_valid;
 800a31a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a31c:	3318      	adds	r3, #24
 800a31e:	f897 2021 	ldrb.w	r2, [r7, #33]	; 0x21
 800a322:	745a      	strb	r2, [r3, #17]
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;
 800a324:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a326:	3318      	adds	r3, #24
 800a328:	f897 2022 	ldrb.w	r2, [r7, #34]	; 0x22
 800a32c:	749a      	strb	r2, [r3, #18]

            /* Success, return to caller immediately!  */
            return(FX_NULL);
 800a32e:	2300      	movs	r3, #0
 800a330:	e0da      	b.n	800a4e8 <_fx_utility_logical_sector_cache_entry_read+0x588>
        }

        /* At this point we have a cache miss.  We need to move all of the sectors down one slot, swapping
           the 4th entry with the first.  */
        temp_storage.fx_cached_sector_memory_buffer =           (cache_entry + 3) -> fx_cached_sector_memory_buffer;
 800a332:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a334:	3348      	adds	r3, #72	; 0x48
 800a336:	681b      	ldr	r3, [r3, #0]
 800a338:	613b      	str	r3, [r7, #16]
        temp_storage.fx_cached_sector =                         (cache_entry + 3) -> fx_cached_sector;
 800a33a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a33c:	3348      	adds	r3, #72	; 0x48
 800a33e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a342:	e9c7 2306 	strd	r2, r3, [r7, #24]
        temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry + 3) -> fx_cached_sector_buffer_dirty;
 800a346:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a348:	3348      	adds	r3, #72	; 0x48
 800a34a:	7c1b      	ldrb	r3, [r3, #16]
 800a34c:	f887 3020 	strb.w	r3, [r7, #32]
        temp_storage.fx_cached_sector_valid =                   (cache_entry + 3) -> fx_cached_sector_valid;
 800a350:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a352:	3348      	adds	r3, #72	; 0x48
 800a354:	7c5b      	ldrb	r3, [r3, #17]
 800a356:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
        temp_storage.fx_cached_sector_type =                    (cache_entry + 3) -> fx_cached_sector_type;
 800a35a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a35c:	3348      	adds	r3, #72	; 0x48
 800a35e:	7c9b      	ldrb	r3, [r3, #18]
 800a360:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

        (cache_entry + 3) -> fx_cached_sector_memory_buffer =   (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a364:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a366:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800a36a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a36c:	3348      	adds	r3, #72	; 0x48
 800a36e:	6812      	ldr	r2, [r2, #0]
 800a370:	601a      	str	r2, [r3, #0]
        (cache_entry + 3) -> fx_cached_sector =                 (cache_entry + 2) -> fx_cached_sector;
 800a372:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a374:	3330      	adds	r3, #48	; 0x30
 800a376:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a378:	f102 0148 	add.w	r1, r2, #72	; 0x48
 800a37c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a380:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (cache_entry + 3) -> fx_cached_sector_buffer_dirty =    (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800a384:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a386:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800a38a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a38c:	3348      	adds	r3, #72	; 0x48
 800a38e:	7c12      	ldrb	r2, [r2, #16]
 800a390:	741a      	strb	r2, [r3, #16]
        (cache_entry + 3) -> fx_cached_sector_valid =           (cache_entry + 2) -> fx_cached_sector_valid;
 800a392:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a394:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800a398:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a39a:	3348      	adds	r3, #72	; 0x48
 800a39c:	7c52      	ldrb	r2, [r2, #17]
 800a39e:	745a      	strb	r2, [r3, #17]
        (cache_entry + 3) -> fx_cached_sector_type =            (cache_entry + 2) -> fx_cached_sector_type;
 800a3a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3a2:	f103 0230 	add.w	r2, r3, #48	; 0x30
 800a3a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3a8:	3348      	adds	r3, #72	; 0x48
 800a3aa:	7c92      	ldrb	r2, [r2, #18]
 800a3ac:	749a      	strb	r2, [r3, #18]

        (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a3ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3b0:	f103 0218 	add.w	r2, r3, #24
 800a3b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3b6:	3330      	adds	r3, #48	; 0x30
 800a3b8:	6812      	ldr	r2, [r2, #0]
 800a3ba:	601a      	str	r2, [r3, #0]
        (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800a3bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3be:	3318      	adds	r3, #24
 800a3c0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a3c2:	f102 0130 	add.w	r1, r2, #48	; 0x30
 800a3c6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a3ca:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a3ce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3d0:	f103 0218 	add.w	r2, r3, #24
 800a3d4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3d6:	3330      	adds	r3, #48	; 0x30
 800a3d8:	7c12      	ldrb	r2, [r2, #16]
 800a3da:	741a      	strb	r2, [r3, #16]
        (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800a3dc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3de:	f103 0218 	add.w	r2, r3, #24
 800a3e2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3e4:	3330      	adds	r3, #48	; 0x30
 800a3e6:	7c52      	ldrb	r2, [r2, #17]
 800a3e8:	745a      	strb	r2, [r3, #17]
        (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800a3ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3ec:	f103 0218 	add.w	r2, r3, #24
 800a3f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3f2:	3330      	adds	r3, #48	; 0x30
 800a3f4:	7c92      	ldrb	r2, [r2, #18]
 800a3f6:	749a      	strb	r2, [r3, #18]

        (cache_entry + 1) -> fx_cached_sector_memory_buffer =   (cache_entry) -> fx_cached_sector_memory_buffer;
 800a3f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a3fa:	3318      	adds	r3, #24
 800a3fc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a3fe:	6812      	ldr	r2, [r2, #0]
 800a400:	601a      	str	r2, [r3, #0]
        (cache_entry + 1) -> fx_cached_sector =                 (cache_entry) -> fx_cached_sector;
 800a402:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a404:	f103 0118 	add.w	r1, r3, #24
 800a408:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a40a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a40e:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    (cache_entry) -> fx_cached_sector_buffer_dirty;
 800a412:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a414:	3318      	adds	r3, #24
 800a416:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a418:	7c12      	ldrb	r2, [r2, #16]
 800a41a:	741a      	strb	r2, [r3, #16]
        (cache_entry + 1) -> fx_cached_sector_valid =           (cache_entry) -> fx_cached_sector_valid;
 800a41c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a41e:	3318      	adds	r3, #24
 800a420:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a422:	7c52      	ldrb	r2, [r2, #17]
 800a424:	745a      	strb	r2, [r3, #17]
        (cache_entry + 1) -> fx_cached_sector_type =            (cache_entry) -> fx_cached_sector_type;
 800a426:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a428:	3318      	adds	r3, #24
 800a42a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a42c:	7c92      	ldrb	r2, [r2, #18]
 800a42e:	749a      	strb	r2, [r3, #18]

        (cache_entry) -> fx_cached_sector_memory_buffer =       temp_storage.fx_cached_sector_memory_buffer;
 800a430:	693a      	ldr	r2, [r7, #16]
 800a432:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a434:	601a      	str	r2, [r3, #0]
        (cache_entry) -> fx_cached_sector =                     temp_storage.fx_cached_sector;
 800a436:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800a43a:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800a43c:	e9c1 2302 	strd	r2, r3, [r1, #8]
        (cache_entry) -> fx_cached_sector_buffer_dirty =        temp_storage.fx_cached_sector_buffer_dirty;
 800a440:	f897 2020 	ldrb.w	r2, [r7, #32]
 800a444:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a446:	741a      	strb	r2, [r3, #16]
        (cache_entry) -> fx_cached_sector_valid =               temp_storage.fx_cached_sector_valid;
 800a448:	f897 2021 	ldrb.w	r2, [r7, #33]	; 0x21
 800a44c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a44e:	745a      	strb	r2, [r3, #17]
        (cache_entry) -> fx_cached_sector_type =                temp_storage.fx_cached_sector_type;
 800a450:	f897 2022 	ldrb.w	r2, [r7, #34]	; 0x22
 800a454:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a456:	749a      	strb	r2, [r3, #18]

        /* Set the previous pointer to NULL to avoid the linked list update below.  */
        *previous_cache_entry =  FX_NULL;
 800a458:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a45a:	2200      	movs	r2, #0
 800a45c:	601a      	str	r2, [r3, #0]
 800a45e:	e042      	b.n	800a4e6 <_fx_utility_logical_sector_cache_entry_read+0x586>
    }
    else
    {

        /* Search for an entry in the cache that matches this request.  */
        cache_size =            media_ptr -> fx_media_sector_cache_size;
 800a460:	68fb      	ldr	r3, [r7, #12]
 800a462:	695b      	ldr	r3, [r3, #20]
 800a464:	633b      	str	r3, [r7, #48]	; 0x30
        cache_entry =           media_ptr -> fx_media_sector_cache_list_ptr;
 800a466:	68fb      	ldr	r3, [r7, #12]
 800a468:	69db      	ldr	r3, [r3, #28]
 800a46a:	637b      	str	r3, [r7, #52]	; 0x34
        *previous_cache_entry =  FX_NULL;
 800a46c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a46e:	2200      	movs	r2, #0
 800a470:	601a      	str	r2, [r3, #0]

        /* Look at the cache entries until a match is found or the end of
           the cache is reached.  */
        while (cache_size--)
 800a472:	e033      	b.n	800a4dc <_fx_utility_logical_sector_cache_entry_read+0x57c>
        {

            /* Determine if the requested sector has been found.  */
            if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800a474:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a476:	7c5b      	ldrb	r3, [r3, #17]
 800a478:	2b00      	cmp	r3, #0
 800a47a:	d025      	beq.n	800a4c8 <_fx_utility_logical_sector_cache_entry_read+0x568>
 800a47c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a47e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a482:	e9d7 0100 	ldrd	r0, r1, [r7]
 800a486:	4299      	cmp	r1, r3
 800a488:	bf08      	it	eq
 800a48a:	4290      	cmpeq	r0, r2
 800a48c:	d11c      	bne.n	800a4c8 <_fx_utility_logical_sector_cache_entry_read+0x568>
            {

                /* Yes, we found a match.  Simply setup the pointer to this
                   buffer and return.  */
                media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 800a48e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a490:	681a      	ldr	r2, [r3, #0]
 800a492:	68fb      	ldr	r3, [r7, #12]
 800a494:	609a      	str	r2, [r3, #8]

                /* Determine if we need to update the last used list.  */
                if (*previous_cache_entry)
 800a496:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a498:	681b      	ldr	r3, [r3, #0]
 800a49a:	2b00      	cmp	r3, #0
 800a49c:	d00b      	beq.n	800a4b6 <_fx_utility_logical_sector_cache_entry_read+0x556>

                    /* Yes, the current entry is not at the front of the list
                       so we need to change the order.  */

                    /* Link the previous entry to this entry's next pointer.  */
                    (*previous_cache_entry) -> fx_cached_sector_next_used =
 800a49e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a4a0:	681b      	ldr	r3, [r3, #0]
                        cache_entry -> fx_cached_sector_next_used;
 800a4a2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a4a4:	6952      	ldr	r2, [r2, #20]
                    (*previous_cache_entry) -> fx_cached_sector_next_used =
 800a4a6:	615a      	str	r2, [r3, #20]

                    /* Place this entry at the head of the list.  */
                    cache_entry -> fx_cached_sector_next_used =
                        media_ptr -> fx_media_sector_cache_list_ptr;
 800a4a8:	68fb      	ldr	r3, [r7, #12]
 800a4aa:	69da      	ldr	r2, [r3, #28]
                    cache_entry -> fx_cached_sector_next_used =
 800a4ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a4ae:	615a      	str	r2, [r3, #20]
                    media_ptr -> fx_media_sector_cache_list_ptr =  cache_entry;
 800a4b0:	68fb      	ldr	r3, [r7, #12]
 800a4b2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a4b4:	61da      	str	r2, [r3, #28]
                }

#ifndef FX_MEDIA_STATISTICS_DISABLE

                /* Increment the number of logical sectors cache read hits.  */
                media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a4b6:	68fb      	ldr	r3, [r7, #12]
 800a4b8:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 800a4bc:	1c5a      	adds	r2, r3, #1
 800a4be:	68fb      	ldr	r3, [r7, #12]
 800a4c0:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
#endif

                /* Success, return to caller immediately!  */
                return(FX_NULL);
 800a4c4:	2300      	movs	r3, #0
 800a4c6:	e00f      	b.n	800a4e8 <_fx_utility_logical_sector_cache_entry_read+0x588>
            }

            /* Otherwise, we have not found the cached entry yet.  */

            /* If there are more entries, move to the next one.  */
            if (cache_entry -> fx_cached_sector_next_used)
 800a4c8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a4ca:	695b      	ldr	r3, [r3, #20]
 800a4cc:	2b00      	cmp	r3, #0
 800a4ce:	d005      	beq.n	800a4dc <_fx_utility_logical_sector_cache_entry_read+0x57c>
            {

                *previous_cache_entry =  cache_entry;
 800a4d0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a4d2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800a4d4:	601a      	str	r2, [r3, #0]
                cache_entry =           cache_entry -> fx_cached_sector_next_used;
 800a4d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a4d8:	695b      	ldr	r3, [r3, #20]
 800a4da:	637b      	str	r3, [r7, #52]	; 0x34
        while (cache_size--)
 800a4dc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a4de:	1e5a      	subs	r2, r3, #1
 800a4e0:	633a      	str	r2, [r7, #48]	; 0x30
 800a4e2:	2b00      	cmp	r3, #0
 800a4e4:	d1c6      	bne.n	800a474 <_fx_utility_logical_sector_cache_entry_read+0x514>
            }
        }
    }

    /* The requested sector is not in cache, return the last cache entry.  */
    return(cache_entry);
 800a4e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    FX_PARAMETER_NOT_USED(media_ptr);
    FX_PARAMETER_NOT_USED(logical_sector);
    FX_PARAMETER_NOT_USED(previous_cache_entry);
    return(FX_NULL);
#endif /* FX_DISABLE_CACHE */
}
 800a4e8:	4618      	mov	r0, r3
 800a4ea:	373c      	adds	r7, #60	; 0x3c
 800a4ec:	46bd      	mov	sp, r7
 800a4ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4f2:	4770      	bx	lr

0800a4f4 <_fx_utility_logical_sector_flush>:
/*                                            errors without cache,       */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_logical_sector_flush(FX_MEDIA *media_ptr, ULONG64 starting_sector, ULONG64 sectors, UINT invalidate)
{
 800a4f4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800a4f8:	b094      	sub	sp, #80	; 0x50
 800a4fa:	af00      	add	r7, sp, #0
 800a4fc:	61f8      	str	r0, [r7, #28]
 800a4fe:	e9c7 2304 	strd	r2, r3, [r7, #16]

    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_LOGICAL_SECTOR_FLUSH_EXTENSION

    /* Calculate the ending sector.  */
    ending_sector =  starting_sector + sectors - 1;
 800a502:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 800a506:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 800a50a:	1884      	adds	r4, r0, r2
 800a50c:	eb41 0503 	adc.w	r5, r1, r3
 800a510:	1e63      	subs	r3, r4, #1
 800a512:	60bb      	str	r3, [r7, #8]
 800a514:	f145 33ff 	adc.w	r3, r5, #4294967295
 800a518:	60fb      	str	r3, [r7, #12]
 800a51a:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800a51e:	e9c7 3408 	strd	r3, r4, [r7, #32]

    /* Pickup the number of dirty sectors currently in the cache.  */
    remaining_dirty =  media_ptr -> fx_media_sector_cache_dirty_count;
 800a522:	69fb      	ldr	r3, [r7, #28]
 800a524:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a526:	633b      	str	r3, [r7, #48]	; 0x30

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_MEDIA_FLUSH, media_ptr, media_ptr -> fx_media_sector_cache_dirty_count, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Determine what type of cache configuration we have.  */
    if (media_ptr -> fx_media_sector_cache_hashed == FX_FALSE)
 800a528:	69fb      	ldr	r3, [r7, #28]
 800a52a:	691b      	ldr	r3, [r3, #16]
 800a52c:	2b00      	cmp	r3, #0
 800a52e:	f040 80b4 	bne.w	800a69a <_fx_utility_logical_sector_flush+0x1a6>

        /* Linear cache present, simply walk through the search list until
           an unused cache entry is present.  */

        /* Flush and invalidate the internal logical sector cache.  */
        cache_size =            media_ptr -> fx_media_sector_cache_size;
 800a532:	69fb      	ldr	r3, [r7, #28]
 800a534:	695b      	ldr	r3, [r3, #20]
 800a536:	64bb      	str	r3, [r7, #72]	; 0x48
        cache_entry =           media_ptr -> fx_media_sector_cache_list_ptr;
 800a538:	69fb      	ldr	r3, [r7, #28]
 800a53a:	69db      	ldr	r3, [r3, #28]
 800a53c:	64fb      	str	r3, [r7, #76]	; 0x4c

        /* Look at the cache entries that have been written to.  */
        while ((cache_size--) && (cache_entry -> fx_cached_sector))
 800a53e:	e09f      	b.n	800a680 <_fx_utility_logical_sector_flush+0x18c>
        {

            /* Determine if invalidation is not required and there are no
               more dirty sectors. */
            if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 800a540:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a542:	2b00      	cmp	r3, #0
 800a544:	d103      	bne.n	800a54e <_fx_utility_logical_sector_flush+0x5a>
 800a546:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800a548:	2b00      	cmp	r3, #0
 800a54a:	f000 81de 	beq.w	800a90a <_fx_utility_logical_sector_flush+0x416>
                /* Yes, nothing left to do.  */
                break;
            }

            /* Determine if there are any more sectors to process.  */
            if (sectors == 0)
 800a54e:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 800a552:	4313      	orrs	r3, r2
 800a554:	f000 81db 	beq.w	800a90e <_fx_utility_logical_sector_flush+0x41a>
                /* No more sectors required to process.  */
                break;
            }

            /* Determine if this cached sector is within the specified range and is valid.  */
            if ((cache_entry -> fx_cached_sector_valid) &&
 800a558:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a55a:	7c5b      	ldrb	r3, [r3, #17]
 800a55c:	2b00      	cmp	r3, #0
 800a55e:	f000 808c 	beq.w	800a67a <_fx_utility_logical_sector_flush+0x186>
                (cache_entry -> fx_cached_sector >= starting_sector) &&
 800a562:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a564:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
            if ((cache_entry -> fx_cached_sector_valid) &&
 800a568:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800a56c:	4290      	cmp	r0, r2
 800a56e:	eb71 0303 	sbcs.w	r3, r1, r3
 800a572:	f0c0 8082 	bcc.w	800a67a <_fx_utility_logical_sector_flush+0x186>
                (cache_entry -> fx_cached_sector <= ending_sector))
 800a576:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a578:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
                (cache_entry -> fx_cached_sector >= starting_sector) &&
 800a57c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800a580:	4290      	cmp	r0, r2
 800a582:	eb71 0303 	sbcs.w	r3, r1, r3
 800a586:	d378      	bcc.n	800a67a <_fx_utility_logical_sector_flush+0x186>
            {

                /* Yes, the cache entry is valid and within the specified range. Determine if
                   the requested sector has been written to.  */
                if (cache_entry -> fx_cached_sector_buffer_dirty)
 800a588:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a58a:	7c1b      	ldrb	r3, [r3, #16]
 800a58c:	2b00      	cmp	r3, #0
 800a58e:	d04d      	beq.n	800a62c <_fx_utility_logical_sector_flush+0x138>
                {

                    /* Yes, write the cached sector out to the media.  */

                    /* Check for write protect at the media level (set by driver).  */
                    if (media_ptr -> fx_media_driver_write_protect == FX_FALSE)
 800a590:	69fb      	ldr	r3, [r7, #28]
 800a592:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 800a596:	2b00      	cmp	r3, #0
 800a598:	d148      	bne.n	800a62c <_fx_utility_logical_sector_flush+0x138>
                    {

#ifndef FX_MEDIA_STATISTICS_DISABLE

                        /* Increment the number of driver write sector(s) requests.  */
                        media_ptr -> fx_media_driver_write_requests++;
 800a59a:	69fb      	ldr	r3, [r7, #28]
 800a59c:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800a5a0:	1c5a      	adds	r2, r3, #1
 800a5a2:	69fb      	ldr	r3, [r7, #28]
 800a5a4:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
#endif

                        /* Build write request to the driver.  */
                        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800a5a8:	69fb      	ldr	r3, [r7, #28]
 800a5aa:	2201      	movs	r2, #1
 800a5ac:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800a5b0:	69fb      	ldr	r3, [r7, #28]
 800a5b2:	2290      	movs	r2, #144	; 0x90
 800a5b4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
                        media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 800a5b8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a5ba:	681a      	ldr	r2, [r3, #0]
 800a5bc:	69fb      	ldr	r3, [r7, #28]
 800a5be:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
                        media_ptr -> fx_media_driver_logical_sector =   cache_entry -> fx_cached_sector;
#else
                        media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 800a5c2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a5c4:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a5c8:	69fb      	ldr	r3, [r7, #28]
 800a5ca:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#endif
                        media_ptr -> fx_media_driver_sectors =          1;
 800a5ce:	69fb      	ldr	r3, [r7, #28]
 800a5d0:	2201      	movs	r2, #1
 800a5d2:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
                        media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 800a5d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a5d8:	7c9b      	ldrb	r3, [r3, #18]
 800a5da:	461a      	mov	r2, r3
 800a5dc:	69fb      	ldr	r3, [r7, #28]
 800a5de:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

                        /* Sectors other than FX_DATA_SECTOR will never be dirty when FX_FAULT_TOLERANT is defined. */
#ifndef FX_FAULT_TOLERANT
                        /* Determine if the system write flag needs to be set.  */
                        if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 800a5e2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a5e4:	7c9b      	ldrb	r3, [r3, #18]
 800a5e6:	2b04      	cmp	r3, #4
 800a5e8:	d003      	beq.n	800a5f2 <_fx_utility_logical_sector_flush+0xfe>
                        {

                            /* Yes, a system sector write is present so set the flag.  The driver
                               can use this flag to make extra safeguards in writing the sector
                               out, yielding more fault tolerance.  */
                            media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800a5ea:	69fb      	ldr	r3, [r7, #28]
 800a5ec:	2201      	movs	r2, #1
 800a5ee:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

                        /* If trace is enabled, insert this event into the trace buffer.  */
                        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, cache_entry -> fx_cached_sector, 1, cache_entry -> fx_cached_sector_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                        /* Invoke the driver to write the sector.  */
                        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800a5f2:	69fb      	ldr	r3, [r7, #28]
 800a5f4:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800a5f8:	69f8      	ldr	r0, [r7, #28]
 800a5fa:	4798      	blx	r3

                        /* Clear the system write flag.  */
                        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800a5fc:	69fb      	ldr	r3, [r7, #28]
 800a5fe:	2200      	movs	r2, #0
 800a600:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

                        /* Check for successful completion.  */
                        if (media_ptr -> fx_media_driver_status)
 800a604:	69fb      	ldr	r3, [r7, #28]
 800a606:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800a60a:	2b00      	cmp	r3, #0
 800a60c:	d003      	beq.n	800a616 <_fx_utility_logical_sector_flush+0x122>
                        {

                            /* Error writing a cached sector out.  Return the
                               error status.  */
                            return(media_ptr -> fx_media_driver_status);
 800a60e:	69fb      	ldr	r3, [r7, #28]
 800a610:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800a614:	e17f      	b.n	800a916 <_fx_utility_logical_sector_flush+0x422>
                        }

                        /* Clear the buffer dirty flag since it has been flushed
                           out.  */
                        cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 800a616:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a618:	2200      	movs	r2, #0
 800a61a:	741a      	strb	r2, [r3, #16]

                        /* Decrement the number of dirty sectors currently in the cache.  */
                        media_ptr -> fx_media_sector_cache_dirty_count--;
 800a61c:	69fb      	ldr	r3, [r7, #28]
 800a61e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a620:	1e5a      	subs	r2, r3, #1
 800a622:	69fb      	ldr	r3, [r7, #28]
 800a624:	625a      	str	r2, [r3, #36]	; 0x24
                        remaining_dirty--;
 800a626:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a628:	3b01      	subs	r3, #1
 800a62a:	633b      	str	r3, [r7, #48]	; 0x30
                    }
                }

                /* Determine if the invalidate option is specified.  */
                if (invalidate)
 800a62c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800a62e:	2b00      	cmp	r3, #0
 800a630:	d018      	beq.n	800a664 <_fx_utility_logical_sector_flush+0x170>
                {

                    /* Invalidate the cache entry.  */
                    cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 800a632:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a634:	2200      	movs	r2, #0
 800a636:	745a      	strb	r2, [r3, #17]

                    /* Place all ones in the sector number.  */
                    cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 800a638:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800a63a:	f04f 32ff 	mov.w	r2, #4294967295
 800a63e:	f04f 33ff 	mov.w	r3, #4294967295
 800a642:	e9c1 2302 	strd	r2, r3, [r1, #8]

                    /* Determine if this sector is still dirty, this could be the case if
                       write protection was turned on.  */
                    if (cache_entry -> fx_cached_sector_buffer_dirty)
 800a646:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a648:	7c1b      	ldrb	r3, [r3, #16]
 800a64a:	2b00      	cmp	r3, #0
 800a64c:	d00a      	beq.n	800a664 <_fx_utility_logical_sector_flush+0x170>
                    {

                        /* Yes, clear the dirty flag.  */
                        cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 800a64e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a650:	2200      	movs	r2, #0
 800a652:	741a      	strb	r2, [r3, #16]

                        /* Decrement the number of dirty sectors currently in the cache.  */
                        media_ptr -> fx_media_sector_cache_dirty_count--;
 800a654:	69fb      	ldr	r3, [r7, #28]
 800a656:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a658:	1e5a      	subs	r2, r3, #1
 800a65a:	69fb      	ldr	r3, [r7, #28]
 800a65c:	625a      	str	r2, [r3, #36]	; 0x24
                        remaining_dirty--;
 800a65e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a660:	3b01      	subs	r3, #1
 800a662:	633b      	str	r3, [r7, #48]	; 0x30
                    }
                }

                /* Decrement the number of sectors in the range that have been processed.  */
                sectors--;
 800a664:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 800a668:	1e51      	subs	r1, r2, #1
 800a66a:	6039      	str	r1, [r7, #0]
 800a66c:	f143 33ff 	adc.w	r3, r3, #4294967295
 800a670:	607b      	str	r3, [r7, #4]
 800a672:	e9d7 3400 	ldrd	r3, r4, [r7]
 800a676:	e9c7 341c 	strd	r3, r4, [r7, #112]	; 0x70
            }

            /* Move to the next entry in the sector cache.  */
            cache_entry =  cache_entry -> fx_cached_sector_next_used;
 800a67a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a67c:	695b      	ldr	r3, [r3, #20]
 800a67e:	64fb      	str	r3, [r7, #76]	; 0x4c
        while ((cache_size--) && (cache_entry -> fx_cached_sector))
 800a680:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800a682:	1e5a      	subs	r2, r3, #1
 800a684:	64ba      	str	r2, [r7, #72]	; 0x48
 800a686:	2b00      	cmp	r3, #0
 800a688:	f000 8144 	beq.w	800a914 <_fx_utility_logical_sector_flush+0x420>
 800a68c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a68e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a692:	4313      	orrs	r3, r2
 800a694:	f47f af54 	bne.w	800a540 <_fx_utility_logical_sector_flush+0x4c>
 800a698:	e13c      	b.n	800a914 <_fx_utility_logical_sector_flush+0x420>
    }
    else
    {

        /* Hashed cache is present. Pickup the cache size.  */
        cache_size =            media_ptr -> fx_media_sector_cache_size;
 800a69a:	69fb      	ldr	r3, [r7, #28]
 800a69c:	695b      	ldr	r3, [r3, #20]
 800a69e:	64bb      	str	r3, [r7, #72]	; 0x48

        /* Initialize the loop control parameters.  */
        bit_set =  0;
 800a6a0:	2300      	movs	r3, #0
 800a6a2:	643b      	str	r3, [r7, #64]	; 0x40
        valid_bit_map =  media_ptr -> fx_media_sector_cache_hashed_sector_valid;
 800a6a4:	69fb      	ldr	r3, [r7, #28]
 800a6a6:	6a1b      	ldr	r3, [r3, #32]
 800a6a8:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Determine how to process the hashed cache based on the number of sectors
           to process. If the sequential sector range is less than the bit map size,
           simply use the starting sector to derive the index into the cache.  */
        if (sectors < 32)
 800a6aa:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 800a6ae:	2a20      	cmp	r2, #32
 800a6b0:	f173 0300 	sbcs.w	r3, r3, #0
 800a6b4:	d202      	bcs.n	800a6bc <_fx_utility_logical_sector_flush+0x1c8>
        {
            use_starting_sector =  FX_TRUE;
 800a6b6:	2301      	movs	r3, #1
 800a6b8:	63fb      	str	r3, [r7, #60]	; 0x3c
 800a6ba:	e121      	b.n	800a900 <_fx_utility_logical_sector_flush+0x40c>
        }
        else
        {
            use_starting_sector =  FX_FALSE;
 800a6bc:	2300      	movs	r3, #0
 800a6be:	63fb      	str	r3, [r7, #60]	; 0x3c
        }

        /* Determine if there is anything valid in the cache.  */
        while (valid_bit_map)
 800a6c0:	e11e      	b.n	800a900 <_fx_utility_logical_sector_flush+0x40c>
        {

            /* Determine if invalidation is not required and there are no
               more dirty sectors. */
            if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 800a6c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a6c4:	2b00      	cmp	r3, #0
 800a6c6:	d103      	bne.n	800a6d0 <_fx_utility_logical_sector_flush+0x1dc>
 800a6c8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800a6ca:	2b00      	cmp	r3, #0
 800a6cc:	f000 8121 	beq.w	800a912 <_fx_utility_logical_sector_flush+0x41e>
                /* Yes, nothing left to do.  */
                break;
            }

            /* Determine if there are any more sectors to process.  */
            if ((sectors == 0) || (starting_sector > ending_sector))
 800a6d0:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 800a6d4:	4313      	orrs	r3, r2
 800a6d6:	f000 811d 	beq.w	800a914 <_fx_utility_logical_sector_flush+0x420>
 800a6da:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800a6de:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800a6e2:	4290      	cmp	r0, r2
 800a6e4:	eb71 0303 	sbcs.w	r3, r1, r3
 800a6e8:	f0c0 8114 	bcc.w	800a914 <_fx_utility_logical_sector_flush+0x420>
                /* No more sectors required to process.  */
                break;
            }

            /* Determine how to compute the hash index.  */
            if (use_starting_sector)
 800a6ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a6ee:	2b00      	cmp	r3, #0
 800a6f0:	d015      	beq.n	800a71e <_fx_utility_logical_sector_flush+0x22a>
            {

                /* Calculate the hash value of this sector using the lower bits.  */
                index =  (ULONG)(starting_sector & media_ptr -> fx_media_sector_cache_hash_mask);
 800a6f2:	693a      	ldr	r2, [r7, #16]
 800a6f4:	69fb      	ldr	r3, [r7, #28]
 800a6f6:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 800a6fa:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 800a6fe:	4013      	ands	r3, r2
 800a700:	63bb      	str	r3, [r7, #56]	; 0x38

                /* Calculate the bit set indicating there is one or more valid sectors at this cache index.  */
                bit_set =  (index % 32);
 800a702:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a704:	f003 031f 	and.w	r3, r3, #31
 800a708:	643b      	str	r3, [r7, #64]	; 0x40

                /* Compute the actual array index by multiplying by the cache depth.  */
                index =  (bit_set * FX_SECTOR_CACHE_DEPTH);
 800a70a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a70c:	009b      	lsls	r3, r3, #2
 800a70e:	63bb      	str	r3, [r7, #56]	; 0x38
 800a710:	e00d      	b.n	800a72e <_fx_utility_logical_sector_flush+0x23a>
                /* Find the next set bit.  */
                while ((valid_bit_map & 1) == 0)
                {

                    /* Otherwise, shift down the bit in the bit map.  */
                    valid_bit_map =  valid_bit_map >> 1;
 800a712:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a714:	085b      	lsrs	r3, r3, #1
 800a716:	62fb      	str	r3, [r7, #44]	; 0x2c

                    /* Increment the set bit marker.  */
                    bit_set++;
 800a718:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a71a:	3301      	adds	r3, #1
 800a71c:	643b      	str	r3, [r7, #64]	; 0x40
                while ((valid_bit_map & 1) == 0)
 800a71e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a720:	f003 0301 	and.w	r3, r3, #1
 800a724:	2b00      	cmp	r3, #0
 800a726:	d0f4      	beq.n	800a712 <_fx_utility_logical_sector_flush+0x21e>
                }

                /* Compute the first actual index into the hashed cache.  */
                index =  (bit_set * FX_SECTOR_CACHE_DEPTH);
 800a728:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a72a:	009b      	lsls	r3, r3, #2
 800a72c:	63bb      	str	r3, [r7, #56]	; 0x38
            /* At this point, bit_set represents the next group of hashed sectors that could
               have valid cache entries and index represents the index into the sector cache
               of that sector group.  */

            /* Clear the remaining valid sectors for this entry in the bit map.  */
            remaining_valid =  0;
 800a72e:	2300      	movs	r3, #0
 800a730:	637b      	str	r3, [r7, #52]	; 0x34
            /* Loop to check the corresponding hash entries.  */
            do
            {

                /* Setup pointer to the cache entry.  */
                cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 800a732:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a734:	4613      	mov	r3, r2
 800a736:	005b      	lsls	r3, r3, #1
 800a738:	4413      	add	r3, r2
 800a73a:	00db      	lsls	r3, r3, #3
 800a73c:	f503 634a 	add.w	r3, r3, #3232	; 0xca0
 800a740:	69fa      	ldr	r2, [r7, #28]
 800a742:	4413      	add	r3, r2
 800a744:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* Loop to examine the full depth of the hashed cache.  */
                for (i = 0; i < 4; i++)
 800a746:	2300      	movs	r3, #0
 800a748:	647b      	str	r3, [r7, #68]	; 0x44
 800a74a:	e0a7      	b.n	800a89c <_fx_utility_logical_sector_flush+0x3a8>
                {

                    /* Determine if this cached sector is within the specified range and is valid.  */
                    if ((cache_entry -> fx_cached_sector_valid) &&
 800a74c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a74e:	7c5b      	ldrb	r3, [r3, #17]
 800a750:	2b00      	cmp	r3, #0
 800a752:	f000 8089 	beq.w	800a868 <_fx_utility_logical_sector_flush+0x374>
                        (cache_entry -> fx_cached_sector >= starting_sector) &&
 800a756:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a758:	e9d3 0102 	ldrd	r0, r1, [r3, #8]
                    if ((cache_entry -> fx_cached_sector_valid) &&
 800a75c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800a760:	4290      	cmp	r0, r2
 800a762:	eb71 0303 	sbcs.w	r3, r1, r3
 800a766:	d37f      	bcc.n	800a868 <_fx_utility_logical_sector_flush+0x374>
                        (cache_entry -> fx_cached_sector <= ending_sector))
 800a768:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a76a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
                        (cache_entry -> fx_cached_sector >= starting_sector) &&
 800a76e:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800a772:	4290      	cmp	r0, r2
 800a774:	eb71 0303 	sbcs.w	r3, r1, r3
 800a778:	d376      	bcc.n	800a868 <_fx_utility_logical_sector_flush+0x374>
                    {

                        /* Determine if the requested sector has been written to.  */
                        if (cache_entry -> fx_cached_sector_buffer_dirty)
 800a77a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a77c:	7c1b      	ldrb	r3, [r3, #16]
 800a77e:	2b00      	cmp	r3, #0
 800a780:	d04d      	beq.n	800a81e <_fx_utility_logical_sector_flush+0x32a>


                            /* Yes, write the cached sector out to the media.  */

                            /* Check for write protect at the media level (set by driver).  */
                            if (media_ptr -> fx_media_driver_write_protect == FX_FALSE)
 800a782:	69fb      	ldr	r3, [r7, #28]
 800a784:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 800a788:	2b00      	cmp	r3, #0
 800a78a:	d148      	bne.n	800a81e <_fx_utility_logical_sector_flush+0x32a>
                            {

#ifndef FX_MEDIA_STATISTICS_DISABLE

                                /* Increment the number of driver write sector(s) requests.  */
                                media_ptr -> fx_media_driver_write_requests++;
 800a78c:	69fb      	ldr	r3, [r7, #28]
 800a78e:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800a792:	1c5a      	adds	r2, r3, #1
 800a794:	69fb      	ldr	r3, [r7, #28]
 800a796:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
#endif

                                /* Build Write request to the driver.  */
                                media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800a79a:	69fb      	ldr	r3, [r7, #28]
 800a79c:	2201      	movs	r2, #1
 800a79e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800a7a2:	69fb      	ldr	r3, [r7, #28]
 800a7a4:	2290      	movs	r2, #144	; 0x90
 800a7a6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
                                media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 800a7aa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a7ac:	681a      	ldr	r2, [r3, #0]
 800a7ae:	69fb      	ldr	r3, [r7, #28]
 800a7b0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
                                media_ptr -> fx_media_driver_logical_sector =   cache_entry -> fx_cached_sector;
#else
                                media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 800a7b4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a7b6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a7ba:	69fb      	ldr	r3, [r7, #28]
 800a7bc:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#endif
                                media_ptr -> fx_media_driver_sectors =          1;
 800a7c0:	69fb      	ldr	r3, [r7, #28]
 800a7c2:	2201      	movs	r2, #1
 800a7c4:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
                                media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 800a7c8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a7ca:	7c9b      	ldrb	r3, [r3, #18]
 800a7cc:	461a      	mov	r2, r3
 800a7ce:	69fb      	ldr	r3, [r7, #28]
 800a7d0:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

                                /* Sectors other than FX_DATA_SECTOR will never be dirty when FX_FAULT_TOLERANT is defined. */
#ifndef FX_FAULT_TOLERANT
                                /* Determine if the system write flag needs to be set.  */
                                if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 800a7d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a7d6:	7c9b      	ldrb	r3, [r3, #18]
 800a7d8:	2b04      	cmp	r3, #4
 800a7da:	d003      	beq.n	800a7e4 <_fx_utility_logical_sector_flush+0x2f0>
                                {

                                    /* Yes, a system sector write is present so set the flag.  The driver
                                       can use this flag to make extra safeguards in writing the sector
                                       out, yielding more fault tolerance.  */
                                    media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800a7dc:	69fb      	ldr	r3, [r7, #28]
 800a7de:	2201      	movs	r2, #1
 800a7e0:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

                                /* If trace is enabled, insert this event into the trace buffer.  */
                                FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, cache_entry -> fx_cached_sector, 1, cache_entry -> fx_cached_sector_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                                /* Invoke the driver to write the sector.  */
                                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800a7e4:	69fb      	ldr	r3, [r7, #28]
 800a7e6:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800a7ea:	69f8      	ldr	r0, [r7, #28]
 800a7ec:	4798      	blx	r3

                                /* Clear the system write flag.  */
                                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800a7ee:	69fb      	ldr	r3, [r7, #28]
 800a7f0:	2200      	movs	r2, #0
 800a7f2:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

                                /* Check for successful completion.  */
                                if (media_ptr -> fx_media_driver_status)
 800a7f6:	69fb      	ldr	r3, [r7, #28]
 800a7f8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800a7fc:	2b00      	cmp	r3, #0
 800a7fe:	d003      	beq.n	800a808 <_fx_utility_logical_sector_flush+0x314>
                                {

                                    /* Error writing a cached sector out.  Return the
                                       error status.  */
                                    return(media_ptr -> fx_media_driver_status);
 800a800:	69fb      	ldr	r3, [r7, #28]
 800a802:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800a806:	e086      	b.n	800a916 <_fx_utility_logical_sector_flush+0x422>
                                }

                                /* Clear the buffer dirty flag since it has been flushed
                                   out.  */
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 800a808:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a80a:	2200      	movs	r2, #0
 800a80c:	741a      	strb	r2, [r3, #16]

                                /* Decrement the number of dirty sectors currently in the cache.  */
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 800a80e:	69fb      	ldr	r3, [r7, #28]
 800a810:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a812:	1e5a      	subs	r2, r3, #1
 800a814:	69fb      	ldr	r3, [r7, #28]
 800a816:	625a      	str	r2, [r3, #36]	; 0x24
                                remaining_dirty--;
 800a818:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a81a:	3b01      	subs	r3, #1
 800a81c:	633b      	str	r3, [r7, #48]	; 0x30
                            }
                        }

                        /* Determine if the invalidate option is specified.  */
                        if (invalidate)
 800a81e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800a820:	2b00      	cmp	r3, #0
 800a822:	d018      	beq.n	800a856 <_fx_utility_logical_sector_flush+0x362>
                        {

                            /* Invalidate the cache entry.  */
                            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 800a824:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a826:	2200      	movs	r2, #0
 800a828:	745a      	strb	r2, [r3, #17]

                            /* Place all ones in the sector number.  */
                            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 800a82a:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 800a82c:	f04f 32ff 	mov.w	r2, #4294967295
 800a830:	f04f 33ff 	mov.w	r3, #4294967295
 800a834:	e9c1 2302 	strd	r2, r3, [r1, #8]

                            /* Determine if this sector is still dirty, this could be the case if
                               write protection was turned on.  */
                            if (cache_entry -> fx_cached_sector_buffer_dirty)
 800a838:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a83a:	7c1b      	ldrb	r3, [r3, #16]
 800a83c:	2b00      	cmp	r3, #0
 800a83e:	d00a      	beq.n	800a856 <_fx_utility_logical_sector_flush+0x362>
                            {

                                /* Yes, clear the dirty flag.  */
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 800a840:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a842:	2200      	movs	r2, #0
 800a844:	741a      	strb	r2, [r3, #16]

                                /* Decrement the number of dirty sectors currently in the cache.  */
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 800a846:	69fb      	ldr	r3, [r7, #28]
 800a848:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a84a:	1e5a      	subs	r2, r3, #1
 800a84c:	69fb      	ldr	r3, [r7, #28]
 800a84e:	625a      	str	r2, [r3, #36]	; 0x24
                                remaining_dirty--;
 800a850:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a852:	3b01      	subs	r3, #1
 800a854:	633b      	str	r3, [r7, #48]	; 0x30
                            }
                        }

                        /* Decrement the number of sectors in the range that have been processed.  */
                        sectors--;
 800a856:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 800a85a:	f112 38ff 	adds.w	r8, r2, #4294967295
 800a85e:	f143 39ff 	adc.w	r9, r3, #4294967295
 800a862:	e9c7 891c 	strd	r8, r9, [r7, #112]	; 0x70
 800a866:	e006      	b.n	800a876 <_fx_utility_logical_sector_flush+0x382>
                    }
                    else
                    {

                        /* Determine if the sector is valid.  */
                        if (cache_entry -> fx_cached_sector_valid)
 800a868:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a86a:	7c5b      	ldrb	r3, [r3, #17]
 800a86c:	2b00      	cmp	r3, #0
 800a86e:	d002      	beq.n	800a876 <_fx_utility_logical_sector_flush+0x382>
                        {

                            /* Increment the number of still remaining but out of range sectors.  */
                            remaining_valid++;
 800a870:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a872:	3301      	adds	r3, #1
 800a874:	637b      	str	r3, [r7, #52]	; 0x34
                        }
                    }

                    /* Determine if invalidation is not required and there are no
                       more dirty sectors. */
                    if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 800a876:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a878:	2b00      	cmp	r3, #0
 800a87a:	d102      	bne.n	800a882 <_fx_utility_logical_sector_flush+0x38e>
 800a87c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800a87e:	2b00      	cmp	r3, #0
 800a880:	d011      	beq.n	800a8a6 <_fx_utility_logical_sector_flush+0x3b2>
                        /* Yes, nothing left to do.  */
                        break;
                    }

                    /* Determine if there are any more sectors to process.  */
                    if ((sectors == 0) && (invalidate == FX_FALSE))
 800a882:	e9d7 231c 	ldrd	r2, r3, [r7, #112]	; 0x70
 800a886:	4313      	orrs	r3, r2
 800a888:	d102      	bne.n	800a890 <_fx_utility_logical_sector_flush+0x39c>
 800a88a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800a88c:	2b00      	cmp	r3, #0
 800a88e:	d00c      	beq.n	800a8aa <_fx_utility_logical_sector_flush+0x3b6>
                        /* No more sectors required to process.  */
                        break;
                    }

                    /* Move to the next cache entry.  */
                    cache_entry++;
 800a890:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a892:	3318      	adds	r3, #24
 800a894:	64fb      	str	r3, [r7, #76]	; 0x4c
                for (i = 0; i < 4; i++)
 800a896:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a898:	3301      	adds	r3, #1
 800a89a:	647b      	str	r3, [r7, #68]	; 0x44
 800a89c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a89e:	2b03      	cmp	r3, #3
 800a8a0:	f67f af54 	bls.w	800a74c <_fx_utility_logical_sector_flush+0x258>
 800a8a4:	e002      	b.n	800a8ac <_fx_utility_logical_sector_flush+0x3b8>
                        break;
 800a8a6:	bf00      	nop
 800a8a8:	e000      	b.n	800a8ac <_fx_utility_logical_sector_flush+0x3b8>
                        break;
 800a8aa:	bf00      	nop
                }

                /* Move the index to the next position since the bit map can only represent 32
                   cache entries.  */
                index =  index + (32 * FX_SECTOR_CACHE_DEPTH);
 800a8ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a8ae:	3380      	adds	r3, #128	; 0x80
 800a8b0:	63bb      	str	r3, [r7, #56]	; 0x38
            } while (index < cache_size);
 800a8b2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a8b4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800a8b6:	429a      	cmp	r2, r3
 800a8b8:	f4ff af3b 	bcc.w	800a732 <_fx_utility_logical_sector_flush+0x23e>

            /* Determine if invalidation was required and there are no more valid sectors
               associated with this bit position.  */
            if ((invalidate) && (remaining_valid == 0))
 800a8bc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800a8be:	2b00      	cmp	r3, #0
 800a8c0:	d00c      	beq.n	800a8dc <_fx_utility_logical_sector_flush+0x3e8>
 800a8c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a8c4:	2b00      	cmp	r3, #0
 800a8c6:	d109      	bne.n	800a8dc <_fx_utility_logical_sector_flush+0x3e8>
            {

                /* Clear this bit position.  */
                media_ptr -> fx_media_sector_cache_hashed_sector_valid &=  ~(((ULONG)1) << bit_set);
 800a8c8:	69fb      	ldr	r3, [r7, #28]
 800a8ca:	6a1a      	ldr	r2, [r3, #32]
 800a8cc:	2101      	movs	r1, #1
 800a8ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a8d0:	fa01 f303 	lsl.w	r3, r1, r3
 800a8d4:	43db      	mvns	r3, r3
 800a8d6:	401a      	ands	r2, r3
 800a8d8:	69fb      	ldr	r3, [r7, #28]
 800a8da:	621a      	str	r2, [r3, #32]
            }

            /* Determine if the starting sector is being used for examination of the hash.  */
            if (use_starting_sector)
 800a8dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a8de:	2b00      	cmp	r3, #0
 800a8e0:	d008      	beq.n	800a8f4 <_fx_utility_logical_sector_flush+0x400>
            {

                /* Move to the next sector.  */
                starting_sector++;
 800a8e2:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800a8e6:	f112 0a01 	adds.w	sl, r2, #1
 800a8ea:	f143 0b00 	adc.w	fp, r3, #0
 800a8ee:	e9c7 ab04 	strd	sl, fp, [r7, #16]
 800a8f2:	e005      	b.n	800a900 <_fx_utility_logical_sector_flush+0x40c>
            }
            else
            {

                /* Move to next bit in the map.  */
                valid_bit_map =  valid_bit_map >> 1;
 800a8f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a8f6:	085b      	lsrs	r3, r3, #1
 800a8f8:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Increment the set bit marker.  */
                bit_set++;
 800a8fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a8fc:	3301      	adds	r3, #1
 800a8fe:	643b      	str	r3, [r7, #64]	; 0x40
        while (valid_bit_map)
 800a900:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a902:	2b00      	cmp	r3, #0
 800a904:	f47f aedd 	bne.w	800a6c2 <_fx_utility_logical_sector_flush+0x1ce>
 800a908:	e004      	b.n	800a914 <_fx_utility_logical_sector_flush+0x420>
                break;
 800a90a:	bf00      	nop
 800a90c:	e002      	b.n	800a914 <_fx_utility_logical_sector_flush+0x420>
                break;
 800a90e:	bf00      	nop
 800a910:	e000      	b.n	800a914 <_fx_utility_logical_sector_flush+0x420>
                break;
 800a912:	bf00      	nop
    FX_PARAMETER_NOT_USED(sectors);
    FX_PARAMETER_NOT_USED(invalidate);
#endif /* FX_DISABLE_CACHE */

    /* If we get here, return successful status to the caller.  */
    return(FX_SUCCESS);
 800a914:	2300      	movs	r3, #0
}
 800a916:	4618      	mov	r0, r3
 800a918:	3750      	adds	r7, #80	; 0x50
 800a91a:	46bd      	mov	sp, r7
 800a91c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800a920 <_fx_utility_logical_sector_read>:
/*                                            resulting in version 6.2.0  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_logical_sector_read(FX_MEDIA *media_ptr, ULONG64 logical_sector,
                                      VOID *buffer_ptr, ULONG sectors, UCHAR sector_type)
{
 800a920:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800a924:	b09c      	sub	sp, #112	; 0x70
 800a926:	af04      	add	r7, sp, #16
 800a928:	64f8      	str	r0, [r7, #76]	; 0x4c
 800a92a:	e9c7 2310 	strd	r2, r3, [r7, #64]	; 0x40


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Determine if the request is for FAT sector.  */
    if (sector_type == FX_FAT_SECTOR)
 800a92e:	f897 3088 	ldrb.w	r3, [r7, #136]	; 0x88
 800a932:	2b02      	cmp	r3, #2
 800a934:	d106      	bne.n	800a944 <_fx_utility_logical_sector_read+0x24>
    {

        /* Increment the number of FAT sector reads.  */
        media_ptr -> fx_media_fat_sector_reads++;
 800a936:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a938:	f8d3 3194 	ldr.w	r3, [r3, #404]	; 0x194
 800a93c:	1c5a      	adds	r2, r3, #1
 800a93e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a940:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
    }

    /* Increment the number of logical sectors read.  */
    media_ptr -> fx_media_logical_sector_reads++;
 800a944:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a946:	f8d3 319c 	ldr.w	r3, [r3, #412]	; 0x19c
 800a94a:	1c5a      	adds	r2, r3, #1
 800a94c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a94e:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_LOGICAL_SECTOR_READ_EXTENSION

#ifndef FX_DISABLE_CACHE
    /* Determine if the request is for the internal media buffer area.  */
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 800a952:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a954:	689a      	ldr	r2, [r3, #8]
 800a956:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800a95a:	4293      	cmp	r3, r2
 800a95c:	f0c0 80d9 	bcc.w	800ab12 <_fx_utility_logical_sector_read+0x1f2>
        (((UCHAR *)buffer_ptr) <= media_ptr -> fx_media_sector_cache_end))
 800a960:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a962:	699a      	ldr	r2, [r3, #24]
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 800a964:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800a968:	4293      	cmp	r3, r2
 800a96a:	f200 80d2 	bhi.w	800ab12 <_fx_utility_logical_sector_read+0x1f2>
    {

        /* Internal cache buffer is requested.  */

        /* Examine the logical sector cache.  */
        cache_entry = _fx_utility_logical_sector_cache_entry_read(media_ptr, logical_sector, &previous_cache_entry);
 800a96e:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800a972:	9300      	str	r3, [sp, #0]
 800a974:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800a978:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800a97a:	f7ff faf1 	bl	8009f60 <_fx_utility_logical_sector_cache_entry_read>
 800a97e:	6578      	str	r0, [r7, #84]	; 0x54

        /* Was the sector found?  */
        if (cache_entry == FX_NULL)
 800a980:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a982:	2b00      	cmp	r3, #0
 800a984:	d101      	bne.n	800a98a <_fx_utility_logical_sector_read+0x6a>
        {

            /* Yes, the sector was found. Return success!  */
            return(FX_SUCCESS);
 800a986:	2300      	movs	r3, #0
 800a988:	e259      	b.n	800ae3e <_fx_utility_logical_sector_read+0x51e>
        /* At this point, we need to read in a sector from the media.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of logical sectors cache read misses.  */
        media_ptr -> fx_media_logical_sector_cache_read_misses++;
 800a98a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a98c:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
 800a990:	1c5a      	adds	r2, r3, #1
 800a992:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a994:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_LOG_SECTOR_CACHE_MISS, media_ptr, logical_sector, 0, media_ptr -> fx_media_sector_cache_size, FX_TRACE_INTERNAL_EVENTS, 0, 0)
#endif

        /* First, check and see if the last used entry has been
           modified.  */
        if ((cache_entry -> fx_cached_sector_valid) &&
 800a998:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a99a:	7c5b      	ldrb	r3, [r3, #17]
 800a99c:	2b00      	cmp	r3, #0
 800a99e:	d049      	beq.n	800aa34 <_fx_utility_logical_sector_read+0x114>
            (cache_entry -> fx_cached_sector_buffer_dirty))
 800a9a0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9a2:	7c1b      	ldrb	r3, [r3, #16]
        if ((cache_entry -> fx_cached_sector_valid) &&
 800a9a4:	2b00      	cmp	r3, #0
 800a9a6:	d045      	beq.n	800aa34 <_fx_utility_logical_sector_read+0x114>
               before we read in the new buffer.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

            /* Increment the number of driver write sector(s) requests.  */
            media_ptr -> fx_media_driver_write_requests++;
 800a9a8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9aa:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800a9ae:	1c5a      	adds	r2, r3, #1
 800a9b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9b2:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
#endif

            /* Build write request to the driver.  */
            media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800a9b6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9b8:	2201      	movs	r2, #1
 800a9ba:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
            media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800a9be:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9c0:	2290      	movs	r2, #144	; 0x90
 800a9c2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 800a9c6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9c8:	681a      	ldr	r2, [r3, #0]
 800a9ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9cc:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
            media_ptr -> fx_media_driver_logical_sector =   cache_entry -> fx_cached_sector;
#else
            media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 800a9d0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9d2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800a9d6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9d8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#endif
            media_ptr -> fx_media_driver_sectors =          1;
 800a9dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9de:	2201      	movs	r2, #1
 800a9e0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
            media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 800a9e4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9e6:	7c9b      	ldrb	r3, [r3, #18]
 800a9e8:	461a      	mov	r2, r3
 800a9ea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9ec:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

            /* Determine if the sector is a data sector or a system sector.  */
            if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 800a9f0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800a9f2:	7c9b      	ldrb	r3, [r3, #18]
 800a9f4:	2b04      	cmp	r3, #4
 800a9f6:	d003      	beq.n	800aa00 <_fx_utility_logical_sector_read+0xe0>
            {

                /* System sector is present.  */
                media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800a9f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9fa:	2201      	movs	r2, #1
 800a9fc:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

            /* If trace is enabled, insert this event into the trace buffer.  */
            FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, cache_entry -> fx_cached_sector, 1, cache_entry -> fx_cached_sector_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

            /* Invoke the driver to write the sector.  */
            (media_ptr -> fx_media_driver_entry) (media_ptr);
 800aa00:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa02:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800aa06:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800aa08:	4798      	blx	r3

            /* Clear the system write flag.  */
            media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800aa0a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa0c:	2200      	movs	r2, #0
 800aa0e:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

            /* Check for successful completion.  */
            if (media_ptr -> fx_media_driver_status)
 800aa12:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa14:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800aa18:	2b00      	cmp	r3, #0
 800aa1a:	d003      	beq.n	800aa24 <_fx_utility_logical_sector_read+0x104>
            {

                /* Error writing a cached sector out.  Return the
                   error status.  */
                return(media_ptr -> fx_media_driver_status);
 800aa1c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa1e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800aa22:	e20c      	b.n	800ae3e <_fx_utility_logical_sector_read+0x51e>
            }

            /* Clear the buffer dirty flag since it has been flushed
               out.  */
            cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 800aa24:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aa26:	2200      	movs	r2, #0
 800aa28:	741a      	strb	r2, [r3, #16]

            /* Decrement the number of outstanding dirty cache entries.  */
            media_ptr -> fx_media_sector_cache_dirty_count--;
 800aa2a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa2c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aa2e:	1e5a      	subs	r2, r3, #1
 800aa30:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa32:	625a      	str	r2, [r3, #36]	; 0x24

        /* At this point, we can go out and setup this cached sector
           entry.  */

        /* Compare against logical sector to make sure it is valid.  */
        if (logical_sector >= media_ptr -> fx_media_total_sectors)
 800aa34:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa36:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	; 0x38
 800aa3a:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
 800aa3e:	4290      	cmp	r0, r2
 800aa40:	eb71 0303 	sbcs.w	r3, r1, r3
 800aa44:	d301      	bcc.n	800aa4a <_fx_utility_logical_sector_read+0x12a>
        {
            return(FX_SECTOR_INVALID);
 800aa46:	2389      	movs	r3, #137	; 0x89
 800aa48:	e1f9      	b.n	800ae3e <_fx_utility_logical_sector_read+0x51e>
        }

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver read sector(s) requests.  */
        media_ptr -> fx_media_driver_read_requests++;
 800aa4a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa4c:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 800aa50:	1c5a      	adds	r2, r3, #1
 800aa52:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa54:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
#endif

        /* Build Read request to the driver.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 800aa58:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa5a:	2200      	movs	r2, #0
 800aa5c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800aa60:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa62:	2290      	movs	r2, #144	; 0x90
 800aa64:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 800aa68:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aa6a:	681a      	ldr	r2, [r3, #0]
 800aa6c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa6e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_driver_logical_sector =   logical_sector;
#else
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 800aa72:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800aa74:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa76:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#endif
        media_ptr -> fx_media_driver_sectors =          1;
 800aa7a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa7c:	2201      	movs	r2, #1
 800aa7e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 800aa82:	f897 2088 	ldrb.w	r2, [r7, #136]	; 0x88
 800aa86:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa88:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

        /* Determine if the sector is a data sector or a system sector.  */
        if (sector_type == FX_DATA_SECTOR)
 800aa8c:	f897 3088 	ldrb.w	r3, [r7, #136]	; 0x88
 800aa90:	2b04      	cmp	r3, #4
 800aa92:	d103      	bne.n	800aa9c <_fx_utility_logical_sector_read+0x17c>
        {

            /* Data sector is present.  */
            media_ptr -> fx_media_driver_data_sector_read =  FX_TRUE;
 800aa94:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa96:	2201      	movs	r2, #1
 800aa98:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, logical_sector, 1, cache_entry -> fx_cached_sector_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to read the sector.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800aa9c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa9e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800aaa2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800aaa4:	4798      	blx	r3

        /* Clear data sector is present flag.  */
        media_ptr -> fx_media_driver_data_sector_read =  FX_FALSE;
 800aaa6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aaa8:	2200      	movs	r2, #0
 800aaaa:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

        /* Determine if the read was successful.  */
        if (media_ptr -> fx_media_driver_status == FX_SUCCESS)
 800aaae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aab0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800aab4:	2b00      	cmp	r3, #0
 800aab6:	d11a      	bne.n	800aaee <_fx_utility_logical_sector_read+0x1ce>
        {

            /* Remember the sector number.  */
            cache_entry -> fx_cached_sector =  logical_sector;
 800aab8:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800aaba:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800aabe:	e9c1 2302 	strd	r2, r3, [r1, #8]

            /* Make the cache entry valid.  */
            cache_entry -> fx_cached_sector_valid =  FX_TRUE;
 800aac2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aac4:	2201      	movs	r2, #1
 800aac6:	745a      	strb	r2, [r3, #17]

            /* Remember the sector type.  */
            cache_entry -> fx_cached_sector_type =  sector_type;
 800aac8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aaca:	f897 2088 	ldrb.w	r2, [r7, #136]	; 0x88
 800aace:	749a      	strb	r2, [r3, #18]

            /* Place this entry that the head of the cached sector
               list.  */

            /* Determine if we need to update the last used list.  */
            if (previous_cache_entry)
 800aad0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800aad2:	2b00      	cmp	r3, #0
 800aad4:	d015      	beq.n	800ab02 <_fx_utility_logical_sector_read+0x1e2>

                /* Yes, the current entry is not at the front of the list
                   so we need to change the order.  */

                /* Link the previous entry to this entry's next pointer.  */
                previous_cache_entry -> fx_cached_sector_next_used =
 800aad6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
                    cache_entry -> fx_cached_sector_next_used;
 800aad8:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800aada:	6952      	ldr	r2, [r2, #20]
                previous_cache_entry -> fx_cached_sector_next_used =
 800aadc:	615a      	str	r2, [r3, #20]

                /* Place this entry at the head of the list.  */
                cache_entry -> fx_cached_sector_next_used =
                    media_ptr -> fx_media_sector_cache_list_ptr;
 800aade:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aae0:	69da      	ldr	r2, [r3, #28]
                cache_entry -> fx_cached_sector_next_used =
 800aae2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aae4:	615a      	str	r2, [r3, #20]
                media_ptr -> fx_media_sector_cache_list_ptr =  cache_entry;
 800aae6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aae8:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800aaea:	61da      	str	r2, [r3, #28]
 800aaec:	e009      	b.n	800ab02 <_fx_utility_logical_sector_read+0x1e2>
        }
        else
        {

            /* Invalidate the cache entry on read errors.  */
            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 800aaee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800aaf0:	2200      	movs	r2, #0
 800aaf2:	745a      	strb	r2, [r3, #17]

            /* Put all ones in the sector value.  */
            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 800aaf4:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800aaf6:	f04f 32ff 	mov.w	r2, #4294967295
 800aafa:	f04f 33ff 	mov.w	r3, #4294967295
 800aafe:	e9c1 2302 	strd	r2, r3, [r1, #8]
        }

        /* Simply setup the pointer to this buffer and return.  */
        media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 800ab02:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ab04:	681a      	ldr	r2, [r3, #0]
 800ab06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab08:	609a      	str	r2, [r3, #8]

        /* Return the driver status.  */
        return(media_ptr -> fx_media_driver_status);
 800ab0a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab0c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ab10:	e195      	b.n	800ae3e <_fx_utility_logical_sector_read+0x51e>
    {

        /* Direct I/O to application buffer area.  */

        /* Compare against logical sector to make sure it is valid.  */
        if ((logical_sector + sectors - 1) > (ULONG)media_ptr -> fx_media_total_sectors)
 800ab12:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ab16:	2200      	movs	r2, #0
 800ab18:	469a      	mov	sl, r3
 800ab1a:	4693      	mov	fp, r2
 800ab1c:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800ab20:	eb1a 0402 	adds.w	r4, sl, r2
 800ab24:	eb4b 0503 	adc.w	r5, fp, r3
 800ab28:	f114 38ff 	adds.w	r8, r4, #4294967295
 800ab2c:	f145 39ff 	adc.w	r9, r5, #4294967295
 800ab30:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab32:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	; 0x38
 800ab36:	2300      	movs	r3, #0
 800ab38:	63ba      	str	r2, [r7, #56]	; 0x38
 800ab3a:	63fb      	str	r3, [r7, #60]	; 0x3c
 800ab3c:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	; 0x38
 800ab40:	460b      	mov	r3, r1
 800ab42:	4543      	cmp	r3, r8
 800ab44:	4613      	mov	r3, r2
 800ab46:	eb73 0309 	sbcs.w	r3, r3, r9
 800ab4a:	d22c      	bcs.n	800aba6 <_fx_utility_logical_sector_read+0x286>
        {
            return(FX_SECTOR_INVALID);
 800ab4c:	2389      	movs	r3, #137	; 0x89
 800ab4e:	e176      	b.n	800ae3e <_fx_utility_logical_sector_read+0x51e>
        /* Attempt to fill the beginning of the buffer from cached sectors.  */
        while (sectors)
        {

            /* Determine if the sector is in the cache.  */
            if (_fx_utility_logical_sector_cache_entry_read(media_ptr, logical_sector, &previous_cache_entry))
 800ab50:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800ab54:	9300      	str	r3, [sp, #0]
 800ab56:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800ab5a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800ab5c:	f7ff fa00 	bl	8009f60 <_fx_utility_logical_sector_cache_entry_read>
 800ab60:	4603      	mov	r3, r0
 800ab62:	2b00      	cmp	r3, #0
 800ab64:	d124      	bne.n	800abb0 <_fx_utility_logical_sector_read+0x290>
                /* Not in the cache - get out of the loop!  */
                break;
            }

            /* Yes, sector is in the cache. Copy the data from the cache to the destination buffer.  */
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, buffer_ptr, media_ptr -> fx_media_bytes_per_sector); /* Use case of memcpy is verified. */
 800ab66:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab68:	6898      	ldr	r0, [r3, #8]
 800ab6a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab6c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ab6e:	461a      	mov	r2, r3
 800ab70:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 800ab74:	f000 fad0 	bl	800b118 <_fx_utility_memory_copy>

            /* Advance the destination buffer.  */
            buffer_ptr =  ((UCHAR *)buffer_ptr) + media_ptr -> fx_media_bytes_per_sector;
 800ab78:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab7a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800ab7c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800ab80:	4413      	add	r3, r2
 800ab82:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

            /* Advance the sector and decrement the number of sectors left.  */
            logical_sector++;
 800ab86:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800ab8a:	1c51      	adds	r1, r2, #1
 800ab8c:	61b9      	str	r1, [r7, #24]
 800ab8e:	f143 0300 	adc.w	r3, r3, #0
 800ab92:	61fb      	str	r3, [r7, #28]
 800ab94:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
 800ab98:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
            sectors--;
 800ab9c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800aba0:	3b01      	subs	r3, #1
 800aba2:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
        while (sectors)
 800aba6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800abaa:	2b00      	cmp	r3, #0
 800abac:	d1d0      	bne.n	800ab50 <_fx_utility_logical_sector_read+0x230>
 800abae:	e000      	b.n	800abb2 <_fx_utility_logical_sector_read+0x292>
                break;
 800abb0:	bf00      	nop
        }

        /* Calculate the end sector.  */
        end_sector = logical_sector + sectors - 1;
 800abb2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800abb6:	2200      	movs	r2, #0
 800abb8:	633b      	str	r3, [r7, #48]	; 0x30
 800abba:	637a      	str	r2, [r7, #52]	; 0x34
 800abbc:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800abc0:	e9d7 450c 	ldrd	r4, r5, [r7, #48]	; 0x30
 800abc4:	4621      	mov	r1, r4
 800abc6:	1889      	adds	r1, r1, r2
 800abc8:	62b9      	str	r1, [r7, #40]	; 0x28
 800abca:	4629      	mov	r1, r5
 800abcc:	eb43 0101 	adc.w	r1, r3, r1
 800abd0:	62f9      	str	r1, [r7, #44]	; 0x2c
 800abd2:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	; 0x28
 800abd6:	460b      	mov	r3, r1
 800abd8:	3b01      	subs	r3, #1
 800abda:	613b      	str	r3, [r7, #16]
 800abdc:	4613      	mov	r3, r2
 800abde:	f143 33ff 	adc.w	r3, r3, #4294967295
 800abe2:	617b      	str	r3, [r7, #20]
 800abe4:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
 800abe8:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58

        /* Attempt to fill the end of the buffer from the opposite direction.  */
        while (sectors)
 800abec:	e02b      	b.n	800ac46 <_fx_utility_logical_sector_read+0x326>
        {

            /* Determine if the sector is in the cache.  */
            if (_fx_utility_logical_sector_cache_entry_read(media_ptr, end_sector, &previous_cache_entry))
 800abee:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800abf2:	9300      	str	r3, [sp, #0]
 800abf4:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800abf8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800abfa:	f7ff f9b1 	bl	8009f60 <_fx_utility_logical_sector_cache_entry_read>
 800abfe:	4603      	mov	r3, r0
 800ac00:	2b00      	cmp	r3, #0
 800ac02:	d125      	bne.n	800ac50 <_fx_utility_logical_sector_read+0x330>
                /* Not in the cache - get out of the loop!  */
                break;
            }

            /* Yes, sector is in the cache. Copy the data from the cache to the destination buffer.  */
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, /* Use case of memcpy is verified. */
 800ac04:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac06:	6898      	ldr	r0, [r3, #8]
                                    ((UCHAR *)buffer_ptr) + ((sectors - 1) * media_ptr -> fx_media_bytes_per_sector),
 800ac08:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ac0c:	3b01      	subs	r3, #1
 800ac0e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800ac10:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800ac12:	fb02 f303 	mul.w	r3, r2, r3
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, /* Use case of memcpy is verified. */
 800ac16:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800ac1a:	18d1      	adds	r1, r2, r3
                                    media_ptr -> fx_media_bytes_per_sector);
 800ac1c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, /* Use case of memcpy is verified. */
 800ac20:	461a      	mov	r2, r3
 800ac22:	f000 fa79 	bl	800b118 <_fx_utility_memory_copy>

            /* Move sector to previous sector and decrement the number of sectors left.  */
            end_sector--;
 800ac26:	e9d7 2316 	ldrd	r2, r3, [r7, #88]	; 0x58
 800ac2a:	1e51      	subs	r1, r2, #1
 800ac2c:	60b9      	str	r1, [r7, #8]
 800ac2e:	f143 33ff 	adc.w	r3, r3, #4294967295
 800ac32:	60fb      	str	r3, [r7, #12]
 800ac34:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
 800ac38:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
            sectors--;
 800ac3c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ac40:	3b01      	subs	r3, #1
 800ac42:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
        while (sectors)
 800ac46:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ac4a:	2b00      	cmp	r3, #0
 800ac4c:	d1cf      	bne.n	800abee <_fx_utility_logical_sector_read+0x2ce>
 800ac4e:	e000      	b.n	800ac52 <_fx_utility_logical_sector_read+0x332>
                break;
 800ac50:	bf00      	nop
        }

        /* Determine if there are still sectors left to read.  */
        if (sectors == 0)
 800ac52:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ac56:	2b00      	cmp	r3, #0
 800ac58:	d101      	bne.n	800ac5e <_fx_utility_logical_sector_read+0x33e>
        {

            /* No more sectors to read - return success!  */
            return(FX_SUCCESS);
 800ac5a:	2300      	movs	r3, #0
 800ac5c:	e0ef      	b.n	800ae3e <_fx_utility_logical_sector_read+0x51e>
        }

        /* Flush and invalidate any entries in the cache that are in this direct I/O read request range.  */
        _fx_utility_logical_sector_flush(media_ptr, logical_sector, (ULONG64) sectors, FX_TRUE);
 800ac5e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ac62:	2200      	movs	r2, #0
 800ac64:	623b      	str	r3, [r7, #32]
 800ac66:	627a      	str	r2, [r7, #36]	; 0x24
 800ac68:	2301      	movs	r3, #1
 800ac6a:	9302      	str	r3, [sp, #8]
 800ac6c:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 800ac70:	e9cd 3400 	strd	r3, r4, [sp]
 800ac74:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800ac78:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800ac7a:	f7ff fc3b 	bl	800a4f4 <_fx_utility_logical_sector_flush>
#endif /* FX_DISABLE_CACHE */

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver read sector(s) requests.  */
        media_ptr -> fx_media_driver_read_requests++;
 800ac7e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac80:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 800ac84:	1c5a      	adds	r2, r3, #1
 800ac86:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac88:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
#endif

        /* Build read request to the driver.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 800ac8c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac8e:	2200      	movs	r2, #0
 800ac90:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800ac94:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac96:	2290      	movs	r2, #144	; 0x90
 800ac98:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 800ac9c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ac9e:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800aca2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_driver_logical_sector =   logical_sector;
#else
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 800aca6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800aca8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800acaa:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#endif
        media_ptr -> fx_media_driver_sectors =          sectors;
 800acae:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800acb0:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800acb4:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 800acb8:	f897 2088 	ldrb.w	r2, [r7, #136]	; 0x88
 800acbc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800acbe:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

        /* Determine if the sector is a data sector or a system sector.  */
        if (sector_type == FX_DATA_SECTOR)
 800acc2:	f897 3088 	ldrb.w	r3, [r7, #136]	; 0x88
 800acc6:	2b04      	cmp	r3, #4
 800acc8:	d103      	bne.n	800acd2 <_fx_utility_logical_sector_read+0x3b2>
        {

            /* Data sector is present.  */
            media_ptr -> fx_media_driver_data_sector_read =  FX_TRUE;
 800acca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800accc:	2201      	movs	r2, #1
 800acce:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, logical_sector, sectors, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to read the sector.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800acd2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800acd4:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800acd8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800acda:	4798      	blx	r3

        /* Clear data sector is present flag.  */
        media_ptr -> fx_media_driver_data_sector_read =  FX_FALSE;
 800acdc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800acde:	2200      	movs	r2, #0
 800ace0:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4

#ifndef FX_DISABLE_DIRECT_DATA_READ_CACHE_FILL

        /* Determine if the read was successful and if number of sectors just read will
           reasonably fit into the cache.  */
        if ((media_ptr -> fx_media_driver_status == FX_SUCCESS) && (sectors < (media_ptr -> fx_media_sector_cache_size / 4)))
 800ace4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ace6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800acea:	2b00      	cmp	r3, #0
 800acec:	f040 80a4 	bne.w	800ae38 <_fx_utility_logical_sector_read+0x518>
 800acf0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800acf2:	695b      	ldr	r3, [r3, #20]
 800acf4:	089b      	lsrs	r3, r3, #2
 800acf6:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800acfa:	429a      	cmp	r2, r3
 800acfc:	f080 809c 	bcs.w	800ae38 <_fx_utility_logical_sector_read+0x518>

            /* Yes, read of direct sectors was successful.  */

            /* Copy the sectors directly read into the cache so they are available on
               subsequent read requests.  */
            while (sectors)
 800ad00:	e095      	b.n	800ae2e <_fx_utility_logical_sector_read+0x50e>
            {

                /* Attempt to read the cache entry.  */
                cache_entry =  _fx_utility_logical_sector_cache_entry_read(media_ptr, logical_sector, &previous_cache_entry);
 800ad02:	f107 0350 	add.w	r3, r7, #80	; 0x50
 800ad06:	9300      	str	r3, [sp, #0]
 800ad08:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800ad0c:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800ad0e:	f7ff f927 	bl	8009f60 <_fx_utility_logical_sector_cache_entry_read>
 800ad12:	6578      	str	r0, [r7, #84]	; 0x54
                FX_UTILITY_LOGICAL_SECTOR_READ_EXTENSION_1

                /* At this point, a cache entry should always be present since we invalidated
                   the cache over this sector range previously. In any case, check for the error
                   condition.  */
                if (cache_entry == FX_NULL)
 800ad14:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad16:	2b00      	cmp	r3, #0
 800ad18:	d101      	bne.n	800ad1e <_fx_utility_logical_sector_read+0x3fe>
                {

                    /* This case should never happen, however, if it does simply give up on updating the
                       cache with the sectors from the direct read.  */
                    return(FX_SUCCESS);
 800ad1a:	2300      	movs	r3, #0
 800ad1c:	e08f      	b.n	800ae3e <_fx_utility_logical_sector_read+0x51e>
                }

                /* Determine if the cache entry is dirty and needs to be written out before it is used.  */
                if ((cache_entry -> fx_cached_sector_valid) &&
 800ad1e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad20:	7c5b      	ldrb	r3, [r3, #17]
 800ad22:	2b00      	cmp	r3, #0
 800ad24:	d049      	beq.n	800adba <_fx_utility_logical_sector_read+0x49a>
                    (cache_entry -> fx_cached_sector_buffer_dirty))
 800ad26:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad28:	7c1b      	ldrb	r3, [r3, #16]
                if ((cache_entry -> fx_cached_sector_valid) &&
 800ad2a:	2b00      	cmp	r3, #0
 800ad2c:	d045      	beq.n	800adba <_fx_utility_logical_sector_read+0x49a>
                       before we read in the new buffer.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

                    /* Increment the number of driver write sector(s) requests.  */
                    media_ptr -> fx_media_driver_write_requests++;
 800ad2e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad30:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800ad34:	1c5a      	adds	r2, r3, #1
 800ad36:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad38:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
#endif

                    /* Build write request to the driver.  */
                    media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800ad3c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad3e:	2201      	movs	r2, #1
 800ad40:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                    media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800ad44:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad46:	2290      	movs	r2, #144	; 0x90
 800ad48:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
                    media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 800ad4c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad4e:	681a      	ldr	r2, [r3, #0]
 800ad50:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad52:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
                    media_ptr -> fx_media_driver_logical_sector =   cache_entry -> fx_cached_sector;
#else
                    media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 800ad56:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad58:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800ad5c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad5e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#endif
                    media_ptr -> fx_media_driver_sectors =          1;
 800ad62:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad64:	2201      	movs	r2, #1
 800ad66:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
                    media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 800ad6a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad6c:	7c9b      	ldrb	r3, [r3, #18]
 800ad6e:	461a      	mov	r2, r3
 800ad70:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad72:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

                    /* Only data sectors may be dirty when FX_FAULT_TOLERANT is defined */
#ifndef FX_FAULT_TOLERANT
                    /* Determine if the sector is a data sector or a system sector.  */
                    if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 800ad76:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ad78:	7c9b      	ldrb	r3, [r3, #18]
 800ad7a:	2b04      	cmp	r3, #4
 800ad7c:	d003      	beq.n	800ad86 <_fx_utility_logical_sector_read+0x466>
                    {

                        /* System sector is present.  */
                        media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800ad7e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad80:	2201      	movs	r2, #1
 800ad82:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

                    /* If trace is enabled, insert this event into the trace buffer.  */
                    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, cache_entry -> fx_cached_sector, 1, cache_entry -> fx_cached_sector_memory_buffer, FX_TRACE_INTERNAL_EVENTS, 0, 0)

                    /* Invoke the driver to write the sector.  */
                    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800ad86:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad88:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800ad8c:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800ad8e:	4798      	blx	r3

                    /* Clear the system write flag.  */
                    media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800ad90:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad92:	2200      	movs	r2, #0
 800ad94:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

                    /* Check for successful completion.  */
                    if (media_ptr -> fx_media_driver_status)
 800ad98:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ad9a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ad9e:	2b00      	cmp	r3, #0
 800ada0:	d003      	beq.n	800adaa <_fx_utility_logical_sector_read+0x48a>
                    {

                        /* Error writing a cached sector out.  Return the
                           error status.  */
                        return(media_ptr -> fx_media_driver_status);
 800ada2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ada4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800ada8:	e049      	b.n	800ae3e <_fx_utility_logical_sector_read+0x51e>
                    }

                    /* Clear the buffer dirty flag since it has been flushed
                       out.  */
                    cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 800adaa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800adac:	2200      	movs	r2, #0
 800adae:	741a      	strb	r2, [r3, #16]

                    /* Decrement the number of outstanding dirty cache entries.  */
                    media_ptr -> fx_media_sector_cache_dirty_count--;
 800adb0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800adb2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800adb4:	1e5a      	subs	r2, r3, #1
 800adb6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800adb8:	625a      	str	r2, [r3, #36]	; 0x24
                }

                /* Now setup the cache entry with information from the new sector.  */

                /* Remember the sector number.  */
                cache_entry -> fx_cached_sector =  logical_sector;
 800adba:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800adbc:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800adc0:	e9c1 2302 	strd	r2, r3, [r1, #8]

                /* Make the cache entry valid.  */
                cache_entry -> fx_cached_sector_valid =  FX_TRUE;
 800adc4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800adc6:	2201      	movs	r2, #1
 800adc8:	745a      	strb	r2, [r3, #17]

                /* Remember the sector type.  */
                cache_entry -> fx_cached_sector_type =  sector_type;
 800adca:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800adcc:	f897 2088 	ldrb.w	r2, [r7, #136]	; 0x88
 800add0:	749a      	strb	r2, [r3, #18]

                /* Place this entry that the head of the cached sector
                   list.  */

                /* Determine if we need to update the last used list.  */
                if (previous_cache_entry)
 800add2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800add4:	2b00      	cmp	r3, #0
 800add6:	d00a      	beq.n	800adee <_fx_utility_logical_sector_read+0x4ce>

                    /* Yes, the current entry is not at the front of the list
                       so we need to change the order.  */

                    /* Link the previous entry to this entry's next pointer.  */
                    previous_cache_entry -> fx_cached_sector_next_used =
 800add8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
                        cache_entry -> fx_cached_sector_next_used;
 800adda:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800addc:	6952      	ldr	r2, [r2, #20]
                    previous_cache_entry -> fx_cached_sector_next_used =
 800adde:	615a      	str	r2, [r3, #20]

                    /* Place this entry at the head of the list.  */
                    cache_entry -> fx_cached_sector_next_used =
                        media_ptr -> fx_media_sector_cache_list_ptr;
 800ade0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ade2:	69da      	ldr	r2, [r3, #28]
                    cache_entry -> fx_cached_sector_next_used =
 800ade4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ade6:	615a      	str	r2, [r3, #20]
                    media_ptr -> fx_media_sector_cache_list_ptr =  cache_entry;
 800ade8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800adea:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800adec:	61da      	str	r2, [r3, #28]
                }

                /* Copy the data from the destination buffer to the cache entry.  */
                _fx_utility_memory_copy(buffer_ptr, /* Use case of memcpy is verified. */
 800adee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800adf0:	6819      	ldr	r1, [r3, #0]
                                        cache_entry -> fx_cached_sector_memory_buffer,
                                        media_ptr -> fx_media_bytes_per_sector);
 800adf2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800adf4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                _fx_utility_memory_copy(buffer_ptr, /* Use case of memcpy is verified. */
 800adf6:	461a      	mov	r2, r3
 800adf8:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
 800adfc:	f000 f98c 	bl	800b118 <_fx_utility_memory_copy>

                /* Advance the destination buffer.  */
                buffer_ptr =  ((UCHAR *)buffer_ptr) + media_ptr -> fx_media_bytes_per_sector;
 800ae00:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ae02:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ae04:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800ae08:	4413      	add	r3, r2
 800ae0a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

                /* Advance the source sector and decrement the sector count.  */
                logical_sector++;
 800ae0e:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
 800ae12:	1c51      	adds	r1, r2, #1
 800ae14:	6039      	str	r1, [r7, #0]
 800ae16:	f143 0300 	adc.w	r3, r3, #0
 800ae1a:	607b      	str	r3, [r7, #4]
 800ae1c:	e9d7 3400 	ldrd	r3, r4, [r7]
 800ae20:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
                sectors--;
 800ae24:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ae28:	3b01      	subs	r3, #1
 800ae2a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
            while (sectors)
 800ae2e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800ae32:	2b00      	cmp	r3, #0
 800ae34:	f47f af65 	bne.w	800ad02 <_fx_utility_logical_sector_read+0x3e2>
            }
        }
#endif

        /* Return the driver status.  */
        return(media_ptr -> fx_media_driver_status);
 800ae38:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ae3a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    }
}
 800ae3e:	4618      	mov	r0, r3
 800ae40:	3760      	adds	r7, #96	; 0x60
 800ae42:	46bd      	mov	sp, r7
 800ae44:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800ae48 <_fx_utility_logical_sector_write>:
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_logical_sector_write(FX_MEDIA *media_ptr, ULONG64 logical_sector,
                                       VOID *buffer_ptr, ULONG sectors, UCHAR sector_type)
{
 800ae48:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800ae4c:	b096      	sub	sp, #88	; 0x58
 800ae4e:	af04      	add	r7, sp, #16
 800ae50:	62f8      	str	r0, [r7, #44]	; 0x2c
 800ae52:	e9c7 2308 	strd	r2, r3, [r7, #32]
#ifndef FX_DISABLE_CACHE
FX_CACHED_SECTOR *cache_entry;
UINT              cache_size;
UINT              index;
UINT              i;
UCHAR             cache_found = FX_FALSE;
 800ae56:	2300      	movs	r3, #0
 800ae58:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
#endif /* FX_DISABLE_CACHE */

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Determine if the request is for FAT sector.  */
    if (sector_type == FX_FAT_SECTOR)
 800ae5c:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 800ae60:	2b02      	cmp	r3, #2
 800ae62:	d106      	bne.n	800ae72 <_fx_utility_logical_sector_write+0x2a>
    {

        /* Increment the number of FAT sector writes.  */
        media_ptr -> fx_media_fat_sector_writes++;
 800ae64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae66:	f8d3 3198 	ldr.w	r3, [r3, #408]	; 0x198
 800ae6a:	1c5a      	adds	r2, r3, #1
 800ae6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae6e:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    }

    /* Increment the number of logical sectors written.  */
    media_ptr -> fx_media_logical_sector_writes++;
 800ae72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae74:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
 800ae78:	1c5a      	adds	r2, r3, #1
 800ae7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae7c:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_LOGICAL_SECTOR_WRITE_EXTENSION

#ifndef FX_DISABLE_CACHE
    /* Determine if the request is from the internal media buffer area.  */
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 800ae80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae82:	689a      	ldr	r2, [r3, #8]
 800ae84:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ae86:	4293      	cmp	r3, r2
 800ae88:	f0c0 80d8 	bcc.w	800b03c <_fx_utility_logical_sector_write+0x1f4>
        (((UCHAR *)buffer_ptr) <= media_ptr -> fx_media_sector_cache_end))
 800ae8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae8e:	699a      	ldr	r2, [r3, #24]
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 800ae90:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ae92:	4293      	cmp	r3, r2
 800ae94:	f200 80d2 	bhi.w	800b03c <_fx_utility_logical_sector_write+0x1f4>
    {

        /* Internal cache buffer is requested.  */

        /* Determine if the logical sector cache access should use the hash function.  */
        if (media_ptr -> fx_media_sector_cache_hashed)
 800ae98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae9a:	691b      	ldr	r3, [r3, #16]
 800ae9c:	2b00      	cmp	r3, #0
 800ae9e:	d030      	beq.n	800af02 <_fx_utility_logical_sector_write+0xba>
        {

            /* Calculate the area of the cache for this logical sector.  */
            index =  (ULONG)(logical_sector & media_ptr -> fx_media_sector_cache_hash_mask) * FX_SECTOR_CACHE_DEPTH;
 800aea0:	6a3a      	ldr	r2, [r7, #32]
 800aea2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aea4:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 800aea8:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 800aeac:	4013      	ands	r3, r2
 800aeae:	009b      	lsls	r3, r3, #2
 800aeb0:	637b      	str	r3, [r7, #52]	; 0x34

            /* Build a pointer to the cache entry.  */
            cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 800aeb2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800aeb4:	4613      	mov	r3, r2
 800aeb6:	005b      	lsls	r3, r3, #1
 800aeb8:	4413      	add	r3, r2
 800aeba:	00db      	lsls	r3, r3, #3
 800aebc:	f503 634a 	add.w	r3, r3, #3232	; 0xca0
 800aec0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800aec2:	4413      	add	r3, r2
 800aec4:	647b      	str	r3, [r7, #68]	; 0x44

            for (i = 0; i < FX_SECTOR_CACHE_DEPTH; i++, cache_entry++)
 800aec6:	2300      	movs	r3, #0
 800aec8:	63fb      	str	r3, [r7, #60]	; 0x3c
 800aeca:	e016      	b.n	800aefa <_fx_utility_logical_sector_write+0xb2>
            {


                /* Determine if the logical sector is in the cache - assuming the depth of the
                   sector cache is 4 entries.  */
                if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800aecc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800aece:	7c5b      	ldrb	r3, [r3, #17]
 800aed0:	2b00      	cmp	r3, #0
 800aed2:	d00c      	beq.n	800aeee <_fx_utility_logical_sector_write+0xa6>
 800aed4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800aed6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800aeda:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800aede:	4299      	cmp	r1, r3
 800aee0:	bf08      	it	eq
 800aee2:	4290      	cmpeq	r0, r2
 800aee4:	d103      	bne.n	800aeee <_fx_utility_logical_sector_write+0xa6>
                {
                    cache_found = FX_TRUE;
 800aee6:	2301      	movs	r3, #1
 800aee8:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
                    break;
 800aeec:	e02d      	b.n	800af4a <_fx_utility_logical_sector_write+0x102>
            for (i = 0; i < FX_SECTOR_CACHE_DEPTH; i++, cache_entry++)
 800aeee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800aef0:	3301      	adds	r3, #1
 800aef2:	63fb      	str	r3, [r7, #60]	; 0x3c
 800aef4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800aef6:	3318      	adds	r3, #24
 800aef8:	647b      	str	r3, [r7, #68]	; 0x44
 800aefa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800aefc:	2b03      	cmp	r3, #3
 800aefe:	d9e5      	bls.n	800aecc <_fx_utility_logical_sector_write+0x84>
 800af00:	e023      	b.n	800af4a <_fx_utility_logical_sector_write+0x102>
        }
        else
        {

            /* Search for an entry in the cache that matches this request.  */
            cache_size =            media_ptr -> fx_media_sector_cache_size;
 800af02:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af04:	695b      	ldr	r3, [r3, #20]
 800af06:	643b      	str	r3, [r7, #64]	; 0x40
            cache_entry =           media_ptr -> fx_media_sector_cache_list_ptr;
 800af08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af0a:	69db      	ldr	r3, [r3, #28]
 800af0c:	647b      	str	r3, [r7, #68]	; 0x44

            /* Look at the cache entries until a match is found or the end of
               the cache is reached.  */
            while (cache_size--)
 800af0e:	e017      	b.n	800af40 <_fx_utility_logical_sector_write+0xf8>
            {

                /* Determine if the requested sector has been found.  */
                if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800af10:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800af12:	7c5b      	ldrb	r3, [r3, #17]
 800af14:	2b00      	cmp	r3, #0
 800af16:	d00c      	beq.n	800af32 <_fx_utility_logical_sector_write+0xea>
 800af18:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800af1a:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 800af1e:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 800af22:	4299      	cmp	r1, r3
 800af24:	bf08      	it	eq
 800af26:	4290      	cmpeq	r0, r2
 800af28:	d103      	bne.n	800af32 <_fx_utility_logical_sector_write+0xea>
                {
                    cache_found = FX_TRUE;
 800af2a:	2301      	movs	r3, #1
 800af2c:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
                    break;
 800af30:	e00b      	b.n	800af4a <_fx_utility_logical_sector_write+0x102>
                }

                /* Otherwise, we have not found the cached entry yet.  */

                /* If there are more entries, move to the next one.  */
                if (cache_entry -> fx_cached_sector_next_used)
 800af32:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800af34:	695b      	ldr	r3, [r3, #20]
 800af36:	2b00      	cmp	r3, #0
 800af38:	d002      	beq.n	800af40 <_fx_utility_logical_sector_write+0xf8>
                {

                    /* Move to the next cache entry.  */
                    cache_entry =  cache_entry -> fx_cached_sector_next_used;
 800af3a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800af3c:	695b      	ldr	r3, [r3, #20]
 800af3e:	647b      	str	r3, [r7, #68]	; 0x44
            while (cache_size--)
 800af40:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800af42:	1e5a      	subs	r2, r3, #1
 800af44:	643a      	str	r2, [r7, #64]	; 0x40
 800af46:	2b00      	cmp	r3, #0
 800af48:	d1e2      	bne.n	800af10 <_fx_utility_logical_sector_write+0xc8>
                }
            }
        }
#endif /* FX_ENABLE_FAULT_TOLERANT */

        if (cache_found)
 800af4a:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 800af4e:	2b00      	cmp	r3, #0
 800af50:	d00d      	beq.n	800af6e <_fx_utility_logical_sector_write+0x126>
                return(media_ptr -> fx_media_driver_status);
            }
#endif

            /* Determine if this is the first write of this logical sector.  */
            if (cache_entry -> fx_cached_sector_buffer_dirty == FX_FALSE)
 800af52:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800af54:	7c1b      	ldrb	r3, [r3, #16]
 800af56:	2b00      	cmp	r3, #0
 800af58:	d107      	bne.n	800af6a <_fx_utility_logical_sector_write+0x122>
            {

                /* Yes, increment the number of outstanding dirty sectors.  */
                media_ptr -> fx_media_sector_cache_dirty_count++;
 800af5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af5c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800af5e:	1c5a      	adds	r2, r3, #1
 800af60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af62:	625a      	str	r2, [r3, #36]	; 0x24

                /* Simply mark this entry as dirty.  */
                cache_entry -> fx_cached_sector_buffer_dirty =  FX_TRUE;
 800af64:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800af66:	2201      	movs	r2, #1
 800af68:	741a      	strb	r2, [r3, #16]

            /* Don't bother updating the cache linked list since writes are
               preceded by reads anyway.  */

            /* Success, return to caller immediately!  */
            return(FX_SUCCESS);
 800af6a:	2300      	movs	r3, #0
 800af6c:	e0cf      	b.n	800b10e <_fx_utility_logical_sector_write+0x2c6>

        /* Okay, so if we are here the request must be for the additional FAT writes, since this is the
           only time a write request is made without a preceding read request.  */

        /* Is the logical sector valid?  */
        if ((logical_sector == 0) || (logical_sector == ((ULONG)0xFFFFFFFF)))
 800af6e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800af72:	4313      	orrs	r3, r2
 800af74:	d004      	beq.n	800af80 <_fx_utility_logical_sector_write+0x138>
 800af76:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800af7a:	1c51      	adds	r1, r2, #1
 800af7c:	430b      	orrs	r3, r1
 800af7e:	d101      	bne.n	800af84 <_fx_utility_logical_sector_write+0x13c>
        {
            return(FX_SECTOR_INVALID);
 800af80:	2389      	movs	r3, #137	; 0x89
 800af82:	e0c4      	b.n	800b10e <_fx_utility_logical_sector_write+0x2c6>
        }

        /* Compare logical sector against total sectors to make sure it is valid.  */
        if ((logical_sector + sectors - 1) >= media_ptr -> fx_media_total_sectors)
 800af84:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800af86:	2200      	movs	r2, #0
 800af88:	61bb      	str	r3, [r7, #24]
 800af8a:	61fa      	str	r2, [r7, #28]
 800af8c:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800af90:	e9d7 4506 	ldrd	r4, r5, [r7, #24]
 800af94:	4621      	mov	r1, r4
 800af96:	1889      	adds	r1, r1, r2
 800af98:	6139      	str	r1, [r7, #16]
 800af9a:	4629      	mov	r1, r5
 800af9c:	eb43 0101 	adc.w	r1, r3, r1
 800afa0:	6179      	str	r1, [r7, #20]
 800afa2:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 800afa6:	460b      	mov	r3, r1
 800afa8:	f113 3aff 	adds.w	sl, r3, #4294967295
 800afac:	4613      	mov	r3, r2
 800afae:	f143 3bff 	adc.w	fp, r3, #4294967295
 800afb2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afb4:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	; 0x38
 800afb8:	4592      	cmp	sl, r2
 800afba:	eb7b 0303 	sbcs.w	r3, fp, r3
 800afbe:	d301      	bcc.n	800afc4 <_fx_utility_logical_sector_write+0x17c>
        {
            return(FX_SECTOR_INVALID);
 800afc0:	2389      	movs	r3, #137	; 0x89
 800afc2:	e0a4      	b.n	800b10e <_fx_utility_logical_sector_write+0x2c6>
        /* Just write the buffer to the media.  */

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver write sector(s) requests.  */
        media_ptr -> fx_media_driver_write_requests++;
 800afc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afc6:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800afca:	1c5a      	adds	r2, r3, #1
 800afcc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afce:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
#endif

        /* Build write request to the driver.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800afd2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afd4:	2201      	movs	r2, #1
 800afd6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800afda:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afdc:	2290      	movs	r2, #144	; 0x90
 800afde:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 800afe2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afe4:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800afe6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_driver_logical_sector =   logical_sector;
#else
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 800afea:	6a3a      	ldr	r2, [r7, #32]
 800afec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afee:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#endif
        media_ptr -> fx_media_driver_sectors =          sectors;
 800aff2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aff4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800aff6:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 800affa:	f897 2070 	ldrb.w	r2, [r7, #112]	; 0x70
 800affe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b000:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

        /* Determine if the system write flag needs to be set.  */
        if (sector_type != FX_DATA_SECTOR)
 800b004:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 800b008:	2b04      	cmp	r3, #4
 800b00a:	d003      	beq.n	800b014 <_fx_utility_logical_sector_write+0x1cc>
        {

            /* Yes, a system sector write is present so set the flag.  The driver
               can use this flag to make extra safeguards in writing the sector
               out, yielding more fault tolerance.  */
            media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800b00c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b00e:	2201      	movs	r2, #1
 800b010:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, logical_sector, sectors, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to write the sector(s).  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800b014:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b016:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800b01a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b01c:	4798      	blx	r3

        /* Clear the system write flag.  */
        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800b01e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b020:	2200      	movs	r2, #0
 800b022:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

        /* Check for successful completion.  */
        if (media_ptr -> fx_media_driver_status)
 800b026:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b028:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800b02c:	2b00      	cmp	r3, #0
 800b02e:	d003      	beq.n	800b038 <_fx_utility_logical_sector_write+0x1f0>
        {

            /* Error writing a internal sector out.  Return the
               error status.  */
            return(media_ptr -> fx_media_driver_status);
 800b030:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b032:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800b036:	e06a      	b.n	800b10e <_fx_utility_logical_sector_write+0x2c6>
        }

        /* At this point, we have a successful write.  */
        return(FX_SUCCESS);
 800b038:	2300      	movs	r3, #0
 800b03a:	e068      	b.n	800b10e <_fx_utility_logical_sector_write+0x2c6>

        /* Otherwise, the write request is being made directly from an application
           buffer. Determine if the logical sector is valid.  */

        /* Is the logical sector valid? */
        if ((logical_sector == 0) || (logical_sector == ((ULONG)0xFFFFFFFF)))
 800b03c:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800b040:	4313      	orrs	r3, r2
 800b042:	d004      	beq.n	800b04e <_fx_utility_logical_sector_write+0x206>
 800b044:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800b048:	1c51      	adds	r1, r2, #1
 800b04a:	430b      	orrs	r3, r1
 800b04c:	d101      	bne.n	800b052 <_fx_utility_logical_sector_write+0x20a>
        {
            return(FX_SECTOR_INVALID);
 800b04e:	2389      	movs	r3, #137	; 0x89
 800b050:	e05d      	b.n	800b10e <_fx_utility_logical_sector_write+0x2c6>
        }

        /* Compare logical sector against total sectors to make sure it is valid.  */
        if ((logical_sector + sectors - 1) >= media_ptr -> fx_media_total_sectors)
 800b052:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800b054:	2200      	movs	r2, #0
 800b056:	60bb      	str	r3, [r7, #8]
 800b058:	60fa      	str	r2, [r7, #12]
 800b05a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800b05e:	e9d7 ab02 	ldrd	sl, fp, [r7, #8]
 800b062:	4651      	mov	r1, sl
 800b064:	eb11 0802 	adds.w	r8, r1, r2
 800b068:	4659      	mov	r1, fp
 800b06a:	eb41 0903 	adc.w	r9, r1, r3
 800b06e:	f118 34ff 	adds.w	r4, r8, #4294967295
 800b072:	f149 35ff 	adc.w	r5, r9, #4294967295
 800b076:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b078:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	; 0x38
 800b07c:	4294      	cmp	r4, r2
 800b07e:	eb75 0303 	sbcs.w	r3, r5, r3
 800b082:	d301      	bcc.n	800b088 <_fx_utility_logical_sector_write+0x240>
        {
            return(FX_SECTOR_INVALID);
 800b084:	2389      	movs	r3, #137	; 0x89
 800b086:	e042      	b.n	800b10e <_fx_utility_logical_sector_write+0x2c6>
        }

        /* Flush and invalidate for any entries in the cache that are in this direct I/O read request range.  */
        _fx_utility_logical_sector_flush(media_ptr, logical_sector, (ULONG64) sectors, FX_TRUE);
 800b088:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800b08a:	2200      	movs	r2, #0
 800b08c:	603b      	str	r3, [r7, #0]
 800b08e:	607a      	str	r2, [r7, #4]
 800b090:	2301      	movs	r3, #1
 800b092:	9302      	str	r3, [sp, #8]
 800b094:	e9d7 3400 	ldrd	r3, r4, [r7]
 800b098:	e9cd 3400 	strd	r3, r4, [sp]
 800b09c:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800b0a0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b0a2:	f7ff fa27 	bl	800a4f4 <_fx_utility_logical_sector_flush>
#endif /* FX_DISABLE_CACHE */

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver write sector(s) requests.  */
        media_ptr -> fx_media_driver_write_requests++;
 800b0a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0a8:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800b0ac:	1c5a      	adds	r2, r3, #1
 800b0ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0b0:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
#endif

        /* Build request to the driver.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800b0b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0b6:	2201      	movs	r2, #1
 800b0b8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800b0bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0be:	2290      	movs	r2, #144	; 0x90
 800b0c0:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 800b0c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0c6:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800b0c8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_driver_logical_sector =   logical_sector;
#else
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 800b0cc:	6a3a      	ldr	r2, [r7, #32]
 800b0ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0d0:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
#endif
        media_ptr -> fx_media_driver_sectors =          sectors;
 800b0d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0d6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 800b0d8:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 800b0dc:	f897 2070 	ldrb.w	r2, [r7, #112]	; 0x70
 800b0e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0e2:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8

        /* Determine if the system write flag needs to be set.  */
        if (sector_type != FX_DATA_SECTOR)
 800b0e6:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 800b0ea:	2b04      	cmp	r3, #4
 800b0ec:	d003      	beq.n	800b0f6 <_fx_utility_logical_sector_write+0x2ae>
        {

            /* Yes, a system sector write is present so set the flag.  The driver
               can use this flag to make extra safeguards in writing the sector
               out, yielding more fault tolerance.  */
            media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800b0ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0f0:	2201      	movs	r2, #1
 800b0f2:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, logical_sector, sectors, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to write the sector(s).  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800b0f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0f8:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 800b0fc:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b0fe:	4798      	blx	r3

        /* Clear the system write flag.  */
        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800b100:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b102:	2200      	movs	r2, #0
 800b104:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0

        /* Return driver status.  */
        return(media_ptr -> fx_media_driver_status);
 800b108:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b10a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
    }
}
 800b10e:	4618      	mov	r0, r3
 800b110:	3748      	adds	r7, #72	; 0x48
 800b112:	46bd      	mov	sp, r7
 800b114:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800b118 <_fx_utility_memory_copy>:
/*                                            memcpy usage,               */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _fx_utility_memory_copy(UCHAR *source_ptr, UCHAR *dest_ptr, ULONG size)
{
 800b118:	b580      	push	{r7, lr}
 800b11a:	b084      	sub	sp, #16
 800b11c:	af00      	add	r7, sp, #0
 800b11e:	60f8      	str	r0, [r7, #12]
 800b120:	60b9      	str	r1, [r7, #8]
 800b122:	607a      	str	r2, [r7, #4]

    /* Copy the memory.  */
    memcpy(dest_ptr, source_ptr, size); /* Use case of memcpy is verified. */
 800b124:	687a      	ldr	r2, [r7, #4]
 800b126:	68f9      	ldr	r1, [r7, #12]
 800b128:	68b8      	ldr	r0, [r7, #8]
 800b12a:	f008 f8c9 	bl	80132c0 <memcpy>
}
 800b12e:	bf00      	nop
 800b130:	3710      	adds	r7, #16
 800b132:	46bd      	mov	sp, r7
 800b134:	bd80      	pop	{r7, pc}

0800b136 <_fx_utility_memory_set>:
/*  09-30-2020     William E. Lamie         Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _fx_utility_memory_set(UCHAR *dest_ptr, UCHAR value, ULONG size)
{
 800b136:	b480      	push	{r7}
 800b138:	b085      	sub	sp, #20
 800b13a:	af00      	add	r7, sp, #0
 800b13c:	60f8      	str	r0, [r7, #12]
 800b13e:	460b      	mov	r3, r1
 800b140:	607a      	str	r2, [r7, #4]
 800b142:	72fb      	strb	r3, [r7, #11]

    /* Loop to set memory.  */
    while (size--)
 800b144:	e004      	b.n	800b150 <_fx_utility_memory_set+0x1a>
    {

        /* Set byte.  */
        *dest_ptr++ =  value;
 800b146:	68fb      	ldr	r3, [r7, #12]
 800b148:	1c5a      	adds	r2, r3, #1
 800b14a:	60fa      	str	r2, [r7, #12]
 800b14c:	7afa      	ldrb	r2, [r7, #11]
 800b14e:	701a      	strb	r2, [r3, #0]
    while (size--)
 800b150:	687b      	ldr	r3, [r7, #4]
 800b152:	1e5a      	subs	r2, r3, #1
 800b154:	607a      	str	r2, [r7, #4]
 800b156:	2b00      	cmp	r3, #0
 800b158:	d1f5      	bne.n	800b146 <_fx_utility_memory_set+0x10>
    }
}
 800b15a:	bf00      	nop
 800b15c:	bf00      	nop
 800b15e:	3714      	adds	r7, #20
 800b160:	46bd      	mov	sp, r7
 800b162:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b166:	4770      	bx	lr

0800b168 <_fxe_media_format>:
/**************************************************************************/
UINT  _fxe_media_format(FX_MEDIA *media_ptr, VOID (*driver)(FX_MEDIA *media), VOID *driver_info_ptr, UCHAR *memory_ptr, UINT memory_size,
                        CHAR *volume_name, UINT number_of_fats, UINT directory_entries, UINT hidden_sectors,
                        ULONG total_sectors, UINT bytes_per_sector, UINT sectors_per_cluster,
                        UINT heads, UINT sectors_per_track)
{
 800b168:	b580      	push	{r7, lr}
 800b16a:	b090      	sub	sp, #64	; 0x40
 800b16c:	af0a      	add	r7, sp, #40	; 0x28
 800b16e:	60f8      	str	r0, [r7, #12]
 800b170:	60b9      	str	r1, [r7, #8]
 800b172:	607a      	str	r2, [r7, #4]
 800b174:	603b      	str	r3, [r7, #0]

UINT status;


    /* Check for invalid input pointers.  */
    if ((media_ptr == FX_NULL) || (driver == FX_NULL) || (memory_ptr == FX_NULL))
 800b176:	68fb      	ldr	r3, [r7, #12]
 800b178:	2b00      	cmp	r3, #0
 800b17a:	d005      	beq.n	800b188 <_fxe_media_format+0x20>
 800b17c:	68bb      	ldr	r3, [r7, #8]
 800b17e:	2b00      	cmp	r3, #0
 800b180:	d002      	beq.n	800b188 <_fxe_media_format+0x20>
 800b182:	683b      	ldr	r3, [r7, #0]
 800b184:	2b00      	cmp	r3, #0
 800b186:	d101      	bne.n	800b18c <_fxe_media_format+0x24>
    {
        return(FX_PTR_ERROR);
 800b188:	2318      	movs	r3, #24
 800b18a:	e02f      	b.n	800b1ec <_fxe_media_format+0x84>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800b18c:	f3ef 8305 	mrs	r3, IPSR
 800b190:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800b192:	693a      	ldr	r2, [r7, #16]
    }

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE
 800b194:	4b17      	ldr	r3, [pc, #92]	; (800b1f4 <_fxe_media_format+0x8c>)
 800b196:	681b      	ldr	r3, [r3, #0]
 800b198:	4313      	orrs	r3, r2
 800b19a:	2b00      	cmp	r3, #0
 800b19c:	d108      	bne.n	800b1b0 <_fxe_media_format+0x48>
 800b19e:	4b16      	ldr	r3, [pc, #88]	; (800b1f8 <_fxe_media_format+0x90>)
 800b1a0:	681b      	ldr	r3, [r3, #0]
 800b1a2:	2b00      	cmp	r3, #0
 800b1a4:	d004      	beq.n	800b1b0 <_fxe_media_format+0x48>
 800b1a6:	4b14      	ldr	r3, [pc, #80]	; (800b1f8 <_fxe_media_format+0x90>)
 800b1a8:	681b      	ldr	r3, [r3, #0]
 800b1aa:	4a14      	ldr	r2, [pc, #80]	; (800b1fc <_fxe_media_format+0x94>)
 800b1ac:	4293      	cmp	r3, r2
 800b1ae:	d101      	bne.n	800b1b4 <_fxe_media_format+0x4c>
 800b1b0:	2320      	movs	r3, #32
 800b1b2:	e01b      	b.n	800b1ec <_fxe_media_format+0x84>

    /* Call actual media format service.  */
    status =  _fx_media_format(media_ptr, driver, driver_info_ptr, memory_ptr, memory_size,
 800b1b4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b1b6:	9309      	str	r3, [sp, #36]	; 0x24
 800b1b8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b1ba:	9308      	str	r3, [sp, #32]
 800b1bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b1be:	9307      	str	r3, [sp, #28]
 800b1c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b1c2:	9306      	str	r3, [sp, #24]
 800b1c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b1c6:	9305      	str	r3, [sp, #20]
 800b1c8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b1ca:	9304      	str	r3, [sp, #16]
 800b1cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b1ce:	9303      	str	r3, [sp, #12]
 800b1d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b1d2:	9302      	str	r3, [sp, #8]
 800b1d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b1d6:	9301      	str	r3, [sp, #4]
 800b1d8:	6a3b      	ldr	r3, [r7, #32]
 800b1da:	9300      	str	r3, [sp, #0]
 800b1dc:	683b      	ldr	r3, [r7, #0]
 800b1de:	687a      	ldr	r2, [r7, #4]
 800b1e0:	68b9      	ldr	r1, [r7, #8]
 800b1e2:	68f8      	ldr	r0, [r7, #12]
 800b1e4:	f7fc fdf6 	bl	8007dd4 <_fx_media_format>
 800b1e8:	6178      	str	r0, [r7, #20]
                               volume_name, number_of_fats, directory_entries, hidden_sectors,
                               total_sectors, bytes_per_sector, sectors_per_cluster,
                               heads, sectors_per_track);

    /* Return completion status.  */
    return(status);
 800b1ea:	697b      	ldr	r3, [r7, #20]
}
 800b1ec:	4618      	mov	r0, r3
 800b1ee:	3718      	adds	r7, #24
 800b1f0:	46bd      	mov	sp, r7
 800b1f2:	bd80      	pop	{r7, pc}
 800b1f4:	20000090 	.word	0x20000090
 800b1f8:	20006d04 	.word	0x20006d04
 800b1fc:	20006e4c 	.word	0x20006e4c

0800b200 <_fxe_media_open>:
/*                                                                        */
/**************************************************************************/
UINT  _fxe_media_open(FX_MEDIA *media_ptr, CHAR *media_name,
                      VOID (*media_driver)(FX_MEDIA *), VOID *driver_info_ptr,
                      VOID *memory_ptr, ULONG memory_size, UINT media_control_block_size)
{
 800b200:	b580      	push	{r7, lr}
 800b202:	b08e      	sub	sp, #56	; 0x38
 800b204:	af02      	add	r7, sp, #8
 800b206:	60f8      	str	r0, [r7, #12]
 800b208:	60b9      	str	r1, [r7, #8]
 800b20a:	607a      	str	r2, [r7, #4]
 800b20c:	603b      	str	r3, [r7, #0]
UINT       old_threshold;
#endif


    /* Check for invalid input pointers.  */
    if ((media_ptr == FX_NULL) || (media_driver == FX_NULL) || (memory_ptr == FX_NULL) || (media_control_block_size != sizeof(FX_MEDIA)))
 800b20e:	68fb      	ldr	r3, [r7, #12]
 800b210:	2b00      	cmp	r3, #0
 800b212:	d00a      	beq.n	800b22a <_fxe_media_open+0x2a>
 800b214:	687b      	ldr	r3, [r7, #4]
 800b216:	2b00      	cmp	r3, #0
 800b218:	d007      	beq.n	800b22a <_fxe_media_open+0x2a>
 800b21a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b21c:	2b00      	cmp	r3, #0
 800b21e:	d004      	beq.n	800b22a <_fxe_media_open+0x2a>
 800b220:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b222:	f242 42b8 	movw	r2, #9400	; 0x24b8
 800b226:	4293      	cmp	r3, r2
 800b228:	d001      	beq.n	800b22e <_fxe_media_open+0x2e>
    {
        return(FX_PTR_ERROR);
 800b22a:	2318      	movs	r3, #24
 800b22c:	e071      	b.n	800b312 <_fxe_media_open+0x112>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800b22e:	f3ef 8305 	mrs	r3, IPSR
 800b232:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800b234:	69ba      	ldr	r2, [r7, #24]
    }

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE
 800b236:	4b39      	ldr	r3, [pc, #228]	; (800b31c <_fxe_media_open+0x11c>)
 800b238:	681b      	ldr	r3, [r3, #0]
 800b23a:	4313      	orrs	r3, r2
 800b23c:	2b00      	cmp	r3, #0
 800b23e:	d108      	bne.n	800b252 <_fxe_media_open+0x52>
 800b240:	4b37      	ldr	r3, [pc, #220]	; (800b320 <_fxe_media_open+0x120>)
 800b242:	681b      	ldr	r3, [r3, #0]
 800b244:	2b00      	cmp	r3, #0
 800b246:	d004      	beq.n	800b252 <_fxe_media_open+0x52>
 800b248:	4b35      	ldr	r3, [pc, #212]	; (800b320 <_fxe_media_open+0x120>)
 800b24a:	681b      	ldr	r3, [r3, #0]
 800b24c:	4a35      	ldr	r2, [pc, #212]	; (800b324 <_fxe_media_open+0x124>)
 800b24e:	4293      	cmp	r3, r2
 800b250:	d101      	bne.n	800b256 <_fxe_media_open+0x56>
 800b252:	2320      	movs	r3, #32
 800b254:	e05d      	b.n	800b312 <_fxe_media_open+0x112>

    /* Check for proper size of the logical sector cache.  */
    temp =  _fx_system_media_max_sector_cache;
 800b256:	4b34      	ldr	r3, [pc, #208]	; (800b328 <_fxe_media_open+0x128>)
 800b258:	681b      	ldr	r3, [r3, #0]
 800b25a:	627b      	str	r3, [r7, #36]	; 0x24

    /* Isolate the lowest set bit.  */
    temp =  (temp & ((~temp) + ((ULONG) 1)));
 800b25c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b25e:	425b      	negs	r3, r3
 800b260:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b262:	4013      	ands	r3, r2
 800b264:	627b      	str	r3, [r7, #36]	; 0x24

    /* If FX_MAX_SECTOR_CACHE is a power of 2, the value of temp should be unchanged.  */
    if ((temp == 1) || (temp != _fx_system_media_max_sector_cache))
 800b266:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b268:	2b01      	cmp	r3, #1
 800b26a:	d004      	beq.n	800b276 <_fxe_media_open+0x76>
 800b26c:	4b2e      	ldr	r3, [pc, #184]	; (800b328 <_fxe_media_open+0x128>)
 800b26e:	681b      	ldr	r3, [r3, #0]
 800b270:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b272:	429a      	cmp	r2, r3
 800b274:	d001      	beq.n	800b27a <_fxe_media_open+0x7a>
    {

        /* Not a power of 2, return an error.  */
        return(FX_MEDIA_INVALID);
 800b276:	2302      	movs	r3, #2
 800b278:	e04b      	b.n	800b312 <_fxe_media_open+0x112>
    }

    /* Check for proper size of the FAT cache.  */
    temp =  _fx_system_media_max_fat_cache;
 800b27a:	4b2c      	ldr	r3, [pc, #176]	; (800b32c <_fxe_media_open+0x12c>)
 800b27c:	681b      	ldr	r3, [r3, #0]
 800b27e:	627b      	str	r3, [r7, #36]	; 0x24

    /* Isolate the lowest set bit.  */
    temp =  (temp & ((~temp) + ((ULONG) 1)));
 800b280:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b282:	425b      	negs	r3, r3
 800b284:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b286:	4013      	ands	r3, r2
 800b288:	627b      	str	r3, [r7, #36]	; 0x24

    /* If FX_MAX_FAT_CACHE is a power of 2, the value of temp should be unchanged.  */
    if ((temp == 1) || (temp != _fx_system_media_max_fat_cache))
 800b28a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b28c:	2b01      	cmp	r3, #1
 800b28e:	d004      	beq.n	800b29a <_fxe_media_open+0x9a>
 800b290:	4b26      	ldr	r3, [pc, #152]	; (800b32c <_fxe_media_open+0x12c>)
 800b292:	681b      	ldr	r3, [r3, #0]
 800b294:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b296:	429a      	cmp	r2, r3
 800b298:	d001      	beq.n	800b29e <_fxe_media_open+0x9e>
    {

        /* Not a power of 2, return an error.  */
        return(FX_MEDIA_INVALID);
 800b29a:	2302      	movs	r3, #2
 800b29c:	e039      	b.n	800b312 <_fxe_media_open+0x112>

#ifndef FX_SINGLE_THREAD

    /* Pickup current thread pointer. At this point we know the current thread pointer is non-null since 
       it was checked by code in FX_CALLER_CHECKING_CODE macro.  */
    current_thread =  tx_thread_identify();
 800b29e:	f002 f921 	bl	800d4e4 <_tx_thread_identify>
 800b2a2:	6238      	str	r0, [r7, #32]

    /* Disable preemption temporarily.  */
    tx_thread_preemption_change(current_thread, 0, &old_threshold);
 800b2a4:	f107 0314 	add.w	r3, r7, #20
 800b2a8:	461a      	mov	r2, r3
 800b2aa:	2100      	movs	r1, #0
 800b2ac:	6a38      	ldr	r0, [r7, #32]
 800b2ae:	f002 f94d 	bl	800d54c <_tx_thread_preemption_change>
#endif

    /* Loop to check for the media already opened.  */
    current_media =  _fx_system_media_opened_ptr;
 800b2b2:	4b1f      	ldr	r3, [pc, #124]	; (800b330 <_fxe_media_open+0x130>)
 800b2b4:	681b      	ldr	r3, [r3, #0]
 800b2b6:	62fb      	str	r3, [r7, #44]	; 0x2c
    open_count =     _fx_system_media_opened_count;
 800b2b8:	4b1e      	ldr	r3, [pc, #120]	; (800b334 <_fxe_media_open+0x134>)
 800b2ba:	681b      	ldr	r3, [r3, #0]
 800b2bc:	62bb      	str	r3, [r7, #40]	; 0x28
    while (open_count--)
 800b2be:	e010      	b.n	800b2e2 <_fxe_media_open+0xe2>
    {

        /* Is the new media pointer already open?  */
        if (media_ptr == current_media)
 800b2c0:	68fa      	ldr	r2, [r7, #12]
 800b2c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2c4:	429a      	cmp	r2, r3
 800b2c6:	d108      	bne.n	800b2da <_fxe_media_open+0xda>
        {

#ifndef FX_SINGLE_THREAD

            /* Restore preemption.  */
            tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
 800b2c8:	697b      	ldr	r3, [r7, #20]
 800b2ca:	f107 0214 	add.w	r2, r7, #20
 800b2ce:	4619      	mov	r1, r3
 800b2d0:	6a38      	ldr	r0, [r7, #32]
 800b2d2:	f002 f93b 	bl	800d54c <_tx_thread_preemption_change>
#endif

            /* Duplicate media open, return an error!  */
            return(FX_PTR_ERROR);
 800b2d6:	2318      	movs	r3, #24
 800b2d8:	e01b      	b.n	800b312 <_fxe_media_open+0x112>
        }

        /* Move to next entry.  */
        current_media =  current_media -> fx_media_opened_next;
 800b2da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b2dc:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 800b2e0:	62fb      	str	r3, [r7, #44]	; 0x2c
    while (open_count--)
 800b2e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b2e4:	1e5a      	subs	r2, r3, #1
 800b2e6:	62ba      	str	r2, [r7, #40]	; 0x28
 800b2e8:	2b00      	cmp	r3, #0
 800b2ea:	d1e9      	bne.n	800b2c0 <_fxe_media_open+0xc0>
    }

#ifndef FX_SINGLE_THREAD

    /* Restore preemption.  */
    tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
 800b2ec:	697b      	ldr	r3, [r7, #20]
 800b2ee:	f107 0214 	add.w	r2, r7, #20
 800b2f2:	4619      	mov	r1, r3
 800b2f4:	6a38      	ldr	r0, [r7, #32]
 800b2f6:	f002 f929 	bl	800d54c <_tx_thread_preemption_change>
#endif

    /* Call actual media open service.  */
    status =  _fx_media_open(media_ptr, media_name, media_driver, driver_info_ptr,
 800b2fa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b2fc:	9301      	str	r3, [sp, #4]
 800b2fe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b300:	9300      	str	r3, [sp, #0]
 800b302:	683b      	ldr	r3, [r7, #0]
 800b304:	687a      	ldr	r2, [r7, #4]
 800b306:	68b9      	ldr	r1, [r7, #8]
 800b308:	68f8      	ldr	r0, [r7, #12]
 800b30a:	f7fd f91b 	bl	8008544 <_fx_media_open>
 800b30e:	61f8      	str	r0, [r7, #28]
                             memory_ptr, memory_size);

    /* Return status.  */
    return(status);
 800b310:	69fb      	ldr	r3, [r7, #28]
}
 800b312:	4618      	mov	r0, r3
 800b314:	3730      	adds	r7, #48	; 0x30
 800b316:	46bd      	mov	sp, r7
 800b318:	bd80      	pop	{r7, pc}
 800b31a:	bf00      	nop
 800b31c:	20000090 	.word	0x20000090
 800b320:	20006d04 	.word	0x20006d04
 800b324:	20006e4c 	.word	0x20006e4c
 800b328:	20006c94 	.word	0x20006c94
 800b32c:	20006c98 	.word	0x20006c98
 800b330:	20006c84 	.word	0x20006c84
 800b334:	20006c88 	.word	0x20006c88

0800b338 <_tx_byte_allocate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_allocate(TX_BYTE_POOL *pool_ptr, VOID **memory_ptr, ULONG memory_size,  ULONG wait_option)
{
 800b338:	b580      	push	{r7, lr}
 800b33a:	b096      	sub	sp, #88	; 0x58
 800b33c:	af00      	add	r7, sp, #0
 800b33e:	60f8      	str	r0, [r7, #12]
 800b340:	60b9      	str	r1, [r7, #8]
 800b342:	607a      	str	r2, [r7, #4]
 800b344:	603b      	str	r3, [r7, #0]
#endif


    /* Round the memory size up to the next size that is evenly divisible by
       an ALIGN_TYPE (this is typically a 32-bit ULONG).  This guarantees proper alignment.  */
    memory_size = (((memory_size + (sizeof(ALIGN_TYPE)))-((ALIGN_TYPE) 1))/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
 800b346:	687b      	ldr	r3, [r7, #4]
 800b348:	3303      	adds	r3, #3
 800b34a:	f023 0303 	bic.w	r3, r3, #3
 800b34e:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b350:	f3ef 8310 	mrs	r3, PRIMASK
 800b354:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 800b356:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    int_posture = __get_interrupt_posture();
 800b358:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
 800b35a:	b672      	cpsid	i
    return(int_posture);
 800b35c:	6b3b      	ldr	r3, [r7, #48]	; 0x30

    /* Disable interrupts.  */
    TX_DISABLE
 800b35e:	657b      	str	r3, [r7, #84]	; 0x54

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800b360:	4b55      	ldr	r3, [pc, #340]	; (800b4b8 <_tx_byte_allocate+0x180>)
 800b362:	681b      	ldr	r3, [r3, #0]
 800b364:	64bb      	str	r3, [r7, #72]	; 0x48
    lower_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_LOWER_OFFSET));
    upper_tbu =  *((ULONG *) (log_entry_ptr + TX_EL_EVENT_TIME_UPPER_OFFSET));
#endif

    /* Set the search finished flag to false.  */
    finished =  TX_FALSE;
 800b366:	2300      	movs	r3, #0
 800b368:	64fb      	str	r3, [r7, #76]	; 0x4c
    /* Loop to handle cases where the owner of the pool changed.  */
    do
    {

        /* Indicate that this thread is the current owner.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 800b36a:	68fb      	ldr	r3, [r7, #12]
 800b36c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b36e:	621a      	str	r2, [r3, #32]
 800b370:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b372:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b374:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b376:	f383 8810 	msr	PRIMASK, r3
}
 800b37a:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* At this point, the executing thread owns the pool and can perform a search
           for free memory.  */
        work_ptr =  _tx_byte_pool_search(pool_ptr, memory_size);
 800b37c:	6879      	ldr	r1, [r7, #4]
 800b37e:	68f8      	ldr	r0, [r7, #12]
 800b380:	f000 f9b2 	bl	800b6e8 <_tx_byte_pool_search>
 800b384:	6478      	str	r0, [r7, #68]	; 0x44
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b386:	f3ef 8310 	mrs	r3, PRIMASK
 800b38a:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800b38c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800b38e:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800b390:	b672      	cpsid	i
    return(int_posture);
 800b392:	6abb      	ldr	r3, [r7, #40]	; 0x28

        /* Optional processing extension.  */
        TX_BYTE_ALLOCATE_EXTENSION

        /* Lockout interrupts.  */
        TX_DISABLE
 800b394:	657b      	str	r3, [r7, #84]	; 0x54

        /* Determine if we are finished.  */
        if (work_ptr != TX_NULL)
 800b396:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b398:	2b00      	cmp	r3, #0
 800b39a:	d002      	beq.n	800b3a2 <_tx_byte_allocate+0x6a>
        {

            /* Yes, we have found a block the search is finished.  */
            finished =  TX_TRUE;
 800b39c:	2301      	movs	r3, #1
 800b39e:	64fb      	str	r3, [r7, #76]	; 0x4c
 800b3a0:	e006      	b.n	800b3b0 <_tx_byte_allocate+0x78>
        }
        else
        {

            /* No block was found, does this thread still own the pool?  */
            if (pool_ptr -> tx_byte_pool_owner == thread_ptr)
 800b3a2:	68fb      	ldr	r3, [r7, #12]
 800b3a4:	6a1b      	ldr	r3, [r3, #32]
 800b3a6:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b3a8:	429a      	cmp	r2, r3
 800b3aa:	d101      	bne.n	800b3b0 <_tx_byte_allocate+0x78>
            {

                /* Yes, then we have looked through the entire pool and haven't found the memory.  */
                finished =  TX_TRUE;
 800b3ac:	2301      	movs	r3, #1
 800b3ae:	64fb      	str	r3, [r7, #76]	; 0x4c
            }
        }

    } while (finished == TX_FALSE);
 800b3b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b3b2:	2b00      	cmp	r3, #0
 800b3b4:	d0d9      	beq.n	800b36a <_tx_byte_allocate+0x32>

    /* Copy the pointer into the return destination.  */
    *memory_ptr =  (VOID *) work_ptr;
 800b3b6:	68bb      	ldr	r3, [r7, #8]
 800b3b8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800b3ba:	601a      	str	r2, [r3, #0]

    /* Determine if memory was found.  */
    if (work_ptr != TX_NULL)
 800b3bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b3be:	2b00      	cmp	r3, #0
 800b3c0:	d008      	beq.n	800b3d4 <_tx_byte_allocate+0x9c>
 800b3c2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b3c4:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b3c6:	6a3b      	ldr	r3, [r7, #32]
 800b3c8:	f383 8810 	msr	PRIMASK, r3
}
 800b3cc:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Set the status to success.  */
        status =  TX_SUCCESS;
 800b3ce:	2300      	movs	r3, #0
 800b3d0:	653b      	str	r3, [r7, #80]	; 0x50
 800b3d2:	e06c      	b.n	800b4ae <_tx_byte_allocate+0x176>
    {

        /* No memory of sufficient size was found...  */

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
 800b3d4:	683b      	ldr	r3, [r7, #0]
 800b3d6:	2b00      	cmp	r3, #0
 800b3d8:	d061      	beq.n	800b49e <_tx_byte_allocate+0x166>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
 800b3da:	4b38      	ldr	r3, [pc, #224]	; (800b4bc <_tx_byte_allocate+0x184>)
 800b3dc:	681b      	ldr	r3, [r3, #0]
 800b3de:	2b00      	cmp	r3, #0
 800b3e0:	d007      	beq.n	800b3f2 <_tx_byte_allocate+0xba>
            {

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
                status =  TX_NO_MEMORY;
 800b3e2:	2310      	movs	r3, #16
 800b3e4:	653b      	str	r3, [r7, #80]	; 0x50
 800b3e6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b3e8:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b3ea:	69fb      	ldr	r3, [r7, #28]
 800b3ec:	f383 8810 	msr	PRIMASK, r3
}
 800b3f0:	e05d      	b.n	800b4ae <_tx_byte_allocate+0x176>
                /* Increment the number of suspensions on this pool.  */
                pool_ptr -> tx_byte_pool_performance_suspension_count++;
#endif

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_byte_pool_cleanup);
 800b3f2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b3f4:	4a32      	ldr	r2, [pc, #200]	; (800b4c0 <_tx_byte_allocate+0x188>)
 800b3f6:	669a      	str	r2, [r3, #104]	; 0x68

                /* Setup cleanup information, i.e. this pool control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) pool_ptr;
 800b3f8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b3fa:	68fa      	ldr	r2, [r7, #12]
 800b3fc:	66da      	str	r2, [r3, #108]	; 0x6c

                /* Save the return memory pointer address as well.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) memory_ptr;
 800b3fe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b400:	68ba      	ldr	r2, [r7, #8]
 800b402:	67da      	str	r2, [r3, #124]	; 0x7c

                /* Save the byte size requested.  */
                thread_ptr -> tx_thread_suspend_info =  memory_size;
 800b404:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b406:	687a      	ldr	r2, [r7, #4]
 800b408:	679a      	str	r2, [r3, #120]	; 0x78

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
 800b40a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b40c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800b410:	1c5a      	adds	r2, r3, #1
 800b412:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b414:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#endif

                /* Pickup the number of suspended threads.  */
                suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
 800b418:	68fb      	ldr	r3, [r7, #12]
 800b41a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b41c:	643b      	str	r3, [r7, #64]	; 0x40

                /* Increment the suspension count.  */
                (pool_ptr -> tx_byte_pool_suspended_count)++;
 800b41e:	68fb      	ldr	r3, [r7, #12]
 800b420:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b422:	1c5a      	adds	r2, r3, #1
 800b424:	68fb      	ldr	r3, [r7, #12]
 800b426:	629a      	str	r2, [r3, #40]	; 0x28

                /* Setup suspension list.  */
                if (suspended_count == TX_NO_SUSPENSIONS)
 800b428:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b42a:	2b00      	cmp	r3, #0
 800b42c:	d109      	bne.n	800b442 <_tx_byte_allocate+0x10a>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    pool_ptr -> tx_byte_pool_suspension_list =      thread_ptr;
 800b42e:	68fb      	ldr	r3, [r7, #12]
 800b430:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b432:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 800b434:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b436:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b438:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 800b43a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b43c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b43e:	675a      	str	r2, [r3, #116]	; 0x74
 800b440:	e011      	b.n	800b466 <_tx_byte_allocate+0x12e>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   pool_ptr -> tx_byte_pool_suspension_list;
 800b442:	68fb      	ldr	r3, [r7, #12]
 800b444:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b446:	63fb      	str	r3, [r7, #60]	; 0x3c
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
 800b448:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b44a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b44c:	671a      	str	r2, [r3, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 800b44e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b450:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b452:	63bb      	str	r3, [r7, #56]	; 0x38
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 800b454:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b456:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800b458:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 800b45a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b45c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b45e:	671a      	str	r2, [r3, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 800b460:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b462:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b464:	675a      	str	r2, [r3, #116]	; 0x74
                }

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =       TX_BYTE_MEMORY;
 800b466:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b468:	2209      	movs	r2, #9
 800b46a:	631a      	str	r2, [r3, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800b46c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b46e:	2201      	movs	r2, #1
 800b470:	639a      	str	r2, [r3, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 800b472:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b474:	683a      	ldr	r2, [r7, #0]
 800b476:	64da      	str	r2, [r3, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 800b478:	4b10      	ldr	r3, [pc, #64]	; (800b4bc <_tx_byte_allocate+0x184>)
 800b47a:	681b      	ldr	r3, [r3, #0]
 800b47c:	3301      	adds	r3, #1
 800b47e:	4a0f      	ldr	r2, [pc, #60]	; (800b4bc <_tx_byte_allocate+0x184>)
 800b480:	6013      	str	r3, [r2, #0]
 800b482:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b484:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b486:	69bb      	ldr	r3, [r7, #24]
 800b488:	f383 8810 	msr	PRIMASK, r3
}
 800b48c:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 800b48e:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 800b490:	f002 fd94 	bl	800dfbc <_tx_thread_system_suspend>
                    *((ULONG *) (log_entry_ptr + TX_EL_EVENT_INFO_4_OFFSET)) =  (ULONG) *memory_ptr;
                }
#endif

                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
 800b494:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b496:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800b49a:	653b      	str	r3, [r7, #80]	; 0x50
 800b49c:	e007      	b.n	800b4ae <_tx_byte_allocate+0x176>
 800b49e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b4a0:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b4a2:	697b      	ldr	r3, [r7, #20]
 800b4a4:	f383 8810 	msr	PRIMASK, r3
}
 800b4a8:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NO_MEMORY;
 800b4aa:	2310      	movs	r3, #16
 800b4ac:	653b      	str	r3, [r7, #80]	; 0x50
        }
    }

    /* Return completion status.  */
    return(status);
 800b4ae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 800b4b0:	4618      	mov	r0, r3
 800b4b2:	3758      	adds	r7, #88	; 0x58
 800b4b4:	46bd      	mov	sp, r7
 800b4b6:	bd80      	pop	{r7, pc}
 800b4b8:	20006d04 	.word	0x20006d04
 800b4bc:	20006d9c 	.word	0x20006d9c
 800b4c0:	0800b4c5 	.word	0x0800b4c5

0800b4c4 <_tx_byte_pool_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_byte_pool_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
 800b4c4:	b580      	push	{r7, lr}
 800b4c6:	b08e      	sub	sp, #56	; 0x38
 800b4c8:	af00      	add	r7, sp, #0
 800b4ca:	6078      	str	r0, [r7, #4]
 800b4cc:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b4ce:	f3ef 8310 	mrs	r3, PRIMASK
 800b4d2:	623b      	str	r3, [r7, #32]
    return(posture);
 800b4d4:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800b4d6:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b4d8:	b672      	cpsid	i
    return(int_posture);
 800b4da:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the byte pool.  */
    TX_DISABLE
 800b4dc:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_byte_pool_cleanup))
 800b4de:	687b      	ldr	r3, [r7, #4]
 800b4e0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800b4e2:	4a33      	ldr	r2, [pc, #204]	; (800b5b0 <_tx_byte_pool_cleanup+0xec>)
 800b4e4:	4293      	cmp	r3, r2
 800b4e6:	d158      	bne.n	800b59a <_tx_byte_pool_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 800b4e8:	687b      	ldr	r3, [r7, #4]
 800b4ea:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800b4ee:	683a      	ldr	r2, [r7, #0]
 800b4f0:	429a      	cmp	r2, r3
 800b4f2:	d152      	bne.n	800b59a <_tx_byte_pool_cleanup+0xd6>
        {

            /* Setup pointer to byte pool control block.  */
            pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 800b4f4:	687b      	ldr	r3, [r7, #4]
 800b4f6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800b4f8:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for a NULL byte pool pointer.  */
            if (pool_ptr != TX_NULL)
 800b4fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b4fc:	2b00      	cmp	r3, #0
 800b4fe:	d04c      	beq.n	800b59a <_tx_byte_pool_cleanup+0xd6>
            {

                /* Check for valid pool ID.  */
                if (pool_ptr -> tx_byte_pool_id == TX_BYTE_POOL_ID)
 800b500:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b502:	681b      	ldr	r3, [r3, #0]
 800b504:	4a2b      	ldr	r2, [pc, #172]	; (800b5b4 <_tx_byte_pool_cleanup+0xf0>)
 800b506:	4293      	cmp	r3, r2
 800b508:	d147      	bne.n	800b59a <_tx_byte_pool_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (pool_ptr -> tx_byte_pool_suspended_count != TX_NO_SUSPENSIONS)
 800b50a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b50c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b50e:	2b00      	cmp	r3, #0
 800b510:	d043      	beq.n	800b59a <_tx_byte_pool_cleanup+0xd6>
                        /* Setup pointer to byte pool control block.  */
                        pool_ptr =  TX_VOID_TO_BYTE_POOL_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
#endif

                        /* Thread suspended for memory... Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800b512:	687b      	ldr	r3, [r7, #4]
 800b514:	2200      	movs	r2, #0
 800b516:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspension count.  */
                        pool_ptr -> tx_byte_pool_suspended_count--;
 800b518:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b51a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b51c:	1e5a      	subs	r2, r3, #1
 800b51e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b520:	629a      	str	r2, [r3, #40]	; 0x28

                        /* Pickup the suspended count.  */
                        suspended_count =  pool_ptr -> tx_byte_pool_suspended_count;
 800b522:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b524:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b526:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 800b528:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b52a:	2b00      	cmp	r3, #0
 800b52c:	d103      	bne.n	800b536 <_tx_byte_pool_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            pool_ptr -> tx_byte_pool_suspension_list =  TX_NULL;
 800b52e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b530:	2200      	movs	r2, #0
 800b532:	625a      	str	r2, [r3, #36]	; 0x24
 800b534:	e013      	b.n	800b55e <_tx_byte_pool_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 800b536:	687b      	ldr	r3, [r7, #4]
 800b538:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b53a:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800b53c:	687b      	ldr	r3, [r7, #4]
 800b53e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b540:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 800b542:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b544:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b546:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 800b548:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b54a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b54c:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (pool_ptr -> tx_byte_pool_suspension_list == thread_ptr)
 800b54e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b550:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b552:	687a      	ldr	r2, [r7, #4]
 800b554:	429a      	cmp	r2, r3
 800b556:	d102      	bne.n	800b55e <_tx_byte_pool_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                pool_ptr -> tx_byte_pool_suspension_list =      next_thread;
 800b558:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b55a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b55c:	625a      	str	r2, [r3, #36]	; 0x24
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_BYTE_MEMORY)
 800b55e:	687b      	ldr	r3, [r7, #4]
 800b560:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b562:	2b09      	cmp	r3, #9
 800b564:	d119      	bne.n	800b59a <_tx_byte_pool_cleanup+0xd6>
                            /* Increment the number of timeouts on this byte pool.  */
                            pool_ptr -> tx_byte_pool_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_MEMORY;
 800b566:	687b      	ldr	r3, [r7, #4]
 800b568:	2210      	movs	r2, #16
 800b56a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 800b56e:	4b12      	ldr	r3, [pc, #72]	; (800b5b8 <_tx_byte_pool_cleanup+0xf4>)
 800b570:	681b      	ldr	r3, [r3, #0]
 800b572:	3301      	adds	r3, #1
 800b574:	4a10      	ldr	r2, [pc, #64]	; (800b5b8 <_tx_byte_pool_cleanup+0xf4>)
 800b576:	6013      	str	r3, [r2, #0]
 800b578:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b57a:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b57c:	693b      	ldr	r3, [r7, #16]
 800b57e:	f383 8810 	msr	PRIMASK, r3
}
 800b582:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 800b584:	6878      	ldr	r0, [r7, #4]
 800b586:	f002 fc19 	bl	800ddbc <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b58a:	f3ef 8310 	mrs	r3, PRIMASK
 800b58e:	61bb      	str	r3, [r7, #24]
    return(posture);
 800b590:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800b592:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b594:	b672      	cpsid	i
    return(int_posture);
 800b596:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 800b598:	637b      	str	r3, [r7, #52]	; 0x34
 800b59a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b59c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b59e:	68fb      	ldr	r3, [r7, #12]
 800b5a0:	f383 8810 	msr	PRIMASK, r3
}
 800b5a4:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 800b5a6:	bf00      	nop
 800b5a8:	3738      	adds	r7, #56	; 0x38
 800b5aa:	46bd      	mov	sp, r7
 800b5ac:	bd80      	pop	{r7, pc}
 800b5ae:	bf00      	nop
 800b5b0:	0800b4c5 	.word	0x0800b4c5
 800b5b4:	42595445 	.word	0x42595445
 800b5b8:	20006d9c 	.word	0x20006d9c

0800b5bc <_tx_byte_pool_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_byte_pool_create(TX_BYTE_POOL *pool_ptr, CHAR *name_ptr, VOID *pool_start, ULONG pool_size)
{
 800b5bc:	b580      	push	{r7, lr}
 800b5be:	b08e      	sub	sp, #56	; 0x38
 800b5c0:	af00      	add	r7, sp, #0
 800b5c2:	60f8      	str	r0, [r7, #12]
 800b5c4:	60b9      	str	r1, [r7, #8]
 800b5c6:	607a      	str	r2, [r7, #4]
 800b5c8:	603b      	str	r3, [r7, #0]
TX_BYTE_POOL        *previous_pool;
ALIGN_TYPE          *free_ptr;


    /* Initialize the byte pool control block to all zeros.  */
    TX_MEMSET(pool_ptr, 0, (sizeof(TX_BYTE_POOL)));
 800b5ca:	2234      	movs	r2, #52	; 0x34
 800b5cc:	2100      	movs	r1, #0
 800b5ce:	68f8      	ldr	r0, [r7, #12]
 800b5d0:	f007 fe4a 	bl	8013268 <memset>

    /* Round the pool size down to something that is evenly divisible by
       an ULONG.  */
    pool_size =   (pool_size/(sizeof(ALIGN_TYPE))) * (sizeof(ALIGN_TYPE));
 800b5d4:	683b      	ldr	r3, [r7, #0]
 800b5d6:	f023 0303 	bic.w	r3, r3, #3
 800b5da:	603b      	str	r3, [r7, #0]

    /* Setup the basic byte pool fields.  */
    pool_ptr -> tx_byte_pool_name =              name_ptr;
 800b5dc:	68fb      	ldr	r3, [r7, #12]
 800b5de:	68ba      	ldr	r2, [r7, #8]
 800b5e0:	605a      	str	r2, [r3, #4]

    /* Save the start and size of the pool.  */
    pool_ptr -> tx_byte_pool_start =   TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 800b5e2:	68fb      	ldr	r3, [r7, #12]
 800b5e4:	687a      	ldr	r2, [r7, #4]
 800b5e6:	619a      	str	r2, [r3, #24]
    pool_ptr -> tx_byte_pool_size =    pool_size;
 800b5e8:	68fb      	ldr	r3, [r7, #12]
 800b5ea:	683a      	ldr	r2, [r7, #0]
 800b5ec:	61da      	str	r2, [r3, #28]

    /* Setup memory list to the beginning as well as the search pointer.  */
    pool_ptr -> tx_byte_pool_list =    TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 800b5ee:	68fb      	ldr	r3, [r7, #12]
 800b5f0:	687a      	ldr	r2, [r7, #4]
 800b5f2:	611a      	str	r2, [r3, #16]
    pool_ptr -> tx_byte_pool_search =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 800b5f4:	68fb      	ldr	r3, [r7, #12]
 800b5f6:	687a      	ldr	r2, [r7, #4]
 800b5f8:	615a      	str	r2, [r3, #20]

    /* Initially, the pool will have two blocks.  One large block at the
       beginning that is available and a small allocated block at the end
       of the pool that is there just for the algorithm.  Be sure to count
       the available block's header in the available bytes count.  */
    pool_ptr -> tx_byte_pool_available =   pool_size - ((sizeof(VOID *)) + (sizeof(ALIGN_TYPE)));
 800b5fa:	683b      	ldr	r3, [r7, #0]
 800b5fc:	f1a3 0208 	sub.w	r2, r3, #8
 800b600:	68fb      	ldr	r3, [r7, #12]
 800b602:	609a      	str	r2, [r3, #8]
    pool_ptr -> tx_byte_pool_fragments =   ((UINT) 2);
 800b604:	68fb      	ldr	r3, [r7, #12]
 800b606:	2202      	movs	r2, #2
 800b608:	60da      	str	r2, [r3, #12]
    /* Each block contains a "next" pointer that points to the next block in the pool followed by a ALIGN_TYPE
       field that contains either the constant TX_BYTE_BLOCK_FREE (if the block is free) or a pointer to the
       owning pool (if the block is allocated).  */

    /* Calculate the end of the pool's memory area.  */
    block_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 800b60a:	687b      	ldr	r3, [r7, #4]
 800b60c:	637b      	str	r3, [r7, #52]	; 0x34
    block_ptr =  TX_UCHAR_POINTER_ADD(block_ptr, pool_size);
 800b60e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b610:	683b      	ldr	r3, [r7, #0]
 800b612:	4413      	add	r3, r2
 800b614:	637b      	str	r3, [r7, #52]	; 0x34

    /* Backup the end of the pool pointer and build the pre-allocated block.  */
    block_ptr =  TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(ALIGN_TYPE)));
 800b616:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b618:	3b04      	subs	r3, #4
 800b61a:	637b      	str	r3, [r7, #52]	; 0x34

    /* Cast the pool pointer into a ULONG.  */
    temp_ptr =             TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
 800b61c:	68fb      	ldr	r3, [r7, #12]
 800b61e:	633b      	str	r3, [r7, #48]	; 0x30
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
 800b620:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b622:	62fb      	str	r3, [r7, #44]	; 0x2c
    *block_indirect_ptr =  temp_ptr;
 800b624:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b626:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b628:	601a      	str	r2, [r3, #0]

    block_ptr =            TX_UCHAR_POINTER_SUB(block_ptr, (sizeof(UCHAR *)));
 800b62a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b62c:	3b04      	subs	r3, #4
 800b62e:	637b      	str	r3, [r7, #52]	; 0x34
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(block_ptr);
 800b630:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b632:	62fb      	str	r3, [r7, #44]	; 0x2c
    *block_indirect_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 800b634:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b636:	687a      	ldr	r2, [r7, #4]
 800b638:	601a      	str	r2, [r3, #0]

    /* Now setup the large available block in the pool.  */
    temp_ptr =             TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 800b63a:	687b      	ldr	r3, [r7, #4]
 800b63c:	633b      	str	r3, [r7, #48]	; 0x30
    block_indirect_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(temp_ptr);
 800b63e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b640:	62fb      	str	r3, [r7, #44]	; 0x2c
    *block_indirect_ptr =  block_ptr;
 800b642:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b644:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b646:	601a      	str	r2, [r3, #0]
    block_ptr =            TX_VOID_TO_UCHAR_POINTER_CONVERT(pool_start);
 800b648:	687b      	ldr	r3, [r7, #4]
 800b64a:	637b      	str	r3, [r7, #52]	; 0x34
    block_ptr =            TX_UCHAR_POINTER_ADD(block_ptr, (sizeof(UCHAR *)));
 800b64c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b64e:	3304      	adds	r3, #4
 800b650:	637b      	str	r3, [r7, #52]	; 0x34
    free_ptr =             TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(block_ptr);
 800b652:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b654:	62bb      	str	r3, [r7, #40]	; 0x28
    *free_ptr =            TX_BYTE_BLOCK_FREE;
 800b656:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b658:	4a1f      	ldr	r2, [pc, #124]	; (800b6d8 <_tx_byte_pool_create+0x11c>)
 800b65a:	601a      	str	r2, [r3, #0]

    /* Clear the owner id.  */
    pool_ptr -> tx_byte_pool_owner =  TX_NULL;
 800b65c:	68fb      	ldr	r3, [r7, #12]
 800b65e:	2200      	movs	r2, #0
 800b660:	621a      	str	r2, [r3, #32]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b662:	f3ef 8310 	mrs	r3, PRIMASK
 800b666:	61bb      	str	r3, [r7, #24]
    return(posture);
 800b668:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800b66a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b66c:	b672      	cpsid	i
    return(int_posture);
 800b66e:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the byte pool on the created list.  */
    TX_DISABLE
 800b670:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the byte pool ID to make it valid.  */
    pool_ptr -> tx_byte_pool_id =  TX_BYTE_POOL_ID;
 800b672:	68fb      	ldr	r3, [r7, #12]
 800b674:	4a19      	ldr	r2, [pc, #100]	; (800b6dc <_tx_byte_pool_create+0x120>)
 800b676:	601a      	str	r2, [r3, #0]

    /* Place the byte pool on the list of created byte pools.  First,
       check for an empty list.  */
    if (_tx_byte_pool_created_count == TX_EMPTY)
 800b678:	4b19      	ldr	r3, [pc, #100]	; (800b6e0 <_tx_byte_pool_create+0x124>)
 800b67a:	681b      	ldr	r3, [r3, #0]
 800b67c:	2b00      	cmp	r3, #0
 800b67e:	d109      	bne.n	800b694 <_tx_byte_pool_create+0xd8>
    {

        /* The created byte pool list is empty.  Add byte pool to empty list.  */
        _tx_byte_pool_created_ptr =                  pool_ptr;
 800b680:	4a18      	ldr	r2, [pc, #96]	; (800b6e4 <_tx_byte_pool_create+0x128>)
 800b682:	68fb      	ldr	r3, [r7, #12]
 800b684:	6013      	str	r3, [r2, #0]
        pool_ptr -> tx_byte_pool_created_next =      pool_ptr;
 800b686:	68fb      	ldr	r3, [r7, #12]
 800b688:	68fa      	ldr	r2, [r7, #12]
 800b68a:	62da      	str	r2, [r3, #44]	; 0x2c
        pool_ptr -> tx_byte_pool_created_previous =  pool_ptr;
 800b68c:	68fb      	ldr	r3, [r7, #12]
 800b68e:	68fa      	ldr	r2, [r7, #12]
 800b690:	631a      	str	r2, [r3, #48]	; 0x30
 800b692:	e011      	b.n	800b6b8 <_tx_byte_pool_create+0xfc>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_pool =      _tx_byte_pool_created_ptr;
 800b694:	4b13      	ldr	r3, [pc, #76]	; (800b6e4 <_tx_byte_pool_create+0x128>)
 800b696:	681b      	ldr	r3, [r3, #0]
 800b698:	623b      	str	r3, [r7, #32]
        previous_pool =  next_pool -> tx_byte_pool_created_previous;
 800b69a:	6a3b      	ldr	r3, [r7, #32]
 800b69c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b69e:	61fb      	str	r3, [r7, #28]

        /* Place the new byte pool in the list.  */
        next_pool -> tx_byte_pool_created_previous =  pool_ptr;
 800b6a0:	6a3b      	ldr	r3, [r7, #32]
 800b6a2:	68fa      	ldr	r2, [r7, #12]
 800b6a4:	631a      	str	r2, [r3, #48]	; 0x30
        previous_pool -> tx_byte_pool_created_next =  pool_ptr;
 800b6a6:	69fb      	ldr	r3, [r7, #28]
 800b6a8:	68fa      	ldr	r2, [r7, #12]
 800b6aa:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Setup this byte pool's created links.  */
        pool_ptr -> tx_byte_pool_created_previous =  previous_pool;
 800b6ac:	68fb      	ldr	r3, [r7, #12]
 800b6ae:	69fa      	ldr	r2, [r7, #28]
 800b6b0:	631a      	str	r2, [r3, #48]	; 0x30
        pool_ptr -> tx_byte_pool_created_next =      next_pool;
 800b6b2:	68fb      	ldr	r3, [r7, #12]
 800b6b4:	6a3a      	ldr	r2, [r7, #32]
 800b6b6:	62da      	str	r2, [r3, #44]	; 0x2c
    }

    /* Increment the number of created byte pools.  */
    _tx_byte_pool_created_count++;
 800b6b8:	4b09      	ldr	r3, [pc, #36]	; (800b6e0 <_tx_byte_pool_create+0x124>)
 800b6ba:	681b      	ldr	r3, [r3, #0]
 800b6bc:	3301      	adds	r3, #1
 800b6be:	4a08      	ldr	r2, [pc, #32]	; (800b6e0 <_tx_byte_pool_create+0x124>)
 800b6c0:	6013      	str	r3, [r2, #0]
 800b6c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6c4:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b6c6:	693b      	ldr	r3, [r7, #16]
 800b6c8:	f383 8810 	msr	PRIMASK, r3
}
 800b6cc:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800b6ce:	2300      	movs	r3, #0
}
 800b6d0:	4618      	mov	r0, r3
 800b6d2:	3738      	adds	r7, #56	; 0x38
 800b6d4:	46bd      	mov	sp, r7
 800b6d6:	bd80      	pop	{r7, pc}
 800b6d8:	ffffeeee 	.word	0xffffeeee
 800b6dc:	42595445 	.word	0x42595445
 800b6e0:	20006cf8 	.word	0x20006cf8
 800b6e4:	20006cf4 	.word	0x20006cf4

0800b6e8 <_tx_byte_pool_search>:
/*                                            calculation,                */
/*                                            resulting in version 6.1.7  */
/*                                                                        */
/**************************************************************************/
UCHAR  *_tx_byte_pool_search(TX_BYTE_POOL *pool_ptr, ULONG memory_size)
{
 800b6e8:	b480      	push	{r7}
 800b6ea:	b097      	sub	sp, #92	; 0x5c
 800b6ec:	af00      	add	r7, sp, #0
 800b6ee:	6078      	str	r0, [r7, #4]
 800b6f0:	6039      	str	r1, [r7, #0]
UCHAR           *next_ptr;
UCHAR           **this_block_link_ptr;
UCHAR           **next_block_link_ptr;
ULONG           available_bytes;
UINT            examine_blocks;
UINT            first_free_block_found =  TX_FALSE;
 800b6f2:	2300      	movs	r3, #0
 800b6f4:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b6f6:	f3ef 8310 	mrs	r3, PRIMASK
 800b6fa:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800b6fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800b6fe:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b700:	b672      	cpsid	i
    return(int_posture);
 800b702:	6a3b      	ldr	r3, [r7, #32]
UCHAR           *work_ptr;
ULONG           total_theoretical_available;


    /* Disable interrupts.  */
    TX_DISABLE
 800b704:	657b      	str	r3, [r7, #84]	; 0x54

    /* First, determine if there are enough bytes in the pool.  */
    /* Theoretical bytes available = free bytes + ((fragments-2) * overhead of each block) */
    total_theoretical_available = pool_ptr -> tx_byte_pool_available + ((pool_ptr -> tx_byte_pool_fragments - 2) * ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE))));
 800b706:	687b      	ldr	r3, [r7, #4]
 800b708:	689a      	ldr	r2, [r3, #8]
 800b70a:	687b      	ldr	r3, [r7, #4]
 800b70c:	68db      	ldr	r3, [r3, #12]
 800b70e:	3b02      	subs	r3, #2
 800b710:	00db      	lsls	r3, r3, #3
 800b712:	4413      	add	r3, r2
 800b714:	643b      	str	r3, [r7, #64]	; 0x40
    if (memory_size >= total_theoretical_available)
 800b716:	683a      	ldr	r2, [r7, #0]
 800b718:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800b71a:	429a      	cmp	r2, r3
 800b71c:	d308      	bcc.n	800b730 <_tx_byte_pool_search+0x48>
 800b71e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b720:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b722:	69fb      	ldr	r3, [r7, #28]
 800b724:	f383 8810 	msr	PRIMASK, r3
}
 800b728:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Not enough memory, return a NULL pointer.  */
        current_ptr =  TX_NULL;
 800b72a:	2300      	movs	r3, #0
 800b72c:	653b      	str	r3, [r7, #80]	; 0x50
 800b72e:	e0dd      	b.n	800b8ec <_tx_byte_pool_search+0x204>
    }
    else
    {

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
 800b730:	4b72      	ldr	r3, [pc, #456]	; (800b8fc <_tx_byte_pool_search+0x214>)
 800b732:	681b      	ldr	r3, [r3, #0]
 800b734:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup ownership of the byte pool.  */
        pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 800b736:	687b      	ldr	r3, [r7, #4]
 800b738:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b73a:	621a      	str	r2, [r3, #32]

        /* Walk through the memory pool in search for a large enough block.  */
        current_ptr =      pool_ptr -> tx_byte_pool_search;
 800b73c:	687b      	ldr	r3, [r7, #4]
 800b73e:	695b      	ldr	r3, [r3, #20]
 800b740:	653b      	str	r3, [r7, #80]	; 0x50
        examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
 800b742:	687b      	ldr	r3, [r7, #4]
 800b744:	68db      	ldr	r3, [r3, #12]
 800b746:	3301      	adds	r3, #1
 800b748:	64bb      	str	r3, [r7, #72]	; 0x48
        available_bytes =  ((ULONG) 0);
 800b74a:	2300      	movs	r3, #0
 800b74c:	64fb      	str	r3, [r7, #76]	; 0x4c
            /* Increment the number of fragments searched on this pool.  */
            pool_ptr -> tx_byte_pool_performance_search_count++;
#endif

            /* Check to see if this block is free.  */
            work_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
 800b74e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b750:	3304      	adds	r3, #4
 800b752:	63bb      	str	r3, [r7, #56]	; 0x38
            free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
 800b754:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b756:	637b      	str	r3, [r7, #52]	; 0x34
            if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
 800b758:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b75a:	681b      	ldr	r3, [r3, #0]
 800b75c:	4a68      	ldr	r2, [pc, #416]	; (800b900 <_tx_byte_pool_search+0x218>)
 800b75e:	4293      	cmp	r3, r2
 800b760:	d143      	bne.n	800b7ea <_tx_byte_pool_search+0x102>
            {

                /* Determine if this is the first free block.  */
                if (first_free_block_found == TX_FALSE)
 800b762:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800b764:	2b00      	cmp	r3, #0
 800b766:	d104      	bne.n	800b772 <_tx_byte_pool_search+0x8a>
                {
                    /* This is the first free block.  */
                    pool_ptr->tx_byte_pool_search =  current_ptr;
 800b768:	687b      	ldr	r3, [r7, #4]
 800b76a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800b76c:	615a      	str	r2, [r3, #20]

                    /* Set the flag to indicate we have found the first free
                       block.  */
                    first_free_block_found =  TX_TRUE;
 800b76e:	2301      	movs	r3, #1
 800b770:	647b      	str	r3, [r7, #68]	; 0x44
                }

                /* Block is free, see if it is large enough.  */

                /* Pickup the next block's pointer.  */
                this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 800b772:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b774:	633b      	str	r3, [r7, #48]	; 0x30
                next_ptr =             *this_block_link_ptr;
 800b776:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b778:	681b      	ldr	r3, [r3, #0]
 800b77a:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Calculate the number of bytes available in this block.  */
                available_bytes =   TX_UCHAR_POINTER_DIF(next_ptr, current_ptr);
 800b77c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b77e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b780:	1ad3      	subs	r3, r2, r3
 800b782:	64fb      	str	r3, [r7, #76]	; 0x4c
                available_bytes =   available_bytes - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
 800b784:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b786:	3b08      	subs	r3, #8
 800b788:	64fb      	str	r3, [r7, #76]	; 0x4c

                /* If this is large enough, we are done because our first-fit algorithm
                   has been satisfied!  */
                if (available_bytes >= memory_size)
 800b78a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800b78c:	683b      	ldr	r3, [r7, #0]
 800b78e:	429a      	cmp	r2, r3
 800b790:	d257      	bcs.n	800b842 <_tx_byte_pool_search+0x15a>
                }
                else
                {

                    /* Clear the available bytes variable.  */
                    available_bytes =  ((ULONG) 0);
 800b792:	2300      	movs	r3, #0
 800b794:	64fb      	str	r3, [r7, #76]	; 0x4c

                    /* Not enough memory, check to see if the neighbor is
                       free and can be merged.  */
                    work_ptr =  TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
 800b796:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b798:	3304      	adds	r3, #4
 800b79a:	63bb      	str	r3, [r7, #56]	; 0x38
                    free_ptr =  TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
 800b79c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b79e:	637b      	str	r3, [r7, #52]	; 0x34
                    if ((*free_ptr) == TX_BYTE_BLOCK_FREE)
 800b7a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b7a2:	681b      	ldr	r3, [r3, #0]
 800b7a4:	4a56      	ldr	r2, [pc, #344]	; (800b900 <_tx_byte_pool_search+0x218>)
 800b7a6:	4293      	cmp	r3, r2
 800b7a8:	d113      	bne.n	800b7d2 <_tx_byte_pool_search+0xea>
                    {

                        /* Yes, neighbor block can be merged!  This is quickly accomplished
                           by updating the current block with the next blocks pointer.  */
                        next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
 800b7aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7ac:	62bb      	str	r3, [r7, #40]	; 0x28
                        *this_block_link_ptr =  *next_block_link_ptr;
 800b7ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b7b0:	681a      	ldr	r2, [r3, #0]
 800b7b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b7b4:	601a      	str	r2, [r3, #0]

                        /* Reduce the fragment total.  We don't need to increase the bytes
                           available because all free headers are also included in the available
                           count.  */
                        pool_ptr -> tx_byte_pool_fragments--;
 800b7b6:	687b      	ldr	r3, [r7, #4]
 800b7b8:	68db      	ldr	r3, [r3, #12]
 800b7ba:	1e5a      	subs	r2, r3, #1
 800b7bc:	687b      	ldr	r3, [r7, #4]
 800b7be:	60da      	str	r2, [r3, #12]
                        /* Increment the number of blocks merged on this pool.  */
                        pool_ptr -> tx_byte_pool_performance_merge_count++;
#endif

                        /* See if the search pointer is affected.  */
                        if (pool_ptr -> tx_byte_pool_search ==  next_ptr)
 800b7c0:	687b      	ldr	r3, [r7, #4]
 800b7c2:	695b      	ldr	r3, [r3, #20]
 800b7c4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b7c6:	429a      	cmp	r2, r3
 800b7c8:	d114      	bne.n	800b7f4 <_tx_byte_pool_search+0x10c>
                        {
                            /* Yes, update the search pointer.   */
                            pool_ptr -> tx_byte_pool_search =  current_ptr;
 800b7ca:	687b      	ldr	r3, [r7, #4]
 800b7cc:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800b7ce:	615a      	str	r2, [r3, #20]
 800b7d0:	e010      	b.n	800b7f4 <_tx_byte_pool_search+0x10c>
                        }
                    }
                    else
                    {
                        /* Neighbor is not free so we can skip over it!  */
                        next_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
 800b7d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b7d4:	62bb      	str	r3, [r7, #40]	; 0x28
                        current_ptr =  *next_block_link_ptr;
 800b7d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b7d8:	681b      	ldr	r3, [r3, #0]
 800b7da:	653b      	str	r3, [r7, #80]	; 0x50

                        /* Decrement the examined block count to account for this one.  */
                        if (examine_blocks != ((UINT) 0))
 800b7dc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b7de:	2b00      	cmp	r3, #0
 800b7e0:	d008      	beq.n	800b7f4 <_tx_byte_pool_search+0x10c>
                        {
                            examine_blocks--;
 800b7e2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b7e4:	3b01      	subs	r3, #1
 800b7e6:	64bb      	str	r3, [r7, #72]	; 0x48
 800b7e8:	e004      	b.n	800b7f4 <_tx_byte_pool_search+0x10c>
            }
            else
            {

                /* Block is not free, move to next block.  */
                this_block_link_ptr =  TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 800b7ea:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b7ec:	633b      	str	r3, [r7, #48]	; 0x30
                current_ptr =  *this_block_link_ptr;
 800b7ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b7f0:	681b      	ldr	r3, [r3, #0]
 800b7f2:	653b      	str	r3, [r7, #80]	; 0x50
            }

            /* Another block has been searched... decrement counter.  */
            if (examine_blocks != ((UINT) 0))
 800b7f4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b7f6:	2b00      	cmp	r3, #0
 800b7f8:	d002      	beq.n	800b800 <_tx_byte_pool_search+0x118>
            {

                examine_blocks--;
 800b7fa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b7fc:	3b01      	subs	r3, #1
 800b7fe:	64bb      	str	r3, [r7, #72]	; 0x48
 800b800:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b802:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b804:	693b      	ldr	r3, [r7, #16]
 800b806:	f383 8810 	msr	PRIMASK, r3
}
 800b80a:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b80c:	f3ef 8310 	mrs	r3, PRIMASK
 800b810:	61bb      	str	r3, [r7, #24]
    return(posture);
 800b812:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800b814:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b816:	b672      	cpsid	i
    return(int_posture);
 800b818:	697b      	ldr	r3, [r7, #20]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts.  */
            TX_DISABLE
 800b81a:	657b      	str	r3, [r7, #84]	; 0x54

            /* Determine if anything has changed in terms of pool ownership.  */
            if (pool_ptr -> tx_byte_pool_owner != thread_ptr)
 800b81c:	687b      	ldr	r3, [r7, #4]
 800b81e:	6a1b      	ldr	r3, [r3, #32]
 800b820:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b822:	429a      	cmp	r2, r3
 800b824:	d009      	beq.n	800b83a <_tx_byte_pool_search+0x152>
            {

                /* Pool changed ownership in the brief period interrupts were
                   enabled.  Reset the search.  */
                current_ptr =      pool_ptr -> tx_byte_pool_search;
 800b826:	687b      	ldr	r3, [r7, #4]
 800b828:	695b      	ldr	r3, [r3, #20]
 800b82a:	653b      	str	r3, [r7, #80]	; 0x50
                examine_blocks =   pool_ptr -> tx_byte_pool_fragments + ((UINT) 1);
 800b82c:	687b      	ldr	r3, [r7, #4]
 800b82e:	68db      	ldr	r3, [r3, #12]
 800b830:	3301      	adds	r3, #1
 800b832:	64bb      	str	r3, [r7, #72]	; 0x48

                /* Setup our ownership again.  */
                pool_ptr -> tx_byte_pool_owner =  thread_ptr;
 800b834:	687b      	ldr	r3, [r7, #4]
 800b836:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b838:	621a      	str	r2, [r3, #32]
            }
        } while(examine_blocks != ((UINT) 0));
 800b83a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b83c:	2b00      	cmp	r3, #0
 800b83e:	d186      	bne.n	800b74e <_tx_byte_pool_search+0x66>
 800b840:	e000      	b.n	800b844 <_tx_byte_pool_search+0x15c>
                    break;
 800b842:	bf00      	nop

        /* Determine if a block was found.  If so, determine if it needs to be
           split.  */
        if (available_bytes != ((ULONG) 0))
 800b844:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b846:	2b00      	cmp	r3, #0
 800b848:	d048      	beq.n	800b8dc <_tx_byte_pool_search+0x1f4>
        {

            /* Determine if we need to split this block.  */
            if ((available_bytes - memory_size) >= ((ULONG) TX_BYTE_BLOCK_MIN))
 800b84a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800b84c:	683b      	ldr	r3, [r7, #0]
 800b84e:	1ad3      	subs	r3, r2, r3
 800b850:	2b13      	cmp	r3, #19
 800b852:	d91e      	bls.n	800b892 <_tx_byte_pool_search+0x1aa>
            {

                /* Split the block.  */
                next_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (memory_size + ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
 800b854:	683b      	ldr	r3, [r7, #0]
 800b856:	3308      	adds	r3, #8
 800b858:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800b85a:	4413      	add	r3, r2
 800b85c:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Setup the new free block.  */
                next_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(next_ptr);
 800b85e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b860:	62bb      	str	r3, [r7, #40]	; 0x28
                this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 800b862:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b864:	633b      	str	r3, [r7, #48]	; 0x30
                *next_block_link_ptr =  *this_block_link_ptr;
 800b866:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b868:	681a      	ldr	r2, [r3, #0]
 800b86a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b86c:	601a      	str	r2, [r3, #0]
                work_ptr =              TX_UCHAR_POINTER_ADD(next_ptr, (sizeof(UCHAR *)));
 800b86e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b870:	3304      	adds	r3, #4
 800b872:	63bb      	str	r3, [r7, #56]	; 0x38
                free_ptr =              TX_UCHAR_TO_ALIGN_TYPE_POINTER_CONVERT(work_ptr);
 800b874:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b876:	637b      	str	r3, [r7, #52]	; 0x34
                *free_ptr =             TX_BYTE_BLOCK_FREE;
 800b878:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b87a:	4a21      	ldr	r2, [pc, #132]	; (800b900 <_tx_byte_pool_search+0x218>)
 800b87c:	601a      	str	r2, [r3, #0]

                /* Increase the total fragment counter.  */
                pool_ptr -> tx_byte_pool_fragments++;
 800b87e:	687b      	ldr	r3, [r7, #4]
 800b880:	68db      	ldr	r3, [r3, #12]
 800b882:	1c5a      	adds	r2, r3, #1
 800b884:	687b      	ldr	r3, [r7, #4]
 800b886:	60da      	str	r2, [r3, #12]

                /* Update the current pointer to point at the newly created block.  */
                *this_block_link_ptr =  next_ptr;
 800b888:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b88a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b88c:	601a      	str	r2, [r3, #0]

                /* Set available equal to memory size for subsequent calculation.  */
                available_bytes =  memory_size;
 800b88e:	683b      	ldr	r3, [r7, #0]
 800b890:	64fb      	str	r3, [r7, #76]	; 0x4c
                pool_ptr -> tx_byte_pool_performance_split_count++;
#endif
            }

            /* In any case, mark the current block as allocated.  */
            work_ptr =              TX_UCHAR_POINTER_ADD(current_ptr, (sizeof(UCHAR *)));
 800b892:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b894:	3304      	adds	r3, #4
 800b896:	63bb      	str	r3, [r7, #56]	; 0x38
            this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(work_ptr);
 800b898:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b89a:	633b      	str	r3, [r7, #48]	; 0x30
            *this_block_link_ptr =  TX_BYTE_POOL_TO_UCHAR_POINTER_CONVERT(pool_ptr);
 800b89c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b89e:	687a      	ldr	r2, [r7, #4]
 800b8a0:	601a      	str	r2, [r3, #0]

            /* Reduce the number of available bytes in the pool.  */
            pool_ptr -> tx_byte_pool_available =  (pool_ptr -> tx_byte_pool_available - available_bytes) - ((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)));
 800b8a2:	687b      	ldr	r3, [r7, #4]
 800b8a4:	689a      	ldr	r2, [r3, #8]
 800b8a6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800b8a8:	1ad3      	subs	r3, r2, r3
 800b8aa:	f1a3 0208 	sub.w	r2, r3, #8
 800b8ae:	687b      	ldr	r3, [r7, #4]
 800b8b0:	609a      	str	r2, [r3, #8]

            /* Determine if the search pointer needs to be updated. This is only done
               if the search pointer matches the block to be returned.  */
            if (current_ptr == pool_ptr -> tx_byte_pool_search)
 800b8b2:	687b      	ldr	r3, [r7, #4]
 800b8b4:	695b      	ldr	r3, [r3, #20]
 800b8b6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800b8b8:	429a      	cmp	r2, r3
 800b8ba:	d105      	bne.n	800b8c8 <_tx_byte_pool_search+0x1e0>
            {

                /* Yes, update the search pointer to the next block.  */
                this_block_link_ptr =   TX_UCHAR_TO_INDIRECT_UCHAR_POINTER_CONVERT(current_ptr);
 800b8bc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b8be:	633b      	str	r3, [r7, #48]	; 0x30
                pool_ptr -> tx_byte_pool_search =  *this_block_link_ptr;
 800b8c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b8c2:	681a      	ldr	r2, [r3, #0]
 800b8c4:	687b      	ldr	r3, [r7, #4]
 800b8c6:	615a      	str	r2, [r3, #20]
 800b8c8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b8ca:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b8cc:	68fb      	ldr	r3, [r7, #12]
 800b8ce:	f383 8810 	msr	PRIMASK, r3
}
 800b8d2:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Adjust the pointer for the application.  */
            current_ptr =  TX_UCHAR_POINTER_ADD(current_ptr, (((sizeof(UCHAR *)) + (sizeof(ALIGN_TYPE)))));
 800b8d4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800b8d6:	3308      	adds	r3, #8
 800b8d8:	653b      	str	r3, [r7, #80]	; 0x50
 800b8da:	e007      	b.n	800b8ec <_tx_byte_pool_search+0x204>
 800b8dc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b8de:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b8e0:	68bb      	ldr	r3, [r7, #8]
 800b8e2:	f383 8810 	msr	PRIMASK, r3
}
 800b8e6:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Set current pointer to NULL to indicate nothing was found.  */
            current_ptr =  TX_NULL;
 800b8e8:	2300      	movs	r3, #0
 800b8ea:	653b      	str	r3, [r7, #80]	; 0x50
        }
    }

    /* Return the search pointer.  */
    return(current_ptr);
 800b8ec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 800b8ee:	4618      	mov	r0, r3
 800b8f0:	375c      	adds	r7, #92	; 0x5c
 800b8f2:	46bd      	mov	sp, r7
 800b8f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8f8:	4770      	bx	lr
 800b8fa:	bf00      	nop
 800b8fc:	20006d04 	.word	0x20006d04
 800b900:	ffffeeee 	.word	0xffffeeee

0800b904 <_tx_event_flags_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_event_flags_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
 800b904:	b580      	push	{r7, lr}
 800b906:	b08e      	sub	sp, #56	; 0x38
 800b908:	af00      	add	r7, sp, #0
 800b90a:	6078      	str	r0, [r7, #4]
 800b90c:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b90e:	f3ef 8310 	mrs	r3, PRIMASK
 800b912:	61fb      	str	r3, [r7, #28]
    return(posture);
 800b914:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800b916:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b918:	b672      	cpsid	i
    return(int_posture);
 800b91a:	69bb      	ldr	r3, [r7, #24]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the event flags group.  */
    TX_DISABLE
 800b91c:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_event_flags_cleanup))
 800b91e:	687b      	ldr	r3, [r7, #4]
 800b920:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800b922:	4a38      	ldr	r2, [pc, #224]	; (800ba04 <_tx_event_flags_cleanup+0x100>)
 800b924:	4293      	cmp	r3, r2
 800b926:	d162      	bne.n	800b9ee <_tx_event_flags_cleanup+0xea>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 800b928:	687b      	ldr	r3, [r7, #4]
 800b92a:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800b92e:	683a      	ldr	r2, [r7, #0]
 800b930:	429a      	cmp	r2, r3
 800b932:	d15c      	bne.n	800b9ee <_tx_event_flags_cleanup+0xea>
        {

            /* Setup pointer to event flags control block.  */
            group_ptr =  TX_VOID_TO_EVENT_FLAGS_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 800b934:	687b      	ldr	r3, [r7, #4]
 800b936:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800b938:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for a NULL event flags control block pointer.  */
            if (group_ptr != TX_NULL)
 800b93a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b93c:	2b00      	cmp	r3, #0
 800b93e:	d056      	beq.n	800b9ee <_tx_event_flags_cleanup+0xea>
            {

                /* Is the group pointer ID valid?  */
                if (group_ptr -> tx_event_flags_group_id == TX_EVENT_FLAGS_ID)
 800b940:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b942:	681b      	ldr	r3, [r3, #0]
 800b944:	4a30      	ldr	r2, [pc, #192]	; (800ba08 <_tx_event_flags_cleanup+0x104>)
 800b946:	4293      	cmp	r3, r2
 800b948:	d151      	bne.n	800b9ee <_tx_event_flags_cleanup+0xea>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 800b94a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b94c:	695b      	ldr	r3, [r3, #20]
 800b94e:	2b00      	cmp	r3, #0
 800b950:	d04d      	beq.n	800b9ee <_tx_event_flags_cleanup+0xea>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800b952:	687b      	ldr	r3, [r7, #4]
 800b954:	2200      	movs	r2, #0
 800b956:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Pickup the suspended count.  */
                        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 800b958:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b95a:	695b      	ldr	r3, [r3, #20]
 800b95c:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Pickup the suspension head.  */
                        suspension_head =  group_ptr -> tx_event_flags_group_suspension_list;
 800b95e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b960:	691b      	ldr	r3, [r3, #16]
 800b962:	62bb      	str	r3, [r7, #40]	; 0x28

                        /* Determine if the cleanup is being done while a set operation was interrupted.  If the
                           suspended count is non-zero and the suspension head is NULL, the list is being processed
                           and cannot be touched from here. The suspension list removal will instead take place
                           inside the event flag set code.  */
                        if (suspension_head != TX_NULL)
 800b964:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b966:	2b00      	cmp	r3, #0
 800b968:	d020      	beq.n	800b9ac <_tx_event_flags_cleanup+0xa8>
                        {

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the local suspension count.  */
                            suspended_count--;
 800b96a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b96c:	3b01      	subs	r3, #1
 800b96e:	62fb      	str	r3, [r7, #44]	; 0x2c

                            /* Store the updated suspended count.  */
                            group_ptr -> tx_event_flags_group_suspended_count =  suspended_count;
 800b970:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b972:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800b974:	615a      	str	r2, [r3, #20]

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
 800b976:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b978:	2b00      	cmp	r3, #0
 800b97a:	d103      	bne.n	800b984 <_tx_event_flags_cleanup+0x80>
                            {

                                /* Yes, the only suspended thread.  */

                                /* Update the head pointer.  */
                                group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 800b97c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b97e:	2200      	movs	r2, #0
 800b980:	611a      	str	r2, [r3, #16]
 800b982:	e016      	b.n	800b9b2 <_tx_event_flags_cleanup+0xae>
                            {

                                /* At least one more thread is on the same suspension list.  */

                                /* Update the links of the adjacent threads.  */
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
 800b984:	687b      	ldr	r3, [r7, #4]
 800b986:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800b988:	627b      	str	r3, [r7, #36]	; 0x24
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 800b98a:	687b      	ldr	r3, [r7, #4]
 800b98c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b98e:	623b      	str	r3, [r7, #32]
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
 800b990:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b992:	6a3a      	ldr	r2, [r7, #32]
 800b994:	675a      	str	r2, [r3, #116]	; 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
 800b996:	6a3b      	ldr	r3, [r7, #32]
 800b998:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b99a:	671a      	str	r2, [r3, #112]	; 0x70

                                /* Determine if we need to update the head pointer.  */
                                if (suspension_head == thread_ptr)
 800b99c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b99e:	687b      	ldr	r3, [r7, #4]
 800b9a0:	429a      	cmp	r2, r3
 800b9a2:	d106      	bne.n	800b9b2 <_tx_event_flags_cleanup+0xae>
                                {

                                    /* Update the list head pointer.  */
                                    group_ptr -> tx_event_flags_group_suspension_list =  next_thread;
 800b9a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b9a6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b9a8:	611a      	str	r2, [r3, #16]
 800b9aa:	e002      	b.n	800b9b2 <_tx_event_flags_cleanup+0xae>
                        }
                        else
                        {

                            /* In this case, the search pointer in an interrupted event flag set must be reset.  */
                            group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
 800b9ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b9ae:	2201      	movs	r2, #1
 800b9b0:	60da      	str	r2, [r3, #12]
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_EVENT_FLAG)
 800b9b2:	687b      	ldr	r3, [r7, #4]
 800b9b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b9b6:	2b07      	cmp	r3, #7
 800b9b8:	d119      	bne.n	800b9ee <_tx_event_flags_cleanup+0xea>
                            /* Increment the number of timeouts on this event flags group.  */
                            group_ptr -> tx_event_flags_group____performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_EVENTS;
 800b9ba:	687b      	ldr	r3, [r7, #4]
 800b9bc:	2207      	movs	r2, #7
 800b9be:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                           /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 800b9c2:	4b12      	ldr	r3, [pc, #72]	; (800ba0c <_tx_event_flags_cleanup+0x108>)
 800b9c4:	681b      	ldr	r3, [r3, #0]
 800b9c6:	3301      	adds	r3, #1
 800b9c8:	4a10      	ldr	r2, [pc, #64]	; (800ba0c <_tx_event_flags_cleanup+0x108>)
 800b9ca:	6013      	str	r3, [r2, #0]
 800b9cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b9ce:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b9d0:	68fb      	ldr	r3, [r7, #12]
 800b9d2:	f383 8810 	msr	PRIMASK, r3
}
 800b9d6:	bf00      	nop
                            TX_RESTORE

                            /* Resume the thread!  Check for preemption even though we are executing
                               from the system timer thread right now which normally executes at the
                               highest priority.  */
                            _tx_thread_system_resume(thread_ptr);
 800b9d8:	6878      	ldr	r0, [r7, #4]
 800b9da:	f002 f9ef 	bl	800ddbc <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800b9de:	f3ef 8310 	mrs	r3, PRIMASK
 800b9e2:	617b      	str	r3, [r7, #20]
    return(posture);
 800b9e4:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800b9e6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800b9e8:	b672      	cpsid	i
    return(int_posture);
 800b9ea:	693b      	ldr	r3, [r7, #16]

                            /* Disable interrupts.  */
                            TX_DISABLE
 800b9ec:	637b      	str	r3, [r7, #52]	; 0x34
 800b9ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b9f0:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800b9f2:	68bb      	ldr	r3, [r7, #8]
 800b9f4:	f383 8810 	msr	PRIMASK, r3
}
 800b9f8:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 800b9fa:	bf00      	nop
 800b9fc:	3738      	adds	r7, #56	; 0x38
 800b9fe:	46bd      	mov	sp, r7
 800ba00:	bd80      	pop	{r7, pc}
 800ba02:	bf00      	nop
 800ba04:	0800b905 	.word	0x0800b905
 800ba08:	4456444e 	.word	0x4456444e
 800ba0c:	20006d9c 	.word	0x20006d9c

0800ba10 <_tx_event_flags_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_create(TX_EVENT_FLAGS_GROUP *group_ptr, CHAR *name_ptr)
{
 800ba10:	b580      	push	{r7, lr}
 800ba12:	b088      	sub	sp, #32
 800ba14:	af00      	add	r7, sp, #0
 800ba16:	6078      	str	r0, [r7, #4]
 800ba18:	6039      	str	r1, [r7, #0]
TX_EVENT_FLAGS_GROUP    *next_group;
TX_EVENT_FLAGS_GROUP    *previous_group;


    /* Initialize event flags control block to all zeros.  */
    TX_MEMSET(group_ptr, 0, (sizeof(TX_EVENT_FLAGS_GROUP)));
 800ba1a:	2224      	movs	r2, #36	; 0x24
 800ba1c:	2100      	movs	r1, #0
 800ba1e:	6878      	ldr	r0, [r7, #4]
 800ba20:	f007 fc22 	bl	8013268 <memset>

    /* Setup the basic event flags group fields.  */
    group_ptr -> tx_event_flags_group_name =             name_ptr;
 800ba24:	687b      	ldr	r3, [r7, #4]
 800ba26:	683a      	ldr	r2, [r7, #0]
 800ba28:	605a      	str	r2, [r3, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ba2a:	f3ef 8310 	mrs	r3, PRIMASK
 800ba2e:	613b      	str	r3, [r7, #16]
    return(posture);
 800ba30:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800ba32:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800ba34:	b672      	cpsid	i
    return(int_posture);
 800ba36:	68fb      	ldr	r3, [r7, #12]

    /* Disable interrupts to put the event flags group on the created list.  */
    TX_DISABLE
 800ba38:	61fb      	str	r3, [r7, #28]

    /* Setup the event flags ID to make it valid.  */
    group_ptr -> tx_event_flags_group_id =  TX_EVENT_FLAGS_ID;
 800ba3a:	687b      	ldr	r3, [r7, #4]
 800ba3c:	4a18      	ldr	r2, [pc, #96]	; (800baa0 <_tx_event_flags_create+0x90>)
 800ba3e:	601a      	str	r2, [r3, #0]

    /* Place the group on the list of created event flag groups.  First,
       check for an empty list.  */
    if (_tx_event_flags_created_count == TX_EMPTY)
 800ba40:	4b18      	ldr	r3, [pc, #96]	; (800baa4 <_tx_event_flags_create+0x94>)
 800ba42:	681b      	ldr	r3, [r3, #0]
 800ba44:	2b00      	cmp	r3, #0
 800ba46:	d109      	bne.n	800ba5c <_tx_event_flags_create+0x4c>
    {

        /* The created event flags list is empty.  Add event flag group to empty list.  */
        _tx_event_flags_created_ptr =                         group_ptr;
 800ba48:	4a17      	ldr	r2, [pc, #92]	; (800baa8 <_tx_event_flags_create+0x98>)
 800ba4a:	687b      	ldr	r3, [r7, #4]
 800ba4c:	6013      	str	r3, [r2, #0]
        group_ptr -> tx_event_flags_group_created_next =      group_ptr;
 800ba4e:	687b      	ldr	r3, [r7, #4]
 800ba50:	687a      	ldr	r2, [r7, #4]
 800ba52:	619a      	str	r2, [r3, #24]
        group_ptr -> tx_event_flags_group_created_previous =  group_ptr;
 800ba54:	687b      	ldr	r3, [r7, #4]
 800ba56:	687a      	ldr	r2, [r7, #4]
 800ba58:	61da      	str	r2, [r3, #28]
 800ba5a:	e011      	b.n	800ba80 <_tx_event_flags_create+0x70>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_group =      _tx_event_flags_created_ptr;
 800ba5c:	4b12      	ldr	r3, [pc, #72]	; (800baa8 <_tx_event_flags_create+0x98>)
 800ba5e:	681b      	ldr	r3, [r3, #0]
 800ba60:	61bb      	str	r3, [r7, #24]
        previous_group =  next_group -> tx_event_flags_group_created_previous;
 800ba62:	69bb      	ldr	r3, [r7, #24]
 800ba64:	69db      	ldr	r3, [r3, #28]
 800ba66:	617b      	str	r3, [r7, #20]

        /* Place the new event flag group in the list.  */
        next_group -> tx_event_flags_group_created_previous =  group_ptr;
 800ba68:	69bb      	ldr	r3, [r7, #24]
 800ba6a:	687a      	ldr	r2, [r7, #4]
 800ba6c:	61da      	str	r2, [r3, #28]
        previous_group -> tx_event_flags_group_created_next =  group_ptr;
 800ba6e:	697b      	ldr	r3, [r7, #20]
 800ba70:	687a      	ldr	r2, [r7, #4]
 800ba72:	619a      	str	r2, [r3, #24]

        /* Setup this group's created links.  */
        group_ptr -> tx_event_flags_group_created_previous =  previous_group;
 800ba74:	687b      	ldr	r3, [r7, #4]
 800ba76:	697a      	ldr	r2, [r7, #20]
 800ba78:	61da      	str	r2, [r3, #28]
        group_ptr -> tx_event_flags_group_created_next =      next_group;
 800ba7a:	687b      	ldr	r3, [r7, #4]
 800ba7c:	69ba      	ldr	r2, [r7, #24]
 800ba7e:	619a      	str	r2, [r3, #24]
    }

    /* Increment the number of created event flag groups.  */
    _tx_event_flags_created_count++;
 800ba80:	4b08      	ldr	r3, [pc, #32]	; (800baa4 <_tx_event_flags_create+0x94>)
 800ba82:	681b      	ldr	r3, [r3, #0]
 800ba84:	3301      	adds	r3, #1
 800ba86:	4a07      	ldr	r2, [pc, #28]	; (800baa4 <_tx_event_flags_create+0x94>)
 800ba88:	6013      	str	r3, [r2, #0]
 800ba8a:	69fb      	ldr	r3, [r7, #28]
 800ba8c:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ba8e:	68bb      	ldr	r3, [r7, #8]
 800ba90:	f383 8810 	msr	PRIMASK, r3
}
 800ba94:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800ba96:	2300      	movs	r3, #0
}
 800ba98:	4618      	mov	r0, r3
 800ba9a:	3720      	adds	r7, #32
 800ba9c:	46bd      	mov	sp, r7
 800ba9e:	bd80      	pop	{r7, pc}
 800baa0:	4456444e 	.word	0x4456444e
 800baa4:	20006ce8 	.word	0x20006ce8
 800baa8:	20006ce4 	.word	0x20006ce4

0800baac <_tx_event_flags_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_delete(TX_EVENT_FLAGS_GROUP *group_ptr)
{
 800baac:	b580      	push	{r7, lr}
 800baae:	b092      	sub	sp, #72	; 0x48
 800bab0:	af00      	add	r7, sp, #0
 800bab2:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bab4:	f3ef 8310 	mrs	r3, PRIMASK
 800bab8:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800baba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800babc:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800babe:	b672      	cpsid	i
    return(int_posture);
 800bac0:	6abb      	ldr	r3, [r7, #40]	; 0x28
TX_EVENT_FLAGS_GROUP    *next_group;
TX_EVENT_FLAGS_GROUP    *previous_group;


    /* Disable interrupts to remove the group from the created list.  */
    TX_DISABLE
 800bac2:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_DELETE_INSERT

    /* Clear the event flag group ID to make it invalid.  */
    group_ptr -> tx_event_flags_group_id =  TX_CLEAR_ID;
 800bac4:	687b      	ldr	r3, [r7, #4]
 800bac6:	2200      	movs	r2, #0
 800bac8:	601a      	str	r2, [r3, #0]

    /* Decrement the number of created event flag groups.  */
    _tx_event_flags_created_count--;
 800baca:	4b3d      	ldr	r3, [pc, #244]	; (800bbc0 <_tx_event_flags_delete+0x114>)
 800bacc:	681b      	ldr	r3, [r3, #0]
 800bace:	3b01      	subs	r3, #1
 800bad0:	4a3b      	ldr	r2, [pc, #236]	; (800bbc0 <_tx_event_flags_delete+0x114>)
 800bad2:	6013      	str	r3, [r2, #0]

    /* See if this group is the only one on the list.  */
    if (_tx_event_flags_created_count == TX_EMPTY)
 800bad4:	4b3a      	ldr	r3, [pc, #232]	; (800bbc0 <_tx_event_flags_delete+0x114>)
 800bad6:	681b      	ldr	r3, [r3, #0]
 800bad8:	2b00      	cmp	r3, #0
 800bada:	d103      	bne.n	800bae4 <_tx_event_flags_delete+0x38>
    {

        /* Only created event flag group, just set the created list to NULL.  */
        _tx_event_flags_created_ptr =  TX_NULL;
 800badc:	4b39      	ldr	r3, [pc, #228]	; (800bbc4 <_tx_event_flags_delete+0x118>)
 800bade:	2200      	movs	r2, #0
 800bae0:	601a      	str	r2, [r3, #0]
 800bae2:	e013      	b.n	800bb0c <_tx_event_flags_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_group =                                           group_ptr -> tx_event_flags_group_created_next;
 800bae4:	687b      	ldr	r3, [r7, #4]
 800bae6:	699b      	ldr	r3, [r3, #24]
 800bae8:	63bb      	str	r3, [r7, #56]	; 0x38
        previous_group =                                       group_ptr -> tx_event_flags_group_created_previous;
 800baea:	687b      	ldr	r3, [r7, #4]
 800baec:	69db      	ldr	r3, [r3, #28]
 800baee:	637b      	str	r3, [r7, #52]	; 0x34
        next_group -> tx_event_flags_group_created_previous =  previous_group;
 800baf0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800baf2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800baf4:	61da      	str	r2, [r3, #28]
        previous_group -> tx_event_flags_group_created_next =  next_group;
 800baf6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800baf8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800bafa:	619a      	str	r2, [r3, #24]

        /* See if we have to update the created list head pointer.  */
        if (_tx_event_flags_created_ptr == group_ptr)
 800bafc:	4b31      	ldr	r3, [pc, #196]	; (800bbc4 <_tx_event_flags_delete+0x118>)
 800bafe:	681b      	ldr	r3, [r3, #0]
 800bb00:	687a      	ldr	r2, [r7, #4]
 800bb02:	429a      	cmp	r2, r3
 800bb04:	d102      	bne.n	800bb0c <_tx_event_flags_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_event_flags_created_ptr =  next_group;
 800bb06:	4a2f      	ldr	r2, [pc, #188]	; (800bbc4 <_tx_event_flags_delete+0x118>)
 800bb08:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bb0a:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800bb0c:	4b2e      	ldr	r3, [pc, #184]	; (800bbc8 <_tx_event_flags_delete+0x11c>)
 800bb0e:	681b      	ldr	r3, [r3, #0]
 800bb10:	3301      	adds	r3, #1
 800bb12:	4a2d      	ldr	r2, [pc, #180]	; (800bbc8 <_tx_event_flags_delete+0x11c>)
 800bb14:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                                         group_ptr -> tx_event_flags_group_suspension_list;
 800bb16:	687b      	ldr	r3, [r7, #4]
 800bb18:	691b      	ldr	r3, [r3, #16]
 800bb1a:	647b      	str	r3, [r7, #68]	; 0x44
    group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 800bb1c:	687b      	ldr	r3, [r7, #4]
 800bb1e:	2200      	movs	r2, #0
 800bb20:	611a      	str	r2, [r3, #16]
    suspended_count =                                    group_ptr -> tx_event_flags_group_suspended_count;
 800bb22:	687b      	ldr	r3, [r7, #4]
 800bb24:	695b      	ldr	r3, [r3, #20]
 800bb26:	643b      	str	r3, [r7, #64]	; 0x40
    group_ptr -> tx_event_flags_group_suspended_count =  TX_NO_SUSPENSIONS;
 800bb28:	687b      	ldr	r3, [r7, #4]
 800bb2a:	2200      	movs	r2, #0
 800bb2c:	615a      	str	r2, [r3, #20]
 800bb2e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800bb30:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bb32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bb34:	f383 8810 	msr	PRIMASK, r3
}
 800bb38:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the event flag suspension list to resume any and all threads
       suspended on this group.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
 800bb3a:	e024      	b.n	800bb86 <_tx_event_flags_delete+0xda>
    {

        /* Decrement the number of suspended threads.  */
        suspended_count--;
 800bb3c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bb3e:	3b01      	subs	r3, #1
 800bb40:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bb42:	f3ef 8310 	mrs	r3, PRIMASK
 800bb46:	61fb      	str	r3, [r7, #28]
    return(posture);
 800bb48:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800bb4a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800bb4c:	b672      	cpsid	i
    return(int_posture);
 800bb4e:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 800bb50:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800bb52:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800bb54:	2200      	movs	r2, #0
 800bb56:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 800bb58:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800bb5a:	2201      	movs	r2, #1
 800bb5c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 800bb60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800bb62:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800bb64:	633b      	str	r3, [r7, #48]	; 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 800bb66:	4b18      	ldr	r3, [pc, #96]	; (800bbc8 <_tx_event_flags_delete+0x11c>)
 800bb68:	681b      	ldr	r3, [r3, #0]
 800bb6a:	3301      	adds	r3, #1
 800bb6c:	4a16      	ldr	r2, [pc, #88]	; (800bbc8 <_tx_event_flags_delete+0x11c>)
 800bb6e:	6013      	str	r3, [r2, #0]
 800bb70:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800bb72:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bb74:	6a3b      	ldr	r3, [r7, #32]
 800bb76:	f383 8810 	msr	PRIMASK, r3
}
 800bb7a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 800bb7c:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800bb7e:	f002 f91d 	bl	800ddbc <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 800bb82:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bb84:	647b      	str	r3, [r7, #68]	; 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
 800bb86:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bb88:	2b00      	cmp	r3, #0
 800bb8a:	d1d7      	bne.n	800bb3c <_tx_event_flags_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bb8c:	f3ef 8310 	mrs	r3, PRIMASK
 800bb90:	613b      	str	r3, [r7, #16]
    return(posture);
 800bb92:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800bb94:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800bb96:	b672      	cpsid	i
    return(int_posture);
 800bb98:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_EVENT_FLAGS_GROUP_DELETE_PORT_COMPLETION(group_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 800bb9a:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 800bb9c:	4b0a      	ldr	r3, [pc, #40]	; (800bbc8 <_tx_event_flags_delete+0x11c>)
 800bb9e:	681b      	ldr	r3, [r3, #0]
 800bba0:	3b01      	subs	r3, #1
 800bba2:	4a09      	ldr	r2, [pc, #36]	; (800bbc8 <_tx_event_flags_delete+0x11c>)
 800bba4:	6013      	str	r3, [r2, #0]
 800bba6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800bba8:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bbaa:	697b      	ldr	r3, [r7, #20]
 800bbac:	f383 8810 	msr	PRIMASK, r3
}
 800bbb0:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800bbb2:	f002 f8c9 	bl	800dd48 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800bbb6:	2300      	movs	r3, #0
}
 800bbb8:	4618      	mov	r0, r3
 800bbba:	3748      	adds	r7, #72	; 0x48
 800bbbc:	46bd      	mov	sp, r7
 800bbbe:	bd80      	pop	{r7, pc}
 800bbc0:	20006ce8 	.word	0x20006ce8
 800bbc4:	20006ce4 	.word	0x20006ce4
 800bbc8:	20006d9c 	.word	0x20006d9c

0800bbcc <_tx_event_flags_get>:
/*                                            resulting in version 6.2.0  */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_get(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG requested_flags,
                    UINT get_option, ULONG *actual_flags_ptr, ULONG wait_option)
{
 800bbcc:	b580      	push	{r7, lr}
 800bbce:	b096      	sub	sp, #88	; 0x58
 800bbd0:	af00      	add	r7, sp, #0
 800bbd2:	60f8      	str	r0, [r7, #12]
 800bbd4:	60b9      	str	r1, [r7, #8]
 800bbd6:	607a      	str	r2, [r7, #4]
 800bbd8:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bbda:	f3ef 8310 	mrs	r3, PRIMASK
 800bbde:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800bbe0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800bbe2:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800bbe4:	b672      	cpsid	i
    return(int_posture);
 800bbe6:	6a3b      	ldr	r3, [r7, #32]
UINT            interrupted_set_request;
#endif


    /* Disable interrupts to examine the event flags group.  */
    TX_DISABLE
 800bbe8:	657b      	str	r3, [r7, #84]	; 0x54

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_GET_INSERT

    /* Pickup current flags.  */
    current_flags =  group_ptr -> tx_event_flags_group_current;
 800bbea:	68fb      	ldr	r3, [r7, #12]
 800bbec:	689b      	ldr	r3, [r3, #8]
 800bbee:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Return the actual event flags and apply delayed clearing.  */
    *actual_flags_ptr =  current_flags & ~group_ptr -> tx_event_flags_group_delayed_clear;
 800bbf0:	68fb      	ldr	r3, [r7, #12]
 800bbf2:	6a1b      	ldr	r3, [r3, #32]
 800bbf4:	43da      	mvns	r2, r3
 800bbf6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800bbf8:	401a      	ands	r2, r3
 800bbfa:	683b      	ldr	r3, [r7, #0]
 800bbfc:	601a      	str	r2, [r3, #0]

    /* Apply the event flag option mask.  */
    and_request =  (get_option & TX_AND);
 800bbfe:	687b      	ldr	r3, [r7, #4]
 800bc00:	f003 0302 	and.w	r3, r3, #2
 800bc04:	643b      	str	r3, [r7, #64]	; 0x40
    }

#else

    /* Pickup delayed clear flags.  */
    delayed_clear_flags =  group_ptr -> tx_event_flags_group_delayed_clear;
 800bc06:	68fb      	ldr	r3, [r7, #12]
 800bc08:	6a1b      	ldr	r3, [r3, #32]
 800bc0a:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Determine if there are any delayed clear operations pending.  */
    if (delayed_clear_flags != ((ULONG) 0))
 800bc0c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800bc0e:	2b00      	cmp	r3, #0
 800bc10:	d004      	beq.n	800bc1c <_tx_event_flags_get+0x50>
    {

        /* Yes, apply them to the current flags.  */
        current_flags =  current_flags & (~delayed_clear_flags);
 800bc12:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800bc14:	43db      	mvns	r3, r3
 800bc16:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800bc18:	4013      	ands	r3, r2
 800bc1a:	64fb      	str	r3, [r7, #76]	; 0x4c
    }

    /* Check for AND condition. All flags must be present to satisfy request.  */
    if (and_request == TX_AND)
 800bc1c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800bc1e:	2b02      	cmp	r3, #2
 800bc20:	d10a      	bne.n	800bc38 <_tx_event_flags_get+0x6c>
    {

        /* AND request is present.  */

        /* Calculate the flags present.  */
        flags_satisfied =  (current_flags & requested_flags);
 800bc22:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800bc24:	68bb      	ldr	r3, [r7, #8]
 800bc26:	4013      	ands	r3, r2
 800bc28:	64bb      	str	r3, [r7, #72]	; 0x48

        /* Determine if they satisfy the AND request.  */
        if (flags_satisfied != requested_flags)
 800bc2a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800bc2c:	68bb      	ldr	r3, [r7, #8]
 800bc2e:	429a      	cmp	r2, r3
 800bc30:	d006      	beq.n	800bc40 <_tx_event_flags_get+0x74>
        {

            /* No, not all the requested flags are present. Clear the flags present variable.  */
            flags_satisfied =  ((ULONG) 0);
 800bc32:	2300      	movs	r3, #0
 800bc34:	64bb      	str	r3, [r7, #72]	; 0x48
 800bc36:	e003      	b.n	800bc40 <_tx_event_flags_get+0x74>
    else
    {

        /* OR request is present. Simply AND together the requested flags and the current flags
           to see if any are present.  */
        flags_satisfied =  (current_flags & requested_flags);
 800bc38:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800bc3a:	68bb      	ldr	r3, [r7, #8]
 800bc3c:	4013      	ands	r3, r2
 800bc3e:	64bb      	str	r3, [r7, #72]	; 0x48
    }

    /* Determine if the request is satisfied.  */
    if (flags_satisfied != ((ULONG) 0))
 800bc40:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800bc42:	2b00      	cmp	r3, #0
 800bc44:	d026      	beq.n	800bc94 <_tx_event_flags_get+0xc8>
    {

        /* Yes, this request can be handled immediately.  */

        /* Pickup the clear bit.  */
        clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
 800bc46:	687b      	ldr	r3, [r7, #4]
 800bc48:	f003 0301 	and.w	r3, r3, #1
 800bc4c:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Determine whether or not clearing needs to take place.  */
        if (clear_request == TX_TRUE)
 800bc4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bc50:	2b01      	cmp	r3, #1
 800bc52:	d11c      	bne.n	800bc8e <_tx_event_flags_get+0xc2>
        {

            /* Set interrupted set request flag to false.  */
            interrupted_set_request =  TX_FALSE;
 800bc54:	2300      	movs	r3, #0
 800bc56:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if the suspension list is being processed by an interrupted
               set request.  */
            if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 800bc58:	68fb      	ldr	r3, [r7, #12]
 800bc5a:	695b      	ldr	r3, [r3, #20]
 800bc5c:	2b00      	cmp	r3, #0
 800bc5e:	d005      	beq.n	800bc6c <_tx_event_flags_get+0xa0>
            {

                if (group_ptr -> tx_event_flags_group_suspension_list == TX_NULL)
 800bc60:	68fb      	ldr	r3, [r7, #12]
 800bc62:	691b      	ldr	r3, [r3, #16]
 800bc64:	2b00      	cmp	r3, #0
 800bc66:	d101      	bne.n	800bc6c <_tx_event_flags_get+0xa0>
                {

                    /* Set the interrupted set request flag.  */
                    interrupted_set_request =  TX_TRUE;
 800bc68:	2301      	movs	r3, #1
 800bc6a:	647b      	str	r3, [r7, #68]	; 0x44
                }
            }

            /* Was a set request interrupted?  */
            if (interrupted_set_request == TX_TRUE)
 800bc6c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800bc6e:	2b01      	cmp	r3, #1
 800bc70:	d106      	bne.n	800bc80 <_tx_event_flags_get+0xb4>
                /* A previous set operation is was interrupted, we need to defer the
                   event clearing until the set operation is complete.  */

                /* Remember the events to clear.  */
                group_ptr -> tx_event_flags_group_delayed_clear =
                                        group_ptr -> tx_event_flags_group_delayed_clear | requested_flags;
 800bc72:	68fb      	ldr	r3, [r7, #12]
 800bc74:	6a1a      	ldr	r2, [r3, #32]
 800bc76:	68bb      	ldr	r3, [r7, #8]
 800bc78:	431a      	orrs	r2, r3
                group_ptr -> tx_event_flags_group_delayed_clear =
 800bc7a:	68fb      	ldr	r3, [r7, #12]
 800bc7c:	621a      	str	r2, [r3, #32]
 800bc7e:	e006      	b.n	800bc8e <_tx_event_flags_get+0xc2>
            else
            {

                /* Yes, clear the flags that satisfied this request.  */
                group_ptr -> tx_event_flags_group_current =
                                        group_ptr -> tx_event_flags_group_current & ~requested_flags;
 800bc80:	68fb      	ldr	r3, [r7, #12]
 800bc82:	689a      	ldr	r2, [r3, #8]
 800bc84:	68bb      	ldr	r3, [r7, #8]
 800bc86:	43db      	mvns	r3, r3
 800bc88:	401a      	ands	r2, r3
                group_ptr -> tx_event_flags_group_current =
 800bc8a:	68fb      	ldr	r3, [r7, #12]
 800bc8c:	609a      	str	r2, [r3, #8]
            }
        }

        /* Set status to success.  */
        status =  TX_SUCCESS;
 800bc8e:	2300      	movs	r3, #0
 800bc90:	653b      	str	r3, [r7, #80]	; 0x50
 800bc92:	e073      	b.n	800bd7c <_tx_event_flags_get+0x1b0>
#endif
    else
    {
        /* flags_satisfied is 0.  */
        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
 800bc94:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800bc96:	2b00      	cmp	r3, #0
 800bc98:	d06e      	beq.n	800bd78 <_tx_event_flags_get+0x1ac>
        {

            /* Determine if the preempt disable flag is non-zero OR the requested events is 0.  */
            if ((_tx_thread_preempt_disable != ((UINT) 0)) || (requested_flags == (UINT) 0))
 800bc9a:	4b3e      	ldr	r3, [pc, #248]	; (800bd94 <_tx_event_flags_get+0x1c8>)
 800bc9c:	681b      	ldr	r3, [r3, #0]
 800bc9e:	2b00      	cmp	r3, #0
 800bca0:	d102      	bne.n	800bca8 <_tx_event_flags_get+0xdc>
 800bca2:	68bb      	ldr	r3, [r7, #8]
 800bca4:	2b00      	cmp	r3, #0
 800bca6:	d102      	bne.n	800bcae <_tx_event_flags_get+0xe2>
            {

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point,
                   or if requested_flags is 0, return error completion.  */
                status =  TX_NO_EVENTS;
 800bca8:	2307      	movs	r3, #7
 800bcaa:	653b      	str	r3, [r7, #80]	; 0x50
 800bcac:	e066      	b.n	800bd7c <_tx_event_flags_get+0x1b0>
                /* Increment the number of event flags suspensions on this semaphore.  */
                group_ptr -> tx_event_flags_group___performance_suspension_count++;
#endif

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(thread_ptr)
 800bcae:	4b3a      	ldr	r3, [pc, #232]	; (800bd98 <_tx_event_flags_get+0x1cc>)
 800bcb0:	681b      	ldr	r3, [r3, #0]
 800bcb2:	63bb      	str	r3, [r7, #56]	; 0x38

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_event_flags_cleanup);
 800bcb4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bcb6:	4a39      	ldr	r2, [pc, #228]	; (800bd9c <_tx_event_flags_get+0x1d0>)
 800bcb8:	669a      	str	r2, [r3, #104]	; 0x68

                /* Remember which event flags we are looking for.  */
                thread_ptr -> tx_thread_suspend_info =  requested_flags;
 800bcba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bcbc:	68ba      	ldr	r2, [r7, #8]
 800bcbe:	679a      	str	r2, [r3, #120]	; 0x78

                /* Save the get option as well.  */
                thread_ptr -> tx_thread_suspend_option =  get_option;
 800bcc0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bcc2:	687a      	ldr	r2, [r7, #4]
 800bcc4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

                /* Save the destination for the current events.  */
                thread_ptr -> tx_thread_additional_suspend_info =  (VOID *) actual_flags_ptr;
 800bcc8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bcca:	683a      	ldr	r2, [r7, #0]
 800bccc:	67da      	str	r2, [r3, #124]	; 0x7c

                /* Setup cleanup information, i.e. this event flags group control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) group_ptr;
 800bcce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bcd0:	68fa      	ldr	r2, [r7, #12]
 800bcd2:	66da      	str	r2, [r3, #108]	; 0x6c

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
 800bcd4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bcd6:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800bcda:	1c5a      	adds	r2, r3, #1
 800bcdc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bcde:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#endif

                /* Pickup the suspended count.  */
                suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 800bce2:	68fb      	ldr	r3, [r7, #12]
 800bce4:	695b      	ldr	r3, [r3, #20]
 800bce6:	637b      	str	r3, [r7, #52]	; 0x34

                /* Setup suspension list.  */
                if (suspended_count == TX_NO_SUSPENSIONS)
 800bce8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bcea:	2b00      	cmp	r3, #0
 800bcec:	d109      	bne.n	800bd02 <_tx_event_flags_get+0x136>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    group_ptr -> tx_event_flags_group_suspension_list =   thread_ptr;
 800bcee:	68fb      	ldr	r3, [r7, #12]
 800bcf0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800bcf2:	611a      	str	r2, [r3, #16]
                    thread_ptr -> tx_thread_suspended_next =              thread_ptr;
 800bcf4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bcf6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800bcf8:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =          thread_ptr;
 800bcfa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bcfc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800bcfe:	675a      	str	r2, [r3, #116]	; 0x74
 800bd00:	e011      	b.n	800bd26 <_tx_event_flags_get+0x15a>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   group_ptr -> tx_event_flags_group_suspension_list;
 800bd02:	68fb      	ldr	r3, [r7, #12]
 800bd04:	691b      	ldr	r3, [r3, #16]
 800bd06:	633b      	str	r3, [r7, #48]	; 0x30
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
 800bd08:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bd0a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800bd0c:	671a      	str	r2, [r3, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 800bd0e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bd10:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bd12:	62fb      	str	r3, [r7, #44]	; 0x2c
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 800bd14:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bd16:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bd18:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 800bd1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd1c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800bd1e:	671a      	str	r2, [r3, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 800bd20:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bd22:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800bd24:	675a      	str	r2, [r3, #116]	; 0x74
                }

                /* Increment the number of threads suspended.  */
                group_ptr -> tx_event_flags_group_suspended_count++;
 800bd26:	68fb      	ldr	r3, [r7, #12]
 800bd28:	695b      	ldr	r3, [r3, #20]
 800bd2a:	1c5a      	adds	r2, r3, #1
 800bd2c:	68fb      	ldr	r3, [r7, #12]
 800bd2e:	615a      	str	r2, [r3, #20]

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =    TX_EVENT_FLAG;
 800bd30:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bd32:	2207      	movs	r2, #7
 800bd34:	631a      	str	r2, [r3, #48]	; 0x30
                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800bd36:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bd38:	2201      	movs	r2, #1
 800bd3a:	639a      	str	r2, [r3, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 800bd3c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bd3e:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800bd40:	64da      	str	r2, [r3, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 800bd42:	4b14      	ldr	r3, [pc, #80]	; (800bd94 <_tx_event_flags_get+0x1c8>)
 800bd44:	681b      	ldr	r3, [r3, #0]
 800bd46:	3301      	adds	r3, #1
 800bd48:	4a12      	ldr	r2, [pc, #72]	; (800bd94 <_tx_event_flags_get+0x1c8>)
 800bd4a:	6013      	str	r3, [r2, #0]
 800bd4c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bd4e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bd50:	697b      	ldr	r3, [r7, #20]
 800bd52:	f383 8810 	msr	PRIMASK, r3
}
 800bd56:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 800bd58:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800bd5a:	f002 f92f 	bl	800dfbc <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bd5e:	f3ef 8310 	mrs	r3, PRIMASK
 800bd62:	61fb      	str	r3, [r7, #28]
    return(posture);
 800bd64:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800bd66:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800bd68:	b672      	cpsid	i
    return(int_posture);
 800bd6a:	69bb      	ldr	r3, [r7, #24]

                /* Disable interrupts.  */
                TX_DISABLE
 800bd6c:	657b      	str	r3, [r7, #84]	; 0x54

                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
 800bd6e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bd70:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800bd74:	653b      	str	r3, [r7, #80]	; 0x50
 800bd76:	e001      	b.n	800bd7c <_tx_event_flags_get+0x1b0>
        }
        else
        {

            /* Immediate return, return error completion.  */
            status =  TX_NO_EVENTS;
 800bd78:	2307      	movs	r3, #7
 800bd7a:	653b      	str	r3, [r7, #80]	; 0x50
 800bd7c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800bd7e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bd80:	693b      	ldr	r3, [r7, #16]
 800bd82:	f383 8810 	msr	PRIMASK, r3
}
 800bd86:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(status);
 800bd88:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 800bd8a:	4618      	mov	r0, r3
 800bd8c:	3758      	adds	r7, #88	; 0x58
 800bd8e:	46bd      	mov	sp, r7
 800bd90:	bd80      	pop	{r7, pc}
 800bd92:	bf00      	nop
 800bd94:	20006d9c 	.word	0x20006d9c
 800bd98:	20006d04 	.word	0x20006d04
 800bd9c:	0800b905 	.word	0x0800b905

0800bda0 <_tx_event_flags_set>:
/*                                            check logic, resulting in   */
/*                                            version 6.1.11              */
/*                                                                        */
/**************************************************************************/
UINT  _tx_event_flags_set(TX_EVENT_FLAGS_GROUP *group_ptr, ULONG flags_to_set, UINT set_option)
{
 800bda0:	b580      	push	{r7, lr}
 800bda2:	b0a6      	sub	sp, #152	; 0x98
 800bda4:	af00      	add	r7, sp, #0
 800bda6:	60f8      	str	r0, [r7, #12]
 800bda8:	60b9      	str	r1, [r7, #8]
 800bdaa:	607a      	str	r2, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bdac:	f3ef 8310 	mrs	r3, PRIMASK
 800bdb0:	64fb      	str	r3, [r7, #76]	; 0x4c
    return(posture);
 800bdb2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    int_posture = __get_interrupt_posture();
 800bdb4:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("CPSID i" : : : "memory");
 800bdb6:	b672      	cpsid	i
    return(int_posture);
 800bdb8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
VOID            (*events_set_notify)(struct TX_EVENT_FLAGS_GROUP_STRUCT *notify_group_ptr);
#endif


    /* Disable interrupts to remove the semaphore from the created list.  */
    TX_DISABLE
 800bdba:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    /* Log this kernel call.  */
    TX_EL_EVENT_FLAGS_SET_INSERT

    /* Determine how to set this group's event flags.  */
    if ((set_option & TX_EVENT_FLAGS_AND_MASK) == TX_AND)
 800bdbe:	687b      	ldr	r3, [r7, #4]
 800bdc0:	f003 0302 	and.w	r3, r3, #2
 800bdc4:	2b00      	cmp	r3, #0
 800bdc6:	d023      	beq.n	800be10 <_tx_event_flags_set+0x70>
    {

#ifndef TX_NOT_INTERRUPTABLE

        /* Set interrupted set request flag to false.  */
        interrupted_set_request =  TX_FALSE;
 800bdc8:	2300      	movs	r3, #0
 800bdca:	673b      	str	r3, [r7, #112]	; 0x70

        /* Determine if the suspension list is being processed by an interrupted
           set request.  */
        if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 800bdcc:	68fb      	ldr	r3, [r7, #12]
 800bdce:	695b      	ldr	r3, [r3, #20]
 800bdd0:	2b00      	cmp	r3, #0
 800bdd2:	d005      	beq.n	800bde0 <_tx_event_flags_set+0x40>
        {

            if (group_ptr -> tx_event_flags_group_suspension_list == TX_NULL)
 800bdd4:	68fb      	ldr	r3, [r7, #12]
 800bdd6:	691b      	ldr	r3, [r3, #16]
 800bdd8:	2b00      	cmp	r3, #0
 800bdda:	d101      	bne.n	800bde0 <_tx_event_flags_set+0x40>
            {

                /* Set the interrupted set request flag.  */
                interrupted_set_request =  TX_TRUE;
 800bddc:	2301      	movs	r3, #1
 800bdde:	673b      	str	r3, [r7, #112]	; 0x70
            }
        }

        /* Was a set request interrupted?  */
        if (interrupted_set_request == TX_TRUE)
 800bde0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800bde2:	2b01      	cmp	r3, #1
 800bde4:	d107      	bne.n	800bdf6 <_tx_event_flags_set+0x56>
            /* A previous set operation was interrupted, we need to defer the
               event clearing until the set operation is complete.  */

            /* Remember the events to clear.  */
            group_ptr -> tx_event_flags_group_delayed_clear =
                                        group_ptr -> tx_event_flags_group_delayed_clear | ~flags_to_set;
 800bde6:	68fb      	ldr	r3, [r7, #12]
 800bde8:	6a1a      	ldr	r2, [r3, #32]
 800bdea:	68bb      	ldr	r3, [r7, #8]
 800bdec:	43db      	mvns	r3, r3
 800bdee:	431a      	orrs	r2, r3
            group_ptr -> tx_event_flags_group_delayed_clear =
 800bdf0:	68fb      	ldr	r3, [r7, #12]
 800bdf2:	621a      	str	r2, [r3, #32]
 800bdf4:	e005      	b.n	800be02 <_tx_event_flags_set+0x62>

            /* Previous set operation was not interrupted, simply clear the
               specified flags by "ANDing" the flags into the current events
               of the group.  */
            group_ptr -> tx_event_flags_group_current =
                group_ptr -> tx_event_flags_group_current & flags_to_set;
 800bdf6:	68fb      	ldr	r3, [r7, #12]
 800bdf8:	689a      	ldr	r2, [r3, #8]
 800bdfa:	68bb      	ldr	r3, [r7, #8]
 800bdfc:	401a      	ands	r2, r3
            group_ptr -> tx_event_flags_group_current =
 800bdfe:	68fb      	ldr	r3, [r7, #12]
 800be00:	609a      	str	r2, [r3, #8]
 800be02:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800be06:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800be08:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800be0a:	f383 8810 	msr	PRIMASK, r3
}
 800be0e:	e1d2      	b.n	800c1b6 <_tx_event_flags_set+0x416>
        events_set_notify =  group_ptr -> tx_event_flags_group_set_notify;
#endif

        /* "OR" the flags into the current events of the group.  */
        group_ptr -> tx_event_flags_group_current =
            group_ptr -> tx_event_flags_group_current | flags_to_set;
 800be10:	68fb      	ldr	r3, [r7, #12]
 800be12:	689a      	ldr	r2, [r3, #8]
 800be14:	68bb      	ldr	r3, [r7, #8]
 800be16:	431a      	orrs	r2, r3
        group_ptr -> tx_event_flags_group_current =
 800be18:	68fb      	ldr	r3, [r7, #12]
 800be1a:	609a      	str	r2, [r3, #8]

#ifndef TX_NOT_INTERRUPTABLE

        /* Determine if there are any delayed flags to clear.  */
        if (group_ptr -> tx_event_flags_group_delayed_clear != ((ULONG) 0))
 800be1c:	68fb      	ldr	r3, [r7, #12]
 800be1e:	6a1b      	ldr	r3, [r3, #32]
 800be20:	2b00      	cmp	r3, #0
 800be22:	d006      	beq.n	800be32 <_tx_event_flags_set+0x92>
        {

            /* Yes, we need to neutralize the delayed clearing as well.  */
            group_ptr -> tx_event_flags_group_delayed_clear =
                                        group_ptr -> tx_event_flags_group_delayed_clear & ~flags_to_set;
 800be24:	68fb      	ldr	r3, [r7, #12]
 800be26:	6a1a      	ldr	r2, [r3, #32]
 800be28:	68bb      	ldr	r3, [r7, #8]
 800be2a:	43db      	mvns	r3, r3
 800be2c:	401a      	ands	r2, r3
            group_ptr -> tx_event_flags_group_delayed_clear =
 800be2e:	68fb      	ldr	r3, [r7, #12]
 800be30:	621a      	str	r2, [r3, #32]
        }
#endif

        /* Clear the preempt check flag.  */
        preempt_check =  TX_FALSE;
 800be32:	2300      	movs	r3, #0
 800be34:	677b      	str	r3, [r7, #116]	; 0x74

        /* Pickup the thread suspended count.  */
        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 800be36:	68fb      	ldr	r3, [r7, #12]
 800be38:	695b      	ldr	r3, [r3, #20]
 800be3a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

        /* Determine if there are any threads suspended on the event flag group.  */
        if (group_ptr -> tx_event_flags_group_suspension_list != TX_NULL)
 800be3e:	68fb      	ldr	r3, [r7, #12]
 800be40:	691b      	ldr	r3, [r3, #16]
 800be42:	2b00      	cmp	r3, #0
 800be44:	f000 81a4 	beq.w	800c190 <_tx_event_flags_set+0x3f0>
        {

            /* Determine if there is just a single thread waiting on the event
               flag group.  */
            if (suspended_count == ((UINT) 1))
 800be48:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800be4c:	2b01      	cmp	r3, #1
 800be4e:	d167      	bne.n	800bf20 <_tx_event_flags_set+0x180>

                /* Single thread waiting for event flags.  Bypass the multiple thread
                   logic.  */

                /* Setup thread pointer.  */
                thread_ptr =  group_ptr -> tx_event_flags_group_suspension_list;
 800be50:	68fb      	ldr	r3, [r7, #12]
 800be52:	691b      	ldr	r3, [r3, #16]
 800be54:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                /* Pickup the current event flags.  */
                current_event_flags =  group_ptr -> tx_event_flags_group_current;
 800be58:	68fb      	ldr	r3, [r7, #12]
 800be5a:	689b      	ldr	r3, [r3, #8]
 800be5c:	67fb      	str	r3, [r7, #124]	; 0x7c

                /* Pickup the suspend information.  */
                requested_flags =  thread_ptr -> tx_thread_suspend_info;
 800be5e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800be62:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800be64:	66bb      	str	r3, [r7, #104]	; 0x68

                /* Pickup the suspend option.  */
                get_option =  thread_ptr -> tx_thread_suspend_option;
 800be66:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800be6a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800be6e:	667b      	str	r3, [r7, #100]	; 0x64

                /* Isolate the AND selection.  */
                and_request =  (get_option & TX_AND);
 800be70:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800be72:	f003 0302 	and.w	r3, r3, #2
 800be76:	663b      	str	r3, [r7, #96]	; 0x60

                /* Check for AND condition. All flags must be present to satisfy request.  */
                if (and_request == TX_AND)
 800be78:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800be7a:	2b02      	cmp	r3, #2
 800be7c:	d10a      	bne.n	800be94 <_tx_event_flags_set+0xf4>
                {

                    /* AND request is present.  */

                    /* Calculate the flags present.  */
                    flags_satisfied =  (current_event_flags & requested_flags);
 800be7e:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800be80:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800be82:	4013      	ands	r3, r2
 800be84:	67bb      	str	r3, [r7, #120]	; 0x78

                    /* Determine if they satisfy the AND request.  */
                    if (flags_satisfied != requested_flags)
 800be86:	6fba      	ldr	r2, [r7, #120]	; 0x78
 800be88:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800be8a:	429a      	cmp	r2, r3
 800be8c:	d006      	beq.n	800be9c <_tx_event_flags_set+0xfc>
                    {

                        /* No, not all the requested flags are present. Clear the flags present variable.  */
                        flags_satisfied =  ((ULONG) 0);
 800be8e:	2300      	movs	r3, #0
 800be90:	67bb      	str	r3, [r7, #120]	; 0x78
 800be92:	e003      	b.n	800be9c <_tx_event_flags_set+0xfc>
                }
                else
                {

                    /* OR request is present. Simply or the requested flags and the current flags.  */
                    flags_satisfied =  (current_event_flags & requested_flags);
 800be94:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800be96:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800be98:	4013      	ands	r3, r2
 800be9a:	67bb      	str	r3, [r7, #120]	; 0x78
                }

                /* Determine if the request is satisfied.  */
                if (flags_satisfied != ((ULONG) 0))
 800be9c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800be9e:	2b00      	cmp	r3, #0
 800bea0:	f000 817d 	beq.w	800c19e <_tx_event_flags_set+0x3fe>

                    /* Yes, resume the thread and apply any event flag
                       clearing.  */

                    /* Return the actual event flags that satisfied the request.  */
                    suspend_info_ptr =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 800bea4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800bea8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800beaa:	65fb      	str	r3, [r7, #92]	; 0x5c
                    *suspend_info_ptr =  current_event_flags;
 800beac:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800beae:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800beb0:	601a      	str	r2, [r3, #0]

                    /* Pickup the clear bit.  */
                    clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
 800beb2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800beb4:	f003 0301 	and.w	r3, r3, #1
 800beb8:	65bb      	str	r3, [r7, #88]	; 0x58

                    /* Determine whether or not clearing needs to take place.  */
                    if (clear_request == TX_TRUE)
 800beba:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800bebc:	2b01      	cmp	r3, #1
 800bebe:	d106      	bne.n	800bece <_tx_event_flags_set+0x12e>
                    {

                        /* Yes, clear the flags that satisfied this request.  */
                        group_ptr -> tx_event_flags_group_current =  group_ptr -> tx_event_flags_group_current & (~requested_flags);
 800bec0:	68fb      	ldr	r3, [r7, #12]
 800bec2:	689a      	ldr	r2, [r3, #8]
 800bec4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800bec6:	43db      	mvns	r3, r3
 800bec8:	401a      	ands	r2, r3
 800beca:	68fb      	ldr	r3, [r7, #12]
 800becc:	609a      	str	r2, [r3, #8]
                    }

                    /* Clear the suspension information in the event flag group.  */
                    group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 800bece:	68fb      	ldr	r3, [r7, #12]
 800bed0:	2200      	movs	r2, #0
 800bed2:	611a      	str	r2, [r3, #16]
                    group_ptr -> tx_event_flags_group_suspended_count =  TX_NO_SUSPENSIONS;
 800bed4:	68fb      	ldr	r3, [r7, #12]
 800bed6:	2200      	movs	r2, #0
 800bed8:	615a      	str	r2, [r3, #20]

                    /* Clear cleanup routine to avoid timeout.  */
                    thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800beda:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800bede:	2200      	movs	r2, #0
 800bee0:	669a      	str	r2, [r3, #104]	; 0x68

                    /* Put return status into the thread control block.  */
                    thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800bee2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800bee6:	2200      	movs	r2, #0
 800bee8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                    /* Resume the thread!  */
                    _tx_thread_system_ni_resume(thread_ptr);
#else

                    /* Temporarily disable preemption.  */
                    _tx_thread_preempt_disable++;
 800beec:	4ba7      	ldr	r3, [pc, #668]	; (800c18c <_tx_event_flags_set+0x3ec>)
 800beee:	681b      	ldr	r3, [r3, #0]
 800bef0:	3301      	adds	r3, #1
 800bef2:	4aa6      	ldr	r2, [pc, #664]	; (800c18c <_tx_event_flags_set+0x3ec>)
 800bef4:	6013      	str	r3, [r2, #0]
 800bef6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800befa:	63bb      	str	r3, [r7, #56]	; 0x38
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800befc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800befe:	f383 8810 	msr	PRIMASK, r3
}
 800bf02:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Resume thread.  */
                    _tx_thread_system_resume(thread_ptr);
 800bf04:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 800bf08:	f001 ff58 	bl	800ddbc <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bf0c:	f3ef 8310 	mrs	r3, PRIMASK
 800bf10:	643b      	str	r3, [r7, #64]	; 0x40
    return(posture);
 800bf12:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    int_posture = __get_interrupt_posture();
 800bf14:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
 800bf16:	b672      	cpsid	i
    return(int_posture);
 800bf18:	6bfb      	ldr	r3, [r7, #60]	; 0x3c

                    /* Disable interrupts to remove the semaphore from the created list.  */
                    TX_DISABLE
 800bf1a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800bf1e:	e13e      	b.n	800c19e <_tx_event_flags_set+0x3fe>

                /* Otherwise, the event flag requests of multiple threads must be
                   examined.  */

                /* Setup thread pointer, keep a local copy of the head pointer.  */
                suspended_list =  group_ptr -> tx_event_flags_group_suspension_list;
 800bf20:	68fb      	ldr	r3, [r7, #12]
 800bf22:	691b      	ldr	r3, [r3, #16]
 800bf24:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                thread_ptr =      suspended_list;
 800bf28:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800bf2c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                /* Clear the suspended list head pointer to thwart manipulation of
                   the list in ISR's while we are processing here.  */
                group_ptr -> tx_event_flags_group_suspension_list =  TX_NULL;
 800bf30:	68fb      	ldr	r3, [r7, #12]
 800bf32:	2200      	movs	r2, #0
 800bf34:	611a      	str	r2, [r3, #16]

                /* Setup the satisfied thread pointers.  */
                satisfied_list =  TX_NULL;
 800bf36:	2300      	movs	r3, #0
 800bf38:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                last_satisfied =  TX_NULL;
 800bf3c:	2300      	movs	r3, #0
 800bf3e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

                /* Pickup the current event flags.  */
                current_event_flags =  group_ptr -> tx_event_flags_group_current;
 800bf42:	68fb      	ldr	r3, [r7, #12]
 800bf44:	689b      	ldr	r3, [r3, #8]
 800bf46:	67fb      	str	r3, [r7, #124]	; 0x7c

                /* Disable preemption while we process the suspended list.  */
                _tx_thread_preempt_disable++;
 800bf48:	4b90      	ldr	r3, [pc, #576]	; (800c18c <_tx_event_flags_set+0x3ec>)
 800bf4a:	681b      	ldr	r3, [r3, #0]
 800bf4c:	3301      	adds	r3, #1
 800bf4e:	4a8f      	ldr	r2, [pc, #572]	; (800c18c <_tx_event_flags_set+0x3ec>)
 800bf50:	6013      	str	r3, [r2, #0]

                /* Since we have temporarily disabled preemption globally, set the preempt 
                   check flag to check for any preemption condition - including from 
                   unrelated ISR processing.  */
                preempt_check =  TX_TRUE;
 800bf52:	2301      	movs	r3, #1
 800bf54:	677b      	str	r3, [r7, #116]	; 0x74
 800bf56:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800bf5a:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800bf5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bf5e:	f383 8810 	msr	PRIMASK, r3
}
 800bf62:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800bf64:	f3ef 8310 	mrs	r3, PRIMASK
 800bf68:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 800bf6a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    int_posture = __get_interrupt_posture();
 800bf6c:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
 800bf6e:	b672      	cpsid	i
    return(int_posture);
 800bf70:	6b3b      	ldr	r3, [r7, #48]	; 0x30

                    /* Restore interrupts temporarily.  */
                    TX_RESTORE

                    /* Disable interrupts again.  */
                    TX_DISABLE
 800bf72:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
#endif

                    /* Determine if we need to reset the search.  */
                    if (group_ptr -> tx_event_flags_group_reset_search != TX_FALSE)
 800bf76:	68fb      	ldr	r3, [r7, #12]
 800bf78:	68db      	ldr	r3, [r3, #12]
 800bf7a:	2b00      	cmp	r3, #0
 800bf7c:	d00f      	beq.n	800bf9e <_tx_event_flags_set+0x1fe>
                    {

                        /* Clear the reset search flag.  */
                        group_ptr -> tx_event_flags_group_reset_search =  TX_FALSE;
 800bf7e:	68fb      	ldr	r3, [r7, #12]
 800bf80:	2200      	movs	r2, #0
 800bf82:	60da      	str	r2, [r3, #12]

                        /* Move the thread pointer to the beginning of the search list.  */
                        thread_ptr =  suspended_list;
 800bf84:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800bf88:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                        /* Reset the suspended count.  */
                        suspended_count =  group_ptr -> tx_event_flags_group_suspended_count;
 800bf8c:	68fb      	ldr	r3, [r7, #12]
 800bf8e:	695b      	ldr	r3, [r3, #20]
 800bf90:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

                        /* Update the current events with any new ones that might
                           have been set in a nested set events call from an ISR.  */
                        current_event_flags =  current_event_flags | group_ptr -> tx_event_flags_group_current;
 800bf94:	68fb      	ldr	r3, [r7, #12]
 800bf96:	689b      	ldr	r3, [r3, #8]
 800bf98:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800bf9a:	4313      	orrs	r3, r2
 800bf9c:	67fb      	str	r3, [r7, #124]	; 0x7c
                    }

                    /* Save next thread pointer.  */
                    next_thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800bf9e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800bfa2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800bfa4:	66fb      	str	r3, [r7, #108]	; 0x6c

                    /* Pickup the suspend information.  */
                    requested_flags =  thread_ptr -> tx_thread_suspend_info;
 800bfa6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800bfaa:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800bfac:	66bb      	str	r3, [r7, #104]	; 0x68

                    /* Pickup this thread's suspension get option.  */
                    get_option =  thread_ptr -> tx_thread_suspend_option;
 800bfae:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800bfb2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800bfb6:	667b      	str	r3, [r7, #100]	; 0x64

                    /* Isolate the AND selection.  */
                    and_request =  (get_option & TX_AND);
 800bfb8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800bfba:	f003 0302 	and.w	r3, r3, #2
 800bfbe:	663b      	str	r3, [r7, #96]	; 0x60

                    /* Check for AND condition. All flags must be present to satisfy request.  */
                    if (and_request == TX_AND)
 800bfc0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800bfc2:	2b02      	cmp	r3, #2
 800bfc4:	d10a      	bne.n	800bfdc <_tx_event_flags_set+0x23c>
                    {

                        /* AND request is present.  */

                        /* Calculate the flags present.  */
                        flags_satisfied =  (current_event_flags & requested_flags);
 800bfc6:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800bfc8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800bfca:	4013      	ands	r3, r2
 800bfcc:	67bb      	str	r3, [r7, #120]	; 0x78

                        /* Determine if they satisfy the AND request.  */
                        if (flags_satisfied != requested_flags)
 800bfce:	6fba      	ldr	r2, [r7, #120]	; 0x78
 800bfd0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800bfd2:	429a      	cmp	r2, r3
 800bfd4:	d006      	beq.n	800bfe4 <_tx_event_flags_set+0x244>
                        {

                            /* No, not all the requested flags are present. Clear the flags present variable.  */
                            flags_satisfied =  ((ULONG) 0);
 800bfd6:	2300      	movs	r3, #0
 800bfd8:	67bb      	str	r3, [r7, #120]	; 0x78
 800bfda:	e003      	b.n	800bfe4 <_tx_event_flags_set+0x244>
                    }
                    else
                    {

                        /* OR request is present. Simply or the requested flags and the current flags.  */
                        flags_satisfied =  (current_event_flags & requested_flags);
 800bfdc:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800bfde:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800bfe0:	4013      	ands	r3, r2
 800bfe2:	67bb      	str	r3, [r7, #120]	; 0x78
                    }

                    /* Check to see if the thread had a timeout or wait abort during the event search processing.
                       If so, just set the flags satisfied to ensure the processing here removes the thread from
                       the suspension list.  */
                    if (thread_ptr -> tx_thread_state != TX_EVENT_FLAG)
 800bfe4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800bfe8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bfea:	2b07      	cmp	r3, #7
 800bfec:	d001      	beq.n	800bff2 <_tx_event_flags_set+0x252>
                    {

                       /* Simply set the satisfied flags to 1 in order to remove the thread from the suspension list.  */
                        flags_satisfied =  ((ULONG) 1);
 800bfee:	2301      	movs	r3, #1
 800bff0:	67bb      	str	r3, [r7, #120]	; 0x78
                    }

                    /* Determine if the request is satisfied.  */
                    if (flags_satisfied != ((ULONG) 0))
 800bff2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800bff4:	2b00      	cmp	r3, #0
 800bff6:	d069      	beq.n	800c0cc <_tx_event_flags_set+0x32c>

                        /* Yes, this request can be handled now.  */

                        /* Determine if the thread is still suspended on the event flag group. If not, a wait
                           abort must have been done from an ISR.  */
                        if (thread_ptr -> tx_thread_state == TX_EVENT_FLAG)
 800bff8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800bffc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bffe:	2b07      	cmp	r3, #7
 800c000:	d11d      	bne.n	800c03e <_tx_event_flags_set+0x29e>
                        {

                            /* Return the actual event flags that satisfied the request.  */
                            suspend_info_ptr =   TX_VOID_TO_ULONG_POINTER_CONVERT(thread_ptr -> tx_thread_additional_suspend_info);
 800c002:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c006:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800c008:	65fb      	str	r3, [r7, #92]	; 0x5c
                            *suspend_info_ptr =  current_event_flags;
 800c00a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800c00c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800c00e:	601a      	str	r2, [r3, #0]

                            /* Pickup the clear bit.  */
                            clear_request =  (get_option & TX_EVENT_FLAGS_CLEAR_MASK);
 800c010:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800c012:	f003 0301 	and.w	r3, r3, #1
 800c016:	65bb      	str	r3, [r7, #88]	; 0x58

                            /* Determine whether or not clearing needs to take place.  */
                            if (clear_request == TX_TRUE)
 800c018:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800c01a:	2b01      	cmp	r3, #1
 800c01c:	d106      	bne.n	800c02c <_tx_event_flags_set+0x28c>
                            {

                                /* Yes, clear the flags that satisfied this request.  */
                                group_ptr -> tx_event_flags_group_current =  group_ptr -> tx_event_flags_group_current & ~requested_flags;
 800c01e:	68fb      	ldr	r3, [r7, #12]
 800c020:	689a      	ldr	r2, [r3, #8]
 800c022:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800c024:	43db      	mvns	r3, r3
 800c026:	401a      	ands	r2, r3
 800c028:	68fb      	ldr	r3, [r7, #12]
 800c02a:	609a      	str	r2, [r3, #8]
                            }

                            /* Prepare for resumption of the first thread.  */

                            /* Clear cleanup routine to avoid timeout.  */
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c02c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c030:	2200      	movs	r2, #0
 800c032:	669a      	str	r2, [r3, #104]	; 0x68

                            /* Put return status into the thread control block.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800c034:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c038:	2200      	movs	r2, #0
 800c03a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

                        /* We need to remove the thread from the suspension list and place it in the
                           expired list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (thread_ptr == thread_ptr -> tx_thread_suspended_next)
 800c03e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c042:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c044:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 800c048:	429a      	cmp	r2, r3
 800c04a:	d103      	bne.n	800c054 <_tx_event_flags_set+0x2b4>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            suspended_list =  TX_NULL;
 800c04c:	2300      	movs	r3, #0
 800c04e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800c052:	e018      	b.n	800c086 <_tx_event_flags_set+0x2e6>
                        {

                            /* At least one more thread is on the same expiration list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                  thread_ptr -> tx_thread_suspended_next;
 800c054:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c058:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c05a:	657b      	str	r3, [r7, #84]	; 0x54
                            previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 800c05c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c060:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c062:	653b      	str	r3, [r7, #80]	; 0x50
                            next_thread -> tx_thread_suspended_previous =  previous_thread;
 800c064:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800c066:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800c068:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =  next_thread;
 800c06a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c06c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800c06e:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Update the list head pointer, if removing the head of the
                               list.  */
                            if (suspended_list == thread_ptr)
 800c070:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800c074:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c078:	429a      	cmp	r2, r3
 800c07a:	d104      	bne.n	800c086 <_tx_event_flags_set+0x2e6>
                            {

                                /* Yes, head pointer needs to be updated.  */
                                suspended_list =  thread_ptr -> tx_thread_suspended_next;
 800c07c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c080:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c082:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                            }
                        }

                        /* Decrement the suspension count.  */
                        group_ptr -> tx_event_flags_group_suspended_count--;
 800c086:	68fb      	ldr	r3, [r7, #12]
 800c088:	695b      	ldr	r3, [r3, #20]
 800c08a:	1e5a      	subs	r2, r3, #1
 800c08c:	68fb      	ldr	r3, [r7, #12]
 800c08e:	615a      	str	r2, [r3, #20]

                        /* Place this thread on the expired list.  */
                        if (satisfied_list == TX_NULL)
 800c090:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800c094:	2b00      	cmp	r3, #0
 800c096:	d10c      	bne.n	800c0b2 <_tx_event_flags_set+0x312>
                        {

                            /* First thread on the satisfied list.  */
                            satisfied_list =  thread_ptr;
 800c098:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c09c:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                            last_satisfied =  thread_ptr;
 800c0a0:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c0a4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

                            /* Setup initial next pointer.  */
                            thread_ptr -> tx_thread_suspended_next =  TX_NULL;
 800c0a8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c0ac:	2200      	movs	r2, #0
 800c0ae:	671a      	str	r2, [r3, #112]	; 0x70
 800c0b0:	e00c      	b.n	800c0cc <_tx_event_flags_set+0x32c>
                        {

                            /* Not the first thread on the satisfied list.  */

                            /* Link it up at the end.  */
                            last_satisfied -> tx_thread_suspended_next =  thread_ptr;
 800c0b2:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800c0b6:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 800c0ba:	671a      	str	r2, [r3, #112]	; 0x70
                            thread_ptr -> tx_thread_suspended_next =      TX_NULL;
 800c0bc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c0c0:	2200      	movs	r2, #0
 800c0c2:	671a      	str	r2, [r3, #112]	; 0x70
                            last_satisfied =                              thread_ptr;
 800c0c4:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c0c8:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
                        }
                    }

                    /* Copy next thread pointer to working thread ptr.  */
                    thread_ptr =  next_thread_ptr;
 800c0cc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800c0ce:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                    /* Decrement the suspension count.  */
                    suspended_count--;
 800c0d2:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800c0d6:	3b01      	subs	r3, #1
 800c0d8:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

                } while (suspended_count != TX_NO_SUSPENSIONS);
 800c0dc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800c0e0:	2b00      	cmp	r3, #0
 800c0e2:	f47f af38 	bne.w	800bf56 <_tx_event_flags_set+0x1b6>

                /* Setup the group's suspension list head again.  */
                group_ptr -> tx_event_flags_group_suspension_list =  suspended_list;
 800c0e6:	68fb      	ldr	r3, [r7, #12]
 800c0e8:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800c0ec:	611a      	str	r2, [r3, #16]

#ifndef TX_NOT_INTERRUPTABLE

                /* Determine if there is any delayed event clearing to perform.  */
                if (group_ptr -> tx_event_flags_group_delayed_clear != ((ULONG) 0))
 800c0ee:	68fb      	ldr	r3, [r7, #12]
 800c0f0:	6a1b      	ldr	r3, [r3, #32]
 800c0f2:	2b00      	cmp	r3, #0
 800c0f4:	d00a      	beq.n	800c10c <_tx_event_flags_set+0x36c>
                {

                    /* Perform the delayed event clearing.  */
                    group_ptr -> tx_event_flags_group_current =
                        group_ptr -> tx_event_flags_group_current & ~(group_ptr -> tx_event_flags_group_delayed_clear);
 800c0f6:	68fb      	ldr	r3, [r7, #12]
 800c0f8:	689a      	ldr	r2, [r3, #8]
 800c0fa:	68fb      	ldr	r3, [r7, #12]
 800c0fc:	6a1b      	ldr	r3, [r3, #32]
 800c0fe:	43db      	mvns	r3, r3
 800c100:	401a      	ands	r2, r3
                    group_ptr -> tx_event_flags_group_current =
 800c102:	68fb      	ldr	r3, [r7, #12]
 800c104:	609a      	str	r2, [r3, #8]

                    /* Clear the delayed event flag clear value.  */
                    group_ptr -> tx_event_flags_group_delayed_clear =  ((ULONG) 0);
 800c106:	68fb      	ldr	r3, [r7, #12]
 800c108:	2200      	movs	r2, #0
 800c10a:	621a      	str	r2, [r3, #32]
 800c10c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800c110:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c112:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c114:	f383 8810 	msr	PRIMASK, r3
}
 800c118:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Walk through the satisfied list, setup initial thread pointer. */
                thread_ptr =  satisfied_list;
 800c11a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800c11e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
                while(thread_ptr != TX_NULL)
 800c122:	e01f      	b.n	800c164 <_tx_event_flags_set+0x3c4>
                {

                    /* Get next pointer first.  */
                    next_thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800c124:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c128:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c12a:	66fb      	str	r3, [r7, #108]	; 0x6c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c12c:	f3ef 8310 	mrs	r3, PRIMASK
 800c130:	623b      	str	r3, [r7, #32]
    return(posture);
 800c132:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800c134:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c136:	b672      	cpsid	i
    return(int_posture);
 800c138:	69fb      	ldr	r3, [r7, #28]

                    /* Disable interrupts.  */
                    TX_DISABLE
 800c13a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
                    /* Restore interrupts.  */
                    TX_RESTORE
#else

                    /* Disable preemption again.  */
                    _tx_thread_preempt_disable++;
 800c13e:	4b13      	ldr	r3, [pc, #76]	; (800c18c <_tx_event_flags_set+0x3ec>)
 800c140:	681b      	ldr	r3, [r3, #0]
 800c142:	3301      	adds	r3, #1
 800c144:	4a11      	ldr	r2, [pc, #68]	; (800c18c <_tx_event_flags_set+0x3ec>)
 800c146:	6013      	str	r3, [r2, #0]
 800c148:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800c14c:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c14e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c150:	f383 8810 	msr	PRIMASK, r3
}
 800c154:	bf00      	nop

                    /* Restore interrupt posture.  */
                    TX_RESTORE

                    /* Resume the thread.  */
                    _tx_thread_system_resume(thread_ptr);
 800c156:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 800c15a:	f001 fe2f 	bl	800ddbc <_tx_thread_system_resume>
#endif

                    /* Move next thread to current.  */
                    thread_ptr =  next_thread_ptr;
 800c15e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800c160:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
                while(thread_ptr != TX_NULL)
 800c164:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800c168:	2b00      	cmp	r3, #0
 800c16a:	d1db      	bne.n	800c124 <_tx_event_flags_set+0x384>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c16c:	f3ef 8310 	mrs	r3, PRIMASK
 800c170:	61bb      	str	r3, [r7, #24]
    return(posture);
 800c172:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800c174:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c176:	b672      	cpsid	i
    return(int_posture);
 800c178:	697b      	ldr	r3, [r7, #20]
                }

                /* Disable interrupts.  */
                TX_DISABLE
 800c17a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                /* Release thread preemption disable.  */
                _tx_thread_preempt_disable--;
 800c17e:	4b03      	ldr	r3, [pc, #12]	; (800c18c <_tx_event_flags_set+0x3ec>)
 800c180:	681b      	ldr	r3, [r3, #0]
 800c182:	3b01      	subs	r3, #1
 800c184:	4a01      	ldr	r2, [pc, #4]	; (800c18c <_tx_event_flags_set+0x3ec>)
 800c186:	6013      	str	r3, [r2, #0]
 800c188:	e009      	b.n	800c19e <_tx_event_flags_set+0x3fe>
 800c18a:	bf00      	nop
 800c18c:	20006d9c 	.word	0x20006d9c
        }
        else
        {

            /* Determine if we need to set the reset search field.  */
            if (group_ptr -> tx_event_flags_group_suspended_count != TX_NO_SUSPENSIONS)
 800c190:	68fb      	ldr	r3, [r7, #12]
 800c192:	695b      	ldr	r3, [r3, #20]
 800c194:	2b00      	cmp	r3, #0
 800c196:	d002      	beq.n	800c19e <_tx_event_flags_set+0x3fe>
            {

                /* We interrupted a search of an event flag group suspension
                   list.  Make sure we reset the search.  */
                group_ptr -> tx_event_flags_group_reset_search =  TX_TRUE;
 800c198:	68fb      	ldr	r3, [r7, #12]
 800c19a:	2201      	movs	r2, #1
 800c19c:	60da      	str	r2, [r3, #12]
 800c19e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800c1a2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c1a4:	693b      	ldr	r3, [r7, #16]
 800c1a6:	f383 8810 	msr	PRIMASK, r3
}
 800c1aa:	bf00      	nop
            (events_set_notify)(group_ptr);
        }
#endif

        /* Determine if a check for preemption is necessary.  */
        if (preempt_check == TX_TRUE)
 800c1ac:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800c1ae:	2b01      	cmp	r3, #1
 800c1b0:	d101      	bne.n	800c1b6 <_tx_event_flags_set+0x416>
        {

            /* Yes, one or more threads were resumed, check for preemption.  */
            _tx_thread_system_preempt_check();
 800c1b2:	f001 fdc9 	bl	800dd48 <_tx_thread_system_preempt_check>
        }
    }

    /* Return completion status.  */
    return(TX_SUCCESS);
 800c1b6:	2300      	movs	r3, #0
}
 800c1b8:	4618      	mov	r0, r3
 800c1ba:	3798      	adds	r7, #152	; 0x98
 800c1bc:	46bd      	mov	sp, r7
 800c1be:	bd80      	pop	{r7, pc}

0800c1c0 <_tx_initialize_high_level>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID    _tx_initialize_high_level(VOID)
{
 800c1c0:	b580      	push	{r7, lr}
 800c1c2:	af00      	add	r7, sp, #0

    /* Initialize the event log, if enabled.  */
    TX_EL_INITIALIZE

    /* Call the thread control initialization function.  */
    _tx_thread_initialize();
 800c1c4:	f001 f9ac 	bl	800d520 <_tx_thread_initialize>

#ifndef TX_NO_TIMER

    /* Call the timer control initialization function.  */
    _tx_timer_initialize();
 800c1c8:	f002 faa4 	bl	800e714 <_tx_timer_initialize>
    _tx_byte_pool_initialize();

    /* Call the mutex initialization function.  */
    _tx_mutex_initialize();
#endif
}
 800c1cc:	bf00      	nop
 800c1ce:	bd80      	pop	{r7, pc}

0800c1d0 <_tx_initialize_kernel_enter>:
/*                                            added EPK initialization,   */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _tx_initialize_kernel_enter(VOID)
{
 800c1d0:	b580      	push	{r7, lr}
 800c1d2:	af00      	add	r7, sp, #0

    /* Determine if the compiler has pre-initialized ThreadX.  */
    if (_tx_thread_system_state != TX_INITIALIZE_ALMOST_DONE)
 800c1d4:	4b10      	ldr	r3, [pc, #64]	; (800c218 <_tx_initialize_kernel_enter+0x48>)
 800c1d6:	681b      	ldr	r3, [r3, #0]
 800c1d8:	f113 3f0f 	cmn.w	r3, #252645135	; 0xf0f0f0f
 800c1dc:	d00c      	beq.n	800c1f8 <_tx_initialize_kernel_enter+0x28>
        /* No, the initialization still needs to take place.  */

        /* Ensure that the system state variable is set to indicate
           initialization is in progress.  Note that this variable is
           later used to represent interrupt nesting.  */
        _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
 800c1de:	4b0e      	ldr	r3, [pc, #56]	; (800c218 <_tx_initialize_kernel_enter+0x48>)
 800c1e0:	f04f 32f0 	mov.w	r2, #4042322160	; 0xf0f0f0f0
 800c1e4:	601a      	str	r2, [r3, #0]
        /* Call any port specific preprocessing.  */
        TX_PORT_SPECIFIC_PRE_INITIALIZATION

        /* Invoke the low-level initialization to handle all processor specific
           initialization issues.  */
        _tx_initialize_low_level();
 800c1e6:	f7f3 ffcb 	bl	8000180 <_tx_initialize_low_level>

        /* Invoke the high-level initialization to exercise all of the
           ThreadX components and the application's initialization
           function.  */
        _tx_initialize_high_level();
 800c1ea:	f7ff ffe9 	bl	800c1c0 <_tx_initialize_high_level>

        /* Call any port specific post-processing.  */
        TX_PORT_SPECIFIC_POST_INITIALIZATION
 800c1ee:	4b0b      	ldr	r3, [pc, #44]	; (800c21c <_tx_initialize_kernel_enter+0x4c>)
 800c1f0:	681b      	ldr	r3, [r3, #0]
 800c1f2:	3301      	adds	r3, #1
 800c1f4:	4a09      	ldr	r2, [pc, #36]	; (800c21c <_tx_initialize_kernel_enter+0x4c>)
 800c1f6:	6013      	str	r3, [r2, #0]
    TX_INITIALIZE_KERNEL_ENTER_EXTENSION

    /* Ensure that the system state variable is set to indicate
       initialization is in progress.  Note that this variable is
       later used to represent interrupt nesting.  */
    _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
 800c1f8:	4b07      	ldr	r3, [pc, #28]	; (800c218 <_tx_initialize_kernel_enter+0x48>)
 800c1fa:	f04f 32f0 	mov.w	r2, #4042322160	; 0xf0f0f0f0
 800c1fe:	601a      	str	r2, [r3, #0]

    /* Call the application provided initialization function.  Pass the
       first available memory address to it.  */
    tx_application_define(_tx_initialize_unused_memory);
 800c200:	4b07      	ldr	r3, [pc, #28]	; (800c220 <_tx_initialize_kernel_enter+0x50>)
 800c202:	681b      	ldr	r3, [r3, #0]
 800c204:	4618      	mov	r0, r3
 800c206:	f7f4 fa5d 	bl	80006c4 <tx_application_define>

    /* Set the system state in preparation for entering the thread
       scheduler.  */
    _tx_thread_system_state =  TX_INITIALIZE_IS_FINISHED;
 800c20a:	4b03      	ldr	r3, [pc, #12]	; (800c218 <_tx_initialize_kernel_enter+0x48>)
 800c20c:	2200      	movs	r2, #0
 800c20e:	601a      	str	r2, [r3, #0]
    /* Initialize Execution Profile Kit.  */
    _tx_execution_initialize();
#endif

    /* Enter the scheduling loop to start executing threads!  */
    _tx_thread_schedule();
 800c210:	f7f3 fff6 	bl	8000200 <_tx_thread_schedule>
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
 800c214:	bf00      	nop
 800c216:	bd80      	pop	{r7, pc}
 800c218:	20000090 	.word	0x20000090
 800c21c:	20006d9c 	.word	0x20006d9c
 800c220:	20006cfc 	.word	0x20006cfc

0800c224 <_tx_mutex_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
 800c224:	b580      	push	{r7, lr}
 800c226:	b08e      	sub	sp, #56	; 0x38
 800c228:	af00      	add	r7, sp, #0
 800c22a:	6078      	str	r0, [r7, #4]
 800c22c:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c22e:	f3ef 8310 	mrs	r3, PRIMASK
 800c232:	623b      	str	r3, [r7, #32]
    return(posture);
 800c234:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800c236:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c238:	b672      	cpsid	i
    return(int_posture);
 800c23a:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the mutex.  */
    TX_DISABLE
 800c23c:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_mutex_cleanup))
 800c23e:	687b      	ldr	r3, [r7, #4]
 800c240:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800c242:	4a33      	ldr	r2, [pc, #204]	; (800c310 <_tx_mutex_cleanup+0xec>)
 800c244:	4293      	cmp	r3, r2
 800c246:	d158      	bne.n	800c2fa <_tx_mutex_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 800c248:	687b      	ldr	r3, [r7, #4]
 800c24a:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800c24e:	683a      	ldr	r2, [r7, #0]
 800c250:	429a      	cmp	r2, r3
 800c252:	d152      	bne.n	800c2fa <_tx_mutex_cleanup+0xd6>
        {

            /* Setup pointer to mutex control block.  */
            mutex_ptr =  TX_VOID_TO_MUTEX_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 800c254:	687b      	ldr	r3, [r7, #4]
 800c256:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800c258:	633b      	str	r3, [r7, #48]	; 0x30

            /* Check for NULL mutex pointer.  */
            if (mutex_ptr != TX_NULL)
 800c25a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c25c:	2b00      	cmp	r3, #0
 800c25e:	d04c      	beq.n	800c2fa <_tx_mutex_cleanup+0xd6>
            {

                /* Determine if the mutex ID is valid.  */
                if (mutex_ptr -> tx_mutex_id == TX_MUTEX_ID)
 800c260:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c262:	681b      	ldr	r3, [r3, #0]
 800c264:	4a2b      	ldr	r2, [pc, #172]	; (800c314 <_tx_mutex_cleanup+0xf0>)
 800c266:	4293      	cmp	r3, r2
 800c268:	d147      	bne.n	800c2fa <_tx_mutex_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
 800c26a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c26c:	69db      	ldr	r3, [r3, #28]
 800c26e:	2b00      	cmp	r3, #0
 800c270:	d043      	beq.n	800c2fa <_tx_mutex_cleanup+0xd6>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c272:	687b      	ldr	r3, [r7, #4]
 800c274:	2200      	movs	r2, #0
 800c276:	669a      	str	r2, [r3, #104]	; 0x68

                        /* Decrement the suspension count.  */
                        mutex_ptr -> tx_mutex_suspended_count--;
 800c278:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c27a:	69db      	ldr	r3, [r3, #28]
 800c27c:	1e5a      	subs	r2, r3, #1
 800c27e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c280:	61da      	str	r2, [r3, #28]

                        /* Pickup the suspended count.  */
                        suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 800c282:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c284:	69db      	ldr	r3, [r3, #28]
 800c286:	62fb      	str	r3, [r7, #44]	; 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
 800c288:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c28a:	2b00      	cmp	r3, #0
 800c28c:	d103      	bne.n	800c296 <_tx_mutex_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 800c28e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c290:	2200      	movs	r2, #0
 800c292:	619a      	str	r2, [r3, #24]
 800c294:	e013      	b.n	800c2be <_tx_mutex_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
 800c296:	687b      	ldr	r3, [r7, #4]
 800c298:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c29a:	62bb      	str	r3, [r7, #40]	; 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800c29c:	687b      	ldr	r3, [r7, #4]
 800c29e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c2a0:	627b      	str	r3, [r7, #36]	; 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 800c2a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c2a4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800c2a6:	675a      	str	r2, [r3, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 800c2a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c2aa:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c2ac:	671a      	str	r2, [r3, #112]	; 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (mutex_ptr -> tx_mutex_suspension_list == thread_ptr)
 800c2ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c2b0:	699b      	ldr	r3, [r3, #24]
 800c2b2:	687a      	ldr	r2, [r7, #4]
 800c2b4:	429a      	cmp	r2, r3
 800c2b6:	d102      	bne.n	800c2be <_tx_mutex_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =         next_thread;
 800c2b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c2ba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c2bc:	619a      	str	r2, [r3, #24]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_MUTEX_SUSP)
 800c2be:	687b      	ldr	r3, [r7, #4]
 800c2c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c2c2:	2b0d      	cmp	r3, #13
 800c2c4:	d119      	bne.n	800c2fa <_tx_mutex_cleanup+0xd6>
                            /* Increment the number of timeouts on this semaphore.  */
                            mutex_ptr -> tx_mutex_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NOT_AVAILABLE;
 800c2c6:	687b      	ldr	r3, [r7, #4]
 800c2c8:	221d      	movs	r2, #29
 800c2ca:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 800c2ce:	4b12      	ldr	r3, [pc, #72]	; (800c318 <_tx_mutex_cleanup+0xf4>)
 800c2d0:	681b      	ldr	r3, [r3, #0]
 800c2d2:	3301      	adds	r3, #1
 800c2d4:	4a10      	ldr	r2, [pc, #64]	; (800c318 <_tx_mutex_cleanup+0xf4>)
 800c2d6:	6013      	str	r3, [r2, #0]
 800c2d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c2da:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c2dc:	693b      	ldr	r3, [r7, #16]
 800c2de:	f383 8810 	msr	PRIMASK, r3
}
 800c2e2:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
 800c2e4:	6878      	ldr	r0, [r7, #4]
 800c2e6:	f001 fd69 	bl	800ddbc <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c2ea:	f3ef 8310 	mrs	r3, PRIMASK
 800c2ee:	61bb      	str	r3, [r7, #24]
    return(posture);
 800c2f0:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800c2f2:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c2f4:	b672      	cpsid	i
    return(int_posture);
 800c2f6:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
 800c2f8:	637b      	str	r3, [r7, #52]	; 0x34
 800c2fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c2fc:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c2fe:	68fb      	ldr	r3, [r7, #12]
 800c300:	f383 8810 	msr	PRIMASK, r3
}
 800c304:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 800c306:	bf00      	nop
 800c308:	3738      	adds	r7, #56	; 0x38
 800c30a:	46bd      	mov	sp, r7
 800c30c:	bd80      	pop	{r7, pc}
 800c30e:	bf00      	nop
 800c310:	0800c225 	.word	0x0800c225
 800c314:	4d555445 	.word	0x4d555445
 800c318:	20006d9c 	.word	0x20006d9c

0800c31c <_tx_mutex_thread_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_thread_release(TX_THREAD  *thread_ptr)
{
 800c31c:	b580      	push	{r7, lr}
 800c31e:	b08a      	sub	sp, #40	; 0x28
 800c320:	af00      	add	r7, sp, #0
 800c322:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c324:	f3ef 8310 	mrs	r3, PRIMASK
 800c328:	61fb      	str	r3, [r7, #28]
    return(posture);
 800c32a:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800c32c:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c32e:	b672      	cpsid	i
    return(int_posture);
 800c330:	69bb      	ldr	r3, [r7, #24]
UINT        status;
#endif


    /* Disable interrupts.  */
    TX_DISABLE
 800c332:	627b      	str	r3, [r7, #36]	; 0x24

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800c334:	4b1a      	ldr	r3, [pc, #104]	; (800c3a0 <_tx_mutex_thread_release+0x84>)
 800c336:	681b      	ldr	r3, [r3, #0]
 800c338:	3301      	adds	r3, #1
 800c33a:	4a19      	ldr	r2, [pc, #100]	; (800c3a0 <_tx_mutex_thread_release+0x84>)
 800c33c:	6013      	str	r3, [r2, #0]
    /* Loop to look at all the mutexes.  */
    do
    {

        /* Pickup the mutex head pointer.  */
        mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
 800c33e:	687b      	ldr	r3, [r7, #4]
 800c340:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800c344:	623b      	str	r3, [r7, #32]

        /* Determine if there is a mutex.  */
        if (mutex_ptr != TX_NULL)
 800c346:	6a3b      	ldr	r3, [r7, #32]
 800c348:	2b00      	cmp	r3, #0
 800c34a:	d017      	beq.n	800c37c <_tx_mutex_thread_release+0x60>
        {

            /* Yes, set the ownership count to 1.  */
            mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 800c34c:	6a3b      	ldr	r3, [r7, #32]
 800c34e:	2201      	movs	r2, #1
 800c350:	609a      	str	r2, [r3, #8]
 800c352:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c354:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c356:	68fb      	ldr	r3, [r7, #12]
 800c358:	f383 8810 	msr	PRIMASK, r3
}
 800c35c:	bf00      	nop
            do
            {
                status =  _tx_mutex_put(mutex_ptr);
            } while (status != TX_SUCCESS);
#else
            _tx_mutex_put(mutex_ptr);
 800c35e:	6a38      	ldr	r0, [r7, #32]
 800c360:	f000 fb9c 	bl	800ca9c <_tx_mutex_put>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c364:	f3ef 8310 	mrs	r3, PRIMASK
 800c368:	617b      	str	r3, [r7, #20]
    return(posture);
 800c36a:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800c36c:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c36e:	b672      	cpsid	i
    return(int_posture);
 800c370:	693b      	ldr	r3, [r7, #16]
#endif

            /* Disable interrupts.  */
            TX_DISABLE
 800c372:	627b      	str	r3, [r7, #36]	; 0x24

            /* Move to the next mutex.  */
            mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
 800c374:	687b      	ldr	r3, [r7, #4]
 800c376:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800c37a:	623b      	str	r3, [r7, #32]
        }
    } while (mutex_ptr != TX_NULL);
 800c37c:	6a3b      	ldr	r3, [r7, #32]
 800c37e:	2b00      	cmp	r3, #0
 800c380:	d1dd      	bne.n	800c33e <_tx_mutex_thread_release+0x22>

    /* Restore preemption.  */
    _tx_thread_preempt_disable--;
 800c382:	4b07      	ldr	r3, [pc, #28]	; (800c3a0 <_tx_mutex_thread_release+0x84>)
 800c384:	681b      	ldr	r3, [r3, #0]
 800c386:	3b01      	subs	r3, #1
 800c388:	4a05      	ldr	r2, [pc, #20]	; (800c3a0 <_tx_mutex_thread_release+0x84>)
 800c38a:	6013      	str	r3, [r2, #0]
 800c38c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c38e:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c390:	68bb      	ldr	r3, [r7, #8]
 800c392:	f383 8810 	msr	PRIMASK, r3
}
 800c396:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE
}
 800c398:	bf00      	nop
 800c39a:	3728      	adds	r7, #40	; 0x28
 800c39c:	46bd      	mov	sp, r7
 800c39e:	bd80      	pop	{r7, pc}
 800c3a0:	20006d9c 	.word	0x20006d9c

0800c3a4 <_tx_mutex_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit)
{
 800c3a4:	b580      	push	{r7, lr}
 800c3a6:	b08a      	sub	sp, #40	; 0x28
 800c3a8:	af00      	add	r7, sp, #0
 800c3aa:	60f8      	str	r0, [r7, #12]
 800c3ac:	60b9      	str	r1, [r7, #8]
 800c3ae:	607a      	str	r2, [r7, #4]
TX_MUTEX        *next_mutex;
TX_MUTEX        *previous_mutex;


    /* Initialize mutex control block to all zeros.  */
    TX_MEMSET(mutex_ptr, 0, (sizeof(TX_MUTEX)));
 800c3b0:	2234      	movs	r2, #52	; 0x34
 800c3b2:	2100      	movs	r1, #0
 800c3b4:	68f8      	ldr	r0, [r7, #12]
 800c3b6:	f006 ff57 	bl	8013268 <memset>

    /* Setup the basic mutex fields.  */
    mutex_ptr -> tx_mutex_name =             name_ptr;
 800c3ba:	68fb      	ldr	r3, [r7, #12]
 800c3bc:	68ba      	ldr	r2, [r7, #8]
 800c3be:	605a      	str	r2, [r3, #4]
    mutex_ptr -> tx_mutex_inherit =          inherit;
 800c3c0:	68fb      	ldr	r3, [r7, #12]
 800c3c2:	687a      	ldr	r2, [r7, #4]
 800c3c4:	611a      	str	r2, [r3, #16]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c3c6:	f3ef 8310 	mrs	r3, PRIMASK
 800c3ca:	61bb      	str	r3, [r7, #24]
    return(posture);
 800c3cc:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800c3ce:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c3d0:	b672      	cpsid	i
    return(int_posture);
 800c3d2:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the mutex on the created list.  */
    TX_DISABLE
 800c3d4:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the mutex ID to make it valid.  */
    mutex_ptr -> tx_mutex_id =  TX_MUTEX_ID;
 800c3d6:	68fb      	ldr	r3, [r7, #12]
 800c3d8:	4a1a      	ldr	r2, [pc, #104]	; (800c444 <_tx_mutex_create+0xa0>)
 800c3da:	601a      	str	r2, [r3, #0]

    /* Setup the thread mutex release function pointer.  */
    _tx_thread_mutex_release =  &(_tx_mutex_thread_release);
 800c3dc:	4b1a      	ldr	r3, [pc, #104]	; (800c448 <_tx_mutex_create+0xa4>)
 800c3de:	4a1b      	ldr	r2, [pc, #108]	; (800c44c <_tx_mutex_create+0xa8>)
 800c3e0:	601a      	str	r2, [r3, #0]

    /* Place the mutex on the list of created mutexes.  First,
       check for an empty list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
 800c3e2:	4b1b      	ldr	r3, [pc, #108]	; (800c450 <_tx_mutex_create+0xac>)
 800c3e4:	681b      	ldr	r3, [r3, #0]
 800c3e6:	2b00      	cmp	r3, #0
 800c3e8:	d109      	bne.n	800c3fe <_tx_mutex_create+0x5a>
    {

        /* The created mutex list is empty.  Add mutex to empty list.  */
        _tx_mutex_created_ptr =                   mutex_ptr;
 800c3ea:	4a1a      	ldr	r2, [pc, #104]	; (800c454 <_tx_mutex_create+0xb0>)
 800c3ec:	68fb      	ldr	r3, [r7, #12]
 800c3ee:	6013      	str	r3, [r2, #0]
        mutex_ptr -> tx_mutex_created_next =      mutex_ptr;
 800c3f0:	68fb      	ldr	r3, [r7, #12]
 800c3f2:	68fa      	ldr	r2, [r7, #12]
 800c3f4:	621a      	str	r2, [r3, #32]
        mutex_ptr -> tx_mutex_created_previous =  mutex_ptr;
 800c3f6:	68fb      	ldr	r3, [r7, #12]
 800c3f8:	68fa      	ldr	r2, [r7, #12]
 800c3fa:	625a      	str	r2, [r3, #36]	; 0x24
 800c3fc:	e011      	b.n	800c422 <_tx_mutex_create+0x7e>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_mutex =      _tx_mutex_created_ptr;
 800c3fe:	4b15      	ldr	r3, [pc, #84]	; (800c454 <_tx_mutex_create+0xb0>)
 800c400:	681b      	ldr	r3, [r3, #0]
 800c402:	623b      	str	r3, [r7, #32]
        previous_mutex =  next_mutex -> tx_mutex_created_previous;
 800c404:	6a3b      	ldr	r3, [r7, #32]
 800c406:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c408:	61fb      	str	r3, [r7, #28]

        /* Place the new mutex in the list.  */
        next_mutex -> tx_mutex_created_previous =  mutex_ptr;
 800c40a:	6a3b      	ldr	r3, [r7, #32]
 800c40c:	68fa      	ldr	r2, [r7, #12]
 800c40e:	625a      	str	r2, [r3, #36]	; 0x24
        previous_mutex -> tx_mutex_created_next =  mutex_ptr;
 800c410:	69fb      	ldr	r3, [r7, #28]
 800c412:	68fa      	ldr	r2, [r7, #12]
 800c414:	621a      	str	r2, [r3, #32]

        /* Setup this mutex's next and previous created links.  */
        mutex_ptr -> tx_mutex_created_previous =  previous_mutex;
 800c416:	68fb      	ldr	r3, [r7, #12]
 800c418:	69fa      	ldr	r2, [r7, #28]
 800c41a:	625a      	str	r2, [r3, #36]	; 0x24
        mutex_ptr -> tx_mutex_created_next =      next_mutex;
 800c41c:	68fb      	ldr	r3, [r7, #12]
 800c41e:	6a3a      	ldr	r2, [r7, #32]
 800c420:	621a      	str	r2, [r3, #32]
    }

    /* Increment the ownership count.  */
    _tx_mutex_created_count++;
 800c422:	4b0b      	ldr	r3, [pc, #44]	; (800c450 <_tx_mutex_create+0xac>)
 800c424:	681b      	ldr	r3, [r3, #0]
 800c426:	3301      	adds	r3, #1
 800c428:	4a09      	ldr	r2, [pc, #36]	; (800c450 <_tx_mutex_create+0xac>)
 800c42a:	6013      	str	r3, [r2, #0]
 800c42c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c42e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c430:	693b      	ldr	r3, [r7, #16]
 800c432:	f383 8810 	msr	PRIMASK, r3
}
 800c436:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800c438:	2300      	movs	r3, #0
}
 800c43a:	4618      	mov	r0, r3
 800c43c:	3728      	adds	r7, #40	; 0x28
 800c43e:	46bd      	mov	sp, r7
 800c440:	bd80      	pop	{r7, pc}
 800c442:	bf00      	nop
 800c444:	4d555445 	.word	0x4d555445
 800c448:	20006da0 	.word	0x20006da0
 800c44c:	0800c31d 	.word	0x0800c31d
 800c450:	20006cf0 	.word	0x20006cf0
 800c454:	20006cec 	.word	0x20006cec

0800c458 <_tx_mutex_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_delete(TX_MUTEX *mutex_ptr)
{
 800c458:	b580      	push	{r7, lr}
 800c45a:	b096      	sub	sp, #88	; 0x58
 800c45c:	af00      	add	r7, sp, #0
 800c45e:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c460:	f3ef 8310 	mrs	r3, PRIMASK
 800c464:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 800c466:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 800c468:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 800c46a:	b672      	cpsid	i
    return(int_posture);
 800c46c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
#ifdef TX_MISRA_ENABLE
UINT            status;
#endif

    /* Disable interrupts to remove the mutex from the created list.  */
    TX_DISABLE
 800c46e:	657b      	str	r3, [r7, #84]	; 0x54

    /* Log this kernel call.  */
    TX_EL_MUTEX_DELETE_INSERT

    /* Clear the mutex ID to make it invalid.  */
    mutex_ptr -> tx_mutex_id =  TX_CLEAR_ID;
 800c470:	687b      	ldr	r3, [r7, #4]
 800c472:	2200      	movs	r2, #0
 800c474:	601a      	str	r2, [r3, #0]

    /* Decrement the created count.  */
    _tx_mutex_created_count--;
 800c476:	4b4a      	ldr	r3, [pc, #296]	; (800c5a0 <_tx_mutex_delete+0x148>)
 800c478:	681b      	ldr	r3, [r3, #0]
 800c47a:	3b01      	subs	r3, #1
 800c47c:	4a48      	ldr	r2, [pc, #288]	; (800c5a0 <_tx_mutex_delete+0x148>)
 800c47e:	6013      	str	r3, [r2, #0]

    /* See if the mutex is the only one on the list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
 800c480:	4b47      	ldr	r3, [pc, #284]	; (800c5a0 <_tx_mutex_delete+0x148>)
 800c482:	681b      	ldr	r3, [r3, #0]
 800c484:	2b00      	cmp	r3, #0
 800c486:	d103      	bne.n	800c490 <_tx_mutex_delete+0x38>
    {

        /* Only created mutex, just set the created list to NULL.  */
        _tx_mutex_created_ptr =  TX_NULL;
 800c488:	4b46      	ldr	r3, [pc, #280]	; (800c5a4 <_tx_mutex_delete+0x14c>)
 800c48a:	2200      	movs	r2, #0
 800c48c:	601a      	str	r2, [r3, #0]
 800c48e:	e013      	b.n	800c4b8 <_tx_mutex_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_mutex =                               mutex_ptr -> tx_mutex_created_next;
 800c490:	687b      	ldr	r3, [r7, #4]
 800c492:	6a1b      	ldr	r3, [r3, #32]
 800c494:	64bb      	str	r3, [r7, #72]	; 0x48
        previous_mutex =                           mutex_ptr -> tx_mutex_created_previous;
 800c496:	687b      	ldr	r3, [r7, #4]
 800c498:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c49a:	647b      	str	r3, [r7, #68]	; 0x44
        next_mutex -> tx_mutex_created_previous =  previous_mutex;
 800c49c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800c49e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800c4a0:	625a      	str	r2, [r3, #36]	; 0x24
        previous_mutex -> tx_mutex_created_next =  next_mutex;
 800c4a2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c4a4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800c4a6:	621a      	str	r2, [r3, #32]

        /* See if we have to update the created list head pointer.  */
        if (_tx_mutex_created_ptr == mutex_ptr)
 800c4a8:	4b3e      	ldr	r3, [pc, #248]	; (800c5a4 <_tx_mutex_delete+0x14c>)
 800c4aa:	681b      	ldr	r3, [r3, #0]
 800c4ac:	687a      	ldr	r2, [r7, #4]
 800c4ae:	429a      	cmp	r2, r3
 800c4b0:	d102      	bne.n	800c4b8 <_tx_mutex_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_mutex_created_ptr =  next_mutex;
 800c4b2:	4a3c      	ldr	r2, [pc, #240]	; (800c5a4 <_tx_mutex_delete+0x14c>)
 800c4b4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800c4b6:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800c4b8:	4b3b      	ldr	r3, [pc, #236]	; (800c5a8 <_tx_mutex_delete+0x150>)
 800c4ba:	681b      	ldr	r3, [r3, #0]
 800c4bc:	3301      	adds	r3, #1
 800c4be:	4a3a      	ldr	r2, [pc, #232]	; (800c5a8 <_tx_mutex_delete+0x150>)
 800c4c0:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                             mutex_ptr -> tx_mutex_suspension_list;
 800c4c2:	687b      	ldr	r3, [r7, #4]
 800c4c4:	699b      	ldr	r3, [r3, #24]
 800c4c6:	653b      	str	r3, [r7, #80]	; 0x50
    mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 800c4c8:	687b      	ldr	r3, [r7, #4]
 800c4ca:	2200      	movs	r2, #0
 800c4cc:	619a      	str	r2, [r3, #24]
    suspended_count =                        mutex_ptr -> tx_mutex_suspended_count;
 800c4ce:	687b      	ldr	r3, [r7, #4]
 800c4d0:	69db      	ldr	r3, [r3, #28]
 800c4d2:	64fb      	str	r3, [r7, #76]	; 0x4c
    mutex_ptr -> tx_mutex_suspended_count =  TX_NO_SUSPENSIONS;
 800c4d4:	687b      	ldr	r3, [r7, #4]
 800c4d6:	2200      	movs	r2, #0
 800c4d8:	61da      	str	r2, [r3, #28]


    /* Determine if the mutex is currently on a thread's ownership list.  */

    /* Setup pointer to owner of mutex.  */
    owner_thread =  mutex_ptr -> tx_mutex_owner;
 800c4da:	687b      	ldr	r3, [r7, #4]
 800c4dc:	68db      	ldr	r3, [r3, #12]
 800c4de:	643b      	str	r3, [r7, #64]	; 0x40

    /* Determine if there is a valid thread pointer.  */
    if (owner_thread != TX_NULL)
 800c4e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c4e2:	2b00      	cmp	r3, #0
 800c4e4:	d013      	beq.n	800c50e <_tx_mutex_delete+0xb6>
    {

        /* Yes, remove this mutex from the owned list.  */

        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 800c4e6:	687b      	ldr	r3, [r7, #4]
 800c4e8:	2201      	movs	r2, #1
 800c4ea:	609a      	str	r2, [r3, #8]
 800c4ec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800c4ee:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c4f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c4f2:	f383 8810 	msr	PRIMASK, r3
}
 800c4f6:	bf00      	nop
        do
        {
            status =  _tx_mutex_put(mutex_ptr);
        } while (status != TX_SUCCESS);
#else
        _tx_mutex_put(mutex_ptr);
 800c4f8:	6878      	ldr	r0, [r7, #4]
 800c4fa:	f000 facf 	bl	800ca9c <_tx_mutex_put>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c4fe:	f3ef 8310 	mrs	r3, PRIMASK
 800c502:	633b      	str	r3, [r7, #48]	; 0x30
    return(posture);
 800c504:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    int_posture = __get_interrupt_posture();
 800c506:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
 800c508:	b672      	cpsid	i
    return(int_posture);
 800c50a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
#endif

        /* Disable interrupts.  */
        TX_DISABLE
 800c50c:	657b      	str	r3, [r7, #84]	; 0x54
 800c50e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800c510:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c512:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c514:	f383 8810 	msr	PRIMASK, r3
}
 800c518:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the mutex list to resume any and all threads suspended
       on this mutex.  */
    while (suspended_count != ((ULONG) 0))
 800c51a:	e024      	b.n	800c566 <_tx_mutex_delete+0x10e>
    {

        /* Decrement the suspension count.  */
        suspended_count--;
 800c51c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c51e:	3b01      	subs	r3, #1
 800c520:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c522:	f3ef 8310 	mrs	r3, PRIMASK
 800c526:	61fb      	str	r3, [r7, #28]
    return(posture);
 800c528:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800c52a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c52c:	b672      	cpsid	i
    return(int_posture);
 800c52e:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 800c530:	657b      	str	r3, [r7, #84]	; 0x54

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c532:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c534:	2200      	movs	r2, #0
 800c536:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 800c538:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c53a:	2201      	movs	r2, #1
 800c53c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 800c540:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800c542:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c544:	63fb      	str	r3, [r7, #60]	; 0x3c
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 800c546:	4b18      	ldr	r3, [pc, #96]	; (800c5a8 <_tx_mutex_delete+0x150>)
 800c548:	681b      	ldr	r3, [r3, #0]
 800c54a:	3301      	adds	r3, #1
 800c54c:	4a16      	ldr	r2, [pc, #88]	; (800c5a8 <_tx_mutex_delete+0x150>)
 800c54e:	6013      	str	r3, [r2, #0]
 800c550:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800c552:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c554:	6a3b      	ldr	r3, [r7, #32]
 800c556:	f383 8810 	msr	PRIMASK, r3
}
 800c55a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 800c55c:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800c55e:	f001 fc2d 	bl	800ddbc <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 800c562:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c564:	653b      	str	r3, [r7, #80]	; 0x50
    while (suspended_count != ((ULONG) 0))
 800c566:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800c568:	2b00      	cmp	r3, #0
 800c56a:	d1d7      	bne.n	800c51c <_tx_mutex_delete+0xc4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c56c:	f3ef 8310 	mrs	r3, PRIMASK
 800c570:	613b      	str	r3, [r7, #16]
    return(posture);
 800c572:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800c574:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c576:	b672      	cpsid	i
    return(int_posture);
 800c578:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_MUTEX_DELETE_PORT_COMPLETION(mutex_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 800c57a:	657b      	str	r3, [r7, #84]	; 0x54

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 800c57c:	4b0a      	ldr	r3, [pc, #40]	; (800c5a8 <_tx_mutex_delete+0x150>)
 800c57e:	681b      	ldr	r3, [r3, #0]
 800c580:	3b01      	subs	r3, #1
 800c582:	4a09      	ldr	r2, [pc, #36]	; (800c5a8 <_tx_mutex_delete+0x150>)
 800c584:	6013      	str	r3, [r2, #0]
 800c586:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800c588:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c58a:	697b      	ldr	r3, [r7, #20]
 800c58c:	f383 8810 	msr	PRIMASK, r3
}
 800c590:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800c592:	f001 fbd9 	bl	800dd48 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800c596:	2300      	movs	r3, #0
}
 800c598:	4618      	mov	r0, r3
 800c59a:	3758      	adds	r7, #88	; 0x58
 800c59c:	46bd      	mov	sp, r7
 800c59e:	bd80      	pop	{r7, pc}
 800c5a0:	20006cf0 	.word	0x20006cf0
 800c5a4:	20006cec 	.word	0x20006cec
 800c5a8:	20006d9c 	.word	0x20006d9c

0800c5ac <_tx_mutex_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
 800c5ac:	b580      	push	{r7, lr}
 800c5ae:	b092      	sub	sp, #72	; 0x48
 800c5b0:	af00      	add	r7, sp, #0
 800c5b2:	6078      	str	r0, [r7, #4]
 800c5b4:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c5b6:	f3ef 8310 	mrs	r3, PRIMASK
 800c5ba:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800c5bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800c5be:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c5c0:	b672      	cpsid	i
    return(int_posture);
 800c5c2:	6a3b      	ldr	r3, [r7, #32]
TX_THREAD       *previous_thread;
UINT            status;


    /* Disable interrupts to get an instance from the mutex.  */
    TX_DISABLE
 800c5c4:	643b      	str	r3, [r7, #64]	; 0x40

    /* Log this kernel call.  */
    TX_EL_MUTEX_GET_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800c5c6:	4b7a      	ldr	r3, [pc, #488]	; (800c7b0 <_tx_mutex_get+0x204>)
 800c5c8:	681b      	ldr	r3, [r3, #0]
 800c5ca:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Determine if this mutex is available.  */
    if (mutex_ptr -> tx_mutex_ownership_count == ((UINT) 0))
 800c5cc:	687b      	ldr	r3, [r7, #4]
 800c5ce:	689b      	ldr	r3, [r3, #8]
 800c5d0:	2b00      	cmp	r3, #0
 800c5d2:	d144      	bne.n	800c65e <_tx_mutex_get+0xb2>
    {

        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 800c5d4:	687b      	ldr	r3, [r7, #4]
 800c5d6:	2201      	movs	r2, #1
 800c5d8:	609a      	str	r2, [r3, #8]

        /* Remember that the calling thread owns the mutex.  */
        mutex_ptr -> tx_mutex_owner =  thread_ptr;
 800c5da:	687b      	ldr	r3, [r7, #4]
 800c5dc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c5de:	60da      	str	r2, [r3, #12]

        /* Determine if the thread pointer is valid.  */
        if (thread_ptr != TX_NULL)
 800c5e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c5e2:	2b00      	cmp	r3, #0
 800c5e4:	d032      	beq.n	800c64c <_tx_mutex_get+0xa0>
        {

            /* Determine if priority inheritance is required.  */
            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800c5e6:	687b      	ldr	r3, [r7, #4]
 800c5e8:	691b      	ldr	r3, [r3, #16]
 800c5ea:	2b01      	cmp	r3, #1
 800c5ec:	d106      	bne.n	800c5fc <_tx_mutex_get+0x50>
            {

                /* Remember the current priority of thread.  */
                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
 800c5ee:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c5f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c5f2:	687b      	ldr	r3, [r7, #4]
 800c5f4:	615a      	str	r2, [r3, #20]

                /* Setup the highest priority waiting thread.  */
                mutex_ptr -> tx_mutex_highest_priority_waiting =  ((UINT) TX_MAX_PRIORITIES);
 800c5f6:	687b      	ldr	r3, [r7, #4]
 800c5f8:	2220      	movs	r2, #32
 800c5fa:	629a      	str	r2, [r3, #40]	; 0x28
            }

            /* Pickup next mutex pointer, which is the head of the list.  */
            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
 800c5fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c5fe:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800c602:	62fb      	str	r3, [r7, #44]	; 0x2c

            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
            if (next_mutex != TX_NULL)
 800c604:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c606:	2b00      	cmp	r3, #0
 800c608:	d00f      	beq.n	800c62a <_tx_mutex_get+0x7e>
            {

                /* Non-empty list. Link up the mutex.  */

                /* Pickup the next and previous mutex pointer.  */
                previous_mutex =  next_mutex -> tx_mutex_owned_previous;
 800c60a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c60c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c60e:	62bb      	str	r3, [r7, #40]	; 0x28

                /* Place the owned mutex in the list.  */
                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
 800c610:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c612:	687a      	ldr	r2, [r7, #4]
 800c614:	631a      	str	r2, [r3, #48]	; 0x30
                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
 800c616:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c618:	687a      	ldr	r2, [r7, #4]
 800c61a:	62da      	str	r2, [r3, #44]	; 0x2c

                /* Setup this mutex's next and previous created links.  */
                mutex_ptr -> tx_mutex_owned_previous =  previous_mutex;
 800c61c:	687b      	ldr	r3, [r7, #4]
 800c61e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c620:	631a      	str	r2, [r3, #48]	; 0x30
                mutex_ptr -> tx_mutex_owned_next =      next_mutex;
 800c622:	687b      	ldr	r3, [r7, #4]
 800c624:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c626:	62da      	str	r2, [r3, #44]	; 0x2c
 800c628:	e009      	b.n	800c63e <_tx_mutex_get+0x92>
            }
            else
            {

                /* The owned mutex list is empty.  Add mutex to empty list.  */
                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
 800c62a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c62c:	687a      	ldr	r2, [r7, #4]
 800c62e:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
 800c632:	687b      	ldr	r3, [r7, #4]
 800c634:	687a      	ldr	r2, [r7, #4]
 800c636:	62da      	str	r2, [r3, #44]	; 0x2c
                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
 800c638:	687b      	ldr	r3, [r7, #4]
 800c63a:	687a      	ldr	r2, [r7, #4]
 800c63c:	631a      	str	r2, [r3, #48]	; 0x30
            }

            /* Increment the number of mutexes owned counter.  */
            thread_ptr -> tx_thread_owned_mutex_count++;
 800c63e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c640:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800c644:	1c5a      	adds	r2, r3, #1
 800c646:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c648:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
 800c64c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c64e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c650:	69fb      	ldr	r3, [r7, #28]
 800c652:	f383 8810 	msr	PRIMASK, r3
}
 800c656:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
 800c658:	2300      	movs	r3, #0
 800c65a:	647b      	str	r3, [r7, #68]	; 0x44
 800c65c:	e0a2      	b.n	800c7a4 <_tx_mutex_get+0x1f8>
    }

    /* Otherwise, see if the owning thread is trying to obtain the same mutex.  */
    else if (mutex_ptr -> tx_mutex_owner == thread_ptr)
 800c65e:	687b      	ldr	r3, [r7, #4]
 800c660:	68db      	ldr	r3, [r3, #12]
 800c662:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c664:	429a      	cmp	r2, r3
 800c666:	d10d      	bne.n	800c684 <_tx_mutex_get+0xd8>
    {

        /* The owning thread is requesting the mutex again, just
           increment the ownership count.  */
        mutex_ptr -> tx_mutex_ownership_count++;
 800c668:	687b      	ldr	r3, [r7, #4]
 800c66a:	689b      	ldr	r3, [r3, #8]
 800c66c:	1c5a      	adds	r2, r3, #1
 800c66e:	687b      	ldr	r3, [r7, #4]
 800c670:	609a      	str	r2, [r3, #8]
 800c672:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c674:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c676:	69bb      	ldr	r3, [r7, #24]
 800c678:	f383 8810 	msr	PRIMASK, r3
}
 800c67c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
 800c67e:	2300      	movs	r3, #0
 800c680:	647b      	str	r3, [r7, #68]	; 0x44
 800c682:	e08f      	b.n	800c7a4 <_tx_mutex_get+0x1f8>
    }
    else
    {

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
 800c684:	683b      	ldr	r3, [r7, #0]
 800c686:	2b00      	cmp	r3, #0
 800c688:	f000 8084 	beq.w	800c794 <_tx_mutex_get+0x1e8>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
 800c68c:	4b49      	ldr	r3, [pc, #292]	; (800c7b4 <_tx_mutex_get+0x208>)
 800c68e:	681b      	ldr	r3, [r3, #0]
 800c690:	2b00      	cmp	r3, #0
 800c692:	d008      	beq.n	800c6a6 <_tx_mutex_get+0xfa>
 800c694:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c696:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c698:	697b      	ldr	r3, [r7, #20]
 800c69a:	f383 8810 	msr	PRIMASK, r3
}
 800c69e:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
                status =  TX_NOT_AVAILABLE;
 800c6a0:	231d      	movs	r3, #29
 800c6a2:	647b      	str	r3, [r7, #68]	; 0x44
 800c6a4:	e07e      	b.n	800c7a4 <_tx_mutex_get+0x1f8>
            {

                /* Prepare for suspension of this thread.  */

                /* Pickup the mutex owner.  */
                mutex_owner =  mutex_ptr -> tx_mutex_owner;
 800c6a6:	687b      	ldr	r3, [r7, #4]
 800c6a8:	68db      	ldr	r3, [r3, #12]
 800c6aa:	63bb      	str	r3, [r7, #56]	; 0x38
#endif
                }
#endif

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_mutex_cleanup);
 800c6ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c6ae:	4a42      	ldr	r2, [pc, #264]	; (800c7b8 <_tx_mutex_get+0x20c>)
 800c6b0:	669a      	str	r2, [r3, #104]	; 0x68

                /* Setup cleanup information, i.e. this mutex control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) mutex_ptr;
 800c6b2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c6b4:	687a      	ldr	r2, [r7, #4]
 800c6b6:	66da      	str	r2, [r3, #108]	; 0x6c

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
 800c6b8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c6ba:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800c6be:	1c5a      	adds	r2, r3, #1
 800c6c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c6c2:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
#endif

                /* Setup suspension list.  */
                if (mutex_ptr -> tx_mutex_suspended_count == TX_NO_SUSPENSIONS)
 800c6c6:	687b      	ldr	r3, [r7, #4]
 800c6c8:	69db      	ldr	r3, [r3, #28]
 800c6ca:	2b00      	cmp	r3, #0
 800c6cc:	d109      	bne.n	800c6e2 <_tx_mutex_get+0x136>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    mutex_ptr -> tx_mutex_suspension_list =         thread_ptr;
 800c6ce:	687b      	ldr	r3, [r7, #4]
 800c6d0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c6d2:	619a      	str	r2, [r3, #24]
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
 800c6d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c6d6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c6d8:	671a      	str	r2, [r3, #112]	; 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 800c6da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c6dc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c6de:	675a      	str	r2, [r3, #116]	; 0x74
 800c6e0:	e011      	b.n	800c706 <_tx_mutex_get+0x15a>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   mutex_ptr -> tx_mutex_suspension_list;
 800c6e2:	687b      	ldr	r3, [r7, #4]
 800c6e4:	699b      	ldr	r3, [r3, #24]
 800c6e6:	637b      	str	r3, [r7, #52]	; 0x34
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
 800c6e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c6ea:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800c6ec:	671a      	str	r2, [r3, #112]	; 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 800c6ee:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c6f0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c6f2:	633b      	str	r3, [r7, #48]	; 0x30
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 800c6f4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c6f6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800c6f8:	675a      	str	r2, [r3, #116]	; 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 800c6fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c6fc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c6fe:	671a      	str	r2, [r3, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 800c700:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c702:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c704:	675a      	str	r2, [r3, #116]	; 0x74
                }

                /* Increment the suspension count.  */
                mutex_ptr -> tx_mutex_suspended_count++;
 800c706:	687b      	ldr	r3, [r7, #4]
 800c708:	69db      	ldr	r3, [r3, #28]
 800c70a:	1c5a      	adds	r2, r3, #1
 800c70c:	687b      	ldr	r3, [r7, #4]
 800c70e:	61da      	str	r2, [r3, #28]

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =    TX_MUTEX_SUSP;
 800c710:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c712:	220d      	movs	r2, #13
 800c714:	631a      	str	r2, [r3, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c716:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c718:	2201      	movs	r2, #1
 800c71a:	639a      	str	r2, [r3, #56]	; 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 800c71c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c71e:	683a      	ldr	r2, [r7, #0]
 800c720:	64da      	str	r2, [r3, #76]	; 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
 800c722:	4b24      	ldr	r3, [pc, #144]	; (800c7b4 <_tx_mutex_get+0x208>)
 800c724:	681b      	ldr	r3, [r3, #0]
 800c726:	3301      	adds	r3, #1
 800c728:	4a22      	ldr	r2, [pc, #136]	; (800c7b4 <_tx_mutex_get+0x208>)
 800c72a:	6013      	str	r3, [r2, #0]
 800c72c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c72e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c730:	693b      	ldr	r3, [r7, #16]
 800c732:	f383 8810 	msr	PRIMASK, r3
}
 800c736:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if we need to raise the priority of the thread
                   owning the mutex.  */
                if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800c738:	687b      	ldr	r3, [r7, #4]
 800c73a:	691b      	ldr	r3, [r3, #16]
 800c73c:	2b01      	cmp	r3, #1
 800c73e:	d121      	bne.n	800c784 <_tx_mutex_get+0x1d8>
                {

                    /* Determine if this is the highest priority to raise for this mutex.  */
                    if (mutex_ptr -> tx_mutex_highest_priority_waiting > thread_ptr -> tx_thread_priority)
 800c740:	687b      	ldr	r3, [r7, #4]
 800c742:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800c744:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c746:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c748:	429a      	cmp	r2, r3
 800c74a:	d903      	bls.n	800c754 <_tx_mutex_get+0x1a8>
                    {

                        /* Remember this priority.  */
                        mutex_ptr -> tx_mutex_highest_priority_waiting =  thread_ptr -> tx_thread_priority;
 800c74c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c74e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c750:	687b      	ldr	r3, [r7, #4]
 800c752:	629a      	str	r2, [r3, #40]	; 0x28
                    }

                    /* Determine if we have to update inherit priority level of the mutex owner.  */
                    if (thread_ptr -> tx_thread_priority < mutex_owner -> tx_thread_inherit_priority)
 800c754:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c756:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c758:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c75a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800c75e:	429a      	cmp	r2, r3
 800c760:	d204      	bcs.n	800c76c <_tx_mutex_get+0x1c0>
                    {

                        /* Remember the new priority inheritance priority.  */
                        mutex_owner -> tx_thread_inherit_priority =  thread_ptr -> tx_thread_priority;
 800c762:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c764:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c766:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c768:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
                    }

                    /* Priority inheritance is requested, check to see if the thread that owns the mutex is lower priority.  */
                    if (mutex_owner -> tx_thread_priority > thread_ptr -> tx_thread_priority)
 800c76c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c76e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c770:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c772:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c774:	429a      	cmp	r2, r3
 800c776:	d905      	bls.n	800c784 <_tx_mutex_get+0x1d8>
                    {

                        /* Yes, raise the suspended, owning thread's priority to that
                           of the current thread.  */
                        _tx_mutex_priority_change(mutex_owner, thread_ptr -> tx_thread_priority);
 800c778:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c77a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c77c:	4619      	mov	r1, r3
 800c77e:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800c780:	f000 f8ce 	bl	800c920 <_tx_mutex_priority_change>
#endif
                    }
                }

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 800c784:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800c786:	f001 fc19 	bl	800dfbc <_tx_thread_system_suspend>
#endif
                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
 800c78a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c78c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800c790:	647b      	str	r3, [r7, #68]	; 0x44
 800c792:	e007      	b.n	800c7a4 <_tx_mutex_get+0x1f8>
 800c794:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c796:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c798:	68fb      	ldr	r3, [r7, #12]
 800c79a:	f383 8810 	msr	PRIMASK, r3
}
 800c79e:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NOT_AVAILABLE;
 800c7a0:	231d      	movs	r3, #29
 800c7a2:	647b      	str	r3, [r7, #68]	; 0x44
        }
    }

    /* Return completion status.  */
    return(status);
 800c7a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
 800c7a6:	4618      	mov	r0, r3
 800c7a8:	3748      	adds	r7, #72	; 0x48
 800c7aa:	46bd      	mov	sp, r7
 800c7ac:	bd80      	pop	{r7, pc}
 800c7ae:	bf00      	nop
 800c7b0:	20006d04 	.word	0x20006d04
 800c7b4:	20006d9c 	.word	0x20006d9c
 800c7b8:	0800c225 	.word	0x0800c225

0800c7bc <_tx_mutex_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_prioritize(TX_MUTEX *mutex_ptr)
{
 800c7bc:	b580      	push	{r7, lr}
 800c7be:	b092      	sub	sp, #72	; 0x48
 800c7c0:	af00      	add	r7, sp, #0
 800c7c2:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c7c4:	f3ef 8310 	mrs	r3, PRIMASK
 800c7c8:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800c7ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800c7cc:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c7ce:	b672      	cpsid	i
    return(int_posture);
 800c7d0:	6a3b      	ldr	r3, [r7, #32]
UINT            status;
#endif


    /* Disable interrupts.  */
    TX_DISABLE
 800c7d2:	647b      	str	r3, [r7, #68]	; 0x44

    /* Log this kernel call.  */
    TX_EL_MUTEX_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 800c7d4:	687b      	ldr	r3, [r7, #4]
 800c7d6:	69db      	ldr	r3, [r3, #28]
 800c7d8:	637b      	str	r3, [r7, #52]	; 0x34

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
 800c7da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c7dc:	2b01      	cmp	r3, #1
 800c7de:	d805      	bhi.n	800c7ec <_tx_mutex_prioritize+0x30>
 800c7e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c7e2:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c7e4:	69fb      	ldr	r3, [r7, #28]
 800c7e6:	f383 8810 	msr	PRIMASK, r3
}
 800c7ea:	e092      	b.n	800c912 <_tx_mutex_prioritize+0x156>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this mutex.  */
    else if (suspended_count == ((UINT) 2))
 800c7ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800c7ee:	2b02      	cmp	r3, #2
 800c7f0:	d114      	bne.n	800c81c <_tx_mutex_prioritize+0x60>
    {

        /* Pickup the head pointer and the next pointer.  */
        head_ptr =  mutex_ptr -> tx_mutex_suspension_list;
 800c7f2:	687b      	ldr	r3, [r7, #4]
 800c7f4:	699b      	ldr	r3, [r3, #24]
 800c7f6:	63bb      	str	r3, [r7, #56]	; 0x38
        next_thread =  head_ptr -> tx_thread_suspended_next;
 800c7f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c7fa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c7fc:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Determine if the next suspended thread has a higher priority.  */
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
 800c7fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c800:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c802:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c804:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c806:	429a      	cmp	r2, r3
 800c808:	d202      	bcs.n	800c810 <_tx_mutex_prioritize+0x54>
        {

            /* Yes, move the list head to the next thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  next_thread;
 800c80a:	687b      	ldr	r3, [r7, #4]
 800c80c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c80e:	619a      	str	r2, [r3, #24]
 800c810:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c812:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c814:	69bb      	ldr	r3, [r7, #24]
 800c816:	f383 8810 	msr	PRIMASK, r3
}
 800c81a:	e07a      	b.n	800c912 <_tx_mutex_prioritize+0x156>
    }
    else
    {

        /* Remember the suspension count and head pointer.  */
        head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
 800c81c:	687b      	ldr	r3, [r7, #4]
 800c81e:	699b      	ldr	r3, [r3, #24]
 800c820:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Default the highest priority thread to the thread at the front of the list.  */
        priority_thread_ptr =  head_ptr;
 800c822:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c824:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 800c826:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c828:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c82a:	643b      	str	r3, [r7, #64]	; 0x40

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 800c82c:	4b3b      	ldr	r3, [pc, #236]	; (800c91c <_tx_mutex_prioritize+0x160>)
 800c82e:	681b      	ldr	r3, [r3, #0]
 800c830:	3301      	adds	r3, #1
 800c832:	4a3a      	ldr	r2, [pc, #232]	; (800c91c <_tx_mutex_prioritize+0x160>)
 800c834:	6013      	str	r3, [r2, #0]

        /* Set the list changed flag to false.  */
        list_changed =  TX_FALSE;
 800c836:	2300      	movs	r3, #0
 800c838:	633b      	str	r3, [r7, #48]	; 0x30
        /* Search through the list to find the highest priority thread.  */
        do
        {

            /* Is the current thread higher priority?  */
            if (thread_ptr -> tx_thread_priority < priority_thread_ptr -> tx_thread_priority)
 800c83a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c83c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c83e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c840:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c842:	429a      	cmp	r2, r3
 800c844:	d201      	bcs.n	800c84a <_tx_mutex_prioritize+0x8e>
            {

                /* Yes, remember that this thread is the highest priority.  */
                priority_thread_ptr =  thread_ptr;
 800c846:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c848:	63fb      	str	r3, [r7, #60]	; 0x3c
 800c84a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c84c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c84e:	68fb      	ldr	r3, [r7, #12]
 800c850:	f383 8810 	msr	PRIMASK, r3
}
 800c854:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c856:	f3ef 8310 	mrs	r3, PRIMASK
 800c85a:	617b      	str	r3, [r7, #20]
    return(posture);
 800c85c:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800c85e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c860:	b672      	cpsid	i
    return(int_posture);
 800c862:	693b      	ldr	r3, [r7, #16]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
 800c864:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if any changes to the list have occurred while
               interrupts were enabled.  */

            /* Is the list head the same?  */
            if (head_ptr != mutex_ptr -> tx_mutex_suspension_list)
 800c866:	687b      	ldr	r3, [r7, #4]
 800c868:	699b      	ldr	r3, [r3, #24]
 800c86a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c86c:	429a      	cmp	r2, r3
 800c86e:	d002      	beq.n	800c876 <_tx_mutex_prioritize+0xba>
            {

                /* The list head has changed, set the list changed flag.  */
                list_changed =  TX_TRUE;
 800c870:	2301      	movs	r3, #1
 800c872:	633b      	str	r3, [r7, #48]	; 0x30
 800c874:	e006      	b.n	800c884 <_tx_mutex_prioritize+0xc8>
            }
            else
            {

                /* Is the suspended count the same?  */
                if (suspended_count != mutex_ptr -> tx_mutex_suspended_count)
 800c876:	687b      	ldr	r3, [r7, #4]
 800c878:	69db      	ldr	r3, [r3, #28]
 800c87a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800c87c:	429a      	cmp	r2, r3
 800c87e:	d001      	beq.n	800c884 <_tx_mutex_prioritize+0xc8>
                {

                    /* The list head has changed, set the list changed flag.  */
                    list_changed =  TX_TRUE;
 800c880:	2301      	movs	r3, #1
 800c882:	633b      	str	r3, [r7, #48]	; 0x30
                }
            }

            /* Determine if the list has changed.  */
            if (list_changed == TX_FALSE)
 800c884:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800c886:	2b00      	cmp	r3, #0
 800c888:	d103      	bne.n	800c892 <_tx_mutex_prioritize+0xd6>
            {

                /* Move the thread pointer to the next thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800c88a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800c88c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c88e:	643b      	str	r3, [r7, #64]	; 0x40
 800c890:	e00c      	b.n	800c8ac <_tx_mutex_prioritize+0xf0>
            }
            else
            {

                /* Remember the suspension count and head pointer.  */
                head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
 800c892:	687b      	ldr	r3, [r7, #4]
 800c894:	699b      	ldr	r3, [r3, #24]
 800c896:	63bb      	str	r3, [r7, #56]	; 0x38
                suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 800c898:	687b      	ldr	r3, [r7, #4]
 800c89a:	69db      	ldr	r3, [r3, #28]
 800c89c:	637b      	str	r3, [r7, #52]	; 0x34

                /* Default the highest priority thread to the thread at the front of the list.  */
                priority_thread_ptr =  head_ptr;
 800c89e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c8a0:	63fb      	str	r3, [r7, #60]	; 0x3c

                /* Setup search pointer.  */
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 800c8a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c8a4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c8a6:	643b      	str	r3, [r7, #64]	; 0x40

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
 800c8a8:	2300      	movs	r3, #0
 800c8aa:	633b      	str	r3, [r7, #48]	; 0x30
            }

        } while (thread_ptr != head_ptr);
 800c8ac:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800c8ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c8b0:	429a      	cmp	r2, r3
 800c8b2:	d1c2      	bne.n	800c83a <_tx_mutex_prioritize+0x7e>

        /* Release preemption.  */
        _tx_thread_preempt_disable--;
 800c8b4:	4b19      	ldr	r3, [pc, #100]	; (800c91c <_tx_mutex_prioritize+0x160>)
 800c8b6:	681b      	ldr	r3, [r3, #0]
 800c8b8:	3b01      	subs	r3, #1
 800c8ba:	4a18      	ldr	r2, [pc, #96]	; (800c91c <_tx_mutex_prioritize+0x160>)
 800c8bc:	6013      	str	r3, [r2, #0]

        /* Now determine if the highest priority thread is at the front
           of the list.  */
        if (priority_thread_ptr != head_ptr)
 800c8be:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c8c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c8c2:	429a      	cmp	r2, r3
 800c8c4:	d01d      	beq.n	800c902 <_tx_mutex_prioritize+0x146>
            /* No, we need to move the highest priority suspended thread to the
               front of the list.  */

            /* First, remove the highest priority thread by updating the
               adjacent suspended threads.  */
            next_thread =                                  priority_thread_ptr -> tx_thread_suspended_next;
 800c8c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c8c8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800c8ca:	62fb      	str	r3, [r7, #44]	; 0x2c
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
 800c8cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c8ce:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c8d0:	62bb      	str	r3, [r7, #40]	; 0x28
            next_thread -> tx_thread_suspended_previous =  previous_thread;
 800c8d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c8d4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c8d6:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
 800c8d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c8da:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c8dc:	671a      	str	r2, [r3, #112]	; 0x70

            /* Now, link the highest priority thread at the front of the list.  */
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
 800c8de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c8e0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800c8e2:	62bb      	str	r3, [r7, #40]	; 0x28
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
 800c8e4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c8e6:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800c8e8:	671a      	str	r2, [r3, #112]	; 0x70
            priority_thread_ptr -> tx_thread_suspended_previous =  previous_thread;
 800c8ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c8ec:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800c8ee:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
 800c8f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c8f2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c8f4:	671a      	str	r2, [r3, #112]	; 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
 800c8f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c8f8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c8fa:	675a      	str	r2, [r3, #116]	; 0x74

            /* Move the list head pointer to the highest priority suspended thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  priority_thread_ptr;
 800c8fc:	687b      	ldr	r3, [r7, #4]
 800c8fe:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800c900:	619a      	str	r2, [r3, #24]
 800c902:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800c904:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c906:	68bb      	ldr	r3, [r7, #8]
 800c908:	f383 8810 	msr	PRIMASK, r3
}
 800c90c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800c90e:	f001 fa1b 	bl	800dd48 <_tx_thread_system_preempt_check>
    /* Return completion status.  */
    return(status);
#else

    /* Return successful completion.  */
    return(TX_SUCCESS);
 800c912:	2300      	movs	r3, #0
#endif
}
 800c914:	4618      	mov	r0, r3
 800c916:	3748      	adds	r7, #72	; 0x48
 800c918:	46bd      	mov	sp, r7
 800c91a:	bd80      	pop	{r7, pc}
 800c91c:	20006d9c 	.word	0x20006d9c

0800c920 <_tx_mutex_priority_change>:
/*                                            priority rather than next,  */
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_priority_change(TX_THREAD *thread_ptr, UINT new_priority)
{
 800c920:	b580      	push	{r7, lr}
 800c922:	b090      	sub	sp, #64	; 0x40
 800c924:	af00      	add	r7, sp, #0
 800c926:	6078      	str	r0, [r7, #4]
 800c928:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c92a:	f3ef 8310 	mrs	r3, PRIMASK
 800c92e:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800c930:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800c932:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800c934:	b672      	cpsid	i
    return(int_posture);
 800c936:	6abb      	ldr	r3, [r7, #40]	; 0x28


#ifndef TX_NOT_INTERRUPTABLE

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
 800c938:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif

    /* Determine if this thread is currently ready.  */
    if (thread_ptr -> tx_thread_state != TX_READY)
 800c93a:	687b      	ldr	r3, [r7, #4]
 800c93c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800c93e:	2b00      	cmp	r3, #0
 800c940:	d017      	beq.n	800c972 <_tx_mutex_priority_change+0x52>
    {

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
 800c942:	687b      	ldr	r3, [r7, #4]
 800c944:	683a      	ldr	r2, [r7, #0]
 800c946:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
 800c948:	687b      	ldr	r3, [r7, #4]
 800c94a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800c94e:	683a      	ldr	r2, [r7, #0]
 800c950:	429a      	cmp	r2, r3
 800c952:	d905      	bls.n	800c960 <_tx_mutex_priority_change+0x40>
        {

            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 800c954:	687b      	ldr	r3, [r7, #4]
 800c956:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 800c95a:	687b      	ldr	r3, [r7, #4]
 800c95c:	63da      	str	r2, [r3, #60]	; 0x3c
 800c95e:	e002      	b.n	800c966 <_tx_mutex_priority_change+0x46>
        }
        else
        {

            /* Change the thread preemption-threshold to the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
 800c960:	687b      	ldr	r3, [r7, #4]
 800c962:	683a      	ldr	r2, [r7, #0]
 800c964:	63da      	str	r2, [r3, #60]	; 0x3c
 800c966:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c968:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c96a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c96c:	f383 8810 	msr	PRIMASK, r3
}
 800c970:	e089      	b.n	800ca86 <_tx_mutex_priority_change+0x166>
    }
    else
    {

        /* Pickup the next thread to execute.  */
        execute_ptr =  _tx_thread_execute_ptr;
 800c972:	4b47      	ldr	r3, [pc, #284]	; (800ca90 <_tx_mutex_priority_change+0x170>)
 800c974:	681b      	ldr	r3, [r3, #0]
 800c976:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Save the original priority.  */
        original_priority =  thread_ptr -> tx_thread_priority;
 800c978:	687b      	ldr	r3, [r7, #4]
 800c97a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c97c:	637b      	str	r3, [r7, #52]	; 0x34
        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
#else

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 2);
 800c97e:	4b45      	ldr	r3, [pc, #276]	; (800ca94 <_tx_mutex_priority_change+0x174>)
 800c980:	681b      	ldr	r3, [r3, #0]
 800c982:	3302      	adds	r3, #2
 800c984:	4a43      	ldr	r2, [pc, #268]	; (800ca94 <_tx_mutex_priority_change+0x174>)
 800c986:	6013      	str	r3, [r2, #0]

        /* Set the state to priority change.  */
        thread_ptr -> tx_thread_state =    TX_PRIORITY_CHANGE;
 800c988:	687b      	ldr	r3, [r7, #4]
 800c98a:	220e      	movs	r2, #14
 800c98c:	631a      	str	r2, [r3, #48]	; 0x30

        /* Set the suspending flag. */
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c98e:	687b      	ldr	r3, [r7, #4]
 800c990:	2201      	movs	r2, #1
 800c992:	639a      	str	r2, [r3, #56]	; 0x38

        /* Setup the timeout period.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800c994:	687b      	ldr	r3, [r7, #4]
 800c996:	2200      	movs	r2, #0
 800c998:	64da      	str	r2, [r3, #76]	; 0x4c
 800c99a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c99c:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c99e:	69bb      	ldr	r3, [r7, #24]
 800c9a0:	f383 8810 	msr	PRIMASK, r3
}
 800c9a4:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* The thread is ready and must first be removed from the list.  Call the
           system suspend function to accomplish this.  */
        _tx_thread_system_suspend(thread_ptr);
 800c9a6:	6878      	ldr	r0, [r7, #4]
 800c9a8:	f001 fb08 	bl	800dfbc <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c9ac:	f3ef 8310 	mrs	r3, PRIMASK
 800c9b0:	623b      	str	r3, [r7, #32]
    return(posture);
 800c9b2:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800c9b4:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c9b6:	b672      	cpsid	i
    return(int_posture);
 800c9b8:	69fb      	ldr	r3, [r7, #28]

        /* Disable interrupts.  */
        TX_DISABLE
 800c9ba:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* At this point, the preempt disable flag is still set, so we still have
           protection against all preemption.  */

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
 800c9bc:	687b      	ldr	r3, [r7, #4]
 800c9be:	683a      	ldr	r2, [r7, #0]
 800c9c0:	62da      	str	r2, [r3, #44]	; 0x2c

        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
 800c9c2:	687b      	ldr	r3, [r7, #4]
 800c9c4:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 800c9c8:	683a      	ldr	r2, [r7, #0]
 800c9ca:	429a      	cmp	r2, r3
 800c9cc:	d905      	bls.n	800c9da <_tx_mutex_priority_change+0xba>
        {

            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 800c9ce:	687b      	ldr	r3, [r7, #4]
 800c9d0:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 800c9d4:	687b      	ldr	r3, [r7, #4]
 800c9d6:	63da      	str	r2, [r3, #60]	; 0x3c
 800c9d8:	e002      	b.n	800c9e0 <_tx_mutex_priority_change+0xc0>
        }
        else
        {

            /* Change the thread preemption-threshold to the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
 800c9da:	687b      	ldr	r3, [r7, #4]
 800c9dc:	683a      	ldr	r2, [r7, #0]
 800c9de:	63da      	str	r2, [r3, #60]	; 0x3c
 800c9e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800c9e2:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800c9e4:	68fb      	ldr	r3, [r7, #12]
 800c9e6:	f383 8810 	msr	PRIMASK, r3
}
 800c9ea:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread with the new priority.  */
        _tx_thread_system_resume(thread_ptr);
 800c9ec:	6878      	ldr	r0, [r7, #4]
 800c9ee:	f001 f9e5 	bl	800ddbc <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800c9f2:	f3ef 8310 	mrs	r3, PRIMASK
 800c9f6:	617b      	str	r3, [r7, #20]
    return(posture);
 800c9f8:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800c9fa:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800c9fc:	b672      	cpsid	i
    return(int_posture);
 800c9fe:	693b      	ldr	r3, [r7, #16]
        TX_MUTEX_PRIORITY_CHANGE_EXTENSION

#ifndef TX_NOT_INTERRUPTABLE

        /* Disable interrupts.  */
        TX_DISABLE
 800ca00:	63fb      	str	r3, [r7, #60]	; 0x3c
#endif

        /* Pickup the next thread to execute.  */
        next_execute_ptr =  _tx_thread_execute_ptr;
 800ca02:	4b23      	ldr	r3, [pc, #140]	; (800ca90 <_tx_mutex_priority_change+0x170>)
 800ca04:	681b      	ldr	r3, [r3, #0]
 800ca06:	633b      	str	r3, [r7, #48]	; 0x30

        /* Determine if this thread is not the next thread to execute.  */
        if (thread_ptr != next_execute_ptr)
 800ca08:	687a      	ldr	r2, [r7, #4]
 800ca0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ca0c:	429a      	cmp	r2, r3
 800ca0e:	d034      	beq.n	800ca7a <_tx_mutex_priority_change+0x15a>
        {

            /* Make sure the thread is still ready.  */
            if (thread_ptr -> tx_thread_state == TX_READY)
 800ca10:	687b      	ldr	r3, [r7, #4]
 800ca12:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ca14:	2b00      	cmp	r3, #0
 800ca16:	d130      	bne.n	800ca7a <_tx_mutex_priority_change+0x15a>
            {

                /* Now check and see if this thread has an equal or higher priority.  */
                if (thread_ptr -> tx_thread_priority <= next_execute_ptr -> tx_thread_priority)
 800ca18:	687b      	ldr	r3, [r7, #4]
 800ca1a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ca1c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ca1e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ca20:	429a      	cmp	r2, r3
 800ca22:	d811      	bhi.n	800ca48 <_tx_mutex_priority_change+0x128>
                {

                    /* Now determine if this thread was the previously executing thread.  */
                    if (thread_ptr == execute_ptr)
 800ca24:	687a      	ldr	r2, [r7, #4]
 800ca26:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ca28:	429a      	cmp	r2, r3
 800ca2a:	d126      	bne.n	800ca7a <_tx_mutex_priority_change+0x15a>

                        /* Yes, this thread was previously executing before we temporarily suspended and resumed
                           it in order to change the priority. A lower or same priority thread cannot be the next thread
                           to execute in this case since this thread really didn't suspend.  Simply reset the execute
                           pointer to this thread.  */
                        _tx_thread_execute_ptr =  thread_ptr;
 800ca2c:	4a18      	ldr	r2, [pc, #96]	; (800ca90 <_tx_mutex_priority_change+0x170>)
 800ca2e:	687b      	ldr	r3, [r7, #4]
 800ca30:	6013      	str	r3, [r2, #0]

                        /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                        if (original_priority < new_priority)
 800ca32:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ca34:	683b      	ldr	r3, [r7, #0]
 800ca36:	429a      	cmp	r2, r3
 800ca38:	d21f      	bcs.n	800ca7a <_tx_mutex_priority_change+0x15a>
                        {

                            /* Ensure that this thread is placed at the front of the priority list.  */
                            _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
 800ca3a:	687b      	ldr	r3, [r7, #4]
 800ca3c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ca3e:	4916      	ldr	r1, [pc, #88]	; (800ca98 <_tx_mutex_priority_change+0x178>)
 800ca40:	687a      	ldr	r2, [r7, #4]
 800ca42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 800ca46:	e018      	b.n	800ca7a <_tx_mutex_priority_change+0x15a>
                }
                else
                {

                    /* Now determine if this thread's preemption-threshold needs to be enforced.  */
                    if (thread_ptr -> tx_thread_preempt_threshold < thread_ptr -> tx_thread_priority)
 800ca48:	687b      	ldr	r3, [r7, #4]
 800ca4a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800ca4c:	687b      	ldr	r3, [r7, #4]
 800ca4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ca50:	429a      	cmp	r2, r3
 800ca52:	d212      	bcs.n	800ca7a <_tx_mutex_priority_change+0x15a>
                    {

                        /* Yes, preemption-threshold is in force for this thread. */

                        /* Compare the next thread to execute thread's priority against the thread's preemption-threshold.  */
                        if (thread_ptr -> tx_thread_preempt_threshold <= next_execute_ptr -> tx_thread_priority)
 800ca54:	687b      	ldr	r3, [r7, #4]
 800ca56:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800ca58:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ca5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ca5c:	429a      	cmp	r2, r3
 800ca5e:	d80c      	bhi.n	800ca7a <_tx_mutex_priority_change+0x15a>
                        {

                            /* We must swap execute pointers to enforce the preemption-threshold of a thread coming out of
                               priority inheritance.  */
                            _tx_thread_execute_ptr =  thread_ptr;
 800ca60:	4a0b      	ldr	r2, [pc, #44]	; (800ca90 <_tx_mutex_priority_change+0x170>)
 800ca62:	687b      	ldr	r3, [r7, #4]
 800ca64:	6013      	str	r3, [r2, #0]

                            /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                            if (original_priority < new_priority)
 800ca66:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ca68:	683b      	ldr	r3, [r7, #0]
 800ca6a:	429a      	cmp	r2, r3
 800ca6c:	d205      	bcs.n	800ca7a <_tx_mutex_priority_change+0x15a>
                            {

                                /* Ensure that this thread is placed at the front of the priority list.  */
                                _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
 800ca6e:	687b      	ldr	r3, [r7, #4]
 800ca70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ca72:	4909      	ldr	r1, [pc, #36]	; (800ca98 <_tx_mutex_priority_change+0x178>)
 800ca74:	687a      	ldr	r2, [r7, #4]
 800ca76:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 800ca7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ca7c:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ca7e:	68bb      	ldr	r3, [r7, #8]
 800ca80:	f383 8810 	msr	PRIMASK, r3
}
 800ca84:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
 800ca86:	bf00      	nop
 800ca88:	3740      	adds	r7, #64	; 0x40
 800ca8a:	46bd      	mov	sp, r7
 800ca8c:	bd80      	pop	{r7, pc}
 800ca8e:	bf00      	nop
 800ca90:	20006d08 	.word	0x20006d08
 800ca94:	20006d9c 	.word	0x20006d9c
 800ca98:	20006d1c 	.word	0x20006d1c

0800ca9c <_tx_mutex_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_put(TX_MUTEX *mutex_ptr)
{
 800ca9c:	b580      	push	{r7, lr}
 800ca9e:	b0a6      	sub	sp, #152	; 0x98
 800caa0:	af00      	add	r7, sp, #0
 800caa2:	6078      	str	r0, [r7, #4]
TX_THREAD       *suspended_thread;
UINT            inheritance_priority;


    /* Setup status to indicate the processing is not complete.  */
    status =  TX_NOT_DONE;
 800caa4:	2320      	movs	r3, #32
 800caa6:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800caaa:	f3ef 8310 	mrs	r3, PRIMASK
 800caae:	65fb      	str	r3, [r7, #92]	; 0x5c
    return(posture);
 800cab0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    int_posture = __get_interrupt_posture();
 800cab2:	65bb      	str	r3, [r7, #88]	; 0x58
    __asm__ volatile ("CPSID i" : : : "memory");
 800cab4:	b672      	cpsid	i
    return(int_posture);
 800cab6:	6dbb      	ldr	r3, [r7, #88]	; 0x58

    /* Disable interrupts to put an instance back to the mutex.  */
    TX_DISABLE
 800cab8:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    /* Log this kernel call.  */
    TX_EL_MUTEX_PUT_INSERT

    /* Determine if this mutex is owned.  */
    if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
 800cabc:	687b      	ldr	r3, [r7, #4]
 800cabe:	689b      	ldr	r3, [r3, #8]
 800cac0:	2b00      	cmp	r3, #0
 800cac2:	f000 81ff 	beq.w	800cec4 <_tx_mutex_put+0x428>
    {

        /* Pickup the owning thread pointer.  */
        thread_ptr =  mutex_ptr -> tx_mutex_owner;
 800cac6:	687b      	ldr	r3, [r7, #4]
 800cac8:	68db      	ldr	r3, [r3, #12]
 800caca:	67fb      	str	r3, [r7, #124]	; 0x7c

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
 800cacc:	4ba3      	ldr	r3, [pc, #652]	; (800cd5c <_tx_mutex_put+0x2c0>)
 800cace:	681b      	ldr	r3, [r3, #0]
 800cad0:	67bb      	str	r3, [r7, #120]	; 0x78

        /* Check to see if the mutex is owned by the calling thread.  */
        if (mutex_ptr -> tx_mutex_owner != current_thread)
 800cad2:	687b      	ldr	r3, [r7, #4]
 800cad4:	68db      	ldr	r3, [r3, #12]
 800cad6:	6fba      	ldr	r2, [r7, #120]	; 0x78
 800cad8:	429a      	cmp	r2, r3
 800cada:	d00d      	beq.n	800caf8 <_tx_mutex_put+0x5c>
        {

            /* Determine if the preempt disable flag is set, indicating that
               the caller is not the application but from ThreadX. In such
               cases, the thread mutex owner does not need to match.  */
            if (_tx_thread_preempt_disable == ((UINT) 0))
 800cadc:	4ba0      	ldr	r3, [pc, #640]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800cade:	681b      	ldr	r3, [r3, #0]
 800cae0:	2b00      	cmp	r3, #0
 800cae2:	d109      	bne.n	800caf8 <_tx_mutex_put+0x5c>
 800cae4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800cae8:	657b      	str	r3, [r7, #84]	; 0x54
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800caea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800caec:	f383 8810 	msr	PRIMASK, r3
}
 800caf0:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Caller does not own the mutex.  */
                status =  TX_NOT_OWNED;
 800caf2:	231e      	movs	r3, #30
 800caf4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
            }
        }

        /* Determine if we should continue.  */
        if (status == TX_NOT_DONE)
 800caf8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800cafc:	2b20      	cmp	r3, #32
 800cafe:	f040 81eb 	bne.w	800ced8 <_tx_mutex_put+0x43c>
        {

            /* Decrement the mutex ownership count.  */
            mutex_ptr -> tx_mutex_ownership_count--;
 800cb02:	687b      	ldr	r3, [r7, #4]
 800cb04:	689b      	ldr	r3, [r3, #8]
 800cb06:	1e5a      	subs	r2, r3, #1
 800cb08:	687b      	ldr	r3, [r7, #4]
 800cb0a:	609a      	str	r2, [r3, #8]

            /* Determine if the mutex is still owned by the current thread.  */
            if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
 800cb0c:	687b      	ldr	r3, [r7, #4]
 800cb0e:	689b      	ldr	r3, [r3, #8]
 800cb10:	2b00      	cmp	r3, #0
 800cb12:	d00a      	beq.n	800cb2a <_tx_mutex_put+0x8e>
 800cb14:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800cb18:	653b      	str	r3, [r7, #80]	; 0x50
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cb1a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800cb1c:	f383 8810 	msr	PRIMASK, r3
}
 800cb20:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Mutex is still owned, just return successful status.  */
                status =  TX_SUCCESS;
 800cb22:	2300      	movs	r3, #0
 800cb24:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800cb28:	e1d6      	b.n	800ced8 <_tx_mutex_put+0x43c>
            }
            else
            {

                /* Check for a NULL thread pointer, which can only happen during initialization.   */
                if (thread_ptr == TX_NULL)
 800cb2a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cb2c:	2b00      	cmp	r3, #0
 800cb2e:	d10a      	bne.n	800cb46 <_tx_mutex_put+0xaa>
 800cb30:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800cb34:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cb36:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800cb38:	f383 8810 	msr	PRIMASK, r3
}
 800cb3c:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Mutex is now available, return successful status.  */
                    status =  TX_SUCCESS;
 800cb3e:	2300      	movs	r3, #0
 800cb40:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800cb44:	e1c8      	b.n	800ced8 <_tx_mutex_put+0x43c>
                    /* The mutex is now available.   */

                    /* Remove this mutex from the owned mutex list.  */

                    /* Decrement the ownership count.  */
                    thread_ptr -> tx_thread_owned_mutex_count--;
 800cb46:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cb48:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800cb4c:	1e5a      	subs	r2, r3, #1
 800cb4e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cb50:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

                    /* Determine if this mutex was the only one on the list.  */
                    if (thread_ptr -> tx_thread_owned_mutex_count == ((UINT) 0))
 800cb54:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cb56:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800cb5a:	2b00      	cmp	r3, #0
 800cb5c:	d104      	bne.n	800cb68 <_tx_mutex_put+0xcc>
                    {

                        /* Yes, the list is empty.  Simply set the head pointer to NULL.  */
                        thread_ptr -> tx_thread_owned_mutex_list =  TX_NULL;
 800cb5e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cb60:	2200      	movs	r2, #0
 800cb62:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
 800cb66:	e019      	b.n	800cb9c <_tx_mutex_put+0x100>
                    {

                        /* No, there are more mutexes on the list.  */

                        /* Link-up the neighbors.  */
                        next_mutex =                             mutex_ptr -> tx_mutex_owned_next;
 800cb68:	687b      	ldr	r3, [r7, #4]
 800cb6a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800cb6c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                        previous_mutex =                         mutex_ptr -> tx_mutex_owned_previous;
 800cb70:	687b      	ldr	r3, [r7, #4]
 800cb72:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800cb74:	677b      	str	r3, [r7, #116]	; 0x74
                        next_mutex -> tx_mutex_owned_previous =  previous_mutex;
 800cb76:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800cb7a:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cb7c:	631a      	str	r2, [r3, #48]	; 0x30
                        previous_mutex -> tx_mutex_owned_next =  next_mutex;
 800cb7e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cb80:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800cb84:	62da      	str	r2, [r3, #44]	; 0x2c

                        /* See if we have to update the created list head pointer.  */
                        if (thread_ptr -> tx_thread_owned_mutex_list == mutex_ptr)
 800cb86:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cb88:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800cb8c:	687a      	ldr	r2, [r7, #4]
 800cb8e:	429a      	cmp	r2, r3
 800cb90:	d104      	bne.n	800cb9c <_tx_mutex_put+0x100>
                        {

                            /* Yes, move the head pointer to the next link. */
                            thread_ptr -> tx_thread_owned_mutex_list =  next_mutex;
 800cb92:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cb94:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800cb98:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                        }
                    }

                    /* Determine if the simple, non-suspension, non-priority inheritance case is present.  */
                    if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
 800cb9c:	687b      	ldr	r3, [r7, #4]
 800cb9e:	699b      	ldr	r3, [r3, #24]
 800cba0:	2b00      	cmp	r3, #0
 800cba2:	d110      	bne.n	800cbc6 <_tx_mutex_put+0x12a>
                    {

                        /* Is this a priority inheritance mutex?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_FALSE)
 800cba4:	687b      	ldr	r3, [r7, #4]
 800cba6:	691b      	ldr	r3, [r3, #16]
 800cba8:	2b00      	cmp	r3, #0
 800cbaa:	d10c      	bne.n	800cbc6 <_tx_mutex_put+0x12a>
                        {

                            /* Yes, we are done - set the mutex owner to NULL.   */
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
 800cbac:	687b      	ldr	r3, [r7, #4]
 800cbae:	2200      	movs	r2, #0
 800cbb0:	60da      	str	r2, [r3, #12]
 800cbb2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800cbb6:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cbb8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800cbba:	f383 8810 	msr	PRIMASK, r3
}
 800cbbe:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Mutex is now available, return successful status.  */
                            status =  TX_SUCCESS;
 800cbc0:	2300      	movs	r3, #0
 800cbc2:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
                        }
                    }

                    /* Determine if the processing is complete.  */
                    if (status == TX_NOT_DONE)
 800cbc6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800cbca:	2b20      	cmp	r3, #32
 800cbcc:	f040 8184 	bne.w	800ced8 <_tx_mutex_put+0x43c>
                    {

                        /* Initialize original owner and thread priority.  */
                        old_owner =      TX_NULL;
 800cbd0:	2300      	movs	r3, #0
 800cbd2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
                        old_priority =   thread_ptr -> tx_thread_user_priority;
 800cbd6:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cbd8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800cbdc:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

                        /* Does this mutex support priority inheritance?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800cbe0:	687b      	ldr	r3, [r7, #4]
 800cbe2:	691b      	ldr	r3, [r3, #16]
 800cbe4:	2b01      	cmp	r3, #1
 800cbe6:	d155      	bne.n	800cc94 <_tx_mutex_put+0x1f8>
                        {

#ifndef TX_NOT_INTERRUPTABLE

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 800cbe8:	4b5d      	ldr	r3, [pc, #372]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800cbea:	681b      	ldr	r3, [r3, #0]
 800cbec:	3301      	adds	r3, #1
 800cbee:	4a5c      	ldr	r2, [pc, #368]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800cbf0:	6013      	str	r3, [r2, #0]
 800cbf2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800cbf6:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cbf8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800cbfa:	f383 8810 	msr	PRIMASK, r3
}
 800cbfe:	bf00      	nop
                            /* Restore interrupts.  */
                            TX_RESTORE
#endif

                            /* Default the inheritance priority to disabled.  */
                            inheritance_priority =  ((UINT) TX_MAX_PRIORITIES);
 800cc00:	2320      	movs	r3, #32
 800cc02:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

                            /* Search the owned mutexes for this thread to determine the highest priority for this
                               former mutex owner to return to.  */
                            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
 800cc06:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cc08:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800cc0c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                            while (next_mutex != TX_NULL)
 800cc10:	e01f      	b.n	800cc52 <_tx_mutex_put+0x1b6>
                            {

                                /* Does this mutex support priority inheritance?  */
                                if (next_mutex -> tx_mutex_inherit == TX_TRUE)
 800cc12:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800cc16:	691b      	ldr	r3, [r3, #16]
 800cc18:	2b01      	cmp	r3, #1
 800cc1a:	d10b      	bne.n	800cc34 <_tx_mutex_put+0x198>
                                {

                                    /* Determine if highest priority field of the mutex is higher than the priority to
                                       restore.  */
                                    if (next_mutex -> tx_mutex_highest_priority_waiting < inheritance_priority)
 800cc1c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800cc20:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800cc22:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800cc26:	429a      	cmp	r2, r3
 800cc28:	d904      	bls.n	800cc34 <_tx_mutex_put+0x198>
                                    {

                                        /* Use this priority to return releasing thread to.  */
                                        inheritance_priority =   next_mutex -> tx_mutex_highest_priority_waiting;
 800cc2a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800cc2e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800cc30:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                                    }
                                }

                                /* Move mutex pointer to the next mutex in the list.  */
                                next_mutex =  next_mutex -> tx_mutex_owned_next;
 800cc34:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800cc38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800cc3a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

                                /* Are we at the end of the list?  */
                                if (next_mutex == thread_ptr -> tx_thread_owned_mutex_list)
 800cc3e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cc40:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800cc44:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800cc48:	429a      	cmp	r2, r3
 800cc4a:	d102      	bne.n	800cc52 <_tx_mutex_put+0x1b6>
                                {

                                    /* Yes, set the next mutex to NULL.  */
                                    next_mutex =  TX_NULL;
 800cc4c:	2300      	movs	r3, #0
 800cc4e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                            while (next_mutex != TX_NULL)
 800cc52:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800cc56:	2b00      	cmp	r3, #0
 800cc58:	d1db      	bne.n	800cc12 <_tx_mutex_put+0x176>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cc5a:	f3ef 8310 	mrs	r3, PRIMASK
 800cc5e:	643b      	str	r3, [r7, #64]	; 0x40
    return(posture);
 800cc60:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    int_posture = __get_interrupt_posture();
 800cc62:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
 800cc64:	b672      	cpsid	i
    return(int_posture);
 800cc66:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
                            }

#ifndef TX_NOT_INTERRUPTABLE

                            /* Disable interrupts.  */
                            TX_DISABLE
 800cc68:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                            /* Undo the temporarily preemption disable.  */
                            _tx_thread_preempt_disable--;
 800cc6c:	4b3c      	ldr	r3, [pc, #240]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800cc6e:	681b      	ldr	r3, [r3, #0]
 800cc70:	3b01      	subs	r3, #1
 800cc72:	4a3b      	ldr	r2, [pc, #236]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800cc74:	6013      	str	r3, [r2, #0]
#endif

                            /* Set the inherit priority to that of the highest priority thread waiting on the mutex.  */
                            thread_ptr -> tx_thread_inherit_priority =  inheritance_priority;
 800cc76:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cc78:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800cc7c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

                            /* Determine if the inheritance priority is less than the default old priority.  */
                            if (inheritance_priority < old_priority)
 800cc80:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 800cc84:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800cc88:	429a      	cmp	r2, r3
 800cc8a:	d203      	bcs.n	800cc94 <_tx_mutex_put+0x1f8>
                            {

                                /* Yes, update the old priority.  */
                                old_priority =  inheritance_priority;
 800cc8c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800cc90:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                            }
                        }

                        /* Determine if priority inheritance is in effect and there are one or more
                           threads suspended on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
 800cc94:	687b      	ldr	r3, [r7, #4]
 800cc96:	69db      	ldr	r3, [r3, #28]
 800cc98:	2b01      	cmp	r3, #1
 800cc9a:	d920      	bls.n	800ccde <_tx_mutex_put+0x242>
                        {

                            /* Is priority inheritance in effect?  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800cc9c:	687b      	ldr	r3, [r7, #4]
 800cc9e:	691b      	ldr	r3, [r3, #16]
 800cca0:	2b01      	cmp	r3, #1
 800cca2:	d11c      	bne.n	800ccde <_tx_mutex_put+0x242>
                                   at the front of the suspension list.  */

#ifndef TX_NOT_INTERRUPTABLE

                                /* Temporarily disable preemption.  */
                                _tx_thread_preempt_disable++;
 800cca4:	4b2e      	ldr	r3, [pc, #184]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800cca6:	681b      	ldr	r3, [r3, #0]
 800cca8:	3301      	adds	r3, #1
 800ccaa:	4a2d      	ldr	r2, [pc, #180]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800ccac:	6013      	str	r3, [r2, #0]
 800ccae:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800ccb2:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ccb4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ccb6:	f383 8810 	msr	PRIMASK, r3
}
 800ccba:	bf00      	nop
                                do
                                {
                                    status =  _tx_mutex_prioritize(mutex_ptr);
                                } while (status != TX_SUCCESS);
#else
                                _tx_mutex_prioritize(mutex_ptr);
 800ccbc:	6878      	ldr	r0, [r7, #4]
 800ccbe:	f7ff fd7d 	bl	800c7bc <_tx_mutex_prioritize>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ccc2:	f3ef 8310 	mrs	r3, PRIMASK
 800ccc6:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 800ccc8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 800ccca:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 800cccc:	b672      	cpsid	i
    return(int_posture);
 800ccce:	6b7b      	ldr	r3, [r7, #52]	; 0x34
                                TX_MUTEX_PUT_EXTENSION_1

#ifndef TX_NOT_INTERRUPTABLE

                                /* Disable interrupts.  */
                                TX_DISABLE
 800ccd0:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                                /* Back off the preemption disable.  */
                                _tx_thread_preempt_disable--;
 800ccd4:	4b22      	ldr	r3, [pc, #136]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800ccd6:	681b      	ldr	r3, [r3, #0]
 800ccd8:	3b01      	subs	r3, #1
 800ccda:	4a21      	ldr	r2, [pc, #132]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800ccdc:	6013      	str	r3, [r2, #0]
#endif
                            }
                        }

                        /* Now determine if there are any threads still waiting on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
 800ccde:	687b      	ldr	r3, [r7, #4]
 800cce0:	699b      	ldr	r3, [r3, #24]
 800cce2:	2b00      	cmp	r3, #0
 800cce4:	d13e      	bne.n	800cd64 <_tx_mutex_put+0x2c8>
                            /* No, there are no longer any threads waiting on the mutex.  */

#ifndef TX_NOT_INTERRUPTABLE

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 800cce6:	4b1e      	ldr	r3, [pc, #120]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800cce8:	681b      	ldr	r3, [r3, #0]
 800ccea:	3301      	adds	r3, #1
 800ccec:	4a1c      	ldr	r2, [pc, #112]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800ccee:	6013      	str	r3, [r2, #0]
 800ccf0:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800ccf4:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ccf6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ccf8:	f383 8810 	msr	PRIMASK, r3
}
 800ccfc:	bf00      	nop
                            /* Mutex is not owned, but it is possible that a thread that
                               caused a priority inheritance to occur is no longer waiting
                               on the mutex.  */

                            /* Setup the highest priority waiting thread.  */
                            mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
 800ccfe:	687b      	ldr	r3, [r7, #4]
 800cd00:	2220      	movs	r2, #32
 800cd02:	629a      	str	r2, [r3, #40]	; 0x28

                            /* Determine if we need to restore priority.  */
                            if ((mutex_ptr -> tx_mutex_owner) -> tx_thread_priority != old_priority)
 800cd04:	687b      	ldr	r3, [r7, #4]
 800cd06:	68db      	ldr	r3, [r3, #12]
 800cd08:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800cd0a:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 800cd0e:	429a      	cmp	r2, r3
 800cd10:	d006      	beq.n	800cd20 <_tx_mutex_put+0x284>
                            {

                                /* Yes, restore the priority of thread.  */
                                _tx_mutex_priority_change(mutex_ptr -> tx_mutex_owner, old_priority);
 800cd12:	687b      	ldr	r3, [r7, #4]
 800cd14:	68db      	ldr	r3, [r3, #12]
 800cd16:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 800cd1a:	4618      	mov	r0, r3
 800cd1c:	f7ff fe00 	bl	800c920 <_tx_mutex_priority_change>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cd20:	f3ef 8310 	mrs	r3, PRIMASK
 800cd24:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800cd26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800cd28:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cd2a:	b672      	cpsid	i
    return(int_posture);
 800cd2c:	6a3b      	ldr	r3, [r7, #32]
                            }

#ifndef TX_NOT_INTERRUPTABLE

                            /* Disable interrupts again.  */
                            TX_DISABLE
 800cd2e:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                            /* Back off the preemption disable.  */
                            _tx_thread_preempt_disable--;
 800cd32:	4b0b      	ldr	r3, [pc, #44]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800cd34:	681b      	ldr	r3, [r3, #0]
 800cd36:	3b01      	subs	r3, #1
 800cd38:	4a09      	ldr	r2, [pc, #36]	; (800cd60 <_tx_mutex_put+0x2c4>)
 800cd3a:	6013      	str	r3, [r2, #0]
#endif

                            /* Set the mutex owner to NULL.  */
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
 800cd3c:	687b      	ldr	r3, [r7, #4]
 800cd3e:	2200      	movs	r2, #0
 800cd40:	60da      	str	r2, [r3, #12]
 800cd42:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800cd46:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cd48:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cd4a:	f383 8810 	msr	PRIMASK, r3
}
 800cd4e:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Check for preemption.  */
                            _tx_thread_system_preempt_check();
 800cd50:	f000 fffa 	bl	800dd48 <_tx_thread_system_preempt_check>

                            /* Set status to success.  */
                            status =  TX_SUCCESS;
 800cd54:	2300      	movs	r3, #0
 800cd56:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800cd5a:	e0bd      	b.n	800ced8 <_tx_mutex_put+0x43c>
 800cd5c:	20006d04 	.word	0x20006d04
 800cd60:	20006d9c 	.word	0x20006d9c
                        }
                        else
                        {

                            /* Pickup the thread at the front of the suspension list.  */
                            thread_ptr =  mutex_ptr -> tx_mutex_suspension_list;
 800cd64:	687b      	ldr	r3, [r7, #4]
 800cd66:	699b      	ldr	r3, [r3, #24]
 800cd68:	67fb      	str	r3, [r7, #124]	; 0x7c

                            /* Save the previous ownership information, if inheritance is
                               in effect.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800cd6a:	687b      	ldr	r3, [r7, #4]
 800cd6c:	691b      	ldr	r3, [r3, #16]
 800cd6e:	2b01      	cmp	r3, #1
 800cd70:	d10a      	bne.n	800cd88 <_tx_mutex_put+0x2ec>
                            {

                                /* Remember the old mutex owner.  */
                                old_owner =  mutex_ptr -> tx_mutex_owner;
 800cd72:	687b      	ldr	r3, [r7, #4]
 800cd74:	68db      	ldr	r3, [r3, #12]
 800cd76:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

                                /* Setup owner thread priority information.  */
                                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
 800cd7a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cd7c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800cd7e:	687b      	ldr	r3, [r7, #4]
 800cd80:	615a      	str	r2, [r3, #20]

                                /* Setup the highest priority waiting thread.  */
                                mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
 800cd82:	687b      	ldr	r3, [r7, #4]
 800cd84:	2220      	movs	r2, #32
 800cd86:	629a      	str	r2, [r3, #40]	; 0x28
                            }

                            /* Determine how many mutexes are owned by this thread.  */
                            owned_count =  thread_ptr -> tx_thread_owned_mutex_count;
 800cd88:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cd8a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 800cd8e:	673b      	str	r3, [r7, #112]	; 0x70

                            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
                            if (owned_count == ((UINT) 0))
 800cd90:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800cd92:	2b00      	cmp	r3, #0
 800cd94:	d10a      	bne.n	800cdac <_tx_mutex_put+0x310>
                            {

                                /* The owned mutex list is empty.  Add mutex to empty list.  */
                                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
 800cd96:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cd98:	687a      	ldr	r2, [r7, #4]
 800cd9a:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
 800cd9e:	687b      	ldr	r3, [r7, #4]
 800cda0:	687a      	ldr	r2, [r7, #4]
 800cda2:	62da      	str	r2, [r3, #44]	; 0x2c
                                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
 800cda4:	687b      	ldr	r3, [r7, #4]
 800cda6:	687a      	ldr	r2, [r7, #4]
 800cda8:	631a      	str	r2, [r3, #48]	; 0x30
 800cdaa:	e016      	b.n	800cdda <_tx_mutex_put+0x33e>
                            {

                                /* Non-empty list. Link up the mutex.  */

                                /* Pickup tail pointer.  */
                                next_mutex =                            thread_ptr -> tx_thread_owned_mutex_list;
 800cdac:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cdae:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800cdb2:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
                                previous_mutex =                        next_mutex -> tx_mutex_owned_previous;
 800cdb6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800cdba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800cdbc:	677b      	str	r3, [r7, #116]	; 0x74

                                /* Place the owned mutex in the list.  */
                                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
 800cdbe:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800cdc2:	687a      	ldr	r2, [r7, #4]
 800cdc4:	631a      	str	r2, [r3, #48]	; 0x30
                                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
 800cdc6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800cdc8:	687a      	ldr	r2, [r7, #4]
 800cdca:	62da      	str	r2, [r3, #44]	; 0x2c

                                /* Setup this mutex's next and previous created links.  */
                                mutex_ptr -> tx_mutex_owned_previous =   previous_mutex;
 800cdcc:	687b      	ldr	r3, [r7, #4]
 800cdce:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800cdd0:	631a      	str	r2, [r3, #48]	; 0x30
                                mutex_ptr -> tx_mutex_owned_next =       next_mutex;
 800cdd2:	687b      	ldr	r3, [r7, #4]
 800cdd4:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 800cdd8:	62da      	str	r2, [r3, #44]	; 0x2c
                            }

                            /* Increment the number of mutexes owned counter.  */
                            thread_ptr -> tx_thread_owned_mutex_count =  owned_count + ((UINT) 1);
 800cdda:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800cddc:	1c5a      	adds	r2, r3, #1
 800cdde:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800cde0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

                            /* Mark the Mutex as owned and fill in the corresponding information.  */
                            mutex_ptr -> tx_mutex_ownership_count =  (UINT) 1;
 800cde4:	687b      	ldr	r3, [r7, #4]
 800cde6:	2201      	movs	r2, #1
 800cde8:	609a      	str	r2, [r3, #8]
                            mutex_ptr -> tx_mutex_owner =            thread_ptr;
 800cdea:	687b      	ldr	r3, [r7, #4]
 800cdec:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800cdee:	60da      	str	r2, [r3, #12]

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the suspension count.  */
                            mutex_ptr -> tx_mutex_suspended_count--;
 800cdf0:	687b      	ldr	r3, [r7, #4]
 800cdf2:	69db      	ldr	r3, [r3, #28]
 800cdf4:	1e5a      	subs	r2, r3, #1
 800cdf6:	687b      	ldr	r3, [r7, #4]
 800cdf8:	61da      	str	r2, [r3, #28]

                            /* Pickup the suspended count.  */
                            suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 800cdfa:	687b      	ldr	r3, [r7, #4]
 800cdfc:	69db      	ldr	r3, [r3, #28]
 800cdfe:	66fb      	str	r3, [r7, #108]	; 0x6c

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
 800ce00:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ce02:	2b00      	cmp	r3, #0
 800ce04:	d103      	bne.n	800ce0e <_tx_mutex_put+0x372>
                            {

                                /* Yes, the only suspended thread.  */

                                /* Update the head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 800ce06:	687b      	ldr	r3, [r7, #4]
 800ce08:	2200      	movs	r2, #0
 800ce0a:	619a      	str	r2, [r3, #24]
 800ce0c:	e00e      	b.n	800ce2c <_tx_mutex_put+0x390>
                            {

                                /* At least one more thread is on the same expiration list.  */

                                /* Update the list head pointer.  */
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
 800ce0e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ce10:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800ce12:	66bb      	str	r3, [r7, #104]	; 0x68
                                mutex_ptr -> tx_mutex_suspension_list =        next_thread;
 800ce14:	687b      	ldr	r3, [r7, #4]
 800ce16:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800ce18:	619a      	str	r2, [r3, #24]

                                /* Update the links of the adjacent threads.  */
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 800ce1a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ce1c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800ce1e:	667b      	str	r3, [r7, #100]	; 0x64
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
 800ce20:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ce22:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800ce24:	675a      	str	r2, [r3, #116]	; 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
 800ce26:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800ce28:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800ce2a:	671a      	str	r2, [r3, #112]	; 0x70
                            }

                            /* Prepare for resumption of the first thread.  */

                            /* Clear cleanup routine to avoid timeout.  */
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800ce2c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ce2e:	2200      	movs	r2, #0
 800ce30:	669a      	str	r2, [r3, #104]	; 0x68

                            /* Put return status into the thread control block.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800ce32:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ce34:	2200      	movs	r2, #0
 800ce36:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                            /* Restore interrupts.  */
                            TX_RESTORE
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 800ce3a:	4b2a      	ldr	r3, [pc, #168]	; (800cee4 <_tx_mutex_put+0x448>)
 800ce3c:	681b      	ldr	r3, [r3, #0]
 800ce3e:	3301      	adds	r3, #1
 800ce40:	4a28      	ldr	r2, [pc, #160]	; (800cee4 <_tx_mutex_put+0x448>)
 800ce42:	6013      	str	r3, [r2, #0]
 800ce44:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800ce48:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ce4a:	69fb      	ldr	r3, [r7, #28]
 800ce4c:	f383 8810 	msr	PRIMASK, r3
}
 800ce50:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Determine if priority inheritance is enabled for this mutex.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800ce52:	687b      	ldr	r3, [r7, #4]
 800ce54:	691b      	ldr	r3, [r3, #16]
 800ce56:	2b01      	cmp	r3, #1
 800ce58:	d12d      	bne.n	800ceb6 <_tx_mutex_put+0x41a>
                            {

                                /* Yes, priority inheritance is requested.  */

                                /* Determine if there are any more threads still suspended on the mutex.  */
                                if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
 800ce5a:	687b      	ldr	r3, [r7, #4]
 800ce5c:	69db      	ldr	r3, [r3, #28]
 800ce5e:	2b00      	cmp	r3, #0
 800ce60:	d01c      	beq.n	800ce9c <_tx_mutex_put+0x400>
                                    do
                                    {
                                        status =  _tx_mutex_prioritize(mutex_ptr);
                                    } while (status != TX_SUCCESS);
#else
                                    _tx_mutex_prioritize(mutex_ptr);
 800ce62:	6878      	ldr	r0, [r7, #4]
 800ce64:	f7ff fcaa 	bl	800c7bc <_tx_mutex_prioritize>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ce68:	f3ef 8310 	mrs	r3, PRIMASK
 800ce6c:	61bb      	str	r3, [r7, #24]
    return(posture);
 800ce6e:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800ce70:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800ce72:	b672      	cpsid	i
    return(int_posture);
 800ce74:	697b      	ldr	r3, [r7, #20]

                                    /* Optional processing extension.  */
                                    TX_MUTEX_PUT_EXTENSION_2

                                    /* Disable interrupts.  */
                                    TX_DISABLE
 800ce76:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

                                    /* Determine if there still are threads suspended for this mutex.  */
                                    suspended_thread =  mutex_ptr -> tx_mutex_suspension_list;
 800ce7a:	687b      	ldr	r3, [r7, #4]
 800ce7c:	699b      	ldr	r3, [r3, #24]
 800ce7e:	663b      	str	r3, [r7, #96]	; 0x60
                                    if (suspended_thread != TX_NULL)
 800ce80:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800ce82:	2b00      	cmp	r3, #0
 800ce84:	d003      	beq.n	800ce8e <_tx_mutex_put+0x3f2>
                                    {

                                        /* Setup the highest priority thread waiting on this mutex.  */
                                        mutex_ptr -> tx_mutex_highest_priority_waiting =  suspended_thread -> tx_thread_priority;
 800ce86:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800ce88:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ce8a:	687b      	ldr	r3, [r7, #4]
 800ce8c:	629a      	str	r2, [r3, #40]	; 0x28
 800ce8e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800ce92:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ce94:	693b      	ldr	r3, [r7, #16]
 800ce96:	f383 8810 	msr	PRIMASK, r3
}
 800ce9a:	bf00      	nop

                                /* Restore previous priority needs to be restored after priority
                                   inheritance.  */

                                /* Is the priority different?  */
                                if (old_owner -> tx_thread_priority != old_priority)
 800ce9c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800cea0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800cea2:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 800cea6:	429a      	cmp	r2, r3
 800cea8:	d005      	beq.n	800ceb6 <_tx_mutex_put+0x41a>
                                {

                                    /* Restore the priority of thread.  */
                                    _tx_mutex_priority_change(old_owner, old_priority);
 800ceaa:	f8d7 108c 	ldr.w	r1, [r7, #140]	; 0x8c
 800ceae:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 800ceb2:	f7ff fd35 	bl	800c920 <_tx_mutex_priority_change>
                                }
                            }

                            /* Resume thread.  */
                            _tx_thread_system_resume(thread_ptr);
 800ceb6:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 800ceb8:	f000 ff80 	bl	800ddbc <_tx_thread_system_resume>
#endif

                            /* Return a successful status.  */
                            status =  TX_SUCCESS;
 800cebc:	2300      	movs	r3, #0
 800cebe:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800cec2:	e009      	b.n	800ced8 <_tx_mutex_put+0x43c>
 800cec4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800cec8:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ceca:	68fb      	ldr	r3, [r7, #12]
 800cecc:	f383 8810 	msr	PRIMASK, r3
}
 800ced0:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Caller does not own the mutex.  */
        status =  TX_NOT_OWNED;
 800ced2:	231e      	movs	r3, #30
 800ced4:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    }

    /* Return the completion status.  */
    return(status);
 800ced8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
}
 800cedc:	4618      	mov	r0, r3
 800cede:	3798      	adds	r7, #152	; 0x98
 800cee0:	46bd      	mov	sp, r7
 800cee2:	bd80      	pop	{r7, pc}
 800cee4:	20006d9c 	.word	0x20006d9c

0800cee8 <_tx_queue_create>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_queue_create(TX_QUEUE *queue_ptr, CHAR *name_ptr, UINT message_size,
                        VOID *queue_start, ULONG queue_size)
{
 800cee8:	b580      	push	{r7, lr}
 800ceea:	b08c      	sub	sp, #48	; 0x30
 800ceec:	af00      	add	r7, sp, #0
 800ceee:	60f8      	str	r0, [r7, #12]
 800cef0:	60b9      	str	r1, [r7, #8]
 800cef2:	607a      	str	r2, [r7, #4]
 800cef4:	603b      	str	r3, [r7, #0]
TX_QUEUE        *next_queue;
TX_QUEUE        *previous_queue;


    /* Initialize queue control block to all zeros.  */
    TX_MEMSET(queue_ptr, 0, (sizeof(TX_QUEUE)));
 800cef6:	2238      	movs	r2, #56	; 0x38
 800cef8:	2100      	movs	r1, #0
 800cefa:	68f8      	ldr	r0, [r7, #12]
 800cefc:	f006 f9b4 	bl	8013268 <memset>

    /* Setup the basic queue fields.  */
    queue_ptr -> tx_queue_name =             name_ptr;
 800cf00:	68fb      	ldr	r3, [r7, #12]
 800cf02:	68ba      	ldr	r2, [r7, #8]
 800cf04:	605a      	str	r2, [r3, #4]

    /* Save the message size in the control block.  */
    queue_ptr -> tx_queue_message_size =  message_size;
 800cf06:	68fb      	ldr	r3, [r7, #12]
 800cf08:	687a      	ldr	r2, [r7, #4]
 800cf0a:	609a      	str	r2, [r3, #8]

    /* Determine how many messages will fit in the queue area and the number
       of ULONGs used.  */
    capacity =    (UINT) (queue_size / ((ULONG) (((ULONG) message_size) * (sizeof(ULONG)))));
 800cf0c:	687b      	ldr	r3, [r7, #4]
 800cf0e:	009b      	lsls	r3, r3, #2
 800cf10:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800cf12:	fbb2 f3f3 	udiv	r3, r2, r3
 800cf16:	62fb      	str	r3, [r7, #44]	; 0x2c
    used_words =  capacity * message_size;
 800cf18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cf1a:	687a      	ldr	r2, [r7, #4]
 800cf1c:	fb02 f303 	mul.w	r3, r2, r3
 800cf20:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Save the starting address and calculate the ending address of
       the queue.  Note that the ending address is really one past the
       end!  */
    queue_ptr -> tx_queue_start =  TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
 800cf22:	68fb      	ldr	r3, [r7, #12]
 800cf24:	683a      	ldr	r2, [r7, #0]
 800cf26:	619a      	str	r2, [r3, #24]
    queue_ptr -> tx_queue_end =    TX_ULONG_POINTER_ADD(queue_ptr -> tx_queue_start, used_words);
 800cf28:	68fb      	ldr	r3, [r7, #12]
 800cf2a:	699a      	ldr	r2, [r3, #24]
 800cf2c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cf2e:	009b      	lsls	r3, r3, #2
 800cf30:	441a      	add	r2, r3
 800cf32:	68fb      	ldr	r3, [r7, #12]
 800cf34:	61da      	str	r2, [r3, #28]

    /* Set the read and write pointers to the beginning of the queue
       area.  */
    queue_ptr -> tx_queue_read =   TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
 800cf36:	68fb      	ldr	r3, [r7, #12]
 800cf38:	683a      	ldr	r2, [r7, #0]
 800cf3a:	621a      	str	r2, [r3, #32]
    queue_ptr -> tx_queue_write =  TX_VOID_TO_ULONG_POINTER_CONVERT(queue_start);
 800cf3c:	68fb      	ldr	r3, [r7, #12]
 800cf3e:	683a      	ldr	r2, [r7, #0]
 800cf40:	625a      	str	r2, [r3, #36]	; 0x24

    /* Setup the number of enqueued messages and the number of message
       slots available in the queue.  */
    queue_ptr -> tx_queue_available_storage =  (UINT) capacity;
 800cf42:	68fb      	ldr	r3, [r7, #12]
 800cf44:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800cf46:	615a      	str	r2, [r3, #20]
    queue_ptr -> tx_queue_capacity =           (UINT) capacity;
 800cf48:	68fb      	ldr	r3, [r7, #12]
 800cf4a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800cf4c:	60da      	str	r2, [r3, #12]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cf4e:	f3ef 8310 	mrs	r3, PRIMASK
 800cf52:	61bb      	str	r3, [r7, #24]
    return(posture);
 800cf54:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800cf56:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cf58:	b672      	cpsid	i
    return(int_posture);
 800cf5a:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to put the queue on the created list.  */
    TX_DISABLE
 800cf5c:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the queue ID to make it valid.  */
    queue_ptr -> tx_queue_id =  TX_QUEUE_ID;
 800cf5e:	68fb      	ldr	r3, [r7, #12]
 800cf60:	4a18      	ldr	r2, [pc, #96]	; (800cfc4 <_tx_queue_create+0xdc>)
 800cf62:	601a      	str	r2, [r3, #0]

    /* Place the queue on the list of created queues.  First,
       check for an empty list.  */
    if (_tx_queue_created_count == TX_EMPTY)
 800cf64:	4b18      	ldr	r3, [pc, #96]	; (800cfc8 <_tx_queue_create+0xe0>)
 800cf66:	681b      	ldr	r3, [r3, #0]
 800cf68:	2b00      	cmp	r3, #0
 800cf6a:	d109      	bne.n	800cf80 <_tx_queue_create+0x98>
    {

        /* The created queue list is empty.  Add queue to empty list.  */
        _tx_queue_created_ptr =                   queue_ptr;
 800cf6c:	4a17      	ldr	r2, [pc, #92]	; (800cfcc <_tx_queue_create+0xe4>)
 800cf6e:	68fb      	ldr	r3, [r7, #12]
 800cf70:	6013      	str	r3, [r2, #0]
        queue_ptr -> tx_queue_created_next =      queue_ptr;
 800cf72:	68fb      	ldr	r3, [r7, #12]
 800cf74:	68fa      	ldr	r2, [r7, #12]
 800cf76:	631a      	str	r2, [r3, #48]	; 0x30
        queue_ptr -> tx_queue_created_previous =  queue_ptr;
 800cf78:	68fb      	ldr	r3, [r7, #12]
 800cf7a:	68fa      	ldr	r2, [r7, #12]
 800cf7c:	635a      	str	r2, [r3, #52]	; 0x34
 800cf7e:	e011      	b.n	800cfa4 <_tx_queue_create+0xbc>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_queue =      _tx_queue_created_ptr;
 800cf80:	4b12      	ldr	r3, [pc, #72]	; (800cfcc <_tx_queue_create+0xe4>)
 800cf82:	681b      	ldr	r3, [r3, #0]
 800cf84:	623b      	str	r3, [r7, #32]
        previous_queue =  next_queue -> tx_queue_created_previous;
 800cf86:	6a3b      	ldr	r3, [r7, #32]
 800cf88:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800cf8a:	61fb      	str	r3, [r7, #28]

        /* Place the new queue in the list.  */
        next_queue -> tx_queue_created_previous =  queue_ptr;
 800cf8c:	6a3b      	ldr	r3, [r7, #32]
 800cf8e:	68fa      	ldr	r2, [r7, #12]
 800cf90:	635a      	str	r2, [r3, #52]	; 0x34
        previous_queue -> tx_queue_created_next =  queue_ptr;
 800cf92:	69fb      	ldr	r3, [r7, #28]
 800cf94:	68fa      	ldr	r2, [r7, #12]
 800cf96:	631a      	str	r2, [r3, #48]	; 0x30

        /* Setup this queues's created links.  */
        queue_ptr -> tx_queue_created_previous =  previous_queue;
 800cf98:	68fb      	ldr	r3, [r7, #12]
 800cf9a:	69fa      	ldr	r2, [r7, #28]
 800cf9c:	635a      	str	r2, [r3, #52]	; 0x34
        queue_ptr -> tx_queue_created_next =      next_queue;
 800cf9e:	68fb      	ldr	r3, [r7, #12]
 800cfa0:	6a3a      	ldr	r2, [r7, #32]
 800cfa2:	631a      	str	r2, [r3, #48]	; 0x30
    }

    /* Increment the created queue count.  */
    _tx_queue_created_count++;
 800cfa4:	4b08      	ldr	r3, [pc, #32]	; (800cfc8 <_tx_queue_create+0xe0>)
 800cfa6:	681b      	ldr	r3, [r3, #0]
 800cfa8:	3301      	adds	r3, #1
 800cfaa:	4a07      	ldr	r2, [pc, #28]	; (800cfc8 <_tx_queue_create+0xe0>)
 800cfac:	6013      	str	r3, [r2, #0]
 800cfae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cfb0:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800cfb2:	693b      	ldr	r3, [r7, #16]
 800cfb4:	f383 8810 	msr	PRIMASK, r3
}
 800cfb8:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800cfba:	2300      	movs	r3, #0
}
 800cfbc:	4618      	mov	r0, r3
 800cfbe:	3730      	adds	r7, #48	; 0x30
 800cfc0:	46bd      	mov	sp, r7
 800cfc2:	bd80      	pop	{r7, pc}
 800cfc4:	51554555 	.word	0x51554555
 800cfc8:	20006ce0 	.word	0x20006ce0
 800cfcc:	20006cdc 	.word	0x20006cdc

0800cfd0 <_tx_semaphore_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count)
{
 800cfd0:	b580      	push	{r7, lr}
 800cfd2:	b08a      	sub	sp, #40	; 0x28
 800cfd4:	af00      	add	r7, sp, #0
 800cfd6:	60f8      	str	r0, [r7, #12]
 800cfd8:	60b9      	str	r1, [r7, #8]
 800cfda:	607a      	str	r2, [r7, #4]
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Initialize semaphore control block to all zeros.  */
    TX_MEMSET(semaphore_ptr, 0, (sizeof(TX_SEMAPHORE)));
 800cfdc:	221c      	movs	r2, #28
 800cfde:	2100      	movs	r1, #0
 800cfe0:	68f8      	ldr	r0, [r7, #12]
 800cfe2:	f006 f941 	bl	8013268 <memset>

    /* Setup the basic semaphore fields.  */
    semaphore_ptr -> tx_semaphore_name =             name_ptr;
 800cfe6:	68fb      	ldr	r3, [r7, #12]
 800cfe8:	68ba      	ldr	r2, [r7, #8]
 800cfea:	605a      	str	r2, [r3, #4]
    semaphore_ptr -> tx_semaphore_count =            initial_count;
 800cfec:	68fb      	ldr	r3, [r7, #12]
 800cfee:	687a      	ldr	r2, [r7, #4]
 800cff0:	609a      	str	r2, [r3, #8]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800cff2:	f3ef 8310 	mrs	r3, PRIMASK
 800cff6:	61bb      	str	r3, [r7, #24]
    return(posture);
 800cff8:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800cffa:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800cffc:	b672      	cpsid	i
    return(int_posture);
 800cffe:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the semaphore on the created list.  */
    TX_DISABLE
 800d000:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the semaphore ID to make it valid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_SEMAPHORE_ID;
 800d002:	68fb      	ldr	r3, [r7, #12]
 800d004:	4a18      	ldr	r2, [pc, #96]	; (800d068 <_tx_semaphore_create+0x98>)
 800d006:	601a      	str	r2, [r3, #0]

    /* Place the semaphore on the list of created semaphores.  First,
       check for an empty list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
 800d008:	4b18      	ldr	r3, [pc, #96]	; (800d06c <_tx_semaphore_create+0x9c>)
 800d00a:	681b      	ldr	r3, [r3, #0]
 800d00c:	2b00      	cmp	r3, #0
 800d00e:	d109      	bne.n	800d024 <_tx_semaphore_create+0x54>
    {

        /* The created semaphore list is empty.  Add semaphore to empty list.  */
        _tx_semaphore_created_ptr =                       semaphore_ptr;
 800d010:	4a17      	ldr	r2, [pc, #92]	; (800d070 <_tx_semaphore_create+0xa0>)
 800d012:	68fb      	ldr	r3, [r7, #12]
 800d014:	6013      	str	r3, [r2, #0]
        semaphore_ptr -> tx_semaphore_created_next =      semaphore_ptr;
 800d016:	68fb      	ldr	r3, [r7, #12]
 800d018:	68fa      	ldr	r2, [r7, #12]
 800d01a:	615a      	str	r2, [r3, #20]
        semaphore_ptr -> tx_semaphore_created_previous =  semaphore_ptr;
 800d01c:	68fb      	ldr	r3, [r7, #12]
 800d01e:	68fa      	ldr	r2, [r7, #12]
 800d020:	619a      	str	r2, [r3, #24]
 800d022:	e011      	b.n	800d048 <_tx_semaphore_create+0x78>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_semaphore =      _tx_semaphore_created_ptr;
 800d024:	4b12      	ldr	r3, [pc, #72]	; (800d070 <_tx_semaphore_create+0xa0>)
 800d026:	681b      	ldr	r3, [r3, #0]
 800d028:	623b      	str	r3, [r7, #32]
        previous_semaphore =  next_semaphore -> tx_semaphore_created_previous;
 800d02a:	6a3b      	ldr	r3, [r7, #32]
 800d02c:	699b      	ldr	r3, [r3, #24]
 800d02e:	61fb      	str	r3, [r7, #28]

        /* Place the new semaphore in the list.  */
        next_semaphore -> tx_semaphore_created_previous =  semaphore_ptr;
 800d030:	6a3b      	ldr	r3, [r7, #32]
 800d032:	68fa      	ldr	r2, [r7, #12]
 800d034:	619a      	str	r2, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  semaphore_ptr;
 800d036:	69fb      	ldr	r3, [r7, #28]
 800d038:	68fa      	ldr	r2, [r7, #12]
 800d03a:	615a      	str	r2, [r3, #20]

        /* Setup this semaphore's next and previous created links.  */
        semaphore_ptr -> tx_semaphore_created_previous =  previous_semaphore;
 800d03c:	68fb      	ldr	r3, [r7, #12]
 800d03e:	69fa      	ldr	r2, [r7, #28]
 800d040:	619a      	str	r2, [r3, #24]
        semaphore_ptr -> tx_semaphore_created_next =      next_semaphore;
 800d042:	68fb      	ldr	r3, [r7, #12]
 800d044:	6a3a      	ldr	r2, [r7, #32]
 800d046:	615a      	str	r2, [r3, #20]
    }

    /* Increment the created count.  */
    _tx_semaphore_created_count++;
 800d048:	4b08      	ldr	r3, [pc, #32]	; (800d06c <_tx_semaphore_create+0x9c>)
 800d04a:	681b      	ldr	r3, [r3, #0]
 800d04c:	3301      	adds	r3, #1
 800d04e:	4a07      	ldr	r2, [pc, #28]	; (800d06c <_tx_semaphore_create+0x9c>)
 800d050:	6013      	str	r3, [r2, #0]
 800d052:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d054:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d056:	693b      	ldr	r3, [r7, #16]
 800d058:	f383 8810 	msr	PRIMASK, r3
}
 800d05c:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800d05e:	2300      	movs	r3, #0
}
 800d060:	4618      	mov	r0, r3
 800d062:	3728      	adds	r7, #40	; 0x28
 800d064:	46bd      	mov	sp, r7
 800d066:	bd80      	pop	{r7, pc}
 800d068:	53454d41 	.word	0x53454d41
 800d06c:	20006cd8 	.word	0x20006cd8
 800d070:	20006cd4 	.word	0x20006cd4

0800d074 <_tx_semaphore_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_delete(TX_SEMAPHORE *semaphore_ptr)
{
 800d074:	b580      	push	{r7, lr}
 800d076:	b092      	sub	sp, #72	; 0x48
 800d078:	af00      	add	r7, sp, #0
 800d07a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d07c:	f3ef 8310 	mrs	r3, PRIMASK
 800d080:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800d082:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800d084:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800d086:	b672      	cpsid	i
    return(int_posture);
 800d088:	6abb      	ldr	r3, [r7, #40]	; 0x28
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Disable interrupts to remove the semaphore from the created list.  */
    TX_DISABLE
 800d08a:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_DELETE_INSERT

    /* Clear the semaphore ID to make it invalid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_CLEAR_ID;
 800d08c:	687b      	ldr	r3, [r7, #4]
 800d08e:	2200      	movs	r2, #0
 800d090:	601a      	str	r2, [r3, #0]

    /* Decrement the number of semaphores.  */
    _tx_semaphore_created_count--;
 800d092:	4b3d      	ldr	r3, [pc, #244]	; (800d188 <_tx_semaphore_delete+0x114>)
 800d094:	681b      	ldr	r3, [r3, #0]
 800d096:	3b01      	subs	r3, #1
 800d098:	4a3b      	ldr	r2, [pc, #236]	; (800d188 <_tx_semaphore_delete+0x114>)
 800d09a:	6013      	str	r3, [r2, #0]

    /* See if the semaphore is the only one on the list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
 800d09c:	4b3a      	ldr	r3, [pc, #232]	; (800d188 <_tx_semaphore_delete+0x114>)
 800d09e:	681b      	ldr	r3, [r3, #0]
 800d0a0:	2b00      	cmp	r3, #0
 800d0a2:	d103      	bne.n	800d0ac <_tx_semaphore_delete+0x38>
    {

        /* Only created semaphore, just set the created list to NULL.  */
        _tx_semaphore_created_ptr =  TX_NULL;
 800d0a4:	4b39      	ldr	r3, [pc, #228]	; (800d18c <_tx_semaphore_delete+0x118>)
 800d0a6:	2200      	movs	r2, #0
 800d0a8:	601a      	str	r2, [r3, #0]
 800d0aa:	e013      	b.n	800d0d4 <_tx_semaphore_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_semaphore =                                   semaphore_ptr -> tx_semaphore_created_next;
 800d0ac:	687b      	ldr	r3, [r7, #4]
 800d0ae:	695b      	ldr	r3, [r3, #20]
 800d0b0:	63bb      	str	r3, [r7, #56]	; 0x38
        previous_semaphore =                               semaphore_ptr -> tx_semaphore_created_previous;
 800d0b2:	687b      	ldr	r3, [r7, #4]
 800d0b4:	699b      	ldr	r3, [r3, #24]
 800d0b6:	637b      	str	r3, [r7, #52]	; 0x34
        next_semaphore -> tx_semaphore_created_previous =  previous_semaphore;
 800d0b8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d0ba:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d0bc:	619a      	str	r2, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  next_semaphore;
 800d0be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d0c0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800d0c2:	615a      	str	r2, [r3, #20]

        /* See if we have to update the created list head pointer.  */
        if (_tx_semaphore_created_ptr == semaphore_ptr)
 800d0c4:	4b31      	ldr	r3, [pc, #196]	; (800d18c <_tx_semaphore_delete+0x118>)
 800d0c6:	681b      	ldr	r3, [r3, #0]
 800d0c8:	687a      	ldr	r2, [r7, #4]
 800d0ca:	429a      	cmp	r2, r3
 800d0cc:	d102      	bne.n	800d0d4 <_tx_semaphore_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_semaphore_created_ptr =  next_semaphore;
 800d0ce:	4a2f      	ldr	r2, [pc, #188]	; (800d18c <_tx_semaphore_delete+0x118>)
 800d0d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d0d2:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800d0d4:	4b2e      	ldr	r3, [pc, #184]	; (800d190 <_tx_semaphore_delete+0x11c>)
 800d0d6:	681b      	ldr	r3, [r3, #0]
 800d0d8:	3301      	adds	r3, #1
 800d0da:	4a2d      	ldr	r2, [pc, #180]	; (800d190 <_tx_semaphore_delete+0x11c>)
 800d0dc:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                                     semaphore_ptr -> tx_semaphore_suspension_list;
 800d0de:	687b      	ldr	r3, [r7, #4]
 800d0e0:	68db      	ldr	r3, [r3, #12]
 800d0e2:	647b      	str	r3, [r7, #68]	; 0x44
    semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 800d0e4:	687b      	ldr	r3, [r7, #4]
 800d0e6:	2200      	movs	r2, #0
 800d0e8:	60da      	str	r2, [r3, #12]
    suspended_count =                                semaphore_ptr -> tx_semaphore_suspended_count;
 800d0ea:	687b      	ldr	r3, [r7, #4]
 800d0ec:	691b      	ldr	r3, [r3, #16]
 800d0ee:	643b      	str	r3, [r7, #64]	; 0x40
    semaphore_ptr -> tx_semaphore_suspended_count =  TX_NO_SUSPENSIONS;
 800d0f0:	687b      	ldr	r3, [r7, #4]
 800d0f2:	2200      	movs	r2, #0
 800d0f4:	611a      	str	r2, [r3, #16]
 800d0f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d0f8:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d0fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d0fc:	f383 8810 	msr	PRIMASK, r3
}
 800d100:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the semaphore list to resume any and all threads suspended
       on this semaphore.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
 800d102:	e024      	b.n	800d14e <_tx_semaphore_delete+0xda>
    {

        /* Decrement the suspension count.  */
        suspended_count--;
 800d104:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d106:	3b01      	subs	r3, #1
 800d108:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d10a:	f3ef 8310 	mrs	r3, PRIMASK
 800d10e:	61fb      	str	r3, [r7, #28]
    return(posture);
 800d110:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800d112:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d114:	b672      	cpsid	i
    return(int_posture);
 800d116:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
 800d118:	63fb      	str	r3, [r7, #60]	; 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800d11a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d11c:	2200      	movs	r2, #0
 800d11e:	669a      	str	r2, [r3, #104]	; 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 800d120:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d122:	2201      	movs	r2, #1
 800d124:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 800d128:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d12a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d12c:	633b      	str	r3, [r7, #48]	; 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 800d12e:	4b18      	ldr	r3, [pc, #96]	; (800d190 <_tx_semaphore_delete+0x11c>)
 800d130:	681b      	ldr	r3, [r3, #0]
 800d132:	3301      	adds	r3, #1
 800d134:	4a16      	ldr	r2, [pc, #88]	; (800d190 <_tx_semaphore_delete+0x11c>)
 800d136:	6013      	str	r3, [r2, #0]
 800d138:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d13a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d13c:	6a3b      	ldr	r3, [r7, #32]
 800d13e:	f383 8810 	msr	PRIMASK, r3
}
 800d142:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 800d144:	6c78      	ldr	r0, [r7, #68]	; 0x44
 800d146:	f000 fe39 	bl	800ddbc <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 800d14a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d14c:	647b      	str	r3, [r7, #68]	; 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
 800d14e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d150:	2b00      	cmp	r3, #0
 800d152:	d1d7      	bne.n	800d104 <_tx_semaphore_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d154:	f3ef 8310 	mrs	r3, PRIMASK
 800d158:	613b      	str	r3, [r7, #16]
    return(posture);
 800d15a:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800d15c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d15e:	b672      	cpsid	i
    return(int_posture);
 800d160:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_SEMAPHORE_DELETE_PORT_COMPLETION(semaphore_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
 800d162:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 800d164:	4b0a      	ldr	r3, [pc, #40]	; (800d190 <_tx_semaphore_delete+0x11c>)
 800d166:	681b      	ldr	r3, [r3, #0]
 800d168:	3b01      	subs	r3, #1
 800d16a:	4a09      	ldr	r2, [pc, #36]	; (800d190 <_tx_semaphore_delete+0x11c>)
 800d16c:	6013      	str	r3, [r2, #0]
 800d16e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800d170:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d172:	697b      	ldr	r3, [r7, #20]
 800d174:	f383 8810 	msr	PRIMASK, r3
}
 800d178:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800d17a:	f000 fde5 	bl	800dd48 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800d17e:	2300      	movs	r3, #0
}
 800d180:	4618      	mov	r0, r3
 800d182:	3748      	adds	r7, #72	; 0x48
 800d184:	46bd      	mov	sp, r7
 800d186:	bd80      	pop	{r7, pc}
 800d188:	20006cd8 	.word	0x20006cd8
 800d18c:	20006cd4 	.word	0x20006cd4
 800d190:	20006d9c 	.word	0x20006d9c

0800d194 <_tx_semaphore_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
 800d194:	b580      	push	{r7, lr}
 800d196:	b08c      	sub	sp, #48	; 0x30
 800d198:	af00      	add	r7, sp, #0
 800d19a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d19c:	f3ef 8310 	mrs	r3, PRIMASK
 800d1a0:	61bb      	str	r3, [r7, #24]
    return(posture);
 800d1a2:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800d1a4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d1a6:	b672      	cpsid	i
    return(int_posture);
 800d1a8:	697b      	ldr	r3, [r7, #20]
TX_THREAD       *next_thread;
TX_THREAD       *previous_thread;


    /* Disable interrupts to put an instance back to the semaphore.  */
    TX_DISABLE
 800d1aa:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_PUT_INSERT

    /* Pickup the number of suspended threads.  */
    suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
 800d1ac:	687b      	ldr	r3, [r7, #4]
 800d1ae:	691b      	ldr	r3, [r3, #16]
 800d1b0:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Determine if there are any threads suspended on the semaphore.  */
    if (suspended_count == TX_NO_SUSPENSIONS)
 800d1b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d1b4:	2b00      	cmp	r3, #0
 800d1b6:	d10a      	bne.n	800d1ce <_tx_semaphore_put+0x3a>
    {

        /* Increment the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count++;
 800d1b8:	687b      	ldr	r3, [r7, #4]
 800d1ba:	689b      	ldr	r3, [r3, #8]
 800d1bc:	1c5a      	adds	r2, r3, #1
 800d1be:	687b      	ldr	r3, [r7, #4]
 800d1c0:	609a      	str	r2, [r3, #8]
 800d1c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d1c4:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d1c6:	693b      	ldr	r3, [r7, #16]
 800d1c8:	f383 8810 	msr	PRIMASK, r3
}
 800d1cc:	e033      	b.n	800d236 <_tx_semaphore_put+0xa2>
    {

        /* A thread is suspended on this semaphore.  */

        /* Pickup the pointer to the first suspended thread.  */
        thread_ptr =  semaphore_ptr -> tx_semaphore_suspension_list;
 800d1ce:	687b      	ldr	r3, [r7, #4]
 800d1d0:	68db      	ldr	r3, [r3, #12]
 800d1d2:	627b      	str	r3, [r7, #36]	; 0x24

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        suspended_count--;
 800d1d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d1d6:	3b01      	subs	r3, #1
 800d1d8:	62bb      	str	r3, [r7, #40]	; 0x28
        if (suspended_count == TX_NO_SUSPENSIONS)
 800d1da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d1dc:	2b00      	cmp	r3, #0
 800d1de:	d103      	bne.n	800d1e8 <_tx_semaphore_put+0x54>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 800d1e0:	687b      	ldr	r3, [r7, #4]
 800d1e2:	2200      	movs	r2, #0
 800d1e4:	60da      	str	r2, [r3, #12]
 800d1e6:	e00e      	b.n	800d206 <_tx_semaphore_put+0x72>
        {

            /* At least one more thread is on the same expiration list.  */

            /* Update the list head pointer.  */
            next_thread =                                     thread_ptr -> tx_thread_suspended_next;
 800d1e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800d1ec:	623b      	str	r3, [r7, #32]
            semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
 800d1ee:	687b      	ldr	r3, [r7, #4]
 800d1f0:	6a3a      	ldr	r2, [r7, #32]
 800d1f2:	60da      	str	r2, [r3, #12]

            /* Update the links of the adjacent threads.  */
            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800d1f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d1f6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800d1f8:	61fb      	str	r3, [r7, #28]
            next_thread -> tx_thread_suspended_previous =   previous_thread;
 800d1fa:	6a3b      	ldr	r3, [r7, #32]
 800d1fc:	69fa      	ldr	r2, [r7, #28]
 800d1fe:	675a      	str	r2, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =   next_thread;
 800d200:	69fb      	ldr	r3, [r7, #28]
 800d202:	6a3a      	ldr	r2, [r7, #32]
 800d204:	671a      	str	r2, [r3, #112]	; 0x70
        }

        /* Decrement the suspension count.  */
        semaphore_ptr -> tx_semaphore_suspended_count =  suspended_count;
 800d206:	687b      	ldr	r3, [r7, #4]
 800d208:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d20a:	611a      	str	r2, [r3, #16]

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800d20c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d20e:	2200      	movs	r2, #0
 800d210:	669a      	str	r2, [r3, #104]	; 0x68
        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
#endif

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800d212:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d214:	2200      	movs	r2, #0
 800d216:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
 800d21a:	4b09      	ldr	r3, [pc, #36]	; (800d240 <_tx_semaphore_put+0xac>)
 800d21c:	681b      	ldr	r3, [r3, #0]
 800d21e:	3301      	adds	r3, #1
 800d220:	4a07      	ldr	r2, [pc, #28]	; (800d240 <_tx_semaphore_put+0xac>)
 800d222:	6013      	str	r3, [r2, #0]
 800d224:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d226:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d228:	68fb      	ldr	r3, [r7, #12]
 800d22a:	f383 8810 	msr	PRIMASK, r3
}
 800d22e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
 800d230:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800d232:	f000 fdc3 	bl	800ddbc <_tx_thread_system_resume>
        }
#endif
    }

    /* Return successful completion.  */
    return(TX_SUCCESS);
 800d236:	2300      	movs	r3, #0
}
 800d238:	4618      	mov	r0, r3
 800d23a:	3730      	adds	r7, #48	; 0x30
 800d23c:	46bd      	mov	sp, r7
 800d23e:	bd80      	pop	{r7, pc}
 800d240:	20006d9c 	.word	0x20006d9c

0800d244 <_tx_thread_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr, VOID (*entry_function)(ULONG id), ULONG entry_input,
                            VOID *stack_start, ULONG stack_size, UINT priority, UINT preempt_threshold,
                            ULONG time_slice, UINT auto_start)
{
 800d244:	b580      	push	{r7, lr}
 800d246:	b092      	sub	sp, #72	; 0x48
 800d248:	af00      	add	r7, sp, #0
 800d24a:	60f8      	str	r0, [r7, #12]
 800d24c:	60b9      	str	r1, [r7, #8]
 800d24e:	607a      	str	r2, [r7, #4]
 800d250:	603b      	str	r3, [r7, #0]
TX_INTERRUPT_SAVE_AREA

TX_THREAD               *next_thread;
TX_THREAD               *previous_thread;
TX_THREAD               *saved_thread_ptr;
UINT                    saved_threshold =  ((UINT) 0);
 800d252:	2300      	movs	r3, #0
 800d254:	643b      	str	r3, [r7, #64]	; 0x40
#ifndef TX_DISABLE_STACK_FILLING

    /* Set the thread stack to a pattern prior to creating the initial
       stack frame.  This pattern is used by the stack checking routines
       to see how much has been used.  */
    TX_MEMSET(stack_start, ((UCHAR) TX_STACK_FILL), stack_size);
 800d256:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800d258:	21ef      	movs	r1, #239	; 0xef
 800d25a:	6d38      	ldr	r0, [r7, #80]	; 0x50
 800d25c:	f006 f804 	bl	8013268 <memset>

    /* Prepare the thread control block prior to placing it on the created
       list.  */

    /* Initialize thread control block to all zeros.  */
    TX_MEMSET(thread_ptr, 0, (sizeof(TX_THREAD)));
 800d260:	22b0      	movs	r2, #176	; 0xb0
 800d262:	2100      	movs	r1, #0
 800d264:	68f8      	ldr	r0, [r7, #12]
 800d266:	f005 ffff 	bl	8013268 <memset>

    /* Place the supplied parameters into the thread's control block.  */
    thread_ptr -> tx_thread_name =              name_ptr;
 800d26a:	68fb      	ldr	r3, [r7, #12]
 800d26c:	68ba      	ldr	r2, [r7, #8]
 800d26e:	629a      	str	r2, [r3, #40]	; 0x28
    thread_ptr -> tx_thread_entry =             entry_function;
 800d270:	68fb      	ldr	r3, [r7, #12]
 800d272:	687a      	ldr	r2, [r7, #4]
 800d274:	645a      	str	r2, [r3, #68]	; 0x44
    thread_ptr -> tx_thread_entry_parameter =   entry_input;
 800d276:	68fb      	ldr	r3, [r7, #12]
 800d278:	683a      	ldr	r2, [r7, #0]
 800d27a:	649a      	str	r2, [r3, #72]	; 0x48
    thread_ptr -> tx_thread_stack_start =       stack_start;
 800d27c:	68fb      	ldr	r3, [r7, #12]
 800d27e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800d280:	60da      	str	r2, [r3, #12]
    thread_ptr -> tx_thread_stack_size =        stack_size;
 800d282:	68fb      	ldr	r3, [r7, #12]
 800d284:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800d286:	615a      	str	r2, [r3, #20]
    thread_ptr -> tx_thread_priority =          priority;
 800d288:	68fb      	ldr	r3, [r7, #12]
 800d28a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800d28c:	62da      	str	r2, [r3, #44]	; 0x2c
    thread_ptr -> tx_thread_user_priority =     priority;
 800d28e:	68fb      	ldr	r3, [r7, #12]
 800d290:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800d292:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    thread_ptr -> tx_thread_time_slice =        time_slice;
 800d296:	68fb      	ldr	r3, [r7, #12]
 800d298:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800d29a:	619a      	str	r2, [r3, #24]
    thread_ptr -> tx_thread_new_time_slice =    time_slice;
 800d29c:	68fb      	ldr	r3, [r7, #12]
 800d29e:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800d2a0:	61da      	str	r2, [r3, #28]
    thread_ptr -> tx_thread_inherit_priority =  ((UINT) TX_MAX_PRIORITIES);
 800d2a2:	68fb      	ldr	r3, [r7, #12]
 800d2a4:	2220      	movs	r2, #32
 800d2a6:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c

    /* Calculate the end of the thread's stack area.  */
    temp_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
 800d2aa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d2ac:	63fb      	str	r3, [r7, #60]	; 0x3c
    temp_ptr =  (TX_UCHAR_POINTER_ADD(temp_ptr, (stack_size - ((ULONG) 1))));
 800d2ae:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d2b0:	3b01      	subs	r3, #1
 800d2b2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800d2b4:	4413      	add	r3, r2
 800d2b6:	63fb      	str	r3, [r7, #60]	; 0x3c
    thread_ptr -> tx_thread_stack_end =         TX_UCHAR_TO_VOID_POINTER_CONVERT(temp_ptr);
 800d2b8:	68fb      	ldr	r3, [r7, #12]
 800d2ba:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800d2bc:	611a      	str	r2, [r3, #16]
    thread_ptr -> tx_thread_preempt_threshold =       preempt_threshold;
    thread_ptr -> tx_thread_user_preempt_threshold =  preempt_threshold;
#else

    /* Preemption-threshold is disabled, determine if preemption-threshold was required.  */
    if (priority != preempt_threshold)
 800d2be:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800d2c0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800d2c2:	429a      	cmp	r2, r3
 800d2c4:	d007      	beq.n	800d2d6 <_tx_thread_create+0x92>
    {

        /* Preemption-threshold specified. Since specific preemption-threshold is not supported,
           disable all preemption.  */
        thread_ptr -> tx_thread_preempt_threshold =       ((UINT) 0);
 800d2c6:	68fb      	ldr	r3, [r7, #12]
 800d2c8:	2200      	movs	r2, #0
 800d2ca:	63da      	str	r2, [r3, #60]	; 0x3c
        thread_ptr -> tx_thread_user_preempt_threshold =  ((UINT) 0);
 800d2cc:	68fb      	ldr	r3, [r7, #12]
 800d2ce:	2200      	movs	r2, #0
 800d2d0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
 800d2d4:	e006      	b.n	800d2e4 <_tx_thread_create+0xa0>
    }
    else
    {

        /* Preemption-threshold is not specified, just setup with the priority.  */
        thread_ptr -> tx_thread_preempt_threshold =       priority;
 800d2d6:	68fb      	ldr	r3, [r7, #12]
 800d2d8:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800d2da:	63da      	str	r2, [r3, #60]	; 0x3c
        thread_ptr -> tx_thread_user_preempt_threshold =  priority;
 800d2dc:	68fb      	ldr	r3, [r7, #12]
 800d2de:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800d2e0:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    }
#endif

    /* Now fill in the values that are required for thread initialization.  */
    thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 800d2e4:	68fb      	ldr	r3, [r7, #12]
 800d2e6:	2203      	movs	r2, #3
 800d2e8:	631a      	str	r2, [r3, #48]	; 0x30

    /* Setup the necessary fields in the thread timer block.  */
    TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
 800d2ea:	68fb      	ldr	r3, [r7, #12]
 800d2ec:	4a48      	ldr	r2, [pc, #288]	; (800d410 <_tx_thread_create+0x1cc>)
 800d2ee:	655a      	str	r2, [r3, #84]	; 0x54
 800d2f0:	68fa      	ldr	r2, [r7, #12]
 800d2f2:	68fb      	ldr	r3, [r7, #12]
 800d2f4:	659a      	str	r2, [r3, #88]	; 0x58
    TX_THREAD_CREATE_INTERNAL_EXTENSION(thread_ptr)

    /* Call the target specific stack frame building routine to build the
       thread's initial stack and to setup the actual stack pointer in the
       control block.  */
    _tx_thread_stack_build(thread_ptr, _tx_thread_shell_entry);
 800d2f6:	4947      	ldr	r1, [pc, #284]	; (800d414 <_tx_thread_create+0x1d0>)
 800d2f8:	68f8      	ldr	r0, [r7, #12]
 800d2fa:	f7f2 ffe1 	bl	80002c0 <_tx_thread_stack_build>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d2fe:	f3ef 8310 	mrs	r3, PRIMASK
 800d302:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800d304:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800d306:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800d308:	b672      	cpsid	i
    return(int_posture);
 800d30a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    /* Setup the highest usage stack pointer.  */
    thread_ptr -> tx_thread_stack_highest_ptr =  thread_ptr -> tx_thread_stack_ptr;
#endif

    /* Prepare to make this thread a member of the created thread list.  */
    TX_DISABLE
 800d30c:	63bb      	str	r3, [r7, #56]	; 0x38

    /* Load the thread ID field in the thread control block.  */
    thread_ptr -> tx_thread_id =  TX_THREAD_ID;
 800d30e:	68fb      	ldr	r3, [r7, #12]
 800d310:	4a41      	ldr	r2, [pc, #260]	; (800d418 <_tx_thread_create+0x1d4>)
 800d312:	601a      	str	r2, [r3, #0]

    /* Place the thread on the list of created threads.  First,
       check for an empty list.  */
    if (_tx_thread_created_count == TX_EMPTY)
 800d314:	4b41      	ldr	r3, [pc, #260]	; (800d41c <_tx_thread_create+0x1d8>)
 800d316:	681b      	ldr	r3, [r3, #0]
 800d318:	2b00      	cmp	r3, #0
 800d31a:	d10b      	bne.n	800d334 <_tx_thread_create+0xf0>
    {

        /* The created thread list is empty.  Add thread to empty list.  */
        _tx_thread_created_ptr =                    thread_ptr;
 800d31c:	4a40      	ldr	r2, [pc, #256]	; (800d420 <_tx_thread_create+0x1dc>)
 800d31e:	68fb      	ldr	r3, [r7, #12]
 800d320:	6013      	str	r3, [r2, #0]
        thread_ptr -> tx_thread_created_next =      thread_ptr;
 800d322:	68fb      	ldr	r3, [r7, #12]
 800d324:	68fa      	ldr	r2, [r7, #12]
 800d326:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        thread_ptr -> tx_thread_created_previous =  thread_ptr;
 800d32a:	68fb      	ldr	r3, [r7, #12]
 800d32c:	68fa      	ldr	r2, [r7, #12]
 800d32e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
 800d332:	e016      	b.n	800d362 <_tx_thread_create+0x11e>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_thread =  _tx_thread_created_ptr;
 800d334:	4b3a      	ldr	r3, [pc, #232]	; (800d420 <_tx_thread_create+0x1dc>)
 800d336:	681b      	ldr	r3, [r3, #0]
 800d338:	637b      	str	r3, [r7, #52]	; 0x34
        previous_thread =  next_thread -> tx_thread_created_previous;
 800d33a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d33c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800d340:	633b      	str	r3, [r7, #48]	; 0x30

        /* Place the new thread in the list.  */
        next_thread -> tx_thread_created_previous =  thread_ptr;
 800d342:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d344:	68fa      	ldr	r2, [r7, #12]
 800d346:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        previous_thread -> tx_thread_created_next =  thread_ptr;
 800d34a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d34c:	68fa      	ldr	r2, [r7, #12]
 800d34e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

        /* Setup this thread's created links.  */
        thread_ptr -> tx_thread_created_previous =  previous_thread;
 800d352:	68fb      	ldr	r3, [r7, #12]
 800d354:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800d356:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        thread_ptr -> tx_thread_created_next =      next_thread;
 800d35a:	68fb      	ldr	r3, [r7, #12]
 800d35c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800d35e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    }

    /* Increment the thread created count.  */
    _tx_thread_created_count++;
 800d362:	4b2e      	ldr	r3, [pc, #184]	; (800d41c <_tx_thread_create+0x1d8>)
 800d364:	681b      	ldr	r3, [r3, #0]
 800d366:	3301      	adds	r3, #1
 800d368:	4a2c      	ldr	r2, [pc, #176]	; (800d41c <_tx_thread_create+0x1d8>)
 800d36a:	6013      	str	r3, [r2, #0]
    TX_EL_THREAD_CREATE_INSERT

#ifndef TX_NOT_INTERRUPTABLE

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800d36c:	4b2d      	ldr	r3, [pc, #180]	; (800d424 <_tx_thread_create+0x1e0>)
 800d36e:	681b      	ldr	r3, [r3, #0]
 800d370:	3301      	adds	r3, #1
 800d372:	4a2c      	ldr	r2, [pc, #176]	; (800d424 <_tx_thread_create+0x1e0>)
 800d374:	6013      	str	r3, [r2, #0]
#endif

    /* Determine if an automatic start was requested.  If so, call the resume
       thread function and then check for a preemption condition.  */
    if (auto_start == TX_AUTO_START)
 800d376:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800d378:	2b01      	cmp	r3, #1
 800d37a:	d129      	bne.n	800d3d0 <_tx_thread_create+0x18c>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d37c:	f3ef 8305 	mrs	r3, IPSR
 800d380:	627b      	str	r3, [r7, #36]	; 0x24
    return(ipsr_value);
 800d382:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
 800d384:	4b28      	ldr	r3, [pc, #160]	; (800d428 <_tx_thread_create+0x1e4>)
 800d386:	681b      	ldr	r3, [r3, #0]
 800d388:	4313      	orrs	r3, r2
 800d38a:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800d38e:	d30d      	bcc.n	800d3ac <_tx_thread_create+0x168>

            /* Pickup the current thread execute pointer, which corresponds to the
               highest priority thread ready to execute.  Interrupt lockout is
               not required, since interrupts are assumed to be disabled during
               initialization.  */
            saved_thread_ptr =  _tx_thread_execute_ptr;
 800d390:	4b26      	ldr	r3, [pc, #152]	; (800d42c <_tx_thread_create+0x1e8>)
 800d392:	681b      	ldr	r3, [r3, #0]
 800d394:	647b      	str	r3, [r7, #68]	; 0x44

            /* Determine if there is thread ready for execution.  */
            if (saved_thread_ptr != TX_NULL)
 800d396:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d398:	2b00      	cmp	r3, #0
 800d39a:	d009      	beq.n	800d3b0 <_tx_thread_create+0x16c>
            {

                /* Yes, a thread is ready for execution when initialization completes.  */

                /* Save the current preemption-threshold.  */
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
 800d39c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d39e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d3a0:	643b      	str	r3, [r7, #64]	; 0x40

                /* For initialization, temporarily set the preemption-threshold to the
                   priority level to make sure the highest-priority thread runs once
                   initialization is complete.  */
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 800d3a2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d3a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d3a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d3a8:	63da      	str	r2, [r3, #60]	; 0x3c
 800d3aa:	e001      	b.n	800d3b0 <_tx_thread_create+0x16c>
        }
        else
        {

            /* Simply set the saved thread pointer to NULL.  */
            saved_thread_ptr =  TX_NULL;
 800d3ac:	2300      	movs	r3, #0
 800d3ae:	647b      	str	r3, [r7, #68]	; 0x44
 800d3b0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d3b2:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d3b4:	6a3b      	ldr	r3, [r7, #32]
 800d3b6:	f383 8810 	msr	PRIMASK, r3
}
 800d3ba:	bf00      	nop

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Call the resume thread function to make this thread ready.  */
        _tx_thread_system_resume(thread_ptr);
 800d3bc:	68f8      	ldr	r0, [r7, #12]
 800d3be:	f000 fcfd 	bl	800ddbc <_tx_thread_system_resume>
#endif

        /* Determine if the thread's preemption-threshold needs to be restored.  */
        if (saved_thread_ptr != TX_NULL)
 800d3c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d3c4:	2b00      	cmp	r3, #0
 800d3c6:	d01e      	beq.n	800d406 <_tx_thread_create+0x1c2>
        {

            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
               can only happen if this routine is called from initialization.  */
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
 800d3c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d3ca:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800d3cc:	63da      	str	r2, [r3, #60]	; 0x3c
 800d3ce:	e01a      	b.n	800d406 <_tx_thread_create+0x1c2>
 800d3d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d3d2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d3d4:	693b      	ldr	r3, [r7, #16]
 800d3d6:	f383 8810 	msr	PRIMASK, r3
}
 800d3da:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d3dc:	f3ef 8310 	mrs	r3, PRIMASK
 800d3e0:	61bb      	str	r3, [r7, #24]
    return(posture);
 800d3e2:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800d3e4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d3e6:	b672      	cpsid	i
    return(int_posture);
 800d3e8:	697b      	ldr	r3, [r7, #20]

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Disable interrupts.  */
        TX_DISABLE
 800d3ea:	63bb      	str	r3, [r7, #56]	; 0x38

        /* Re-enable preemption.  */
        _tx_thread_preempt_disable--;
 800d3ec:	4b0d      	ldr	r3, [pc, #52]	; (800d424 <_tx_thread_create+0x1e0>)
 800d3ee:	681b      	ldr	r3, [r3, #0]
 800d3f0:	3b01      	subs	r3, #1
 800d3f2:	4a0c      	ldr	r2, [pc, #48]	; (800d424 <_tx_thread_create+0x1e0>)
 800d3f4:	6013      	str	r3, [r2, #0]
 800d3f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800d3f8:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d3fa:	69fb      	ldr	r3, [r7, #28]
 800d3fc:	f383 8810 	msr	PRIMASK, r3
}
 800d400:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800d402:	f000 fca1 	bl	800dd48 <_tx_thread_system_preempt_check>
#endif
    }

    /* Always return a success.  */
    return(TX_SUCCESS);
 800d406:	2300      	movs	r3, #0
}
 800d408:	4618      	mov	r0, r3
 800d40a:	3748      	adds	r7, #72	; 0x48
 800d40c:	46bd      	mov	sp, r7
 800d40e:	bd80      	pop	{r7, pc}
 800d410:	0800e591 	.word	0x0800e591
 800d414:	0800d8fd 	.word	0x0800d8fd
 800d418:	54485244 	.word	0x54485244
 800d41c:	20006d10 	.word	0x20006d10
 800d420:	20006d0c 	.word	0x20006d0c
 800d424:	20006d9c 	.word	0x20006d9c
 800d428:	20000090 	.word	0x20000090
 800d42c:	20006d08 	.word	0x20006d08

0800d430 <_tx_thread_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_delete(TX_THREAD *thread_ptr)
{
 800d430:	b480      	push	{r7}
 800d432:	b08b      	sub	sp, #44	; 0x2c
 800d434:	af00      	add	r7, sp, #0
 800d436:	6078      	str	r0, [r7, #4]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800d438:	2300      	movs	r3, #0
 800d43a:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d43c:	f3ef 8310 	mrs	r3, PRIMASK
 800d440:	617b      	str	r3, [r7, #20]
    return(posture);
 800d442:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800d444:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d446:	b672      	cpsid	i
    return(int_posture);
 800d448:	693b      	ldr	r3, [r7, #16]

    /* Lockout interrupts while the thread is being deleted.  */
    TX_DISABLE
 800d44a:	623b      	str	r3, [r7, #32]

    /* Check for proper status of this thread to delete.  */
    if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 800d44c:	687b      	ldr	r3, [r7, #4]
 800d44e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d450:	2b01      	cmp	r3, #1
 800d452:	d00b      	beq.n	800d46c <_tx_thread_delete+0x3c>
    {

        /* Now check for terminated state.  */
        if (thread_ptr -> tx_thread_state != TX_TERMINATED)
 800d454:	687b      	ldr	r3, [r7, #4]
 800d456:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d458:	2b02      	cmp	r3, #2
 800d45a:	d007      	beq.n	800d46c <_tx_thread_delete+0x3c>
 800d45c:	6a3b      	ldr	r3, [r7, #32]
 800d45e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d460:	68fb      	ldr	r3, [r7, #12]
 800d462:	f383 8810 	msr	PRIMASK, r3
}
 800d466:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Thread not completed or terminated - return an error!  */
            status =  TX_DELETE_ERROR;
 800d468:	2311      	movs	r3, #17
 800d46a:	627b      	str	r3, [r7, #36]	; 0x24
        }
    }

    /* Determine if the delete operation is okay.  */
    if (status == TX_SUCCESS)
 800d46c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d46e:	2b00      	cmp	r3, #0
 800d470:	d12d      	bne.n	800d4ce <_tx_thread_delete+0x9e>

        /* Unregister thread in the thread array structure.  */
        TX_EL_THREAD_UNREGISTER(thread_ptr)

        /* Clear the thread ID to make it invalid.  */
        thread_ptr -> tx_thread_id =  TX_CLEAR_ID;
 800d472:	687b      	ldr	r3, [r7, #4]
 800d474:	2200      	movs	r2, #0
 800d476:	601a      	str	r2, [r3, #0]

        /* Decrement the number of created threads.  */
        _tx_thread_created_count--;
 800d478:	4b18      	ldr	r3, [pc, #96]	; (800d4dc <_tx_thread_delete+0xac>)
 800d47a:	681b      	ldr	r3, [r3, #0]
 800d47c:	3b01      	subs	r3, #1
 800d47e:	4a17      	ldr	r2, [pc, #92]	; (800d4dc <_tx_thread_delete+0xac>)
 800d480:	6013      	str	r3, [r2, #0]

        /* See if the thread is the only one on the list.  */
        if (_tx_thread_created_count == TX_EMPTY)
 800d482:	4b16      	ldr	r3, [pc, #88]	; (800d4dc <_tx_thread_delete+0xac>)
 800d484:	681b      	ldr	r3, [r3, #0]
 800d486:	2b00      	cmp	r3, #0
 800d488:	d103      	bne.n	800d492 <_tx_thread_delete+0x62>
        {

            /* Only created thread, just set the created list to NULL.  */
            _tx_thread_created_ptr =  TX_NULL;
 800d48a:	4b15      	ldr	r3, [pc, #84]	; (800d4e0 <_tx_thread_delete+0xb0>)
 800d48c:	2200      	movs	r2, #0
 800d48e:	601a      	str	r2, [r3, #0]
 800d490:	e017      	b.n	800d4c2 <_tx_thread_delete+0x92>
        }
        else
        {

            /* Otherwise, not the only created thread, link-up the neighbors.  */
            next_thread =                                thread_ptr -> tx_thread_created_next;
 800d492:	687b      	ldr	r3, [r7, #4]
 800d494:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800d498:	61fb      	str	r3, [r7, #28]
            previous_thread =                            thread_ptr -> tx_thread_created_previous;
 800d49a:	687b      	ldr	r3, [r7, #4]
 800d49c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800d4a0:	61bb      	str	r3, [r7, #24]
            next_thread -> tx_thread_created_previous =  previous_thread;
 800d4a2:	69fb      	ldr	r3, [r7, #28]
 800d4a4:	69ba      	ldr	r2, [r7, #24]
 800d4a6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            previous_thread -> tx_thread_created_next =  next_thread;
 800d4aa:	69bb      	ldr	r3, [r7, #24]
 800d4ac:	69fa      	ldr	r2, [r7, #28]
 800d4ae:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

            /* See if we have to update the created list head pointer.  */
            if (_tx_thread_created_ptr == thread_ptr)
 800d4b2:	4b0b      	ldr	r3, [pc, #44]	; (800d4e0 <_tx_thread_delete+0xb0>)
 800d4b4:	681b      	ldr	r3, [r3, #0]
 800d4b6:	687a      	ldr	r2, [r7, #4]
 800d4b8:	429a      	cmp	r2, r3
 800d4ba:	d102      	bne.n	800d4c2 <_tx_thread_delete+0x92>
            {

                /* Yes, move the head pointer to the next link. */
                _tx_thread_created_ptr =  next_thread;
 800d4bc:	4a08      	ldr	r2, [pc, #32]	; (800d4e0 <_tx_thread_delete+0xb0>)
 800d4be:	69fb      	ldr	r3, [r7, #28]
 800d4c0:	6013      	str	r3, [r2, #0]
 800d4c2:	6a3b      	ldr	r3, [r7, #32]
 800d4c4:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d4c6:	68bb      	ldr	r3, [r7, #8]
 800d4c8:	f383 8810 	msr	PRIMASK, r3
}
 800d4cc:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Return completion status.  */
    return(status);
 800d4ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 800d4d0:	4618      	mov	r0, r3
 800d4d2:	372c      	adds	r7, #44	; 0x2c
 800d4d4:	46bd      	mov	sp, r7
 800d4d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d4da:	4770      	bx	lr
 800d4dc:	20006d10 	.word	0x20006d10
 800d4e0:	20006d0c 	.word	0x20006d0c

0800d4e4 <_tx_thread_identify>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
TX_THREAD  *_tx_thread_identify(VOID)
{
 800d4e4:	b480      	push	{r7}
 800d4e6:	b087      	sub	sp, #28
 800d4e8:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d4ea:	f3ef 8310 	mrs	r3, PRIMASK
 800d4ee:	60bb      	str	r3, [r7, #8]
    return(posture);
 800d4f0:	68bb      	ldr	r3, [r7, #8]
    int_posture = __get_interrupt_posture();
 800d4f2:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d4f4:	b672      	cpsid	i
    return(int_posture);
 800d4f6:	687b      	ldr	r3, [r7, #4]

TX_INTERRUPT_SAVE_AREA


    /* Disable interrupts to put the timer on the created list.  */
    TX_DISABLE
 800d4f8:	617b      	str	r3, [r7, #20]

   /* Log this kernel call.  */
    TX_EL_THREAD_IDENTIFY_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800d4fa:	4b08      	ldr	r3, [pc, #32]	; (800d51c <_tx_thread_identify+0x38>)
 800d4fc:	681b      	ldr	r3, [r3, #0]
 800d4fe:	613b      	str	r3, [r7, #16]
 800d500:	697b      	ldr	r3, [r7, #20]
 800d502:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d504:	68fb      	ldr	r3, [r7, #12]
 800d506:	f383 8810 	msr	PRIMASK, r3
}
 800d50a:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return the current thread pointer.  */
    return(thread_ptr);
 800d50c:	693b      	ldr	r3, [r7, #16]
}
 800d50e:	4618      	mov	r0, r3
 800d510:	371c      	adds	r7, #28
 800d512:	46bd      	mov	sp, r7
 800d514:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d518:	4770      	bx	lr
 800d51a:	bf00      	nop
 800d51c:	20006d04 	.word	0x20006d04

0800d520 <_tx_thread_initialize>:
/*                                            stack check error handling, */
/*                                            resulting in version 6.1.9  */   
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_initialize(VOID)
{
 800d520:	b480      	push	{r7}
 800d522:	af00      	add	r7, sp, #0
#endif
#endif

    /* Setup the highest priority variable to the max, indicating no thread is currently
       ready.  */
    _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 800d524:	4b07      	ldr	r3, [pc, #28]	; (800d544 <_tx_thread_initialize+0x24>)
 800d526:	2220      	movs	r2, #32
 800d528:	601a      	str	r2, [r3, #0]
#endif
#ifdef TX_DISABLE_REDUNDANT_CLEARING
                            | (((ULONG) 1) << 18)
#endif
#ifdef TX_DISABLE_NOTIFY_CALLBACKS
                            | (((ULONG) 1) << 17)
 800d52a:	4b07      	ldr	r3, [pc, #28]	; (800d548 <_tx_thread_initialize+0x28>)
 800d52c:	681b      	ldr	r3, [r3, #0]
 800d52e:	f043 4382 	orr.w	r3, r3, #1090519040	; 0x41000000
 800d532:	f443 039c 	orr.w	r3, r3, #5111808	; 0x4e0000
    _tx_build_options =  _tx_build_options 
 800d536:	4a04      	ldr	r2, [pc, #16]	; (800d548 <_tx_thread_initialize+0x28>)
 800d538:	6013      	str	r3, [r2, #0]
#endif
#if TX_PORT_SPECIFIC_BUILD_OPTIONS != 0
                            | TX_PORT_SPECIFIC_BUILD_OPTIONS
#endif
                            ;
}
 800d53a:	bf00      	nop
 800d53c:	46bd      	mov	sp, r7
 800d53e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d542:	4770      	bx	lr
 800d544:	20006d18 	.word	0x20006d18
 800d548:	20006da4 	.word	0x20006da4

0800d54c <_tx_thread_preemption_change>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_preemption_change(TX_THREAD *thread_ptr, UINT new_threshold, UINT *old_threshold)
{
 800d54c:	b580      	push	{r7, lr}
 800d54e:	b08c      	sub	sp, #48	; 0x30
 800d550:	af00      	add	r7, sp, #0
 800d552:	60f8      	str	r0, [r7, #12]
 800d554:	60b9      	str	r1, [r7, #8]
 800d556:	607a      	str	r2, [r7, #4]
#endif
UINT        status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
 800d558:	2300      	movs	r3, #0
 800d55a:	62bb      	str	r3, [r7, #40]	; 0x28
#ifdef TX_DISABLE_PREEMPTION_THRESHOLD

    /* Only allow 0 (disable all preemption) and returning preemption-threshold to the
       current thread priority if preemption-threshold is disabled. All other threshold
       values are converted to 0.  */
    if (thread_ptr -> tx_thread_user_priority != new_threshold)
 800d55c:	68fb      	ldr	r3, [r7, #12]
 800d55e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800d562:	68ba      	ldr	r2, [r7, #8]
 800d564:	429a      	cmp	r2, r3
 800d566:	d004      	beq.n	800d572 <_tx_thread_preemption_change+0x26>
    {

        /* Is the new threshold zero?  */
        if (new_threshold != ((UINT) 0))
 800d568:	68bb      	ldr	r3, [r7, #8]
 800d56a:	2b00      	cmp	r3, #0
 800d56c:	d001      	beq.n	800d572 <_tx_thread_preemption_change+0x26>
        {

            /* Convert the new threshold to disable all preemption, since preemption-threshold is
               not supported.  */
            new_threshold =  ((UINT) 0);
 800d56e:	2300      	movs	r3, #0
 800d570:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d572:	f3ef 8310 	mrs	r3, PRIMASK
 800d576:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800d578:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800d57a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d57c:	b672      	cpsid	i
    return(int_posture);
 800d57e:	6a3b      	ldr	r3, [r7, #32]
        }
    }
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 800d580:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Log this kernel call.  */
    TX_EL_THREAD_PREEMPTION_CHANGE_INSERT

    /* Determine if the new threshold is greater than the current user priority.  */
    if (new_threshold > thread_ptr -> tx_thread_user_priority)
 800d582:	68fb      	ldr	r3, [r7, #12]
 800d584:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800d588:	68ba      	ldr	r2, [r7, #8]
 800d58a:	429a      	cmp	r2, r3
 800d58c:	d902      	bls.n	800d594 <_tx_thread_preemption_change+0x48>
    {

        /* Return error.  */
        status =  TX_THRESH_ERROR;
 800d58e:	2318      	movs	r3, #24
 800d590:	62bb      	str	r3, [r7, #40]	; 0x28
 800d592:	e03e      	b.n	800d612 <_tx_thread_preemption_change+0xc6>
            }
        }
#endif

        /* Return the user's preemption-threshold.   */
        *old_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 800d594:	68fb      	ldr	r3, [r7, #12]
 800d596:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 800d59a:	687b      	ldr	r3, [r7, #4]
 800d59c:	601a      	str	r2, [r3, #0]

        /* Setup the new threshold.  */
        thread_ptr -> tx_thread_user_preempt_threshold =  new_threshold;
 800d59e:	68fb      	ldr	r3, [r7, #12]
 800d5a0:	68ba      	ldr	r2, [r7, #8]
 800d5a2:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98

        /* Determine if the new threshold represents a higher priority than the priority inheritance threshold.  */
        if (new_threshold < thread_ptr -> tx_thread_inherit_priority)
 800d5a6:	68fb      	ldr	r3, [r7, #12]
 800d5a8:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800d5ac:	68ba      	ldr	r2, [r7, #8]
 800d5ae:	429a      	cmp	r2, r3
 800d5b0:	d203      	bcs.n	800d5ba <_tx_thread_preemption_change+0x6e>
        {

            /* Update the actual preemption-threshold with the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_threshold;
 800d5b2:	68fb      	ldr	r3, [r7, #12]
 800d5b4:	68ba      	ldr	r2, [r7, #8]
 800d5b6:	63da      	str	r2, [r3, #60]	; 0x3c
 800d5b8:	e004      	b.n	800d5c4 <_tx_thread_preemption_change+0x78>
        }
        else
        {

            /* Update the actual preemption-threshold with the priority inheritance.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_inherit_priority;
 800d5ba:	68fb      	ldr	r3, [r7, #12]
 800d5bc:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 800d5c0:	68fb      	ldr	r3, [r7, #12]
 800d5c2:	63da      	str	r2, [r3, #60]	; 0x3c
        }

        /* Is the thread priority less than the current highest priority?  If not, no preemption is required.  */
        if (_tx_thread_highest_priority < thread_ptr -> tx_thread_priority)
 800d5c4:	68fb      	ldr	r3, [r7, #12]
 800d5c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d5c8:	4b17      	ldr	r3, [pc, #92]	; (800d628 <_tx_thread_preemption_change+0xdc>)
 800d5ca:	681b      	ldr	r3, [r3, #0]
 800d5cc:	429a      	cmp	r2, r3
 800d5ce:	d920      	bls.n	800d612 <_tx_thread_preemption_change+0xc6>
        {

            /* Is the new thread preemption-threshold less than the current highest priority?  If not, no preemption is required.  */
            if (_tx_thread_highest_priority < new_threshold)
 800d5d0:	4b15      	ldr	r3, [pc, #84]	; (800d628 <_tx_thread_preemption_change+0xdc>)
 800d5d2:	681b      	ldr	r3, [r3, #0]
 800d5d4:	68ba      	ldr	r2, [r7, #8]
 800d5d6:	429a      	cmp	r2, r3
 800d5d8:	d91b      	bls.n	800d612 <_tx_thread_preemption_change+0xc6>
            {

                /* If the current execute pointer is the same at this thread, preemption needs to take place.  */
                if (_tx_thread_execute_ptr == thread_ptr)
 800d5da:	4b14      	ldr	r3, [pc, #80]	; (800d62c <_tx_thread_preemption_change+0xe0>)
 800d5dc:	681b      	ldr	r3, [r3, #0]
 800d5de:	68fa      	ldr	r2, [r7, #12]
 800d5e0:	429a      	cmp	r2, r3
 800d5e2:	d116      	bne.n	800d612 <_tx_thread_preemption_change+0xc6>
                        _tx_thread_performance_execute_log[_tx_thread_performance__execute_log_index] =  _tx_thread_execute_ptr;
                    }
#endif

                    /* Setup the highest priority thread to execute.  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800d5e4:	4b10      	ldr	r3, [pc, #64]	; (800d628 <_tx_thread_preemption_change+0xdc>)
 800d5e6:	681b      	ldr	r3, [r3, #0]
 800d5e8:	4a11      	ldr	r2, [pc, #68]	; (800d630 <_tx_thread_preemption_change+0xe4>)
 800d5ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d5ee:	4a0f      	ldr	r2, [pc, #60]	; (800d62c <_tx_thread_preemption_change+0xe0>)
 800d5f0:	6013      	str	r3, [r2, #0]
 800d5f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d5f4:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d5f6:	697b      	ldr	r3, [r7, #20]
 800d5f8:	f383 8810 	msr	PRIMASK, r3
}
 800d5fc:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Check for preemption.  */
                    _tx_thread_system_preempt_check();
 800d5fe:	f000 fba3 	bl	800dd48 <_tx_thread_system_preempt_check>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d602:	f3ef 8310 	mrs	r3, PRIMASK
 800d606:	61fb      	str	r3, [r7, #28]
    return(posture);
 800d608:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
 800d60a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d60c:	b672      	cpsid	i
    return(int_posture);
 800d60e:	69bb      	ldr	r3, [r7, #24]

                    /* Disable interrupts.  */
                    TX_DISABLE
 800d610:	62fb      	str	r3, [r7, #44]	; 0x2c
 800d612:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d614:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d616:	693b      	ldr	r3, [r7, #16]
 800d618:	f383 8810 	msr	PRIMASK, r3
}
 800d61c:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(status);
 800d61e:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
 800d620:	4618      	mov	r0, r3
 800d622:	3730      	adds	r7, #48	; 0x30
 800d624:	46bd      	mov	sp, r7
 800d626:	bd80      	pop	{r7, pc}
 800d628:	20006d18 	.word	0x20006d18
 800d62c:	20006d08 	.word	0x20006d08
 800d630:	20006d1c 	.word	0x20006d1c

0800d634 <_tx_thread_relinquish>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_relinquish(VOID)
{
 800d634:	b480      	push	{r7}
 800d636:	b08b      	sub	sp, #44	; 0x2c
 800d638:	af00      	add	r7, sp, #0
UINT            priority;
TX_THREAD       *thread_ptr;


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800d63a:	4b2b      	ldr	r3, [pc, #172]	; (800d6e8 <_tx_thread_relinquish+0xb4>)
 800d63c:	681b      	ldr	r3, [r3, #0]
 800d63e:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d640:	f3ef 8310 	mrs	r3, PRIMASK
 800d644:	61bb      	str	r3, [r7, #24]
    return(posture);
 800d646:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800d648:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d64a:	b672      	cpsid	i
    return(int_posture);
 800d64c:	697b      	ldr	r3, [r7, #20]
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Disable interrupts.  */
    TX_DISABLE
 800d64e:	623b      	str	r3, [r7, #32]

#ifndef TX_NO_TIMER

    /* Reset time slice for current thread.  */
    _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800d650:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d652:	69db      	ldr	r3, [r3, #28]
 800d654:	4a25      	ldr	r2, [pc, #148]	; (800d6ec <_tx_thread_relinquish+0xb8>)
 800d656:	6013      	str	r3, [r2, #0]
#endif

    /* Pickup the thread's priority.  */
    priority =  thread_ptr -> tx_thread_priority;
 800d658:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d65a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d65c:	61fb      	str	r3, [r7, #28]

    /* Determine if there is another thread at the same priority.  */
    if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 800d65e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d660:	6a1b      	ldr	r3, [r3, #32]
 800d662:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d664:	429a      	cmp	r2, r3
 800d666:	d009      	beq.n	800d67c <_tx_thread_relinquish+0x48>
    {

        /* Yes, there is another thread at this priority, make it the highest at
           this priority level.  */
        _tx_thread_priority_list[priority] =  thread_ptr -> tx_thread_ready_next;
 800d668:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d66a:	6a1a      	ldr	r2, [r3, #32]
 800d66c:	4920      	ldr	r1, [pc, #128]	; (800d6f0 <_tx_thread_relinquish+0xbc>)
 800d66e:	69fb      	ldr	r3, [r7, #28]
 800d670:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Mark the new thread as the one to execute.  */
        _tx_thread_execute_ptr = thread_ptr -> tx_thread_ready_next;
 800d674:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d676:	6a1b      	ldr	r3, [r3, #32]
 800d678:	4a1e      	ldr	r2, [pc, #120]	; (800d6f4 <_tx_thread_relinquish+0xc0>)
 800d67a:	6013      	str	r3, [r2, #0]
    }

    /* Determine if there is a higher-priority thread ready.  */
    if (_tx_thread_highest_priority < priority)
 800d67c:	4b1e      	ldr	r3, [pc, #120]	; (800d6f8 <_tx_thread_relinquish+0xc4>)
 800d67e:	681b      	ldr	r3, [r3, #0]
 800d680:	69fa      	ldr	r2, [r7, #28]
 800d682:	429a      	cmp	r2, r3
 800d684:	d906      	bls.n	800d694 <_tx_thread_relinquish+0x60>
    {

        /* Yes, there is a higher priority thread ready to execute.  Make
           it visible to the thread scheduler.  */
        _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800d686:	4b1c      	ldr	r3, [pc, #112]	; (800d6f8 <_tx_thread_relinquish+0xc4>)
 800d688:	681b      	ldr	r3, [r3, #0]
 800d68a:	4a19      	ldr	r2, [pc, #100]	; (800d6f0 <_tx_thread_relinquish+0xbc>)
 800d68c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d690:	4a18      	ldr	r2, [pc, #96]	; (800d6f4 <_tx_thread_relinquish+0xc0>)
 800d692:	6013      	str	r3, [r2, #0]
 800d694:	6a3b      	ldr	r3, [r7, #32]
 800d696:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d698:	693b      	ldr	r3, [r7, #16]
 800d69a:	f383 8810 	msr	PRIMASK, r3
}
 800d69e:	bf00      	nop

    /* Restore previous interrupt posture.  */
    TX_RESTORE

    /* Determine if this thread needs to return to the system.  */
    if (_tx_thread_execute_ptr != thread_ptr)
 800d6a0:	4b14      	ldr	r3, [pc, #80]	; (800d6f4 <_tx_thread_relinquish+0xc0>)
 800d6a2:	681b      	ldr	r3, [r3, #0]
 800d6a4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d6a6:	429a      	cmp	r2, r3
 800d6a8:	d017      	beq.n	800d6da <_tx_thread_relinquish+0xa6>
__attribute__( ( always_inline ) ) static inline void _tx_thread_system_return_inline(void)
{
unsigned int interrupt_save;

    /* Set PendSV to invoke ThreadX scheduler.  */
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800d6aa:	4b14      	ldr	r3, [pc, #80]	; (800d6fc <_tx_thread_relinquish+0xc8>)
 800d6ac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800d6b0:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d6b2:	f3ef 8305 	mrs	r3, IPSR
 800d6b6:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
 800d6b8:	68fb      	ldr	r3, [r7, #12]
    if (__get_ipsr_value() == 0)
 800d6ba:	2b00      	cmp	r3, #0
 800d6bc:	d10c      	bne.n	800d6d8 <_tx_thread_relinquish+0xa4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d6be:	f3ef 8310 	mrs	r3, PRIMASK
 800d6c2:	60bb      	str	r3, [r7, #8]
    return(posture);
 800d6c4:	68bb      	ldr	r3, [r7, #8]
    {
        interrupt_save = __get_interrupt_posture();
 800d6c6:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800d6c8:	b662      	cpsie	i
}
 800d6ca:	bf00      	nop
 800d6cc:	687b      	ldr	r3, [r7, #4]
 800d6ce:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d6d0:	683b      	ldr	r3, [r7, #0]
 800d6d2:	f383 8810 	msr	PRIMASK, r3
}
 800d6d6:	bf00      	nop
#else
        __enable_interrupts();
#endif
        __restore_interrupt(interrupt_save);
    }
}
 800d6d8:	bf00      	nop

        /* Transfer control to the system so the scheduler can execute
           the next thread.  */
        _tx_thread_system_return();
    }
}
 800d6da:	bf00      	nop
 800d6dc:	372c      	adds	r7, #44	; 0x2c
 800d6de:	46bd      	mov	sp, r7
 800d6e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6e4:	4770      	bx	lr
 800d6e6:	bf00      	nop
 800d6e8:	20006d04 	.word	0x20006d04
 800d6ec:	20007308 	.word	0x20007308
 800d6f0:	20006d1c 	.word	0x20006d1c
 800d6f4:	20006d08 	.word	0x20006d08
 800d6f8:	20006d18 	.word	0x20006d18
 800d6fc:	e000ed04 	.word	0xe000ed04

0800d700 <_tx_thread_resume>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_resume(TX_THREAD *thread_ptr)
{
 800d700:	b480      	push	{r7}
 800d702:	b09b      	sub	sp, #108	; 0x6c
 800d704:	af00      	add	r7, sp, #0
 800d706:	6078      	str	r0, [r7, #4]

TX_INTERRUPT_SAVE_AREA

UINT        status;
TX_THREAD   *saved_thread_ptr;
UINT        saved_threshold =  ((UINT) 0);
 800d708:	2300      	movs	r3, #0
 800d70a:	65fb      	str	r3, [r7, #92]	; 0x5c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d70c:	f3ef 8310 	mrs	r3, PRIMASK
 800d710:	63bb      	str	r3, [r7, #56]	; 0x38
    return(posture);
 800d712:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    int_posture = __get_interrupt_posture();
 800d714:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
 800d716:	b672      	cpsid	i
    return(int_posture);
 800d718:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 800d71a:	65bb      	str	r3, [r7, #88]	; 0x58
    /* Log this kernel call.  */
    TX_EL_THREAD_RESUME_INSERT

    /* Determine if the thread is suspended or in the process of suspending.
       If so, call the thread resume processing.  */
    if (thread_ptr -> tx_thread_state == TX_SUSPENDED)
 800d71c:	687b      	ldr	r3, [r7, #4]
 800d71e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800d720:	2b03      	cmp	r3, #3
 800d722:	f040 809c 	bne.w	800d85e <_tx_thread_resume+0x15e>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d726:	f3ef 8305 	mrs	r3, IPSR
 800d72a:	633b      	str	r3, [r7, #48]	; 0x30
    return(ipsr_value);
 800d72c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
 800d72e:	4b6b      	ldr	r3, [pc, #428]	; (800d8dc <_tx_thread_resume+0x1dc>)
 800d730:	681b      	ldr	r3, [r3, #0]
 800d732:	4313      	orrs	r3, r2
 800d734:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800d738:	d30d      	bcc.n	800d756 <_tx_thread_resume+0x56>

            /* Pickup the current thread execute pointer, which corresponds to the
               highest priority thread ready to execute.  Interrupt lockout is
               not required, since interrupts are assumed to be disabled during
               initialization.  */
            saved_thread_ptr =  _tx_thread_execute_ptr;
 800d73a:	4b69      	ldr	r3, [pc, #420]	; (800d8e0 <_tx_thread_resume+0x1e0>)
 800d73c:	681b      	ldr	r3, [r3, #0]
 800d73e:	663b      	str	r3, [r7, #96]	; 0x60

            /* Determine if there is thread ready for execution.  */
            if (saved_thread_ptr != TX_NULL)
 800d740:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d742:	2b00      	cmp	r3, #0
 800d744:	d009      	beq.n	800d75a <_tx_thread_resume+0x5a>
            {

                /* Yes, a thread is ready for execution when initialization completes.  */

                /* Save the current preemption-threshold.  */
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
 800d746:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d748:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d74a:	65fb      	str	r3, [r7, #92]	; 0x5c

                /* For initialization, temporarily set the preemption-threshold to the
                   priority level to make sure the highest-priority thread runs once
                   initialization is complete.  */
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 800d74c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d74e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800d750:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d752:	63da      	str	r2, [r3, #60]	; 0x3c
 800d754:	e001      	b.n	800d75a <_tx_thread_resume+0x5a>
        }
        else
        {

            /* Simply set the saved thread pointer to NULL.  */
            saved_thread_ptr =  TX_NULL;
 800d756:	2300      	movs	r3, #0
 800d758:	663b      	str	r3, [r7, #96]	; 0x60
#endif

        /* Make this thread ready.  */

        /* Change the state to ready.  */
        thread_ptr -> tx_thread_state =  TX_READY;
 800d75a:	687b      	ldr	r3, [r7, #4]
 800d75c:	2200      	movs	r2, #0
 800d75e:	631a      	str	r2, [r3, #48]	; 0x30

        /* Pickup priority of thread.  */
        priority =  thread_ptr -> tx_thread_priority;
 800d760:	687b      	ldr	r3, [r7, #4]
 800d762:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800d764:	657b      	str	r3, [r7, #84]	; 0x54
        thread_ptr -> tx_thread_performance_resume_count++;
#endif

        /* Determine if there are other threads at this priority that are
           ready.  */
        head_ptr =  _tx_thread_priority_list[priority];
 800d766:	4a5f      	ldr	r2, [pc, #380]	; (800d8e4 <_tx_thread_resume+0x1e4>)
 800d768:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d76a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d76e:	653b      	str	r3, [r7, #80]	; 0x50
        if (head_ptr == TX_NULL)
 800d770:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d772:	2b00      	cmp	r3, #0
 800d774:	d15b      	bne.n	800d82e <_tx_thread_resume+0x12e>
        {

            /* First thread at this priority ready.  Add to the front of the list.  */
            _tx_thread_priority_list[priority] =       thread_ptr;
 800d776:	495b      	ldr	r1, [pc, #364]	; (800d8e4 <_tx_thread_resume+0x1e4>)
 800d778:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d77a:	687a      	ldr	r2, [r7, #4]
 800d77c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            thread_ptr -> tx_thread_ready_next =       thread_ptr;
 800d780:	687b      	ldr	r3, [r7, #4]
 800d782:	687a      	ldr	r2, [r7, #4]
 800d784:	621a      	str	r2, [r3, #32]
            thread_ptr -> tx_thread_ready_previous =   thread_ptr;
 800d786:	687b      	ldr	r3, [r7, #4]
 800d788:	687a      	ldr	r2, [r7, #4]
 800d78a:	625a      	str	r2, [r3, #36]	; 0x24
            TX_DIV32_BIT_SET(priority, priority_bit)
            _tx_thread_priority_map_active =  _tx_thread_priority_map_active | priority_bit;
#endif

            /* Or in the thread's priority bit.  */
            TX_MOD32_BIT_SET(priority, priority_bit)
 800d78c:	2201      	movs	r2, #1
 800d78e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d790:	fa02 f303 	lsl.w	r3, r2, r3
 800d794:	64bb      	str	r3, [r7, #72]	; 0x48
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
 800d796:	4b54      	ldr	r3, [pc, #336]	; (800d8e8 <_tx_thread_resume+0x1e8>)
 800d798:	681a      	ldr	r2, [r3, #0]
 800d79a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800d79c:	4313      	orrs	r3, r2
 800d79e:	4a52      	ldr	r2, [pc, #328]	; (800d8e8 <_tx_thread_resume+0x1e8>)
 800d7a0:	6013      	str	r3, [r2, #0]

            /* Determine if this newly ready thread is the highest priority.  */
            if (priority < _tx_thread_highest_priority)
 800d7a2:	4b52      	ldr	r3, [pc, #328]	; (800d8ec <_tx_thread_resume+0x1ec>)
 800d7a4:	681b      	ldr	r3, [r3, #0]
 800d7a6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800d7a8:	429a      	cmp	r2, r3
 800d7aa:	d24f      	bcs.n	800d84c <_tx_thread_resume+0x14c>
            {

                /* A new highest priority thread is present. */

                /* Update the highest priority variable.  */
                _tx_thread_highest_priority =  priority;
 800d7ac:	4a4f      	ldr	r2, [pc, #316]	; (800d8ec <_tx_thread_resume+0x1ec>)
 800d7ae:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800d7b0:	6013      	str	r3, [r2, #0]

                /* Pickup the execute pointer. Since it is going to be referenced multiple
                   times, it is placed in a local variable.  */
                execute_ptr =  _tx_thread_execute_ptr;
 800d7b2:	4b4b      	ldr	r3, [pc, #300]	; (800d8e0 <_tx_thread_resume+0x1e0>)
 800d7b4:	681b      	ldr	r3, [r3, #0]
 800d7b6:	647b      	str	r3, [r7, #68]	; 0x44

                /* Determine if no thread is currently executing.  */
                if (execute_ptr == TX_NULL)
 800d7b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d7ba:	2b00      	cmp	r3, #0
 800d7bc:	d103      	bne.n	800d7c6 <_tx_thread_resume+0xc6>
                {

                    /* Simply setup the execute pointer.  */
                    _tx_thread_execute_ptr =  thread_ptr;
 800d7be:	4a48      	ldr	r2, [pc, #288]	; (800d8e0 <_tx_thread_resume+0x1e0>)
 800d7c0:	687b      	ldr	r3, [r7, #4]
 800d7c2:	6013      	str	r3, [r2, #0]
 800d7c4:	e042      	b.n	800d84c <_tx_thread_resume+0x14c>
                {

                    /* Another thread has been scheduled for execution.  */

                    /* Check to see if this is a higher priority thread and determine if preemption is allowed.  */
                    if (priority < execute_ptr -> tx_thread_preempt_threshold)
 800d7c6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800d7c8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800d7ca:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800d7cc:	429a      	cmp	r2, r3
 800d7ce:	d23d      	bcs.n	800d84c <_tx_thread_resume+0x14c>
                        /* Remember the thread that preempted this thread.  */
                        execute_ptr -> tx_thread_performance_last_preempting_thread =  thread_ptr;
#endif

                        /* Yes, modify the execute thread pointer.  */
                        _tx_thread_execute_ptr =  thread_ptr;
 800d7d0:	4a43      	ldr	r2, [pc, #268]	; (800d8e0 <_tx_thread_resume+0x1e0>)
 800d7d2:	687b      	ldr	r3, [r7, #4]
 800d7d4:	6013      	str	r3, [r2, #0]
#ifndef TX_MISRA_ENABLE

                        /* If MISRA is not-enabled, insert a preemption and return in-line for performance.  */

                        /* Determine if the thread's preemption-threshold needs to be restored.  */
                        if (saved_thread_ptr != TX_NULL)
 800d7d6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d7d8:	2b00      	cmp	r3, #0
 800d7da:	d002      	beq.n	800d7e2 <_tx_thread_resume+0xe2>
                        {

                            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
                               can only happen if this routine is called from initialization.  */
                            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
 800d7dc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d7de:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800d7e0:	63da      	str	r2, [r3, #60]	; 0x3c
 800d7e2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d7e4:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d7e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d7e8:	f383 8810 	msr	PRIMASK, r3
}
 800d7ec:	bf00      	nop
                        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

                        /* Now determine if preemption should take place. This is only possible if the current thread pointer is
                           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800d7ee:	4b40      	ldr	r3, [pc, #256]	; (800d8f0 <_tx_thread_resume+0x1f0>)
 800d7f0:	681b      	ldr	r3, [r3, #0]
 800d7f2:	643b      	str	r3, [r7, #64]	; 0x40
                        if (combined_flags == ((ULONG) 0))
 800d7f4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d7f6:	2b00      	cmp	r3, #0
 800d7f8:	d117      	bne.n	800d82a <_tx_thread_resume+0x12a>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800d7fa:	4b3e      	ldr	r3, [pc, #248]	; (800d8f4 <_tx_thread_resume+0x1f4>)
 800d7fc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800d800:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d802:	f3ef 8305 	mrs	r3, IPSR
 800d806:	62bb      	str	r3, [r7, #40]	; 0x28
    return(ipsr_value);
 800d808:	6abb      	ldr	r3, [r7, #40]	; 0x28
    if (__get_ipsr_value() == 0)
 800d80a:	2b00      	cmp	r3, #0
 800d80c:	d10c      	bne.n	800d828 <_tx_thread_resume+0x128>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d80e:	f3ef 8310 	mrs	r3, PRIMASK
 800d812:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800d814:	6a7b      	ldr	r3, [r7, #36]	; 0x24
        interrupt_save = __get_interrupt_posture();
 800d816:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800d818:	b662      	cpsie	i
}
 800d81a:	bf00      	nop
 800d81c:	6a3b      	ldr	r3, [r7, #32]
 800d81e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d820:	69fb      	ldr	r3, [r7, #28]
 800d822:	f383 8810 	msr	PRIMASK, r3
}
 800d826:	bf00      	nop
}
 800d828:	bf00      	nop
                            /* Preemption is needed - return to the system!  */
                            _tx_thread_system_return();
                        }

                        /* Return in-line when MISRA is not enabled.  */
                        return(TX_SUCCESS);
 800d82a:	2300      	movs	r3, #0
 800d82c:	e050      	b.n	800d8d0 <_tx_thread_resume+0x1d0>
        {

            /* No, there are other threads at this priority already ready.  */

            /* Just add this thread to the priority list.  */
            tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
 800d82e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d830:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800d832:	64fb      	str	r3, [r7, #76]	; 0x4c
            tail_ptr -> tx_thread_ready_next =         thread_ptr;
 800d834:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800d836:	687a      	ldr	r2, [r7, #4]
 800d838:	621a      	str	r2, [r3, #32]
            head_ptr -> tx_thread_ready_previous =     thread_ptr;
 800d83a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800d83c:	687a      	ldr	r2, [r7, #4]
 800d83e:	625a      	str	r2, [r3, #36]	; 0x24
            thread_ptr -> tx_thread_ready_previous =   tail_ptr;
 800d840:	687b      	ldr	r3, [r7, #4]
 800d842:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800d844:	625a      	str	r2, [r3, #36]	; 0x24
            thread_ptr -> tx_thread_ready_next =       head_ptr;
 800d846:	687b      	ldr	r3, [r7, #4]
 800d848:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800d84a:	621a      	str	r2, [r3, #32]
            }
        }
#endif

        /* Determine if the thread's preemption-threshold needs to be restored.  */
        if (saved_thread_ptr != TX_NULL)
 800d84c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d84e:	2b00      	cmp	r3, #0
 800d850:	d002      	beq.n	800d858 <_tx_thread_resume+0x158>
        {

            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
               can only happen if this routine is called from initialization.  */
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
 800d852:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800d854:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800d856:	63da      	str	r2, [r3, #60]	; 0x3c
        }

        /* Setup successful return status.  */
        status =  TX_SUCCESS;
 800d858:	2300      	movs	r3, #0
 800d85a:	667b      	str	r3, [r7, #100]	; 0x64
 800d85c:	e00b      	b.n	800d876 <_tx_thread_resume+0x176>
#endif
    }
    else if (thread_ptr -> tx_thread_delayed_suspend == TX_TRUE)
 800d85e:	687b      	ldr	r3, [r7, #4]
 800d860:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d862:	2b01      	cmp	r3, #1
 800d864:	d105      	bne.n	800d872 <_tx_thread_resume+0x172>
    {

        /* Clear the delayed suspension.  */
        thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 800d866:	687b      	ldr	r3, [r7, #4]
 800d868:	2200      	movs	r2, #0
 800d86a:	635a      	str	r2, [r3, #52]	; 0x34

        /* Setup delayed suspend lifted return status.  */
        status =  TX_SUSPEND_LIFTED;
 800d86c:	2319      	movs	r3, #25
 800d86e:	667b      	str	r3, [r7, #100]	; 0x64
 800d870:	e001      	b.n	800d876 <_tx_thread_resume+0x176>
    }
    else
    {

        /* Setup invalid resume return status.  */
        status =  TX_RESUME_ERROR;
 800d872:	2312      	movs	r3, #18
 800d874:	667b      	str	r3, [r7, #100]	; 0x64
 800d876:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800d878:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d87a:	69bb      	ldr	r3, [r7, #24]
 800d87c:	f383 8810 	msr	PRIMASK, r3
}
 800d880:	bf00      	nop
    TX_RESTORE

#ifdef TX_INLINE_THREAD_RESUME_SUSPEND

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800d882:	4b1d      	ldr	r3, [pc, #116]	; (800d8f8 <_tx_thread_resume+0x1f8>)
 800d884:	681b      	ldr	r3, [r3, #0]
 800d886:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
 800d888:	4b15      	ldr	r3, [pc, #84]	; (800d8e0 <_tx_thread_resume+0x1e0>)
 800d88a:	681b      	ldr	r3, [r3, #0]
 800d88c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800d88e:	429a      	cmp	r2, r3
 800d890:	d01d      	beq.n	800d8ce <_tx_thread_resume+0x1ce>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Now determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800d892:	4b17      	ldr	r3, [pc, #92]	; (800d8f0 <_tx_thread_resume+0x1f0>)
 800d894:	681b      	ldr	r3, [r3, #0]
 800d896:	643b      	str	r3, [r7, #64]	; 0x40
        if (combined_flags == ((ULONG) 0))
 800d898:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800d89a:	2b00      	cmp	r3, #0
 800d89c:	d117      	bne.n	800d8ce <_tx_thread_resume+0x1ce>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800d89e:	4b15      	ldr	r3, [pc, #84]	; (800d8f4 <_tx_thread_resume+0x1f4>)
 800d8a0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800d8a4:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d8a6:	f3ef 8305 	mrs	r3, IPSR
 800d8aa:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800d8ac:	697b      	ldr	r3, [r7, #20]
    if (__get_ipsr_value() == 0)
 800d8ae:	2b00      	cmp	r3, #0
 800d8b0:	d10c      	bne.n	800d8cc <_tx_thread_resume+0x1cc>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d8b2:	f3ef 8310 	mrs	r3, PRIMASK
 800d8b6:	613b      	str	r3, [r7, #16]
    return(posture);
 800d8b8:	693b      	ldr	r3, [r7, #16]
        interrupt_save = __get_interrupt_posture();
 800d8ba:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800d8bc:	b662      	cpsie	i
}
 800d8be:	bf00      	nop
 800d8c0:	68fb      	ldr	r3, [r7, #12]
 800d8c2:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d8c4:	68bb      	ldr	r3, [r7, #8]
 800d8c6:	f383 8810 	msr	PRIMASK, r3
}
 800d8ca:	bf00      	nop
}
 800d8cc:	bf00      	nop
        }
    }
#endif

    /* Return completion status. */
    return(status);
 800d8ce:	6e7b      	ldr	r3, [r7, #100]	; 0x64
}
 800d8d0:	4618      	mov	r0, r3
 800d8d2:	376c      	adds	r7, #108	; 0x6c
 800d8d4:	46bd      	mov	sp, r7
 800d8d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8da:	4770      	bx	lr
 800d8dc:	20000090 	.word	0x20000090
 800d8e0:	20006d08 	.word	0x20006d08
 800d8e4:	20006d1c 	.word	0x20006d1c
 800d8e8:	20006d14 	.word	0x20006d14
 800d8ec:	20006d18 	.word	0x20006d18
 800d8f0:	20006d9c 	.word	0x20006d9c
 800d8f4:	e000ed04 	.word	0xe000ed04
 800d8f8:	20006d04 	.word	0x20006d04

0800d8fc <_tx_thread_shell_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_shell_entry(VOID)
{
 800d8fc:	b580      	push	{r7, lr}
 800d8fe:	b088      	sub	sp, #32
 800d900:	af00      	add	r7, sp, #0
VOID            (*entry_exit_notify)(TX_THREAD *notify_thread_ptr, UINT type);
#endif


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800d902:	4b21      	ldr	r3, [pc, #132]	; (800d988 <_tx_thread_shell_entry+0x8c>)
 800d904:	681b      	ldr	r3, [r3, #0]
 800d906:	61fb      	str	r3, [r7, #28]
        (entry_exit_notify)(thread_ptr, TX_THREAD_ENTRY);
    }
#endif

    /* Call current thread's entry function.  */
    (thread_ptr -> tx_thread_entry) (thread_ptr -> tx_thread_entry_parameter);
 800d908:	69fb      	ldr	r3, [r7, #28]
 800d90a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800d90c:	69fa      	ldr	r2, [r7, #28]
 800d90e:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800d910:	4610      	mov	r0, r2
 800d912:	4798      	blx	r3

    /* Suspend thread with a "completed" state.  */

    /* Determine if the application is using mutexes.  */
    if (_tx_thread_mutex_release != TX_NULL)
 800d914:	4b1d      	ldr	r3, [pc, #116]	; (800d98c <_tx_thread_shell_entry+0x90>)
 800d916:	681b      	ldr	r3, [r3, #0]
 800d918:	2b00      	cmp	r3, #0
 800d91a:	d003      	beq.n	800d924 <_tx_thread_shell_entry+0x28>
    {

        /* Yes, call the mutex release function via a function pointer that
           is setup during mutex initialization.  */
        (_tx_thread_mutex_release)(thread_ptr);
 800d91c:	4b1b      	ldr	r3, [pc, #108]	; (800d98c <_tx_thread_shell_entry+0x90>)
 800d91e:	681b      	ldr	r3, [r3, #0]
 800d920:	69f8      	ldr	r0, [r7, #28]
 800d922:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d924:	f3ef 8310 	mrs	r3, PRIMASK
 800d928:	607b      	str	r3, [r7, #4]
    return(posture);
 800d92a:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
 800d92c:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
 800d92e:	b672      	cpsid	i
    return(int_posture);
 800d930:	683b      	ldr	r3, [r7, #0]
    }

    /* Lockout interrupts while the thread state is setup.  */
    TX_DISABLE
 800d932:	61bb      	str	r3, [r7, #24]
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
#endif

    /* Set the status to suspending, in order to indicate the suspension
       is in progress.  */
    thread_ptr -> tx_thread_state =  TX_COMPLETED;
 800d934:	69fb      	ldr	r3, [r7, #28]
 800d936:	2201      	movs	r2, #1
 800d938:	631a      	str	r2, [r3, #48]	; 0x30
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Set the suspending flag. */
    thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800d93a:	69fb      	ldr	r3, [r7, #28]
 800d93c:	2201      	movs	r2, #1
 800d93e:	639a      	str	r2, [r3, #56]	; 0x38

    /* Setup for no timeout period.  */
    thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800d940:	69fb      	ldr	r3, [r7, #28]
 800d942:	2200      	movs	r2, #0
 800d944:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800d946:	4b12      	ldr	r3, [pc, #72]	; (800d990 <_tx_thread_shell_entry+0x94>)
 800d948:	681b      	ldr	r3, [r3, #0]
 800d94a:	3301      	adds	r3, #1
 800d94c:	4a10      	ldr	r2, [pc, #64]	; (800d990 <_tx_thread_shell_entry+0x94>)
 800d94e:	6013      	str	r3, [r2, #0]
 800d950:	69bb      	ldr	r3, [r7, #24]
 800d952:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d954:	68bb      	ldr	r3, [r7, #8]
 800d956:	f383 8810 	msr	PRIMASK, r3
}
 800d95a:	bf00      	nop
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800d95c:	f3ef 8314 	mrs	r3, CONTROL
 800d960:	60fb      	str	r3, [r7, #12]
    return(control_value);
 800d962:	68fb      	ldr	r3, [r7, #12]

    /* Restore interrupts.  */
    TX_RESTORE

    /* Perform any additional activities for tool or user purpose.  */
    TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
 800d964:	617b      	str	r3, [r7, #20]
 800d966:	697b      	ldr	r3, [r7, #20]
 800d968:	f023 0304 	bic.w	r3, r3, #4
 800d96c:	617b      	str	r3, [r7, #20]
 800d96e:	697b      	ldr	r3, [r7, #20]
 800d970:	613b      	str	r3, [r7, #16]
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 800d972:	693b      	ldr	r3, [r7, #16]
 800d974:	f383 8814 	msr	CONTROL, r3
}
 800d978:	bf00      	nop
        (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
    }
#endif

    /* Call actual thread suspension routine.  */
    _tx_thread_system_suspend(thread_ptr);
 800d97a:	69f8      	ldr	r0, [r7, #28]
 800d97c:	f000 fb1e 	bl	800dfbc <_tx_thread_system_suspend>
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
 800d980:	bf00      	nop
 800d982:	3720      	adds	r7, #32
 800d984:	46bd      	mov	sp, r7
 800d986:	bd80      	pop	{r7, pc}
 800d988:	20006d04 	.word	0x20006d04
 800d98c:	20006da0 	.word	0x20006da0
 800d990:	20006d9c 	.word	0x20006d9c

0800d994 <_tx_thread_sleep>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_sleep(ULONG timer_ticks)
{
 800d994:	b580      	push	{r7, lr}
 800d996:	b08e      	sub	sp, #56	; 0x38
 800d998:	af00      	add	r7, sp, #0
 800d99a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800d99c:	f3ef 8310 	mrs	r3, PRIMASK
 800d9a0:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 800d9a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    int_posture = __get_interrupt_posture();
 800d9a4:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
 800d9a6:	b672      	cpsid	i
    return(int_posture);
 800d9a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
UINT            status;
TX_THREAD       *thread_ptr;


    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 800d9aa:	633b      	str	r3, [r7, #48]	; 0x30

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800d9ac:	4b35      	ldr	r3, [pc, #212]	; (800da84 <_tx_thread_sleep+0xf0>)
 800d9ae:	681b      	ldr	r3, [r3, #0]
 800d9b0:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Determine if this is a legal request.  */

    /* Is there a current thread?  */
    if (thread_ptr == TX_NULL)
 800d9b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d9b4:	2b00      	cmp	r3, #0
 800d9b6:	d108      	bne.n	800d9ca <_tx_thread_sleep+0x36>
 800d9b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d9ba:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d9bc:	6a3b      	ldr	r3, [r7, #32]
 800d9be:	f383 8810 	msr	PRIMASK, r3
}
 800d9c2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
 800d9c4:	2313      	movs	r3, #19
 800d9c6:	637b      	str	r3, [r7, #52]	; 0x34
 800d9c8:	e056      	b.n	800da78 <_tx_thread_sleep+0xe4>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d9ca:	f3ef 8305 	mrs	r3, IPSR
 800d9ce:	61fb      	str	r3, [r7, #28]
    return(ipsr_value);
 800d9d0:	69fa      	ldr	r2, [r7, #28]
    }

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800d9d2:	4b2d      	ldr	r3, [pc, #180]	; (800da88 <_tx_thread_sleep+0xf4>)
 800d9d4:	681b      	ldr	r3, [r3, #0]
 800d9d6:	4313      	orrs	r3, r2
 800d9d8:	2b00      	cmp	r3, #0
 800d9da:	d008      	beq.n	800d9ee <_tx_thread_sleep+0x5a>
 800d9dc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d9de:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d9e0:	69bb      	ldr	r3, [r7, #24]
 800d9e2:	f383 8810 	msr	PRIMASK, r3
}
 800d9e6:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
 800d9e8:	2313      	movs	r3, #19
 800d9ea:	637b      	str	r3, [r7, #52]	; 0x34
 800d9ec:	e044      	b.n	800da78 <_tx_thread_sleep+0xe4>
    }

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Is the caller the system timer thread?  */
    else if (thread_ptr == &_tx_timer_thread)
 800d9ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d9f0:	4a26      	ldr	r2, [pc, #152]	; (800da8c <_tx_thread_sleep+0xf8>)
 800d9f2:	4293      	cmp	r3, r2
 800d9f4:	d108      	bne.n	800da08 <_tx_thread_sleep+0x74>
 800d9f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800d9f8:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800d9fa:	697b      	ldr	r3, [r7, #20]
 800d9fc:	f383 8810 	msr	PRIMASK, r3
}
 800da00:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
 800da02:	2313      	movs	r3, #19
 800da04:	637b      	str	r3, [r7, #52]	; 0x34
 800da06:	e037      	b.n	800da78 <_tx_thread_sleep+0xe4>
    }
#endif

    /* Determine if the requested number of ticks is zero.  */
    else if (timer_ticks == ((ULONG) 0))
 800da08:	687b      	ldr	r3, [r7, #4]
 800da0a:	2b00      	cmp	r3, #0
 800da0c:	d108      	bne.n	800da20 <_tx_thread_sleep+0x8c>
 800da0e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800da10:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800da12:	693b      	ldr	r3, [r7, #16]
 800da14:	f383 8810 	msr	PRIMASK, r3
}
 800da18:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Just return with a successful status.  */
        status =  TX_SUCCESS;
 800da1a:	2300      	movs	r3, #0
 800da1c:	637b      	str	r3, [r7, #52]	; 0x34
 800da1e:	e02b      	b.n	800da78 <_tx_thread_sleep+0xe4>
    }
    else
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 800da20:	4b1b      	ldr	r3, [pc, #108]	; (800da90 <_tx_thread_sleep+0xfc>)
 800da22:	681b      	ldr	r3, [r3, #0]
 800da24:	2b00      	cmp	r3, #0
 800da26:	d008      	beq.n	800da3a <_tx_thread_sleep+0xa6>
 800da28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800da2a:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800da2c:	68fb      	ldr	r3, [r7, #12]
 800da2e:	f383 8810 	msr	PRIMASK, r3
}
 800da32:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_CALLER_ERROR;
 800da34:	2313      	movs	r3, #19
 800da36:	637b      	str	r3, [r7, #52]	; 0x34
 800da38:	e01e      	b.n	800da78 <_tx_thread_sleep+0xe4>
            TX_EL_THREAD_SLEEP_INSERT

            /* Suspend the current thread.  */

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SLEEP;
 800da3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800da3c:	2204      	movs	r2, #4
 800da3e:	631a      	str	r2, [r3, #48]	; 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag. */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800da40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800da42:	2201      	movs	r2, #1
 800da44:	639a      	str	r2, [r3, #56]	; 0x38

            /* Initialize the status to successful.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800da46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800da48:	2200      	movs	r2, #0
 800da4a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  timer_ticks;
 800da4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800da50:	687a      	ldr	r2, [r7, #4]
 800da52:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800da54:	4b0e      	ldr	r3, [pc, #56]	; (800da90 <_tx_thread_sleep+0xfc>)
 800da56:	681b      	ldr	r3, [r3, #0]
 800da58:	3301      	adds	r3, #1
 800da5a:	4a0d      	ldr	r2, [pc, #52]	; (800da90 <_tx_thread_sleep+0xfc>)
 800da5c:	6013      	str	r3, [r2, #0]
 800da5e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800da60:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800da62:	68bb      	ldr	r3, [r7, #8]
 800da64:	f383 8810 	msr	PRIMASK, r3
}
 800da68:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800da6a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800da6c:	f000 faa6 	bl	800dfbc <_tx_thread_system_suspend>
#endif

            /* Return status to the caller.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 800da70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800da72:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800da76:	637b      	str	r3, [r7, #52]	; 0x34
        }
    }

    /* Return completion status.  */
    return(status);
 800da78:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800da7a:	4618      	mov	r0, r3
 800da7c:	3738      	adds	r7, #56	; 0x38
 800da7e:	46bd      	mov	sp, r7
 800da80:	bd80      	pop	{r7, pc}
 800da82:	bf00      	nop
 800da84:	20006d04 	.word	0x20006d04
 800da88:	20000090 	.word	0x20000090
 800da8c:	20006e4c 	.word	0x20006e4c
 800da90:	20006d9c 	.word	0x20006d9c

0800da94 <_tx_thread_suspend>:
/*                                            a MISRA compliance issue,   */
/*                                            resulting in version 6.1.1  */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_suspend(TX_THREAD *thread_ptr)
{
 800da94:	b480      	push	{r7}
 800da96:	b0a3      	sub	sp, #140	; 0x8c
 800da98:	af00      	add	r7, sp, #0
 800da9a:	6078      	str	r0, [r7, #4]
ULONG                       time_stamp =  ((ULONG) 0);
#endif


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800da9c:	4b96      	ldr	r3, [pc, #600]	; (800dcf8 <_tx_thread_suspend+0x264>)
 800da9e:	681b      	ldr	r3, [r3, #0]
 800daa0:	67fb      	str	r3, [r7, #124]	; 0x7c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800daa2:	f3ef 8310 	mrs	r3, PRIMASK
 800daa6:	65fb      	str	r3, [r7, #92]	; 0x5c
    return(posture);
 800daa8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    int_posture = __get_interrupt_posture();
 800daaa:	65bb      	str	r3, [r7, #88]	; 0x58
    __asm__ volatile ("CPSID i" : : : "memory");
 800daac:	b672      	cpsid	i
    return(int_posture);
 800daae:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
 800dab0:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

#ifndef TX_NO_TIMER

    /* Determine if this is the current thread.  */
    if (thread_ptr == current_thread)
 800dab4:	687a      	ldr	r2, [r7, #4]
 800dab6:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800dab8:	429a      	cmp	r2, r3
 800daba:	d103      	bne.n	800dac4 <_tx_thread_suspend+0x30>
    {

        /* Yes, current thread is suspending - reset time slice for current thread.  */
        _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800dabc:	687b      	ldr	r3, [r7, #4]
 800dabe:	69db      	ldr	r3, [r3, #28]
 800dac0:	4a8e      	ldr	r2, [pc, #568]	; (800dcfc <_tx_thread_suspend+0x268>)
 800dac2:	6013      	str	r3, [r2, #0]

    /* Log this kernel call.  */
    TX_EL_THREAD_SUSPEND_INSERT

    /* Check the specified thread's current status.  */
    if (thread_ptr -> tx_thread_state == TX_READY)
 800dac4:	687b      	ldr	r3, [r7, #4]
 800dac6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dac8:	2b00      	cmp	r3, #0
 800daca:	f040 80fc 	bne.w	800dcc6 <_tx_thread_suspend+0x232>
    {

        /* Initialize status to success.  */
        status =  TX_SUCCESS;
 800dace:	2300      	movs	r3, #0
 800dad0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800dad4:	f3ef 8305 	mrs	r3, IPSR
 800dad8:	657b      	str	r3, [r7, #84]	; 0x54
    return(ipsr_value);
 800dada:	6d7a      	ldr	r2, [r7, #84]	; 0x54

        /* Determine if we are in a thread context.  */
        if (TX_THREAD_GET_SYSTEM_STATE() == ((ULONG) 0))
 800dadc:	4b88      	ldr	r3, [pc, #544]	; (800dd00 <_tx_thread_suspend+0x26c>)
 800dade:	681b      	ldr	r3, [r3, #0]
 800dae0:	4313      	orrs	r3, r2
 800dae2:	2b00      	cmp	r3, #0
 800dae4:	d10a      	bne.n	800dafc <_tx_thread_suspend+0x68>
        {

            /* Yes, we are in a thread context.  */

            /* Determine if the current thread is also the suspending thread.  */
            if (current_thread == thread_ptr)
 800dae6:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800dae8:	687b      	ldr	r3, [r7, #4]
 800daea:	429a      	cmp	r2, r3
 800daec:	d106      	bne.n	800dafc <_tx_thread_suspend+0x68>
            {

                /* Now determine if the preempt disable flag is non-zero.  */
                if (_tx_thread_preempt_disable != ((UINT) 0))
 800daee:	4b85      	ldr	r3, [pc, #532]	; (800dd04 <_tx_thread_suspend+0x270>)
 800daf0:	681b      	ldr	r3, [r3, #0]
 800daf2:	2b00      	cmp	r3, #0
 800daf4:	d002      	beq.n	800dafc <_tx_thread_suspend+0x68>
                {

                    /* Current thread cannot suspend when the preempt disable flag is non-zero,
                       return an error.  */
                    status =  TX_SUSPEND_ERROR;
 800daf6:	2314      	movs	r3, #20
 800daf8:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                }
            }
        }

        /* Determine if the status is still successful.  */
        if (status == TX_SUCCESS)
 800dafc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800db00:	2b00      	cmp	r3, #0
 800db02:	f040 8111 	bne.w	800dd28 <_tx_thread_suspend+0x294>
            /* Increment the total number of thread suspensions.  */
            _tx_thread_performance_suspend_count++;
#endif

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SUSPENDED;
 800db06:	687b      	ldr	r3, [r7, #4]
 800db08:	2203      	movs	r2, #3
 800db0a:	631a      	str	r2, [r3, #48]	; 0x30
                time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
            }
#endif

            /* Pickup priority of thread.  */
            priority =  thread_ptr -> tx_thread_priority;
 800db0c:	687b      	ldr	r3, [r7, #4]
 800db0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800db10:	67bb      	str	r3, [r7, #120]	; 0x78

            /* Pickup the previous and next ready thread pointers.  */
            ready_next =      thread_ptr -> tx_thread_ready_next;
 800db12:	687b      	ldr	r3, [r7, #4]
 800db14:	6a1b      	ldr	r3, [r3, #32]
 800db16:	677b      	str	r3, [r7, #116]	; 0x74
            ready_previous =  thread_ptr -> tx_thread_ready_previous;
 800db18:	687b      	ldr	r3, [r7, #4]
 800db1a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800db1c:	673b      	str	r3, [r7, #112]	; 0x70

            /* Determine if there are other threads at this priority that are
               ready.  */
            if (ready_next != thread_ptr)
 800db1e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800db20:	687b      	ldr	r3, [r7, #4]
 800db22:	429a      	cmp	r2, r3
 800db24:	d012      	beq.n	800db4c <_tx_thread_suspend+0xb8>
            {

                /* Yes, there are other threads at this priority ready.  */

                /* Just remove this thread from the priority list.  */
                ready_next -> tx_thread_ready_previous =    ready_previous;
 800db26:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800db28:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 800db2a:	625a      	str	r2, [r3, #36]	; 0x24
                ready_previous -> tx_thread_ready_next =    ready_next;
 800db2c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800db2e:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800db30:	621a      	str	r2, [r3, #32]

                /* Determine if this is the head of the priority list.  */
                if (_tx_thread_priority_list[priority] == thread_ptr)
 800db32:	4a75      	ldr	r2, [pc, #468]	; (800dd08 <_tx_thread_suspend+0x274>)
 800db34:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800db36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800db3a:	687a      	ldr	r2, [r7, #4]
 800db3c:	429a      	cmp	r2, r3
 800db3e:	d158      	bne.n	800dbf2 <_tx_thread_suspend+0x15e>
                {

                    /* Update the head pointer of this priority list.  */
                    _tx_thread_priority_list[priority] =  ready_next;
 800db40:	4971      	ldr	r1, [pc, #452]	; (800dd08 <_tx_thread_suspend+0x274>)
 800db42:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800db44:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800db46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 800db4a:	e052      	b.n	800dbf2 <_tx_thread_suspend+0x15e>
            else
            {

                /* This is the only thread at this priority ready to run.  Set the head
                   pointer to NULL.  */
                _tx_thread_priority_list[priority] =    TX_NULL;
 800db4c:	4a6e      	ldr	r2, [pc, #440]	; (800dd08 <_tx_thread_suspend+0x274>)
 800db4e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800db50:	2100      	movs	r1, #0
 800db52:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                /* Calculate the index into the bit map array.  */
                map_index =  priority/((UINT) 32);
#endif

                /* Clear this priority bit in the ready priority bit map.  */
                TX_MOD32_BIT_SET(priority, priority_bit)
 800db56:	2201      	movs	r2, #1
 800db58:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 800db5a:	fa02 f303 	lsl.w	r3, r2, r3
 800db5e:	66fb      	str	r3, [r7, #108]	; 0x6c
                _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
 800db60:	4b6a      	ldr	r3, [pc, #424]	; (800dd0c <_tx_thread_suspend+0x278>)
 800db62:	681a      	ldr	r2, [r3, #0]
 800db64:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800db66:	43db      	mvns	r3, r3
 800db68:	4013      	ands	r3, r2
 800db6a:	4a68      	ldr	r2, [pc, #416]	; (800dd0c <_tx_thread_suspend+0x278>)
 800db6c:	6013      	str	r3, [r2, #0]
                /* Calculate the base priority as well.  */
                base_priority =  map_index * ((UINT) 32);
#else

                /* Setup the base priority to zero.  */
                base_priority =   ((UINT) 0);
 800db6e:	2300      	movs	r3, #0
 800db70:	66bb      	str	r3, [r7, #104]	; 0x68
#endif

                /* Setup working variable for the priority map.  */
                priority_map =    _tx_thread_priority_maps[MAP_INDEX];
 800db72:	4b66      	ldr	r3, [pc, #408]	; (800dd0c <_tx_thread_suspend+0x278>)
 800db74:	681b      	ldr	r3, [r3, #0]
 800db76:	667b      	str	r3, [r7, #100]	; 0x64

                /* Make a quick check for no other threads ready for execution.  */
                if (priority_map == ((ULONG) 0))
 800db78:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800db7a:	2b00      	cmp	r3, #0
 800db7c:	d12c      	bne.n	800dbd8 <_tx_thread_suspend+0x144>
                {

                    /* Nothing else is ready.  Set highest priority and execute thread
                       accordingly.  */
                    _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 800db7e:	4b64      	ldr	r3, [pc, #400]	; (800dd10 <_tx_thread_suspend+0x27c>)
 800db80:	2220      	movs	r2, #32
 800db82:	601a      	str	r2, [r3, #0]
                    _tx_thread_execute_ptr =       TX_NULL;
 800db84:	4b63      	ldr	r3, [pc, #396]	; (800dd14 <_tx_thread_suspend+0x280>)
 800db86:	2200      	movs	r2, #0
 800db88:	601a      	str	r2, [r3, #0]
 800db8a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800db8e:	653b      	str	r3, [r7, #80]	; 0x50
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800db90:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800db92:	f383 8810 	msr	PRIMASK, r3
}
 800db96:	bf00      	nop
                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Determine if preemption should take place. This is only possible if the current thread pointer is
                       not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                    TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800db98:	4b5a      	ldr	r3, [pc, #360]	; (800dd04 <_tx_thread_suspend+0x270>)
 800db9a:	681b      	ldr	r3, [r3, #0]
 800db9c:	663b      	str	r3, [r7, #96]	; 0x60
                    if (combined_flags == ((ULONG) 0))
 800db9e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800dba0:	2b00      	cmp	r3, #0
 800dba2:	d117      	bne.n	800dbd4 <_tx_thread_suspend+0x140>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800dba4:	4b5c      	ldr	r3, [pc, #368]	; (800dd18 <_tx_thread_suspend+0x284>)
 800dba6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800dbaa:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800dbac:	f3ef 8305 	mrs	r3, IPSR
 800dbb0:	64fb      	str	r3, [r7, #76]	; 0x4c
    return(ipsr_value);
 800dbb2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    if (__get_ipsr_value() == 0)
 800dbb4:	2b00      	cmp	r3, #0
 800dbb6:	d10c      	bne.n	800dbd2 <_tx_thread_suspend+0x13e>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800dbb8:	f3ef 8310 	mrs	r3, PRIMASK
 800dbbc:	64bb      	str	r3, [r7, #72]	; 0x48
    return(posture);
 800dbbe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
        interrupt_save = __get_interrupt_posture();
 800dbc0:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("CPSIE  i": : : "memory");
 800dbc2:	b662      	cpsie	i
}
 800dbc4:	bf00      	nop
 800dbc6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800dbc8:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dbca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800dbcc:	f383 8810 	msr	PRIMASK, r3
}
 800dbd0:	bf00      	nop
}
 800dbd2:	bf00      	nop
                        /* Preemption is needed - return to the system!  */
                        _tx_thread_system_return();
                    }

                    /* Return to caller.  */
                    return(TX_SUCCESS);
 800dbd4:	2300      	movs	r3, #0
 800dbd6:	e0b0      	b.n	800dd3a <_tx_thread_suspend+0x2a6>
                }
                else
                {

                    /* Calculate the lowest bit set in the priority map. */
                    TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
 800dbd8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800dbda:	fa93 f3a3 	rbit	r3, r3
 800dbde:	667b      	str	r3, [r7, #100]	; 0x64
 800dbe0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800dbe2:	fab3 f383 	clz	r3, r3
 800dbe6:	66fb      	str	r3, [r7, #108]	; 0x6c

                    /* Setup the next highest priority variable.  */
                    _tx_thread_highest_priority =  base_priority + priority_bit;
 800dbe8:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800dbea:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800dbec:	4413      	add	r3, r2
 800dbee:	4a48      	ldr	r2, [pc, #288]	; (800dd10 <_tx_thread_suspend+0x27c>)
 800dbf0:	6013      	str	r3, [r2, #0]
                }
            }

            /* Determine if this thread is the thread designated to execute.  */
            if (thread_ptr == _tx_thread_execute_ptr)
 800dbf2:	4b48      	ldr	r3, [pc, #288]	; (800dd14 <_tx_thread_suspend+0x280>)
 800dbf4:	681b      	ldr	r3, [r3, #0]
 800dbf6:	687a      	ldr	r2, [r7, #4]
 800dbf8:	429a      	cmp	r2, r3
 800dbfa:	d12d      	bne.n	800dc58 <_tx_thread_suspend+0x1c4>
            {

                /* Pickup the highest priority thread to execute.  */
                _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800dbfc:	4b44      	ldr	r3, [pc, #272]	; (800dd10 <_tx_thread_suspend+0x27c>)
 800dbfe:	681b      	ldr	r3, [r3, #0]
 800dc00:	4a41      	ldr	r2, [pc, #260]	; (800dd08 <_tx_thread_suspend+0x274>)
 800dc02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800dc06:	4a43      	ldr	r2, [pc, #268]	; (800dd14 <_tx_thread_suspend+0x280>)
 800dc08:	6013      	str	r3, [r2, #0]
 800dc0a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800dc0e:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dc10:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800dc12:	f383 8810 	msr	PRIMASK, r3
}
 800dc16:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if preemption should take place. This is only possible if the current thread pointer is
                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800dc18:	4b3a      	ldr	r3, [pc, #232]	; (800dd04 <_tx_thread_suspend+0x270>)
 800dc1a:	681b      	ldr	r3, [r3, #0]
 800dc1c:	663b      	str	r3, [r7, #96]	; 0x60
                if (combined_flags == ((ULONG) 0))
 800dc1e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800dc20:	2b00      	cmp	r3, #0
 800dc22:	d117      	bne.n	800dc54 <_tx_thread_suspend+0x1c0>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800dc24:	4b3c      	ldr	r3, [pc, #240]	; (800dd18 <_tx_thread_suspend+0x284>)
 800dc26:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800dc2a:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800dc2c:	f3ef 8305 	mrs	r3, IPSR
 800dc30:	63bb      	str	r3, [r7, #56]	; 0x38
    return(ipsr_value);
 800dc32:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    if (__get_ipsr_value() == 0)
 800dc34:	2b00      	cmp	r3, #0
 800dc36:	d10c      	bne.n	800dc52 <_tx_thread_suspend+0x1be>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800dc38:	f3ef 8310 	mrs	r3, PRIMASK
 800dc3c:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 800dc3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
        interrupt_save = __get_interrupt_posture();
 800dc40:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSIE  i": : : "memory");
 800dc42:	b662      	cpsie	i
}
 800dc44:	bf00      	nop
 800dc46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800dc48:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dc4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800dc4c:	f383 8810 	msr	PRIMASK, r3
}
 800dc50:	bf00      	nop
}
 800dc52:	bf00      	nop
                    /* Preemption is needed - return to the system!  */
                    _tx_thread_system_return();
                }

                /* Return to caller.  */
                return(TX_SUCCESS);
 800dc54:	2300      	movs	r3, #0
 800dc56:	e070      	b.n	800dd3a <_tx_thread_suspend+0x2a6>
 800dc58:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800dc5c:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dc5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dc60:	f383 8810 	msr	PRIMASK, r3
}
 800dc64:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Determine if a preemption condition is present.  */
            if (current_thread != _tx_thread_execute_ptr)
 800dc66:	4b2b      	ldr	r3, [pc, #172]	; (800dd14 <_tx_thread_suspend+0x280>)
 800dc68:	681b      	ldr	r3, [r3, #0]
 800dc6a:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 800dc6c:	429a      	cmp	r2, r3
 800dc6e:	d01d      	beq.n	800dcac <_tx_thread_suspend+0x218>
                TX_THREAD_STACK_CHECK(thread_ptr)
#endif

                /* Determine if preemption should take place. This is only possible if the current thread pointer is
                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800dc70:	4b24      	ldr	r3, [pc, #144]	; (800dd04 <_tx_thread_suspend+0x270>)
 800dc72:	681b      	ldr	r3, [r3, #0]
 800dc74:	663b      	str	r3, [r7, #96]	; 0x60
                if (combined_flags == ((ULONG) 0))
 800dc76:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800dc78:	2b00      	cmp	r3, #0
 800dc7a:	d117      	bne.n	800dcac <_tx_thread_suspend+0x218>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800dc7c:	4b26      	ldr	r3, [pc, #152]	; (800dd18 <_tx_thread_suspend+0x284>)
 800dc7e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800dc82:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800dc84:	f3ef 8305 	mrs	r3, IPSR
 800dc88:	627b      	str	r3, [r7, #36]	; 0x24
    return(ipsr_value);
 800dc8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    if (__get_ipsr_value() == 0)
 800dc8c:	2b00      	cmp	r3, #0
 800dc8e:	d10c      	bne.n	800dcaa <_tx_thread_suspend+0x216>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800dc90:	f3ef 8310 	mrs	r3, PRIMASK
 800dc94:	623b      	str	r3, [r7, #32]
    return(posture);
 800dc96:	6a3b      	ldr	r3, [r7, #32]
        interrupt_save = __get_interrupt_posture();
 800dc98:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800dc9a:	b662      	cpsie	i
}
 800dc9c:	bf00      	nop
 800dc9e:	69fb      	ldr	r3, [r7, #28]
 800dca0:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dca2:	69bb      	ldr	r3, [r7, #24]
 800dca4:	f383 8810 	msr	PRIMASK, r3
}
 800dca8:	bf00      	nop
}
 800dcaa:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800dcac:	f3ef 8310 	mrs	r3, PRIMASK
 800dcb0:	617b      	str	r3, [r7, #20]
    return(posture);
 800dcb2:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800dcb4:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800dcb6:	b672      	cpsid	i
    return(int_posture);
 800dcb8:	693b      	ldr	r3, [r7, #16]
                    _tx_thread_system_return();
                }
            }

            /* Disable interrupts.  */
            TX_DISABLE
 800dcba:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

            /* Return success.  */
            status =  TX_SUCCESS;
 800dcbe:	2300      	movs	r3, #0
 800dcc0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800dcc4:	e030      	b.n	800dd28 <_tx_thread_suspend+0x294>
        }
    }
    else if (thread_ptr -> tx_thread_state == TX_TERMINATED)
 800dcc6:	687b      	ldr	r3, [r7, #4]
 800dcc8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dcca:	2b02      	cmp	r3, #2
 800dccc:	d103      	bne.n	800dcd6 <_tx_thread_suspend+0x242>
    {

        /* Thread is terminated.  */
        status =  TX_SUSPEND_ERROR;
 800dcce:	2314      	movs	r3, #20
 800dcd0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800dcd4:	e028      	b.n	800dd28 <_tx_thread_suspend+0x294>
    }
    else if (thread_ptr -> tx_thread_state == TX_COMPLETED)
 800dcd6:	687b      	ldr	r3, [r7, #4]
 800dcd8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dcda:	2b01      	cmp	r3, #1
 800dcdc:	d103      	bne.n	800dce6 <_tx_thread_suspend+0x252>
    {

        /* Thread is completed.  */
        status =  TX_SUSPEND_ERROR;
 800dcde:	2314      	movs	r3, #20
 800dce0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800dce4:	e020      	b.n	800dd28 <_tx_thread_suspend+0x294>
    }
    else if (thread_ptr -> tx_thread_state == TX_SUSPENDED)
 800dce6:	687b      	ldr	r3, [r7, #4]
 800dce8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800dcea:	2b03      	cmp	r3, #3
 800dcec:	d116      	bne.n	800dd1c <_tx_thread_suspend+0x288>
    {

        /* Already suspended, just set status to success.  */
        status =  TX_SUCCESS;
 800dcee:	2300      	movs	r3, #0
 800dcf0:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800dcf4:	e018      	b.n	800dd28 <_tx_thread_suspend+0x294>
 800dcf6:	bf00      	nop
 800dcf8:	20006d04 	.word	0x20006d04
 800dcfc:	20007308 	.word	0x20007308
 800dd00:	20000090 	.word	0x20000090
 800dd04:	20006d9c 	.word	0x20006d9c
 800dd08:	20006d1c 	.word	0x20006d1c
 800dd0c:	20006d14 	.word	0x20006d14
 800dd10:	20006d18 	.word	0x20006d18
 800dd14:	20006d08 	.word	0x20006d08
 800dd18:	e000ed04 	.word	0xe000ed04
    }
    else
    {

        /* Just set the delayed suspension flag.  */
        thread_ptr -> tx_thread_delayed_suspend =  TX_TRUE;
 800dd1c:	687b      	ldr	r3, [r7, #4]
 800dd1e:	2201      	movs	r2, #1
 800dd20:	635a      	str	r2, [r3, #52]	; 0x34

        /* Set status to success.  */
        status =  TX_SUCCESS;
 800dd22:	2300      	movs	r3, #0
 800dd24:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800dd28:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800dd2c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dd2e:	68fb      	ldr	r3, [r7, #12]
 800dd30:	f383 8810 	msr	PRIMASK, r3
}
 800dd34:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(status);
 800dd36:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
#endif
}
 800dd3a:	4618      	mov	r0, r3
 800dd3c:	378c      	adds	r7, #140	; 0x8c
 800dd3e:	46bd      	mov	sp, r7
 800dd40:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd44:	4770      	bx	lr
 800dd46:	bf00      	nop

0800dd48 <_tx_thread_system_preempt_check>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_preempt_check(VOID)
{
 800dd48:	b480      	push	{r7}
 800dd4a:	b089      	sub	sp, #36	; 0x24
 800dd4c:	af00      	add	r7, sp, #0
TX_THREAD       *current_thread;
TX_THREAD       *thread_ptr;


    /* Combine the system state and preempt disable flags into one for comparison.  */
    TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800dd4e:	4b17      	ldr	r3, [pc, #92]	; (800ddac <_tx_thread_system_preempt_check+0x64>)
 800dd50:	681b      	ldr	r3, [r3, #0]
 800dd52:	61fb      	str	r3, [r7, #28]

    /* Determine if we are in a system state (ISR or Initialization) or internal preemption is disabled.  */
    if (combined_flags == ((ULONG) 0))
 800dd54:	69fb      	ldr	r3, [r7, #28]
 800dd56:	2b00      	cmp	r3, #0
 800dd58:	d121      	bne.n	800dd9e <_tx_thread_system_preempt_check+0x56>
    {

        /* No, at thread execution level so continue checking for preemption.  */

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
 800dd5a:	4b15      	ldr	r3, [pc, #84]	; (800ddb0 <_tx_thread_system_preempt_check+0x68>)
 800dd5c:	681b      	ldr	r3, [r3, #0]
 800dd5e:	61bb      	str	r3, [r7, #24]

        /* Pickup the next execute pointer.  */
        thread_ptr =  _tx_thread_execute_ptr;
 800dd60:	4b14      	ldr	r3, [pc, #80]	; (800ddb4 <_tx_thread_system_preempt_check+0x6c>)
 800dd62:	681b      	ldr	r3, [r3, #0]
 800dd64:	617b      	str	r3, [r7, #20]

        /* Determine if preemption should take place.  */
        if (current_thread != thread_ptr)
 800dd66:	69ba      	ldr	r2, [r7, #24]
 800dd68:	697b      	ldr	r3, [r7, #20]
 800dd6a:	429a      	cmp	r2, r3
 800dd6c:	d017      	beq.n	800dd9e <_tx_thread_system_preempt_check+0x56>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800dd6e:	4b12      	ldr	r3, [pc, #72]	; (800ddb8 <_tx_thread_system_preempt_check+0x70>)
 800dd70:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800dd74:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800dd76:	f3ef 8305 	mrs	r3, IPSR
 800dd7a:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
 800dd7c:	693b      	ldr	r3, [r7, #16]
    if (__get_ipsr_value() == 0)
 800dd7e:	2b00      	cmp	r3, #0
 800dd80:	d10c      	bne.n	800dd9c <_tx_thread_system_preempt_check+0x54>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800dd82:	f3ef 8310 	mrs	r3, PRIMASK
 800dd86:	60fb      	str	r3, [r7, #12]
    return(posture);
 800dd88:	68fb      	ldr	r3, [r7, #12]
        interrupt_save = __get_interrupt_posture();
 800dd8a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800dd8c:	b662      	cpsie	i
}
 800dd8e:	bf00      	nop
 800dd90:	68bb      	ldr	r3, [r7, #8]
 800dd92:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dd94:	687b      	ldr	r3, [r7, #4]
 800dd96:	f383 8810 	msr	PRIMASK, r3
}
 800dd9a:	bf00      	nop
}
 800dd9c:	bf00      	nop

            /* Return to the system so the higher priority thread can be scheduled.  */
            _tx_thread_system_return();
        }
    }
}
 800dd9e:	bf00      	nop
 800dda0:	3724      	adds	r7, #36	; 0x24
 800dda2:	46bd      	mov	sp, r7
 800dda4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dda8:	4770      	bx	lr
 800ddaa:	bf00      	nop
 800ddac:	20006d9c 	.word	0x20006d9c
 800ddb0:	20006d04 	.word	0x20006d04
 800ddb4:	20006d08 	.word	0x20006d08
 800ddb8:	e000ed04 	.word	0xe000ed04

0800ddbc <_tx_thread_system_resume>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_resume(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
 800ddbc:	b580      	push	{r7, lr}
 800ddbe:	b096      	sub	sp, #88	; 0x58
 800ddc0:	af00      	add	r7, sp, #0
 800ddc2:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ddc4:	f3ef 8310 	mrs	r3, PRIMASK
 800ddc8:	637b      	str	r3, [r7, #52]	; 0x34
    return(posture);
 800ddca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    int_posture = __get_interrupt_posture();
 800ddcc:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
 800ddce:	b672      	cpsid	i
    return(int_posture);
 800ddd0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
 800ddd2:	657b      	str	r3, [r7, #84]	; 0x54

#ifndef TX_NO_TIMER

    /* Deactivate the timeout timer if necessary.  */
    if (thread_ptr -> tx_thread_timer.tx_timer_internal_list_head != TX_NULL)
 800ddd4:	687b      	ldr	r3, [r7, #4]
 800ddd6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800ddd8:	2b00      	cmp	r3, #0
 800ddda:	d005      	beq.n	800dde8 <_tx_thread_system_resume+0x2c>
    {

        /* Deactivate the thread's timeout timer.  */
        _tx_timer_system_deactivate(&(thread_ptr -> tx_thread_timer));
 800dddc:	687b      	ldr	r3, [r7, #4]
 800ddde:	334c      	adds	r3, #76	; 0x4c
 800dde0:	4618      	mov	r0, r3
 800dde2:	f000 fd4d 	bl	800e880 <_tx_timer_system_deactivate>
 800dde6:	e002      	b.n	800ddee <_tx_thread_system_resume+0x32>
    }
    else
    {

        /* Clear the remaining time to ensure timer doesn't get activated.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800dde8:	687b      	ldr	r3, [r7, #4]
 800ddea:	2200      	movs	r2, #0
 800ddec:	64da      	str	r2, [r3, #76]	; 0x4c
        time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
 800ddee:	4b6c      	ldr	r3, [pc, #432]	; (800dfa0 <_tx_thread_system_resume+0x1e4>)
 800ddf0:	681b      	ldr	r3, [r3, #0]
 800ddf2:	3b01      	subs	r3, #1
 800ddf4:	4a6a      	ldr	r2, [pc, #424]	; (800dfa0 <_tx_thread_system_resume+0x1e4>)
 800ddf6:	6013      	str	r3, [r2, #0]

    /* Determine if the thread is in the process of suspending.  If so, the thread
       control block is already on the linked list so nothing needs to be done.  */
    if (thread_ptr -> tx_thread_suspending == TX_FALSE)
 800ddf8:	687b      	ldr	r3, [r7, #4]
 800ddfa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ddfc:	2b00      	cmp	r3, #0
 800ddfe:	f040 8083 	bne.w	800df08 <_tx_thread_system_resume+0x14c>
    {

        /* Thread is not in the process of suspending. Now check to make sure the thread
           has not already been resumed.  */
        if (thread_ptr -> tx_thread_state != TX_READY)
 800de02:	687b      	ldr	r3, [r7, #4]
 800de04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800de06:	2b00      	cmp	r3, #0
 800de08:	f000 8097 	beq.w	800df3a <_tx_thread_system_resume+0x17e>
        {

            /* No, now check to see if the delayed suspension flag is set.  */
            if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
 800de0c:	687b      	ldr	r3, [r7, #4]
 800de0e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800de10:	2b00      	cmp	r3, #0
 800de12:	d172      	bne.n	800defa <_tx_thread_system_resume+0x13e>
                /* Resume the thread!  */

                /* Make this thread ready.  */

                /* Change the state to ready.  */
                thread_ptr -> tx_thread_state =  TX_READY;
 800de14:	687b      	ldr	r3, [r7, #4]
 800de16:	2200      	movs	r2, #0
 800de18:	631a      	str	r2, [r3, #48]	; 0x30

                /* Pickup priority of thread.  */
                priority =  thread_ptr -> tx_thread_priority;
 800de1a:	687b      	ldr	r3, [r7, #4]
 800de1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800de1e:	653b      	str	r3, [r7, #80]	; 0x50
                thread_ptr -> tx_thread_performance_resume_count++;
#endif

                /* Determine if there are other threads at this priority that are
                   ready.  */
                head_ptr =  _tx_thread_priority_list[priority];
 800de20:	4a60      	ldr	r2, [pc, #384]	; (800dfa4 <_tx_thread_system_resume+0x1e8>)
 800de22:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800de24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800de28:	64fb      	str	r3, [r7, #76]	; 0x4c
                if (head_ptr == TX_NULL)
 800de2a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800de2c:	2b00      	cmp	r3, #0
 800de2e:	d154      	bne.n	800deda <_tx_thread_system_resume+0x11e>
                {

                    /* First thread at this priority ready.  Add to the front of the list.  */
                    _tx_thread_priority_list[priority] =       thread_ptr;
 800de30:	495c      	ldr	r1, [pc, #368]	; (800dfa4 <_tx_thread_system_resume+0x1e8>)
 800de32:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800de34:	687a      	ldr	r2, [r7, #4]
 800de36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                    thread_ptr -> tx_thread_ready_next =       thread_ptr;
 800de3a:	687b      	ldr	r3, [r7, #4]
 800de3c:	687a      	ldr	r2, [r7, #4]
 800de3e:	621a      	str	r2, [r3, #32]
                    thread_ptr -> tx_thread_ready_previous =   thread_ptr;
 800de40:	687b      	ldr	r3, [r7, #4]
 800de42:	687a      	ldr	r2, [r7, #4]
 800de44:	625a      	str	r2, [r3, #36]	; 0x24
                    TX_DIV32_BIT_SET(priority, priority_bit)
                    _tx_thread_priority_map_active =  _tx_thread_priority_map_active | priority_bit;
#endif

                    /* Or in the thread's priority bit.  */
                    TX_MOD32_BIT_SET(priority, priority_bit)
 800de46:	2201      	movs	r2, #1
 800de48:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800de4a:	fa02 f303 	lsl.w	r3, r2, r3
 800de4e:	647b      	str	r3, [r7, #68]	; 0x44
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
 800de50:	4b55      	ldr	r3, [pc, #340]	; (800dfa8 <_tx_thread_system_resume+0x1ec>)
 800de52:	681a      	ldr	r2, [r3, #0]
 800de54:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800de56:	4313      	orrs	r3, r2
 800de58:	4a53      	ldr	r2, [pc, #332]	; (800dfa8 <_tx_thread_system_resume+0x1ec>)
 800de5a:	6013      	str	r3, [r2, #0]

                    /* Determine if this newly ready thread is the highest priority.  */
                    if (priority < _tx_thread_highest_priority)
 800de5c:	4b53      	ldr	r3, [pc, #332]	; (800dfac <_tx_thread_system_resume+0x1f0>)
 800de5e:	681b      	ldr	r3, [r3, #0]
 800de60:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800de62:	429a      	cmp	r2, r3
 800de64:	d269      	bcs.n	800df3a <_tx_thread_system_resume+0x17e>
                    {

                        /* A new highest priority thread is present. */

                        /* Update the highest priority variable.  */
                        _tx_thread_highest_priority =  priority;
 800de66:	4a51      	ldr	r2, [pc, #324]	; (800dfac <_tx_thread_system_resume+0x1f0>)
 800de68:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800de6a:	6013      	str	r3, [r2, #0]

                        /* Pickup the execute pointer. Since it is going to be referenced multiple
                           times, it is placed in a local variable.  */
                        execute_ptr =  _tx_thread_execute_ptr;
 800de6c:	4b50      	ldr	r3, [pc, #320]	; (800dfb0 <_tx_thread_system_resume+0x1f4>)
 800de6e:	681b      	ldr	r3, [r3, #0]
 800de70:	643b      	str	r3, [r7, #64]	; 0x40

                        /* Determine if no thread is currently executing.  */
                        if (execute_ptr == TX_NULL)
 800de72:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800de74:	2b00      	cmp	r3, #0
 800de76:	d103      	bne.n	800de80 <_tx_thread_system_resume+0xc4>
                        {

                            /* Simply setup the execute pointer.  */
                            _tx_thread_execute_ptr =  thread_ptr;
 800de78:	4a4d      	ldr	r2, [pc, #308]	; (800dfb0 <_tx_thread_system_resume+0x1f4>)
 800de7a:	687b      	ldr	r3, [r7, #4]
 800de7c:	6013      	str	r3, [r2, #0]
 800de7e:	e05c      	b.n	800df3a <_tx_thread_system_resume+0x17e>
                        {

                            /* Another thread has been scheduled for execution.  */

                            /* Check to see if this is a higher priority thread and determine if preemption is allowed.  */
                            if (priority < execute_ptr -> tx_thread_preempt_threshold)
 800de80:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800de82:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800de84:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800de86:	429a      	cmp	r2, r3
 800de88:	d257      	bcs.n	800df3a <_tx_thread_system_resume+0x17e>
                                execute_ptr -> tx_thread_performance_last_preempting_thread =  thread_ptr;

#endif

                                /* Yes, modify the execute thread pointer.  */
                                _tx_thread_execute_ptr =  thread_ptr;
 800de8a:	4a49      	ldr	r2, [pc, #292]	; (800dfb0 <_tx_thread_system_resume+0x1f4>)
 800de8c:	687b      	ldr	r3, [r7, #4]
 800de8e:	6013      	str	r3, [r2, #0]
 800de90:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800de92:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800de94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800de96:	f383 8810 	msr	PRIMASK, r3
}
 800de9a:	bf00      	nop
                                TX_THREAD_STACK_CHECK(thread_ptr)
#endif

                                /* Now determine if preemption should take place. This is only possible if the current thread pointer is
                                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800de9c:	4b40      	ldr	r3, [pc, #256]	; (800dfa0 <_tx_thread_system_resume+0x1e4>)
 800de9e:	681b      	ldr	r3, [r3, #0]
 800dea0:	63fb      	str	r3, [r7, #60]	; 0x3c
                                if (combined_flags == ((ULONG) 0))
 800dea2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800dea4:	2b00      	cmp	r3, #0
 800dea6:	d174      	bne.n	800df92 <_tx_thread_system_resume+0x1d6>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800dea8:	4b42      	ldr	r3, [pc, #264]	; (800dfb4 <_tx_thread_system_resume+0x1f8>)
 800deaa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800deae:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800deb0:	f3ef 8305 	mrs	r3, IPSR
 800deb4:	62bb      	str	r3, [r7, #40]	; 0x28
    return(ipsr_value);
 800deb6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    if (__get_ipsr_value() == 0)
 800deb8:	2b00      	cmp	r3, #0
 800deba:	d10c      	bne.n	800ded6 <_tx_thread_system_resume+0x11a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800debc:	f3ef 8310 	mrs	r3, PRIMASK
 800dec0:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800dec2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
        interrupt_save = __get_interrupt_posture();
 800dec4:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800dec6:	b662      	cpsie	i
}
 800dec8:	bf00      	nop
 800deca:	6a3b      	ldr	r3, [r7, #32]
 800decc:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800dece:	69fb      	ldr	r3, [r7, #28]
 800ded0:	f383 8810 	msr	PRIMASK, r3
}
 800ded4:	bf00      	nop
}
 800ded6:	bf00      	nop
                                    /* Preemption is needed - return to the system!  */
                                    _tx_thread_system_return();
                                }

                                /* Return in-line when MISRA is not enabled.  */
                                return;
 800ded8:	e05b      	b.n	800df92 <_tx_thread_system_resume+0x1d6>
                {

                    /* No, there are other threads at this priority already ready.  */

                    /* Just add this thread to the priority list.  */
                    tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
 800deda:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800dedc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800dede:	64bb      	str	r3, [r7, #72]	; 0x48
                    tail_ptr -> tx_thread_ready_next =         thread_ptr;
 800dee0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800dee2:	687a      	ldr	r2, [r7, #4]
 800dee4:	621a      	str	r2, [r3, #32]
                    head_ptr -> tx_thread_ready_previous =     thread_ptr;
 800dee6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800dee8:	687a      	ldr	r2, [r7, #4]
 800deea:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_previous =   tail_ptr;
 800deec:	687b      	ldr	r3, [r7, #4]
 800deee:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800def0:	625a      	str	r2, [r3, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_next =       head_ptr;
 800def2:	687b      	ldr	r3, [r7, #4]
 800def4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800def6:	621a      	str	r2, [r3, #32]
 800def8:	e01f      	b.n	800df3a <_tx_thread_system_resume+0x17e>
            /* Else, delayed suspend flag was set.  */
            else
            {

                /* Clear the delayed suspend flag and change the state.  */
                thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 800defa:	687b      	ldr	r3, [r7, #4]
 800defc:	2200      	movs	r2, #0
 800defe:	635a      	str	r2, [r3, #52]	; 0x34
                thread_ptr -> tx_thread_state =            TX_SUSPENDED;
 800df00:	687b      	ldr	r3, [r7, #4]
 800df02:	2203      	movs	r2, #3
 800df04:	631a      	str	r2, [r3, #48]	; 0x30
 800df06:	e018      	b.n	800df3a <_tx_thread_system_resume+0x17e>
        /* A resumption occurred in the middle of a previous thread suspension.  */

        /* Make sure the type of suspension under way is not a terminate or
           thread completion.  In either of these cases, do not void the
           interrupted suspension processing.  */
        if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 800df08:	687b      	ldr	r3, [r7, #4]
 800df0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800df0c:	2b01      	cmp	r3, #1
 800df0e:	d014      	beq.n	800df3a <_tx_thread_system_resume+0x17e>
        {

            /* Make sure the thread isn't terminated.  */
            if (thread_ptr -> tx_thread_state != TX_TERMINATED)
 800df10:	687b      	ldr	r3, [r7, #4]
 800df12:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800df14:	2b02      	cmp	r3, #2
 800df16:	d010      	beq.n	800df3a <_tx_thread_system_resume+0x17e>
            {

                /* No, now check to see if the delayed suspension flag is set.  */
                if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
 800df18:	687b      	ldr	r3, [r7, #4]
 800df1a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800df1c:	2b00      	cmp	r3, #0
 800df1e:	d106      	bne.n	800df2e <_tx_thread_system_resume+0x172>
                {

                    /* Clear the suspending flag.  */
                    thread_ptr -> tx_thread_suspending =   TX_FALSE;
 800df20:	687b      	ldr	r3, [r7, #4]
 800df22:	2200      	movs	r2, #0
 800df24:	639a      	str	r2, [r3, #56]	; 0x38

                    /* Restore the state to ready.  */
                    thread_ptr -> tx_thread_state =        TX_READY;
 800df26:	687b      	ldr	r3, [r7, #4]
 800df28:	2200      	movs	r2, #0
 800df2a:	631a      	str	r2, [r3, #48]	; 0x30
 800df2c:	e005      	b.n	800df3a <_tx_thread_system_resume+0x17e>
                }
                else
                {

                    /* Clear the delayed suspend flag and change the state.  */
                    thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 800df2e:	687b      	ldr	r3, [r7, #4]
 800df30:	2200      	movs	r2, #0
 800df32:	635a      	str	r2, [r3, #52]	; 0x34
                    thread_ptr -> tx_thread_state =            TX_SUSPENDED;
 800df34:	687b      	ldr	r3, [r7, #4]
 800df36:	2203      	movs	r2, #3
 800df38:	631a      	str	r2, [r3, #48]	; 0x30
        }
    }
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800df3a:	4b1f      	ldr	r3, [pc, #124]	; (800dfb8 <_tx_thread_system_resume+0x1fc>)
 800df3c:	681b      	ldr	r3, [r3, #0]
 800df3e:	63bb      	str	r3, [r7, #56]	; 0x38
 800df40:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800df42:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800df44:	69bb      	ldr	r3, [r7, #24]
 800df46:	f383 8810 	msr	PRIMASK, r3
}
 800df4a:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
 800df4c:	4b18      	ldr	r3, [pc, #96]	; (800dfb0 <_tx_thread_system_resume+0x1f4>)
 800df4e:	681b      	ldr	r3, [r3, #0]
 800df50:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800df52:	429a      	cmp	r2, r3
 800df54:	d020      	beq.n	800df98 <_tx_thread_system_resume+0x1dc>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Now determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800df56:	4b12      	ldr	r3, [pc, #72]	; (800dfa0 <_tx_thread_system_resume+0x1e4>)
 800df58:	681b      	ldr	r3, [r3, #0]
 800df5a:	63fb      	str	r3, [r7, #60]	; 0x3c
        if (combined_flags == ((ULONG) 0))
 800df5c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800df5e:	2b00      	cmp	r3, #0
 800df60:	d11a      	bne.n	800df98 <_tx_thread_system_resume+0x1dc>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800df62:	4b14      	ldr	r3, [pc, #80]	; (800dfb4 <_tx_thread_system_resume+0x1f8>)
 800df64:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800df68:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800df6a:	f3ef 8305 	mrs	r3, IPSR
 800df6e:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
 800df70:	697b      	ldr	r3, [r7, #20]
    if (__get_ipsr_value() == 0)
 800df72:	2b00      	cmp	r3, #0
 800df74:	d10f      	bne.n	800df96 <_tx_thread_system_resume+0x1da>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800df76:	f3ef 8310 	mrs	r3, PRIMASK
 800df7a:	613b      	str	r3, [r7, #16]
    return(posture);
 800df7c:	693b      	ldr	r3, [r7, #16]
        interrupt_save = __get_interrupt_posture();
 800df7e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800df80:	b662      	cpsie	i
}
 800df82:	bf00      	nop
 800df84:	68fb      	ldr	r3, [r7, #12]
 800df86:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800df88:	68bb      	ldr	r3, [r7, #8]
 800df8a:	f383 8810 	msr	PRIMASK, r3
}
 800df8e:	bf00      	nop
}
 800df90:	e001      	b.n	800df96 <_tx_thread_system_resume+0x1da>
                                return;
 800df92:	bf00      	nop
 800df94:	e000      	b.n	800df98 <_tx_thread_system_resume+0x1dc>
 800df96:	bf00      	nop

            /* Preemption is needed - return to the system!  */
            _tx_thread_system_return();
        }
    }
}
 800df98:	3758      	adds	r7, #88	; 0x58
 800df9a:	46bd      	mov	sp, r7
 800df9c:	bd80      	pop	{r7, pc}
 800df9e:	bf00      	nop
 800dfa0:	20006d9c 	.word	0x20006d9c
 800dfa4:	20006d1c 	.word	0x20006d1c
 800dfa8:	20006d14 	.word	0x20006d14
 800dfac:	20006d18 	.word	0x20006d18
 800dfb0:	20006d08 	.word	0x20006d08
 800dfb4:	e000ed04 	.word	0xe000ed04
 800dfb8:	20006d04 	.word	0x20006d04

0800dfbc <_tx_thread_system_suspend>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_suspend(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
 800dfbc:	b580      	push	{r7, lr}
 800dfbe:	b09e      	sub	sp, #120	; 0x78
 800dfc0:	af00      	add	r7, sp, #0
 800dfc2:	6078      	str	r0, [r7, #4]
TX_TRACE_BUFFER_ENTRY       *entry_ptr;
ULONG                       time_stamp =  ((ULONG) 0);
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800dfc4:	4b81      	ldr	r3, [pc, #516]	; (800e1cc <_tx_thread_system_suspend+0x210>)
 800dfc6:	681b      	ldr	r3, [r3, #0]
 800dfc8:	677b      	str	r3, [r7, #116]	; 0x74
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800dfca:	f3ef 8310 	mrs	r3, PRIMASK
 800dfce:	64fb      	str	r3, [r7, #76]	; 0x4c
    return(posture);
 800dfd0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    int_posture = __get_interrupt_posture();
 800dfd2:	64bb      	str	r3, [r7, #72]	; 0x48
    __asm__ volatile ("CPSID i" : : : "memory");
 800dfd4:	b672      	cpsid	i
    return(int_posture);
 800dfd6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
 800dfd8:	673b      	str	r3, [r7, #112]	; 0x70

#ifndef TX_NO_TIMER

    /* Is the current thread suspending?  */
    if (thread_ptr == current_thread)
 800dfda:	687a      	ldr	r2, [r7, #4]
 800dfdc:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800dfde:	429a      	cmp	r2, r3
 800dfe0:	d112      	bne.n	800e008 <_tx_thread_system_suspend+0x4c>
    {

        /* Pickup the wait option.  */
        timeout =  thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks;
 800dfe2:	687b      	ldr	r3, [r7, #4]
 800dfe4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800dfe6:	66fb      	str	r3, [r7, #108]	; 0x6c

        /* Determine if an activation is needed.  */
        if (timeout != TX_NO_WAIT)
 800dfe8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800dfea:	2b00      	cmp	r3, #0
 800dfec:	d008      	beq.n	800e000 <_tx_thread_system_suspend+0x44>
        {

            /* Make sure the suspension is not a wait-forever.  */
            if (timeout != TX_WAIT_FOREVER)
 800dfee:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800dff0:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dff4:	d004      	beq.n	800e000 <_tx_thread_system_suspend+0x44>
            {

                /* Activate the thread timer with the timeout value setup in the caller.  */
                _tx_timer_system_activate(&(thread_ptr -> tx_thread_timer));
 800dff6:	687b      	ldr	r3, [r7, #4]
 800dff8:	334c      	adds	r3, #76	; 0x4c
 800dffa:	4618      	mov	r0, r3
 800dffc:	f000 fbde 	bl	800e7bc <_tx_timer_system_activate>
            }
        }

        /* Yes, reset time slice for current thread.  */
        _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800e000:	687b      	ldr	r3, [r7, #4]
 800e002:	69db      	ldr	r3, [r3, #28]
 800e004:	4a72      	ldr	r2, [pc, #456]	; (800e1d0 <_tx_thread_system_suspend+0x214>)
 800e006:	6013      	str	r3, [r2, #0]
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
 800e008:	4b72      	ldr	r3, [pc, #456]	; (800e1d4 <_tx_thread_system_suspend+0x218>)
 800e00a:	681b      	ldr	r3, [r3, #0]
 800e00c:	3b01      	subs	r3, #1
 800e00e:	4a71      	ldr	r2, [pc, #452]	; (800e1d4 <_tx_thread_system_suspend+0x218>)
 800e010:	6013      	str	r3, [r2, #0]
    _tx_thread_performance_suspend_count++;
#endif

    /* Check to make sure the thread suspending flag is still set.  If not, it
       has already been resumed.  */
    if (thread_ptr -> tx_thread_suspending == TX_TRUE)
 800e012:	687b      	ldr	r3, [r7, #4]
 800e014:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800e016:	2b01      	cmp	r3, #1
 800e018:	f040 80a6 	bne.w	800e168 <_tx_thread_system_suspend+0x1ac>
            time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
        }
#endif

        /* Actually suspend this thread.  But first, clear the suspending flag.  */
        thread_ptr -> tx_thread_suspending =  TX_FALSE;
 800e01c:	687b      	ldr	r3, [r7, #4]
 800e01e:	2200      	movs	r2, #0
 800e020:	639a      	str	r2, [r3, #56]	; 0x38

        /* Pickup priority of thread.  */
        priority =  thread_ptr -> tx_thread_priority;
 800e022:	687b      	ldr	r3, [r7, #4]
 800e024:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e026:	66bb      	str	r3, [r7, #104]	; 0x68

        /* Pickup the next ready thread pointer.  */
        ready_next =      thread_ptr -> tx_thread_ready_next;
 800e028:	687b      	ldr	r3, [r7, #4]
 800e02a:	6a1b      	ldr	r3, [r3, #32]
 800e02c:	667b      	str	r3, [r7, #100]	; 0x64

        /* Determine if there are other threads at this priority that are
           ready.  */
        if (ready_next != thread_ptr)
 800e02e:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800e030:	687b      	ldr	r3, [r7, #4]
 800e032:	429a      	cmp	r2, r3
 800e034:	d015      	beq.n	800e062 <_tx_thread_system_suspend+0xa6>
        {

            /* Yes, there are other threads at this priority ready.  */

            /* Pickup the previous ready thread pointer.  */
            ready_previous =  thread_ptr -> tx_thread_ready_previous;
 800e036:	687b      	ldr	r3, [r7, #4]
 800e038:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800e03a:	653b      	str	r3, [r7, #80]	; 0x50

            /* Just remove this thread from the priority list.  */
            ready_next -> tx_thread_ready_previous =    ready_previous;
 800e03c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e03e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800e040:	625a      	str	r2, [r3, #36]	; 0x24
            ready_previous -> tx_thread_ready_next =    ready_next;
 800e042:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e044:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800e046:	621a      	str	r2, [r3, #32]

            /* Determine if this is the head of the priority list.  */
            if (_tx_thread_priority_list[priority] == thread_ptr)
 800e048:	4a63      	ldr	r2, [pc, #396]	; (800e1d8 <_tx_thread_system_suspend+0x21c>)
 800e04a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e04c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e050:	687a      	ldr	r2, [r7, #4]
 800e052:	429a      	cmp	r2, r3
 800e054:	d157      	bne.n	800e106 <_tx_thread_system_suspend+0x14a>
            {

                /* Update the head pointer of this priority list.  */
                _tx_thread_priority_list[priority] =  ready_next;
 800e056:	4960      	ldr	r1, [pc, #384]	; (800e1d8 <_tx_thread_system_suspend+0x21c>)
 800e058:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e05a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800e05c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 800e060:	e051      	b.n	800e106 <_tx_thread_system_suspend+0x14a>
        else
        {

            /* This is the only thread at this priority ready to run.  Set the head
               pointer to NULL.  */
            _tx_thread_priority_list[priority] =    TX_NULL;
 800e062:	4a5d      	ldr	r2, [pc, #372]	; (800e1d8 <_tx_thread_system_suspend+0x21c>)
 800e064:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e066:	2100      	movs	r1, #0
 800e068:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            /* Calculate the index into the bit map array.  */
            map_index =  priority/((UINT) 32);
#endif

            /* Clear this priority bit in the ready priority bit map.  */
            TX_MOD32_BIT_SET(priority, priority_bit)
 800e06c:	2201      	movs	r2, #1
 800e06e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e070:	fa02 f303 	lsl.w	r3, r2, r3
 800e074:	663b      	str	r3, [r7, #96]	; 0x60
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
 800e076:	4b59      	ldr	r3, [pc, #356]	; (800e1dc <_tx_thread_system_suspend+0x220>)
 800e078:	681a      	ldr	r2, [r3, #0]
 800e07a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e07c:	43db      	mvns	r3, r3
 800e07e:	4013      	ands	r3, r2
 800e080:	4a56      	ldr	r2, [pc, #344]	; (800e1dc <_tx_thread_system_suspend+0x220>)
 800e082:	6013      	str	r3, [r2, #0]
            /* Calculate the base priority as well.  */
            base_priority =  map_index * ((UINT) 32);
#else

            /* Setup the base priority to zero.  */
            base_priority =   ((UINT) 0);
 800e084:	2300      	movs	r3, #0
 800e086:	65fb      	str	r3, [r7, #92]	; 0x5c
#endif

            /* Setup working variable for the priority map.  */
            priority_map =    _tx_thread_priority_maps[MAP_INDEX];
 800e088:	4b54      	ldr	r3, [pc, #336]	; (800e1dc <_tx_thread_system_suspend+0x220>)
 800e08a:	681b      	ldr	r3, [r3, #0]
 800e08c:	65bb      	str	r3, [r7, #88]	; 0x58

            /* Make a quick check for no other threads ready for execution.  */
            if (priority_map == ((ULONG) 0))
 800e08e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e090:	2b00      	cmp	r3, #0
 800e092:	d12b      	bne.n	800e0ec <_tx_thread_system_suspend+0x130>
            {

                /* Nothing else is ready.  Set highest priority and execute thread
                   accordingly.  */
                _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 800e094:	4b52      	ldr	r3, [pc, #328]	; (800e1e0 <_tx_thread_system_suspend+0x224>)
 800e096:	2220      	movs	r2, #32
 800e098:	601a      	str	r2, [r3, #0]
                _tx_thread_execute_ptr =       TX_NULL;
 800e09a:	4b52      	ldr	r3, [pc, #328]	; (800e1e4 <_tx_thread_system_suspend+0x228>)
 800e09c:	2200      	movs	r2, #0
 800e09e:	601a      	str	r2, [r3, #0]
 800e0a0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e0a2:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e0a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e0a6:	f383 8810 	msr	PRIMASK, r3
}
 800e0aa:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if preemption should take place. This is only possible if the current thread pointer is
                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800e0ac:	4b49      	ldr	r3, [pc, #292]	; (800e1d4 <_tx_thread_system_suspend+0x218>)
 800e0ae:	681b      	ldr	r3, [r3, #0]
 800e0b0:	657b      	str	r3, [r7, #84]	; 0x54
                if (combined_flags == ((ULONG) 0))
 800e0b2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e0b4:	2b00      	cmp	r3, #0
 800e0b6:	f040 8081 	bne.w	800e1bc <_tx_thread_system_suspend+0x200>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800e0ba:	4b4b      	ldr	r3, [pc, #300]	; (800e1e8 <_tx_thread_system_suspend+0x22c>)
 800e0bc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800e0c0:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e0c2:	f3ef 8305 	mrs	r3, IPSR
 800e0c6:	643b      	str	r3, [r7, #64]	; 0x40
    return(ipsr_value);
 800e0c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    if (__get_ipsr_value() == 0)
 800e0ca:	2b00      	cmp	r3, #0
 800e0cc:	d10c      	bne.n	800e0e8 <_tx_thread_system_suspend+0x12c>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e0ce:	f3ef 8310 	mrs	r3, PRIMASK
 800e0d2:	63fb      	str	r3, [r7, #60]	; 0x3c
    return(posture);
 800e0d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
        interrupt_save = __get_interrupt_posture();
 800e0d6:	63bb      	str	r3, [r7, #56]	; 0x38
    __asm__ volatile ("CPSIE  i": : : "memory");
 800e0d8:	b662      	cpsie	i
}
 800e0da:	bf00      	nop
 800e0dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e0de:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e0e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e0e2:	f383 8810 	msr	PRIMASK, r3
}
 800e0e6:	bf00      	nop
}
 800e0e8:	bf00      	nop
                    /* Preemption is needed - return to the system!  */
                    _tx_thread_system_return();
                }

                /* Return to caller.  */
                return;
 800e0ea:	e067      	b.n	800e1bc <_tx_thread_system_suspend+0x200>
            {

                /* Other threads at different priority levels are ready to run.  */

                /* Calculate the lowest bit set in the priority map. */
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
 800e0ec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e0ee:	fa93 f3a3 	rbit	r3, r3
 800e0f2:	65bb      	str	r3, [r7, #88]	; 0x58
 800e0f4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e0f6:	fab3 f383 	clz	r3, r3
 800e0fa:	663b      	str	r3, [r7, #96]	; 0x60

                /* Setup the next highest priority variable.  */
                _tx_thread_highest_priority =  base_priority + ((UINT) priority_bit);
 800e0fc:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800e0fe:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e100:	4413      	add	r3, r2
 800e102:	4a37      	ldr	r2, [pc, #220]	; (800e1e0 <_tx_thread_system_suspend+0x224>)
 800e104:	6013      	str	r3, [r2, #0]
            }
        }

        /* Determine if the suspending thread is the thread designated to execute.  */
        if (thread_ptr == _tx_thread_execute_ptr)
 800e106:	4b37      	ldr	r3, [pc, #220]	; (800e1e4 <_tx_thread_system_suspend+0x228>)
 800e108:	681b      	ldr	r3, [r3, #0]
 800e10a:	687a      	ldr	r2, [r7, #4]
 800e10c:	429a      	cmp	r2, r3
 800e10e:	d12b      	bne.n	800e168 <_tx_thread_system_suspend+0x1ac>
        {

            /* Pickup the highest priority thread to execute.  */
            _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800e110:	4b33      	ldr	r3, [pc, #204]	; (800e1e0 <_tx_thread_system_suspend+0x224>)
 800e112:	681b      	ldr	r3, [r3, #0]
 800e114:	4a30      	ldr	r2, [pc, #192]	; (800e1d8 <_tx_thread_system_suspend+0x21c>)
 800e116:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e11a:	4a32      	ldr	r2, [pc, #200]	; (800e1e4 <_tx_thread_system_suspend+0x228>)
 800e11c:	6013      	str	r3, [r2, #0]
 800e11e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e120:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e122:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e124:	f383 8810 	msr	PRIMASK, r3
}
 800e128:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE

            /* Determine if preemption should take place. This is only possible if the current thread pointer is
               not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
            TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800e12a:	4b2a      	ldr	r3, [pc, #168]	; (800e1d4 <_tx_thread_system_suspend+0x218>)
 800e12c:	681b      	ldr	r3, [r3, #0]
 800e12e:	657b      	str	r3, [r7, #84]	; 0x54
            if (combined_flags == ((ULONG) 0))
 800e130:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e132:	2b00      	cmp	r3, #0
 800e134:	d144      	bne.n	800e1c0 <_tx_thread_system_suspend+0x204>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800e136:	4b2c      	ldr	r3, [pc, #176]	; (800e1e8 <_tx_thread_system_suspend+0x22c>)
 800e138:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800e13c:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e13e:	f3ef 8305 	mrs	r3, IPSR
 800e142:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(ipsr_value);
 800e144:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    if (__get_ipsr_value() == 0)
 800e146:	2b00      	cmp	r3, #0
 800e148:	d10c      	bne.n	800e164 <_tx_thread_system_suspend+0x1a8>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e14a:	f3ef 8310 	mrs	r3, PRIMASK
 800e14e:	62bb      	str	r3, [r7, #40]	; 0x28
    return(posture);
 800e150:	6abb      	ldr	r3, [r7, #40]	; 0x28
        interrupt_save = __get_interrupt_posture();
 800e152:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("CPSIE  i": : : "memory");
 800e154:	b662      	cpsie	i
}
 800e156:	bf00      	nop
 800e158:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e15a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e15c:	6a3b      	ldr	r3, [r7, #32]
 800e15e:	f383 8810 	msr	PRIMASK, r3
}
 800e162:	bf00      	nop
}
 800e164:	bf00      	nop
                /* Preemption is needed - return to the system!  */
                _tx_thread_system_return();
            }

            /* Return to caller.  */
            return;
 800e166:	e02b      	b.n	800e1c0 <_tx_thread_system_suspend+0x204>
 800e168:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800e16a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e16c:	69fb      	ldr	r3, [r7, #28]
 800e16e:	f383 8810 	msr	PRIMASK, r3
}
 800e172:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
 800e174:	4b1b      	ldr	r3, [pc, #108]	; (800e1e4 <_tx_thread_system_suspend+0x228>)
 800e176:	681b      	ldr	r3, [r3, #0]
 800e178:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 800e17a:	429a      	cmp	r2, r3
 800e17c:	d022      	beq.n	800e1c4 <_tx_thread_system_suspend+0x208>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800e17e:	4b15      	ldr	r3, [pc, #84]	; (800e1d4 <_tx_thread_system_suspend+0x218>)
 800e180:	681b      	ldr	r3, [r3, #0]
 800e182:	657b      	str	r3, [r7, #84]	; 0x54
        if (combined_flags == ((ULONG) 0))
 800e184:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e186:	2b00      	cmp	r3, #0
 800e188:	d11c      	bne.n	800e1c4 <_tx_thread_system_suspend+0x208>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800e18a:	4b17      	ldr	r3, [pc, #92]	; (800e1e8 <_tx_thread_system_suspend+0x22c>)
 800e18c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800e190:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e192:	f3ef 8305 	mrs	r3, IPSR
 800e196:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
 800e198:	69bb      	ldr	r3, [r7, #24]
    if (__get_ipsr_value() == 0)
 800e19a:	2b00      	cmp	r3, #0
 800e19c:	d10c      	bne.n	800e1b8 <_tx_thread_system_suspend+0x1fc>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e19e:	f3ef 8310 	mrs	r3, PRIMASK
 800e1a2:	617b      	str	r3, [r7, #20]
    return(posture);
 800e1a4:	697b      	ldr	r3, [r7, #20]
        interrupt_save = __get_interrupt_posture();
 800e1a6:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSIE  i": : : "memory");
 800e1a8:	b662      	cpsie	i
}
 800e1aa:	bf00      	nop
 800e1ac:	693b      	ldr	r3, [r7, #16]
 800e1ae:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e1b0:	68fb      	ldr	r3, [r7, #12]
 800e1b2:	f383 8810 	msr	PRIMASK, r3
}
 800e1b6:	bf00      	nop
}
 800e1b8:	bf00      	nop
            _tx_thread_system_return();
        }
    }

    /* Return to caller.  */
    return;
 800e1ba:	e003      	b.n	800e1c4 <_tx_thread_system_suspend+0x208>
                return;
 800e1bc:	bf00      	nop
 800e1be:	e002      	b.n	800e1c6 <_tx_thread_system_suspend+0x20a>
            return;
 800e1c0:	bf00      	nop
 800e1c2:	e000      	b.n	800e1c6 <_tx_thread_system_suspend+0x20a>
    return;
 800e1c4:	bf00      	nop
}
 800e1c6:	3778      	adds	r7, #120	; 0x78
 800e1c8:	46bd      	mov	sp, r7
 800e1ca:	bd80      	pop	{r7, pc}
 800e1cc:	20006d04 	.word	0x20006d04
 800e1d0:	20007308 	.word	0x20007308
 800e1d4:	20006d9c 	.word	0x20006d9c
 800e1d8:	20006d1c 	.word	0x20006d1c
 800e1dc:	20006d14 	.word	0x20006d14
 800e1e0:	20006d18 	.word	0x20006d18
 800e1e4:	20006d08 	.word	0x20006d08
 800e1e8:	e000ed04 	.word	0xe000ed04

0800e1ec <_tx_thread_terminate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_terminate(TX_THREAD *thread_ptr)
{
 800e1ec:	b580      	push	{r7, lr}
 800e1ee:	b0ac      	sub	sp, #176	; 0xb0
 800e1f0:	af00      	add	r7, sp, #0
 800e1f2:	6078      	str	r0, [r7, #4]
UINT        status;
ULONG       suspension_sequence;


    /* Default to successful completion.  */
    status =  TX_SUCCESS;
 800e1f4:	2300      	movs	r3, #0
 800e1f6:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e1fa:	f3ef 8310 	mrs	r3, PRIMASK
 800e1fe:	67fb      	str	r3, [r7, #124]	; 0x7c
    return(posture);
 800e200:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
    int_posture = __get_interrupt_posture();
 800e202:	67bb      	str	r3, [r7, #120]	; 0x78
    __asm__ volatile ("CPSID i" : : : "memory");
 800e204:	b672      	cpsid	i
    return(int_posture);
 800e206:	6fbb      	ldr	r3, [r7, #120]	; 0x78

    /* Lockout interrupts while the thread is being terminated.  */
    TX_DISABLE
 800e208:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

    /* Deactivate thread timer, if active.  */
    _tx_timer_system_deactivate(&thread_ptr -> tx_thread_timer);
 800e20c:	687b      	ldr	r3, [r7, #4]
 800e20e:	334c      	adds	r3, #76	; 0x4c
 800e210:	4618      	mov	r0, r3
 800e212:	f000 fb35 	bl	800e880 <_tx_timer_system_deactivate>

    /* Log this kernel call.  */
    TX_EL_THREAD_TERMINATE_INSERT

    /* Is the thread already terminated?  */
    if (thread_ptr -> tx_thread_state == TX_TERMINATED)
 800e216:	687b      	ldr	r3, [r7, #4]
 800e218:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e21a:	2b02      	cmp	r3, #2
 800e21c:	d10a      	bne.n	800e234 <_tx_thread_terminate+0x48>
 800e21e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e222:	677b      	str	r3, [r7, #116]	; 0x74
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e224:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800e226:	f383 8810 	msr	PRIMASK, r3
}
 800e22a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success since thread is already terminated.  */
        status =  TX_SUCCESS;
 800e22c:	2300      	movs	r3, #0
 800e22e:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 800e232:	e148      	b.n	800e4c6 <_tx_thread_terminate+0x2da>
    }

    /* Check the specified thread's current status.  */
    else if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 800e234:	687b      	ldr	r3, [r7, #4]
 800e236:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e238:	2b01      	cmp	r3, #1
 800e23a:	f000 813d 	beq.w	800e4b8 <_tx_thread_terminate+0x2cc>
    {

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 800e23e:	4ba6      	ldr	r3, [pc, #664]	; (800e4d8 <_tx_thread_terminate+0x2ec>)
 800e240:	681b      	ldr	r3, [r3, #0]
 800e242:	3301      	adds	r3, #1
 800e244:	4aa4      	ldr	r2, [pc, #656]	; (800e4d8 <_tx_thread_terminate+0x2ec>)
 800e246:	6013      	str	r3, [r2, #0]
        /* Pickup the entry/exit application callback routine.  */
        entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
#endif

        /* Check to see if the thread is currently ready.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
 800e248:	687b      	ldr	r3, [r7, #4]
 800e24a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e24c:	2b00      	cmp	r3, #0
 800e24e:	d17a      	bne.n	800e346 <_tx_thread_terminate+0x15a>
        {

            /* Set the state to terminated.  */
            thread_ptr -> tx_thread_state =  TX_TERMINATED;
 800e250:	687b      	ldr	r3, [r7, #4]
 800e252:	2202      	movs	r2, #2
 800e254:	631a      	str	r2, [r3, #48]	; 0x30
            /* Call actual non-interruptable thread suspension routine.  */
            _tx_thread_system_ni_suspend(thread_ptr, ((ULONG) 0));
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800e256:	687b      	ldr	r3, [r7, #4]
 800e258:	2201      	movs	r2, #1
 800e25a:	639a      	str	r2, [r3, #56]	; 0x38

            /* Setup for no timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800e25c:	687b      	ldr	r3, [r7, #4]
 800e25e:	2200      	movs	r2, #0
 800e260:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Disable preemption.  */
            _tx_thread_preempt_disable++;
 800e262:	4b9d      	ldr	r3, [pc, #628]	; (800e4d8 <_tx_thread_terminate+0x2ec>)
 800e264:	681b      	ldr	r3, [r3, #0]
 800e266:	3301      	adds	r3, #1
 800e268:	4a9b      	ldr	r2, [pc, #620]	; (800e4d8 <_tx_thread_terminate+0x2ec>)
 800e26a:	6013      	str	r3, [r2, #0]
 800e26c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e270:	66fb      	str	r3, [r7, #108]	; 0x6c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e272:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e274:	f383 8810 	msr	PRIMASK, r3
}
 800e278:	bf00      	nop
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e27a:	f3ef 8305 	mrs	r3, IPSR
 800e27e:	673b      	str	r3, [r7, #112]	; 0x70
    return(ipsr_value);
 800e280:	6f3a      	ldr	r2, [r7, #112]	; 0x70

            /* Restore interrupts.  */
            TX_RESTORE

            /* Perform any additional activities for tool or user purpose.  */
            TX_THREAD_TERMINATED_EXTENSION(thread_ptr)
 800e282:	4b96      	ldr	r3, [pc, #600]	; (800e4dc <_tx_thread_terminate+0x2f0>)
 800e284:	681b      	ldr	r3, [r3, #0]
 800e286:	4313      	orrs	r3, r2
 800e288:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 800e28c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800e290:	2b00      	cmp	r3, #0
 800e292:	d118      	bne.n	800e2c6 <_tx_thread_terminate+0xda>
 800e294:	4b92      	ldr	r3, [pc, #584]	; (800e4e0 <_tx_thread_terminate+0x2f4>)
 800e296:	681b      	ldr	r3, [r3, #0]
 800e298:	687a      	ldr	r2, [r7, #4]
 800e29a:	429a      	cmp	r2, r3
 800e29c:	d113      	bne.n	800e2c6 <_tx_thread_terminate+0xda>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800e29e:	f3ef 8314 	mrs	r3, CONTROL
 800e2a2:	667b      	str	r3, [r7, #100]	; 0x64
    return(control_value);
 800e2a4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800e2a6:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800e2aa:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800e2ae:	f023 0304 	bic.w	r3, r3, #4
 800e2b2:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
 800e2b6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800e2ba:	66bb      	str	r3, [r7, #104]	; 0x68
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 800e2bc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800e2be:	f383 8814 	msr	CONTROL, r3
}
 800e2c2:	bf00      	nop
 800e2c4:	e032      	b.n	800e32c <_tx_thread_terminate+0x140>
 800e2c6:	4b87      	ldr	r3, [pc, #540]	; (800e4e4 <_tx_thread_terminate+0x2f8>)
 800e2c8:	681b      	ldr	r3, [r3, #0]
 800e2ca:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800e2ce:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800e2d2:	f003 0301 	and.w	r3, r3, #1
 800e2d6:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 800e2da:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800e2de:	2b01      	cmp	r3, #1
 800e2e0:	d124      	bne.n	800e32c <_tx_thread_terminate+0x140>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800e2e2:	f3ef 8314 	mrs	r3, CONTROL
 800e2e6:	663b      	str	r3, [r7, #96]	; 0x60
    return(control_value);
 800e2e8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800e2ea:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800e2ee:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800e2f2:	f003 0304 	and.w	r3, r3, #4
 800e2f6:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800e2fa:	eeb0 0a40 	vmov.f32	s0, s0
 800e2fe:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800e302:	2b00      	cmp	r3, #0
 800e304:	d112      	bne.n	800e32c <_tx_thread_terminate+0x140>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800e306:	f3ef 8314 	mrs	r3, CONTROL
 800e30a:	65bb      	str	r3, [r7, #88]	; 0x58
    return(control_value);
 800e30c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800e30e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800e312:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800e316:	f023 0304 	bic.w	r3, r3, #4
 800e31a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 800e31e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 800e322:	65fb      	str	r3, [r7, #92]	; 0x5c
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 800e324:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800e326:	f383 8814 	msr	CONTROL, r3
}
 800e32a:	bf00      	nop
                (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
            }
#endif

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800e32c:	6878      	ldr	r0, [r7, #4]
 800e32e:	f7ff fe45 	bl	800dfbc <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e332:	f3ef 8310 	mrs	r3, PRIMASK
 800e336:	657b      	str	r3, [r7, #84]	; 0x54
    return(posture);
 800e338:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    int_posture = __get_interrupt_posture();
 800e33a:	653b      	str	r3, [r7, #80]	; 0x50
    __asm__ volatile ("CPSID i" : : : "memory");
 800e33c:	b672      	cpsid	i
    return(int_posture);
 800e33e:	6d3b      	ldr	r3, [r7, #80]	; 0x50

            /* Disable interrupts.  */
            TX_DISABLE
 800e340:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 800e344:	e094      	b.n	800e470 <_tx_thread_terminate+0x284>
        }
        else
        {

            /* Change the state to terminated.  */
            thread_ptr -> tx_thread_state =    TX_TERMINATED;
 800e346:	687b      	ldr	r3, [r7, #4]
 800e348:	2202      	movs	r2, #2
 800e34a:	631a      	str	r2, [r3, #48]	; 0x30
            /* Thread state change.  */
            TX_THREAD_STATE_CHANGE(thread_ptr, TX_TERMINATED)

            /* Set the suspending flag.  This prevents the thread from being
               resumed before the cleanup routine is executed.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800e34c:	687b      	ldr	r3, [r7, #4]
 800e34e:	2201      	movs	r2, #1
 800e350:	639a      	str	r2, [r3, #56]	; 0x38

            /* Pickup the cleanup routine address.  */
            suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
 800e352:	687b      	ldr	r3, [r7, #4]
 800e354:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800e356:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4

#ifndef TX_NOT_INTERRUPTABLE

            /* Pickup the suspension sequence number that is used later to verify that the
               cleanup is still necessary.  */
            suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
 800e35a:	687b      	ldr	r3, [r7, #4]
 800e35c:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800e360:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
 800e364:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e368:	64fb      	str	r3, [r7, #76]	; 0x4c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e36a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e36c:	f383 8810 	msr	PRIMASK, r3
}
 800e370:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE
#endif

            /* Call any cleanup routines.  */
            if (suspend_cleanup != TX_NULL)
 800e372:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800e376:	2b00      	cmp	r3, #0
 800e378:	d005      	beq.n	800e386 <_tx_thread_terminate+0x19a>
            {

                /* Yes, there is a function to call.  */
                (suspend_cleanup)(thread_ptr, suspension_sequence);
 800e37a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800e37e:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 800e382:	6878      	ldr	r0, [r7, #4]
 800e384:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e386:	f3ef 8310 	mrs	r3, PRIMASK
 800e38a:	643b      	str	r3, [r7, #64]	; 0x40
    return(posture);
 800e38c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    int_posture = __get_interrupt_posture();
 800e38e:	63fb      	str	r3, [r7, #60]	; 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
 800e390:	b672      	cpsid	i
    return(int_posture);
 800e392:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
            }

#ifndef TX_NOT_INTERRUPTABLE

            /* Disable interrupts.  */
            TX_DISABLE
 800e394:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
#endif

            /* Clear the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_FALSE;
 800e398:	687b      	ldr	r3, [r7, #4]
 800e39a:	2200      	movs	r2, #0
 800e39c:	639a      	str	r2, [r3, #56]	; 0x38
 800e39e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e3a2:	647b      	str	r3, [r7, #68]	; 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e3a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800e3a6:	f383 8810 	msr	PRIMASK, r3
}
 800e3aa:	bf00      	nop
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800e3ac:	f3ef 8305 	mrs	r3, IPSR
 800e3b0:	64bb      	str	r3, [r7, #72]	; 0x48
    return(ipsr_value);
 800e3b2:	6cba      	ldr	r2, [r7, #72]	; 0x48
            /* Restore interrupts.  */
            TX_RESTORE
#endif

            /* Perform any additional activities for tool or user purpose.  */
            TX_THREAD_TERMINATED_EXTENSION(thread_ptr)
 800e3b4:	4b49      	ldr	r3, [pc, #292]	; (800e4dc <_tx_thread_terminate+0x2f0>)
 800e3b6:	681b      	ldr	r3, [r3, #0]
 800e3b8:	4313      	orrs	r3, r2
 800e3ba:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 800e3be:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800e3c2:	2b00      	cmp	r3, #0
 800e3c4:	d118      	bne.n	800e3f8 <_tx_thread_terminate+0x20c>
 800e3c6:	4b46      	ldr	r3, [pc, #280]	; (800e4e0 <_tx_thread_terminate+0x2f4>)
 800e3c8:	681b      	ldr	r3, [r3, #0]
 800e3ca:	687a      	ldr	r2, [r7, #4]
 800e3cc:	429a      	cmp	r2, r3
 800e3ce:	d113      	bne.n	800e3f8 <_tx_thread_terminate+0x20c>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800e3d0:	f3ef 8314 	mrs	r3, CONTROL
 800e3d4:	637b      	str	r3, [r7, #52]	; 0x34
    return(control_value);
 800e3d6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e3d8:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800e3dc:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e3e0:	f023 0304 	bic.w	r3, r3, #4
 800e3e4:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
 800e3e8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e3ec:	63bb      	str	r3, [r7, #56]	; 0x38
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 800e3ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e3f0:	f383 8814 	msr	CONTROL, r3
}
 800e3f4:	bf00      	nop
 800e3f6:	e032      	b.n	800e45e <_tx_thread_terminate+0x272>
 800e3f8:	4b3a      	ldr	r3, [pc, #232]	; (800e4e4 <_tx_thread_terminate+0x2f8>)
 800e3fa:	681b      	ldr	r3, [r3, #0]
 800e3fc:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800e400:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800e404:	f003 0301 	and.w	r3, r3, #1
 800e408:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 800e40c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 800e410:	2b01      	cmp	r3, #1
 800e412:	d124      	bne.n	800e45e <_tx_thread_terminate+0x272>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800e414:	f3ef 8314 	mrs	r3, CONTROL
 800e418:	633b      	str	r3, [r7, #48]	; 0x30
    return(control_value);
 800e41a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e41c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800e420:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e424:	f003 0304 	and.w	r3, r3, #4
 800e428:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800e42c:	eeb0 0a40 	vmov.f32	s0, s0
 800e430:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e434:	2b00      	cmp	r3, #0
 800e436:	d112      	bne.n	800e45e <_tx_thread_terminate+0x272>
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
 800e438:	f3ef 8314 	mrs	r3, CONTROL
 800e43c:	62bb      	str	r3, [r7, #40]	; 0x28
    return(control_value);
 800e43e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800e440:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800e444:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e448:	f023 0304 	bic.w	r3, r3, #4
 800e44c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 800e450:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800e454:	62fb      	str	r3, [r7, #44]	; 0x2c
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
 800e456:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e458:	f383 8814 	msr	CONTROL, r3
}
 800e45c:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e45e:	f3ef 8310 	mrs	r3, PRIMASK
 800e462:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800e464:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800e466:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800e468:	b672      	cpsid	i
    return(int_posture);
 800e46a:	6a3b      	ldr	r3, [r7, #32]
#endif

#ifndef TX_NOT_INTERRUPTABLE

            /* Disable interrupts.  */
            TX_DISABLE
 800e46c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 800e470:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e474:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e476:	69fb      	ldr	r3, [r7, #28]
 800e478:	f383 8810 	msr	PRIMASK, r3
}
 800e47c:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
#endif

        /* Determine if the application is using mutexes.  */
        if (_tx_thread_mutex_release != TX_NULL)
 800e47e:	4b1a      	ldr	r3, [pc, #104]	; (800e4e8 <_tx_thread_terminate+0x2fc>)
 800e480:	681b      	ldr	r3, [r3, #0]
 800e482:	2b00      	cmp	r3, #0
 800e484:	d003      	beq.n	800e48e <_tx_thread_terminate+0x2a2>
        {

            /* Yes, call the mutex release function via a function pointer that
               is setup during initialization.  */
            (_tx_thread_mutex_release)(thread_ptr);
 800e486:	4b18      	ldr	r3, [pc, #96]	; (800e4e8 <_tx_thread_terminate+0x2fc>)
 800e488:	681b      	ldr	r3, [r3, #0]
 800e48a:	6878      	ldr	r0, [r7, #4]
 800e48c:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e48e:	f3ef 8310 	mrs	r3, PRIMASK
 800e492:	617b      	str	r3, [r7, #20]
    return(posture);
 800e494:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800e496:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800e498:	b672      	cpsid	i
    return(int_posture);
 800e49a:	693b      	ldr	r3, [r7, #16]
        }

#ifndef TX_NOT_INTERRUPTABLE

        /* Disable interrupts.  */
        TX_DISABLE
 800e49c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
#endif

        /* Enable preemption.  */
        _tx_thread_preempt_disable--;
 800e4a0:	4b0d      	ldr	r3, [pc, #52]	; (800e4d8 <_tx_thread_terminate+0x2ec>)
 800e4a2:	681b      	ldr	r3, [r3, #0]
 800e4a4:	3b01      	subs	r3, #1
 800e4a6:	4a0c      	ldr	r2, [pc, #48]	; (800e4d8 <_tx_thread_terminate+0x2ec>)
 800e4a8:	6013      	str	r3, [r2, #0]
 800e4aa:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e4ae:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e4b0:	69bb      	ldr	r3, [r7, #24]
 800e4b2:	f383 8810 	msr	PRIMASK, r3
}
 800e4b6:	e006      	b.n	800e4c6 <_tx_thread_terminate+0x2da>
 800e4b8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e4bc:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e4be:	68fb      	ldr	r3, [r7, #12]
 800e4c0:	f383 8810 	msr	PRIMASK, r3
}
 800e4c4:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800e4c6:	f7ff fc3f 	bl	800dd48 <_tx_thread_system_preempt_check>

    /* Return completion status.  */
    return(status);
 800e4ca:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
}
 800e4ce:	4618      	mov	r0, r3
 800e4d0:	37b0      	adds	r7, #176	; 0xb0
 800e4d2:	46bd      	mov	sp, r7
 800e4d4:	bd80      	pop	{r7, pc}
 800e4d6:	bf00      	nop
 800e4d8:	20006d9c 	.word	0x20006d9c
 800e4dc:	20000090 	.word	0x20000090
 800e4e0:	20006d04 	.word	0x20006d04
 800e4e4:	e000ef34 	.word	0xe000ef34
 800e4e8:	20006da0 	.word	0x20006da0

0800e4ec <_tx_thread_time_slice>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_time_slice(VOID)
{
 800e4ec:	b480      	push	{r7}
 800e4ee:	b087      	sub	sp, #28
 800e4f0:	af00      	add	r7, sp, #0
ULONG           system_state;
UINT            preempt_disable;
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800e4f2:	4b21      	ldr	r3, [pc, #132]	; (800e578 <_tx_thread_time_slice+0x8c>)
 800e4f4:	681b      	ldr	r3, [r3, #0]
 800e4f6:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e4f8:	f3ef 8310 	mrs	r3, PRIMASK
 800e4fc:	60fb      	str	r3, [r7, #12]
    return(posture);
 800e4fe:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
 800e500:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
 800e502:	b672      	cpsid	i
    return(int_posture);
 800e504:	68bb      	ldr	r3, [r7, #8]
    /* Set the next thread pointer to NULL.  */
    next_thread_ptr =  TX_NULL;
#endif

    /* Lockout interrupts while the time-slice is evaluated.  */
    TX_DISABLE
 800e506:	613b      	str	r3, [r7, #16]

    /* Clear the expired time-slice flag.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
 800e508:	4b1c      	ldr	r3, [pc, #112]	; (800e57c <_tx_thread_time_slice+0x90>)
 800e50a:	2200      	movs	r2, #0
 800e50c:	601a      	str	r2, [r3, #0]

    /* Make sure the thread pointer is valid.  */
    if (thread_ptr != TX_NULL)
 800e50e:	697b      	ldr	r3, [r7, #20]
 800e510:	2b00      	cmp	r3, #0
 800e512:	d024      	beq.n	800e55e <_tx_thread_time_slice+0x72>
    {

        /* Make sure the thread is still active, i.e. not suspended.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
 800e514:	697b      	ldr	r3, [r7, #20]
 800e516:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e518:	2b00      	cmp	r3, #0
 800e51a:	d120      	bne.n	800e55e <_tx_thread_time_slice+0x72>
        {

            /* Setup a fresh time-slice for the thread.  */
            thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800e51c:	697b      	ldr	r3, [r7, #20]
 800e51e:	69da      	ldr	r2, [r3, #28]
 800e520:	697b      	ldr	r3, [r7, #20]
 800e522:	619a      	str	r2, [r3, #24]

            /* Reset the actual time-slice variable.  */
            _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
 800e524:	697b      	ldr	r3, [r7, #20]
 800e526:	699b      	ldr	r3, [r3, #24]
 800e528:	4a15      	ldr	r2, [pc, #84]	; (800e580 <_tx_thread_time_slice+0x94>)
 800e52a:	6013      	str	r3, [r2, #0]

            /* Determine if there is another thread at the same priority and preemption-threshold
               is not set.  Preemption-threshold overrides time-slicing.  */
            if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 800e52c:	697b      	ldr	r3, [r7, #20]
 800e52e:	6a1b      	ldr	r3, [r3, #32]
 800e530:	697a      	ldr	r2, [r7, #20]
 800e532:	429a      	cmp	r2, r3
 800e534:	d013      	beq.n	800e55e <_tx_thread_time_slice+0x72>
            {

                /* Check to see if preemption-threshold is not being used.  */
                if (thread_ptr -> tx_thread_priority == thread_ptr -> tx_thread_preempt_threshold)
 800e536:	697b      	ldr	r3, [r7, #20]
 800e538:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800e53a:	697b      	ldr	r3, [r7, #20]
 800e53c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e53e:	429a      	cmp	r2, r3
 800e540:	d10d      	bne.n	800e55e <_tx_thread_time_slice+0x72>

                    /* Preemption-threshold is not being used by this thread.  */

                    /* There is another thread at this priority, make it the highest at
                       this priority level.  */
                    _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
 800e542:	697b      	ldr	r3, [r7, #20]
 800e544:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e546:	697a      	ldr	r2, [r7, #20]
 800e548:	6a12      	ldr	r2, [r2, #32]
 800e54a:	490e      	ldr	r1, [pc, #56]	; (800e584 <_tx_thread_time_slice+0x98>)
 800e54c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

                    /* Designate the highest priority thread as the one to execute.  Don't use this
                       thread's priority as an index just in case a higher priority thread is now
                       ready!  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800e550:	4b0d      	ldr	r3, [pc, #52]	; (800e588 <_tx_thread_time_slice+0x9c>)
 800e552:	681b      	ldr	r3, [r3, #0]
 800e554:	4a0b      	ldr	r2, [pc, #44]	; (800e584 <_tx_thread_time_slice+0x98>)
 800e556:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800e55a:	4a0c      	ldr	r2, [pc, #48]	; (800e58c <_tx_thread_time_slice+0xa0>)
 800e55c:	6013      	str	r3, [r2, #0]
 800e55e:	693b      	ldr	r3, [r7, #16]
 800e560:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e562:	687b      	ldr	r3, [r7, #4]
 800e564:	f383 8810 	msr	PRIMASK, r3
}
 800e568:	bf00      	nop

        /* Yes, check this thread's stack.  */
        TX_THREAD_STACK_CHECK(next_thread_ptr)
    }
#endif
}
 800e56a:	bf00      	nop
 800e56c:	371c      	adds	r7, #28
 800e56e:	46bd      	mov	sp, r7
 800e570:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e574:	4770      	bx	lr
 800e576:	bf00      	nop
 800e578:	20006d04 	.word	0x20006d04
 800e57c:	20006dac 	.word	0x20006dac
 800e580:	20007308 	.word	0x20007308
 800e584:	20006d1c 	.word	0x20006d1c
 800e588:	20006d18 	.word	0x20006d18
 800e58c:	20006d08 	.word	0x20006d08

0800e590 <_tx_thread_timeout>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_timeout(ULONG timeout_input)
{
 800e590:	b580      	push	{r7, lr}
 800e592:	b08a      	sub	sp, #40	; 0x28
 800e594:	af00      	add	r7, sp, #0
 800e596:	6078      	str	r0, [r7, #4]
VOID            (*suspend_cleanup)(struct TX_THREAD_STRUCT *suspend_thread_ptr, ULONG suspension_sequence);
ULONG           suspension_sequence;


    /* Pickup the thread pointer.  */
    TX_THREAD_TIMEOUT_POINTER_SETUP(thread_ptr)
 800e598:	687b      	ldr	r3, [r7, #4]
 800e59a:	627b      	str	r3, [r7, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e59c:	f3ef 8310 	mrs	r3, PRIMASK
 800e5a0:	617b      	str	r3, [r7, #20]
    return(posture);
 800e5a2:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800e5a4:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800e5a6:	b672      	cpsid	i
    return(int_posture);
 800e5a8:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts.  */
    TX_DISABLE
 800e5aa:	623b      	str	r3, [r7, #32]

    /* Determine how the thread is currently suspended.  */
    if (thread_ptr -> tx_thread_state == TX_SLEEP)
 800e5ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e5ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800e5b0:	2b04      	cmp	r3, #4
 800e5b2:	d10e      	bne.n	800e5d2 <_tx_thread_timeout+0x42>
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Increment the disable preemption flag.  */
        _tx_thread_preempt_disable++;
 800e5b4:	4b13      	ldr	r3, [pc, #76]	; (800e604 <_tx_thread_timeout+0x74>)
 800e5b6:	681b      	ldr	r3, [r3, #0]
 800e5b8:	3301      	adds	r3, #1
 800e5ba:	4a12      	ldr	r2, [pc, #72]	; (800e604 <_tx_thread_timeout+0x74>)
 800e5bc:	6013      	str	r3, [r2, #0]
 800e5be:	6a3b      	ldr	r3, [r7, #32]
 800e5c0:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e5c2:	68fb      	ldr	r3, [r7, #12]
 800e5c4:	f383 8810 	msr	PRIMASK, r3
}
 800e5c8:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Lift the suspension on the sleeping thread.  */
        _tx_thread_system_resume(thread_ptr);
 800e5ca:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e5cc:	f7ff fbf6 	bl	800ddbc <_tx_thread_system_resume>

        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
 800e5d0:	e013      	b.n	800e5fa <_tx_thread_timeout+0x6a>
        suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
 800e5d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e5d4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800e5d6:	61fb      	str	r3, [r7, #28]
        suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
 800e5d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e5da:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 800e5de:	61bb      	str	r3, [r7, #24]
 800e5e0:	6a3b      	ldr	r3, [r7, #32]
 800e5e2:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e5e4:	68bb      	ldr	r3, [r7, #8]
 800e5e6:	f383 8810 	msr	PRIMASK, r3
}
 800e5ea:	bf00      	nop
        if (suspend_cleanup != TX_NULL)
 800e5ec:	69fb      	ldr	r3, [r7, #28]
 800e5ee:	2b00      	cmp	r3, #0
 800e5f0:	d003      	beq.n	800e5fa <_tx_thread_timeout+0x6a>
            (suspend_cleanup)(thread_ptr, suspension_sequence);
 800e5f2:	69fb      	ldr	r3, [r7, #28]
 800e5f4:	69b9      	ldr	r1, [r7, #24]
 800e5f6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800e5f8:	4798      	blx	r3
}
 800e5fa:	bf00      	nop
 800e5fc:	3728      	adds	r7, #40	; 0x28
 800e5fe:	46bd      	mov	sp, r7
 800e600:	bd80      	pop	{r7, pc}
 800e602:	bf00      	nop
 800e604:	20006d9c 	.word	0x20006d9c

0800e608 <_tx_timer_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_create(TX_TIMER *timer_ptr, CHAR *name_ptr,
            VOID (*expiration_function)(ULONG id), ULONG expiration_input,
            ULONG initial_ticks, ULONG reschedule_ticks, UINT auto_activate)
{
 800e608:	b580      	push	{r7, lr}
 800e60a:	b08a      	sub	sp, #40	; 0x28
 800e60c:	af00      	add	r7, sp, #0
 800e60e:	60f8      	str	r0, [r7, #12]
 800e610:	60b9      	str	r1, [r7, #8]
 800e612:	607a      	str	r2, [r7, #4]
 800e614:	603b      	str	r3, [r7, #0]
TX_TIMER        *next_timer;
TX_TIMER        *previous_timer;


    /* Initialize timer control block to all zeros.  */
    TX_MEMSET(timer_ptr, 0, (sizeof(TX_TIMER)));
 800e616:	222c      	movs	r2, #44	; 0x2c
 800e618:	2100      	movs	r1, #0
 800e61a:	68f8      	ldr	r0, [r7, #12]
 800e61c:	f004 fe24 	bl	8013268 <memset>

    /* Setup the basic timer fields.  */
    timer_ptr -> tx_timer_name =                                            name_ptr;
 800e620:	68fb      	ldr	r3, [r7, #12]
 800e622:	68ba      	ldr	r2, [r7, #8]
 800e624:	605a      	str	r2, [r3, #4]
    timer_ptr -> tx_timer_internal.tx_timer_internal_remaining_ticks =      initial_ticks;
 800e626:	68fb      	ldr	r3, [r7, #12]
 800e628:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e62a:	609a      	str	r2, [r3, #8]
    timer_ptr -> tx_timer_internal.tx_timer_internal_re_initialize_ticks =  reschedule_ticks;
 800e62c:	68fb      	ldr	r3, [r7, #12]
 800e62e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800e630:	60da      	str	r2, [r3, #12]
    timer_ptr -> tx_timer_internal.tx_timer_internal_timeout_function =     expiration_function;
 800e632:	68fb      	ldr	r3, [r7, #12]
 800e634:	687a      	ldr	r2, [r7, #4]
 800e636:	611a      	str	r2, [r3, #16]
    timer_ptr -> tx_timer_internal.tx_timer_internal_timeout_param =        expiration_input;
 800e638:	68fb      	ldr	r3, [r7, #12]
 800e63a:	683a      	ldr	r2, [r7, #0]
 800e63c:	615a      	str	r2, [r3, #20]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e63e:	f3ef 8310 	mrs	r3, PRIMASK
 800e642:	61bb      	str	r3, [r7, #24]
    return(posture);
 800e644:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
 800e646:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
 800e648:	b672      	cpsid	i
    return(int_posture);
 800e64a:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to put the timer on the created list.  */
    TX_DISABLE
 800e64c:	627b      	str	r3, [r7, #36]	; 0x24

    /* Setup the timer ID to make it valid.  */
    timer_ptr -> tx_timer_id =  TX_TIMER_ID;
 800e64e:	68fb      	ldr	r3, [r7, #12]
 800e650:	4a1c      	ldr	r2, [pc, #112]	; (800e6c4 <_tx_timer_create+0xbc>)
 800e652:	601a      	str	r2, [r3, #0]

    /* Place the timer on the list of created application timers.  First,
       check for an empty list.  */
    if (_tx_timer_created_count == TX_EMPTY)
 800e654:	4b1c      	ldr	r3, [pc, #112]	; (800e6c8 <_tx_timer_create+0xc0>)
 800e656:	681b      	ldr	r3, [r3, #0]
 800e658:	2b00      	cmp	r3, #0
 800e65a:	d109      	bne.n	800e670 <_tx_timer_create+0x68>
    {

        /* The created timer list is empty.  Add timer to empty list.  */
        _tx_timer_created_ptr =                   timer_ptr;
 800e65c:	4a1b      	ldr	r2, [pc, #108]	; (800e6cc <_tx_timer_create+0xc4>)
 800e65e:	68fb      	ldr	r3, [r7, #12]
 800e660:	6013      	str	r3, [r2, #0]
        timer_ptr -> tx_timer_created_next =      timer_ptr;
 800e662:	68fb      	ldr	r3, [r7, #12]
 800e664:	68fa      	ldr	r2, [r7, #12]
 800e666:	625a      	str	r2, [r3, #36]	; 0x24
        timer_ptr -> tx_timer_created_previous =  timer_ptr;
 800e668:	68fb      	ldr	r3, [r7, #12]
 800e66a:	68fa      	ldr	r2, [r7, #12]
 800e66c:	629a      	str	r2, [r3, #40]	; 0x28
 800e66e:	e011      	b.n	800e694 <_tx_timer_create+0x8c>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_timer =  _tx_timer_created_ptr;
 800e670:	4b16      	ldr	r3, [pc, #88]	; (800e6cc <_tx_timer_create+0xc4>)
 800e672:	681b      	ldr	r3, [r3, #0]
 800e674:	623b      	str	r3, [r7, #32]
        previous_timer =  next_timer -> tx_timer_created_previous;
 800e676:	6a3b      	ldr	r3, [r7, #32]
 800e678:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800e67a:	61fb      	str	r3, [r7, #28]

        /* Place the new timer in the list.  */
        next_timer -> tx_timer_created_previous =  timer_ptr;
 800e67c:	6a3b      	ldr	r3, [r7, #32]
 800e67e:	68fa      	ldr	r2, [r7, #12]
 800e680:	629a      	str	r2, [r3, #40]	; 0x28
        previous_timer -> tx_timer_created_next =    timer_ptr;
 800e682:	69fb      	ldr	r3, [r7, #28]
 800e684:	68fa      	ldr	r2, [r7, #12]
 800e686:	625a      	str	r2, [r3, #36]	; 0x24

        /* Setup this timer's created links.  */
        timer_ptr -> tx_timer_created_previous =  previous_timer;
 800e688:	68fb      	ldr	r3, [r7, #12]
 800e68a:	69fa      	ldr	r2, [r7, #28]
 800e68c:	629a      	str	r2, [r3, #40]	; 0x28
        timer_ptr -> tx_timer_created_next =      next_timer;
 800e68e:	68fb      	ldr	r3, [r7, #12]
 800e690:	6a3a      	ldr	r2, [r7, #32]
 800e692:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /* Increment the number of created timers.  */
    _tx_timer_created_count++;
 800e694:	4b0c      	ldr	r3, [pc, #48]	; (800e6c8 <_tx_timer_create+0xc0>)
 800e696:	681b      	ldr	r3, [r3, #0]
 800e698:	3301      	adds	r3, #1
 800e69a:	4a0b      	ldr	r2, [pc, #44]	; (800e6c8 <_tx_timer_create+0xc0>)
 800e69c:	6013      	str	r3, [r2, #0]

    /* Log this kernel call.  */
    TX_EL_TIMER_CREATE_INSERT

    /* Determine if this timer needs to be activated.  */
    if (auto_activate == TX_AUTO_ACTIVATE)
 800e69e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800e6a0:	2b01      	cmp	r3, #1
 800e6a2:	d104      	bne.n	800e6ae <_tx_timer_create+0xa6>
        /* Increment the number of activations on this timer.  */
        timer_ptr -> tx_timer_performance_activate_count++;
#endif

        /* Call actual activation function.  */
        _tx_timer_system_activate(&(timer_ptr -> tx_timer_internal));
 800e6a4:	68fb      	ldr	r3, [r7, #12]
 800e6a6:	3308      	adds	r3, #8
 800e6a8:	4618      	mov	r0, r3
 800e6aa:	f000 f887 	bl	800e7bc <_tx_timer_system_activate>
 800e6ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800e6b0:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e6b2:	693b      	ldr	r3, [r7, #16]
 800e6b4:	f383 8810 	msr	PRIMASK, r3
}
 800e6b8:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
 800e6ba:	2300      	movs	r3, #0
}
 800e6bc:	4618      	mov	r0, r3
 800e6be:	3728      	adds	r7, #40	; 0x28
 800e6c0:	46bd      	mov	sp, r7
 800e6c2:	bd80      	pop	{r7, pc}
 800e6c4:	4154494d 	.word	0x4154494d
 800e6c8:	20006e44 	.word	0x20006e44
 800e6cc:	20006e40 	.word	0x20006e40

0800e6d0 <_tx_timer_expiration_process>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_expiration_process(VOID)
{
 800e6d0:	b580      	push	{r7, lr}
 800e6d2:	b084      	sub	sp, #16
 800e6d4:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e6d6:	f3ef 8310 	mrs	r3, PRIMASK
 800e6da:	607b      	str	r3, [r7, #4]
    return(posture);
 800e6dc:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
 800e6de:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
 800e6e0:	b672      	cpsid	i
    return(int_posture);
 800e6e2:	683b      	ldr	r3, [r7, #0]

    /* Don't process in the ISR, wakeup the system timer thread to process the
       timer expiration.  */

    /* Disable interrupts.  */
    TX_DISABLE
 800e6e4:	60fb      	str	r3, [r7, #12]
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Increment the preempt disable flag.  */
    _tx_thread_preempt_disable++;
 800e6e6:	4b09      	ldr	r3, [pc, #36]	; (800e70c <_tx_timer_expiration_process+0x3c>)
 800e6e8:	681b      	ldr	r3, [r3, #0]
 800e6ea:	3301      	adds	r3, #1
 800e6ec:	4a07      	ldr	r2, [pc, #28]	; (800e70c <_tx_timer_expiration_process+0x3c>)
 800e6ee:	6013      	str	r3, [r2, #0]
 800e6f0:	68fb      	ldr	r3, [r7, #12]
 800e6f2:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e6f4:	68bb      	ldr	r3, [r7, #8]
 800e6f6:	f383 8810 	msr	PRIMASK, r3
}
 800e6fa:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Call the system resume function to activate the timer thread.  */
    _tx_thread_system_resume(&_tx_timer_thread);
 800e6fc:	4804      	ldr	r0, [pc, #16]	; (800e710 <_tx_timer_expiration_process+0x40>)
 800e6fe:	f7ff fb5d 	bl	800ddbc <_tx_thread_system_resume>
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 800e702:	bf00      	nop
 800e704:	3710      	adds	r7, #16
 800e706:	46bd      	mov	sp, r7
 800e708:	bd80      	pop	{r7, pc}
 800e70a:	bf00      	nop
 800e70c:	20006d9c 	.word	0x20006d9c
 800e710:	20006e4c 	.word	0x20006e4c

0800e714 <_tx_timer_initialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_initialize(VOID)
{
 800e714:	b590      	push	{r4, r7, lr}
 800e716:	b089      	sub	sp, #36	; 0x24
 800e718:	af06      	add	r7, sp, #24
    /* First, initialize the timer list.  */
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
#endif

    /* Initialize all of the list pointers.  */
    _tx_timer_list_start =   &_tx_timer_list[0];
 800e71a:	4b1b      	ldr	r3, [pc, #108]	; (800e788 <_tx_timer_initialize+0x74>)
 800e71c:	4a1b      	ldr	r2, [pc, #108]	; (800e78c <_tx_timer_initialize+0x78>)
 800e71e:	601a      	str	r2, [r3, #0]
    _tx_timer_current_ptr =  &_tx_timer_list[0];
 800e720:	4b1b      	ldr	r3, [pc, #108]	; (800e790 <_tx_timer_initialize+0x7c>)
 800e722:	4a1a      	ldr	r2, [pc, #104]	; (800e78c <_tx_timer_initialize+0x78>)
 800e724:	601a      	str	r2, [r3, #0]

    /* Set the timer list end pointer to one past the actual timer list.  This is done
       to make the timer interrupt handling in assembly language a little easier.  */
    _tx_timer_list_end =     &_tx_timer_list[TX_TIMER_ENTRIES-((ULONG) 1)];
 800e726:	4b1b      	ldr	r3, [pc, #108]	; (800e794 <_tx_timer_initialize+0x80>)
 800e728:	4a1b      	ldr	r2, [pc, #108]	; (800e798 <_tx_timer_initialize+0x84>)
 800e72a:	601a      	str	r2, [r3, #0]
    _tx_timer_list_end =     TX_TIMER_POINTER_ADD(_tx_timer_list_end, ((ULONG) 1));
 800e72c:	4b19      	ldr	r3, [pc, #100]	; (800e794 <_tx_timer_initialize+0x80>)
 800e72e:	681b      	ldr	r3, [r3, #0]
 800e730:	3304      	adds	r3, #4
 800e732:	4a18      	ldr	r2, [pc, #96]	; (800e794 <_tx_timer_initialize+0x80>)
 800e734:	6013      	str	r3, [r2, #0]

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Setup the variables associated with the system timer thread's stack and
       priority.  */
    _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
 800e736:	4b19      	ldr	r3, [pc, #100]	; (800e79c <_tx_timer_initialize+0x88>)
 800e738:	4a19      	ldr	r2, [pc, #100]	; (800e7a0 <_tx_timer_initialize+0x8c>)
 800e73a:	601a      	str	r2, [r3, #0]
    _tx_timer_stack_size =   ((ULONG) TX_TIMER_THREAD_STACK_SIZE);
 800e73c:	4b19      	ldr	r3, [pc, #100]	; (800e7a4 <_tx_timer_initialize+0x90>)
 800e73e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800e742:	601a      	str	r2, [r3, #0]
    _tx_timer_priority =     ((UINT) TX_TIMER_THREAD_PRIORITY);
 800e744:	4b18      	ldr	r3, [pc, #96]	; (800e7a8 <_tx_timer_initialize+0x94>)
 800e746:	2200      	movs	r2, #0
 800e748:	601a      	str	r2, [r3, #0]
       low-level initialization component.  */
    do
    {

        /* Create the system timer thread.  */
        status =  _tx_thread_create(&_tx_timer_thread,
 800e74a:	4b14      	ldr	r3, [pc, #80]	; (800e79c <_tx_timer_initialize+0x88>)
 800e74c:	681b      	ldr	r3, [r3, #0]
 800e74e:	4a15      	ldr	r2, [pc, #84]	; (800e7a4 <_tx_timer_initialize+0x90>)
 800e750:	6812      	ldr	r2, [r2, #0]
 800e752:	4915      	ldr	r1, [pc, #84]	; (800e7a8 <_tx_timer_initialize+0x94>)
 800e754:	6809      	ldr	r1, [r1, #0]
 800e756:	4814      	ldr	r0, [pc, #80]	; (800e7a8 <_tx_timer_initialize+0x94>)
 800e758:	6800      	ldr	r0, [r0, #0]
 800e75a:	2400      	movs	r4, #0
 800e75c:	9405      	str	r4, [sp, #20]
 800e75e:	2400      	movs	r4, #0
 800e760:	9404      	str	r4, [sp, #16]
 800e762:	9003      	str	r0, [sp, #12]
 800e764:	9102      	str	r1, [sp, #8]
 800e766:	9201      	str	r2, [sp, #4]
 800e768:	9300      	str	r3, [sp, #0]
 800e76a:	4b10      	ldr	r3, [pc, #64]	; (800e7ac <_tx_timer_initialize+0x98>)
 800e76c:	4a10      	ldr	r2, [pc, #64]	; (800e7b0 <_tx_timer_initialize+0x9c>)
 800e76e:	4911      	ldr	r1, [pc, #68]	; (800e7b4 <_tx_timer_initialize+0xa0>)
 800e770:	4811      	ldr	r0, [pc, #68]	; (800e7b8 <_tx_timer_initialize+0xa4>)
 800e772:	f7fe fd67 	bl	800d244 <_tx_thread_create>
 800e776:	6078      	str	r0, [r7, #4]
#endif

        /* Define timer initialize extension.  */
        TX_TIMER_INITIALIZE_EXTENSION(status)

    } while (status != TX_SUCCESS);
 800e778:	687b      	ldr	r3, [r7, #4]
 800e77a:	2b00      	cmp	r3, #0
 800e77c:	d1e5      	bne.n	800e74a <_tx_timer_initialize+0x36>
    _tx_timer_performance_expiration_count =         ((ULONG) 0);
    _tx_timer_performance__expiration_adjust_count =  ((ULONG) 0);
#endif
#endif
#endif
}
 800e77e:	bf00      	nop
 800e780:	bf00      	nop
 800e782:	370c      	adds	r7, #12
 800e784:	46bd      	mov	sp, r7
 800e786:	bd90      	pop	{r4, r7, pc}
 800e788:	20006e30 	.word	0x20006e30
 800e78c:	20006db0 	.word	0x20006db0
 800e790:	20006e38 	.word	0x20006e38
 800e794:	20006e34 	.word	0x20006e34
 800e798:	20006e2c 	.word	0x20006e2c
 800e79c:	20006efc 	.word	0x20006efc
 800e7a0:	20006f08 	.word	0x20006f08
 800e7a4:	20006f00 	.word	0x20006f00
 800e7a8:	20006f04 	.word	0x20006f04
 800e7ac:	4154494d 	.word	0x4154494d
 800e7b0:	0800e8f1 	.word	0x0800e8f1
 800e7b4:	080133bc 	.word	0x080133bc
 800e7b8:	20006e4c 	.word	0x20006e4c

0800e7bc <_tx_timer_system_activate>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_activate(TX_TIMER_INTERNAL *timer_ptr)
{
 800e7bc:	b480      	push	{r7}
 800e7be:	b089      	sub	sp, #36	; 0x24
 800e7c0:	af00      	add	r7, sp, #0
 800e7c2:	6078      	str	r0, [r7, #4]
ULONG                       remaining_ticks;
ULONG                       expiration_time;


    /* Pickup the remaining ticks.  */
    remaining_ticks =  timer_ptr -> tx_timer_internal_remaining_ticks;
 800e7c4:	687b      	ldr	r3, [r7, #4]
 800e7c6:	681b      	ldr	r3, [r3, #0]
 800e7c8:	617b      	str	r3, [r7, #20]

    /* Determine if there is a timer to activate.  */
    if (remaining_ticks != ((ULONG) 0))
 800e7ca:	697b      	ldr	r3, [r7, #20]
 800e7cc:	2b00      	cmp	r3, #0
 800e7ce:	d04a      	beq.n	800e866 <_tx_timer_system_activate+0xaa>
    {

        /* Determine if the timer is set to wait forever.  */
        if (remaining_ticks != TX_WAIT_FOREVER)
 800e7d0:	697b      	ldr	r3, [r7, #20]
 800e7d2:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e7d6:	d046      	beq.n	800e866 <_tx_timer_system_activate+0xaa>
        {

            /* Valid timer activate request.  */

            /* Determine if the timer still needs activation.  */
            if (timer_ptr -> tx_timer_internal_list_head == TX_NULL)
 800e7d8:	687b      	ldr	r3, [r7, #4]
 800e7da:	699b      	ldr	r3, [r3, #24]
 800e7dc:	2b00      	cmp	r3, #0
 800e7de:	d142      	bne.n	800e866 <_tx_timer_system_activate+0xaa>
            {

                /* Activate the timer.  */

                /* Calculate the amount of time remaining for the timer.  */
                if (remaining_ticks > TX_TIMER_ENTRIES)
 800e7e0:	697b      	ldr	r3, [r7, #20]
 800e7e2:	2b20      	cmp	r3, #32
 800e7e4:	d902      	bls.n	800e7ec <_tx_timer_system_activate+0x30>
                {

                    /* Set expiration time to the maximum number of entries.  */
                    expiration_time =  TX_TIMER_ENTRIES - ((ULONG) 1);
 800e7e6:	231f      	movs	r3, #31
 800e7e8:	61bb      	str	r3, [r7, #24]
 800e7ea:	e002      	b.n	800e7f2 <_tx_timer_system_activate+0x36>
                {

                    /* Timer value fits in the timer entries.  */

                    /* Set the expiration time.  */
                    expiration_time =  (remaining_ticks - ((ULONG) 1));
 800e7ec:	697b      	ldr	r3, [r7, #20]
 800e7ee:	3b01      	subs	r3, #1
 800e7f0:	61bb      	str	r3, [r7, #24]

                /* At this point, we are ready to put the timer on one of
                   the timer lists.  */

                /* Calculate the proper place for the timer.  */
                timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
 800e7f2:	4b20      	ldr	r3, [pc, #128]	; (800e874 <_tx_timer_system_activate+0xb8>)
 800e7f4:	681a      	ldr	r2, [r3, #0]
 800e7f6:	69bb      	ldr	r3, [r7, #24]
 800e7f8:	009b      	lsls	r3, r3, #2
 800e7fa:	4413      	add	r3, r2
 800e7fc:	61fb      	str	r3, [r7, #28]
                if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
 800e7fe:	4b1e      	ldr	r3, [pc, #120]	; (800e878 <_tx_timer_system_activate+0xbc>)
 800e800:	681b      	ldr	r3, [r3, #0]
 800e802:	69fa      	ldr	r2, [r7, #28]
 800e804:	429a      	cmp	r2, r3
 800e806:	d30b      	bcc.n	800e820 <_tx_timer_system_activate+0x64>
                {

                    /* Wrap from the beginning of the list.  */
                    delta =  TX_TIMER_POINTER_DIF(timer_list, _tx_timer_list_end);
 800e808:	4b1b      	ldr	r3, [pc, #108]	; (800e878 <_tx_timer_system_activate+0xbc>)
 800e80a:	681b      	ldr	r3, [r3, #0]
 800e80c:	69fa      	ldr	r2, [r7, #28]
 800e80e:	1ad3      	subs	r3, r2, r3
 800e810:	109b      	asrs	r3, r3, #2
 800e812:	613b      	str	r3, [r7, #16]
                    timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
 800e814:	4b19      	ldr	r3, [pc, #100]	; (800e87c <_tx_timer_system_activate+0xc0>)
 800e816:	681a      	ldr	r2, [r3, #0]
 800e818:	693b      	ldr	r3, [r7, #16]
 800e81a:	009b      	lsls	r3, r3, #2
 800e81c:	4413      	add	r3, r2
 800e81e:	61fb      	str	r3, [r7, #28]
                }

                /* Now put the timer on this list.  */
                if ((*timer_list) == TX_NULL)
 800e820:	69fb      	ldr	r3, [r7, #28]
 800e822:	681b      	ldr	r3, [r3, #0]
 800e824:	2b00      	cmp	r3, #0
 800e826:	d109      	bne.n	800e83c <_tx_timer_system_activate+0x80>
                {

                    /* This list is NULL, just put the new timer on it.  */

                    /* Setup the links in this timer.  */
                    timer_ptr -> tx_timer_internal_active_next =      timer_ptr;
 800e828:	687b      	ldr	r3, [r7, #4]
 800e82a:	687a      	ldr	r2, [r7, #4]
 800e82c:	611a      	str	r2, [r3, #16]
                    timer_ptr -> tx_timer_internal_active_previous =  timer_ptr;
 800e82e:	687b      	ldr	r3, [r7, #4]
 800e830:	687a      	ldr	r2, [r7, #4]
 800e832:	615a      	str	r2, [r3, #20]

                    /* Setup the list head pointer.  */
                    *timer_list =  timer_ptr;
 800e834:	69fb      	ldr	r3, [r7, #28]
 800e836:	687a      	ldr	r2, [r7, #4]
 800e838:	601a      	str	r2, [r3, #0]
 800e83a:	e011      	b.n	800e860 <_tx_timer_system_activate+0xa4>
                }
                else
                {

                    /* This list is not NULL, add current timer to the end. */
                    next_timer =                                        *timer_list;
 800e83c:	69fb      	ldr	r3, [r7, #28]
 800e83e:	681b      	ldr	r3, [r3, #0]
 800e840:	60fb      	str	r3, [r7, #12]
                    previous_timer =                                    next_timer -> tx_timer_internal_active_previous;
 800e842:	68fb      	ldr	r3, [r7, #12]
 800e844:	695b      	ldr	r3, [r3, #20]
 800e846:	60bb      	str	r3, [r7, #8]
                    previous_timer -> tx_timer_internal_active_next =   timer_ptr;
 800e848:	68bb      	ldr	r3, [r7, #8]
 800e84a:	687a      	ldr	r2, [r7, #4]
 800e84c:	611a      	str	r2, [r3, #16]
                    next_timer -> tx_timer_internal_active_previous =   timer_ptr;
 800e84e:	68fb      	ldr	r3, [r7, #12]
 800e850:	687a      	ldr	r2, [r7, #4]
 800e852:	615a      	str	r2, [r3, #20]
                    timer_ptr -> tx_timer_internal_active_next =        next_timer;
 800e854:	687b      	ldr	r3, [r7, #4]
 800e856:	68fa      	ldr	r2, [r7, #12]
 800e858:	611a      	str	r2, [r3, #16]
                    timer_ptr -> tx_timer_internal_active_previous =    previous_timer;
 800e85a:	687b      	ldr	r3, [r7, #4]
 800e85c:	68ba      	ldr	r2, [r7, #8]
 800e85e:	615a      	str	r2, [r3, #20]
                }

                /* Setup list head pointer.  */
                timer_ptr -> tx_timer_internal_list_head =  timer_list;
 800e860:	687b      	ldr	r3, [r7, #4]
 800e862:	69fa      	ldr	r2, [r7, #28]
 800e864:	619a      	str	r2, [r3, #24]
            }
        }
    }
}
 800e866:	bf00      	nop
 800e868:	3724      	adds	r7, #36	; 0x24
 800e86a:	46bd      	mov	sp, r7
 800e86c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e870:	4770      	bx	lr
 800e872:	bf00      	nop
 800e874:	20006e38 	.word	0x20006e38
 800e878:	20006e34 	.word	0x20006e34
 800e87c:	20006e30 	.word	0x20006e30

0800e880 <_tx_timer_system_deactivate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_deactivate(TX_TIMER_INTERNAL *timer_ptr)
{
 800e880:	b480      	push	{r7}
 800e882:	b087      	sub	sp, #28
 800e884:	af00      	add	r7, sp, #0
 800e886:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL   *next_timer;
TX_TIMER_INTERNAL   *previous_timer;


    /* Pickup the list head pointer.  */
    list_head =  timer_ptr -> tx_timer_internal_list_head;
 800e888:	687b      	ldr	r3, [r7, #4]
 800e88a:	699b      	ldr	r3, [r3, #24]
 800e88c:	617b      	str	r3, [r7, #20]

    /* Determine if the timer still needs deactivation.  */
    if (list_head != TX_NULL)
 800e88e:	697b      	ldr	r3, [r7, #20]
 800e890:	2b00      	cmp	r3, #0
 800e892:	d026      	beq.n	800e8e2 <_tx_timer_system_deactivate+0x62>
    {

        /* Deactivate the timer.  */

        /* Pickup the next active timer.  */
        next_timer =  timer_ptr -> tx_timer_internal_active_next;
 800e894:	687b      	ldr	r3, [r7, #4]
 800e896:	691b      	ldr	r3, [r3, #16]
 800e898:	613b      	str	r3, [r7, #16]

        /* See if this is the only timer in the list.  */
        if (timer_ptr == next_timer)
 800e89a:	687a      	ldr	r2, [r7, #4]
 800e89c:	693b      	ldr	r3, [r7, #16]
 800e89e:	429a      	cmp	r2, r3
 800e8a0:	d108      	bne.n	800e8b4 <_tx_timer_system_deactivate+0x34>
        {

            /* Yes, the only timer on the list.  */

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
 800e8a2:	697b      	ldr	r3, [r7, #20]
 800e8a4:	681b      	ldr	r3, [r3, #0]
 800e8a6:	687a      	ldr	r2, [r7, #4]
 800e8a8:	429a      	cmp	r2, r3
 800e8aa:	d117      	bne.n	800e8dc <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the head pointer.  */
                *(list_head) =  TX_NULL;
 800e8ac:	697b      	ldr	r3, [r7, #20]
 800e8ae:	2200      	movs	r2, #0
 800e8b0:	601a      	str	r2, [r3, #0]
 800e8b2:	e013      	b.n	800e8dc <_tx_timer_system_deactivate+0x5c>
        {

            /* At least one more timer is on the same expiration list.  */

            /* Update the links of the adjacent timers.  */
            previous_timer =                                   timer_ptr -> tx_timer_internal_active_previous;
 800e8b4:	687b      	ldr	r3, [r7, #4]
 800e8b6:	695b      	ldr	r3, [r3, #20]
 800e8b8:	60fb      	str	r3, [r7, #12]
            next_timer -> tx_timer_internal_active_previous =  previous_timer;
 800e8ba:	693b      	ldr	r3, [r7, #16]
 800e8bc:	68fa      	ldr	r2, [r7, #12]
 800e8be:	615a      	str	r2, [r3, #20]
            previous_timer -> tx_timer_internal_active_next =  next_timer;
 800e8c0:	68fb      	ldr	r3, [r7, #12]
 800e8c2:	693a      	ldr	r2, [r7, #16]
 800e8c4:	611a      	str	r2, [r3, #16]

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
 800e8c6:	697b      	ldr	r3, [r7, #20]
 800e8c8:	681b      	ldr	r3, [r3, #0]
 800e8ca:	687a      	ldr	r2, [r7, #4]
 800e8cc:	429a      	cmp	r2, r3
 800e8ce:	d105      	bne.n	800e8dc <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the next timer in the list with the list head pointer.  */
                next_timer -> tx_timer_internal_list_head =  list_head;
 800e8d0:	693b      	ldr	r3, [r7, #16]
 800e8d2:	697a      	ldr	r2, [r7, #20]
 800e8d4:	619a      	str	r2, [r3, #24]

                /* Update the head pointer.  */
                *(list_head) =  next_timer;
 800e8d6:	697b      	ldr	r3, [r7, #20]
 800e8d8:	693a      	ldr	r2, [r7, #16]
 800e8da:	601a      	str	r2, [r3, #0]
            }
        }

        /* Clear the timer's list head pointer.  */
        timer_ptr -> tx_timer_internal_list_head =  TX_NULL;
 800e8dc:	687b      	ldr	r3, [r7, #4]
 800e8de:	2200      	movs	r2, #0
 800e8e0:	619a      	str	r2, [r3, #24]
    }
}
 800e8e2:	bf00      	nop
 800e8e4:	371c      	adds	r7, #28
 800e8e6:	46bd      	mov	sp, r7
 800e8e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e8ec:	4770      	bx	lr
	...

0800e8f0 <_tx_timer_thread_entry>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
#ifndef TX_TIMER_PROCESS_IN_ISR
VOID  _tx_timer_thread_entry(ULONG timer_thread_input)
{
 800e8f0:	b580      	push	{r7, lr}
 800e8f2:	b09c      	sub	sp, #112	; 0x70
 800e8f4:	af00      	add	r7, sp, #0
 800e8f6:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL           *reactivate_timer;
TX_TIMER_INTERNAL           *next_timer;
TX_TIMER_INTERNAL           *previous_timer;
TX_TIMER_INTERNAL           *current_timer;
VOID                        (*timeout_function)(ULONG id);
ULONG                       timeout_param =  ((ULONG) 0);
 800e8f8:	2300      	movs	r3, #0
 800e8fa:	667b      	str	r3, [r7, #100]	; 0x64
#endif


    /* Make sure the timer input is correct.  This also gets rid of the
       silly compiler warnings.  */
    if (timer_thread_input == TX_TIMER_ID)
 800e8fc:	687b      	ldr	r3, [r7, #4]
 800e8fe:	4a6c      	ldr	r2, [pc, #432]	; (800eab0 <_tx_timer_thread_entry+0x1c0>)
 800e900:	4293      	cmp	r3, r2
 800e902:	f040 812a 	bne.w	800eb5a <_tx_timer_thread_entry+0x26a>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e906:	f3ef 8310 	mrs	r3, PRIMASK
 800e90a:	647b      	str	r3, [r7, #68]	; 0x44
    return(posture);
 800e90c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    int_posture = __get_interrupt_posture();
 800e90e:	643b      	str	r3, [r7, #64]	; 0x40
    __asm__ volatile ("CPSID i" : : : "memory");
 800e910:	b672      	cpsid	i
    return(int_posture);
 800e912:	6c3b      	ldr	r3, [r7, #64]	; 0x40
        {

            /* First, move the current list pointer and clear the timer
               expired value.  This allows the interrupt handling portion
               to continue looking for timer expirations.  */
            TX_DISABLE
 800e914:	66fb      	str	r3, [r7, #108]	; 0x6c

            /* Save the current timer expiration list pointer.  */
            expired_timers =  *_tx_timer_current_ptr;
 800e916:	4b67      	ldr	r3, [pc, #412]	; (800eab4 <_tx_timer_thread_entry+0x1c4>)
 800e918:	681b      	ldr	r3, [r3, #0]
 800e91a:	681b      	ldr	r3, [r3, #0]
 800e91c:	613b      	str	r3, [r7, #16]

            /* Modify the head pointer in the first timer in the list, if there
               is one!  */
            if (expired_timers != TX_NULL)
 800e91e:	693b      	ldr	r3, [r7, #16]
 800e920:	2b00      	cmp	r3, #0
 800e922:	d003      	beq.n	800e92c <_tx_timer_thread_entry+0x3c>
            {

                expired_timers -> tx_timer_internal_list_head =  &expired_timers;
 800e924:	693b      	ldr	r3, [r7, #16]
 800e926:	f107 0210 	add.w	r2, r7, #16
 800e92a:	619a      	str	r2, [r3, #24]
            }

            /* Set the current list pointer to NULL.  */
            *_tx_timer_current_ptr =  TX_NULL;
 800e92c:	4b61      	ldr	r3, [pc, #388]	; (800eab4 <_tx_timer_thread_entry+0x1c4>)
 800e92e:	681b      	ldr	r3, [r3, #0]
 800e930:	2200      	movs	r2, #0
 800e932:	601a      	str	r2, [r3, #0]

            /* Move the current pointer up one timer entry wrap if we get to
               the end of the list.  */
            _tx_timer_current_ptr =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, 1);
 800e934:	4b5f      	ldr	r3, [pc, #380]	; (800eab4 <_tx_timer_thread_entry+0x1c4>)
 800e936:	681b      	ldr	r3, [r3, #0]
 800e938:	3304      	adds	r3, #4
 800e93a:	4a5e      	ldr	r2, [pc, #376]	; (800eab4 <_tx_timer_thread_entry+0x1c4>)
 800e93c:	6013      	str	r3, [r2, #0]
            if (_tx_timer_current_ptr == _tx_timer_list_end)
 800e93e:	4b5d      	ldr	r3, [pc, #372]	; (800eab4 <_tx_timer_thread_entry+0x1c4>)
 800e940:	681a      	ldr	r2, [r3, #0]
 800e942:	4b5d      	ldr	r3, [pc, #372]	; (800eab8 <_tx_timer_thread_entry+0x1c8>)
 800e944:	681b      	ldr	r3, [r3, #0]
 800e946:	429a      	cmp	r2, r3
 800e948:	d103      	bne.n	800e952 <_tx_timer_thread_entry+0x62>
            {

                _tx_timer_current_ptr =  _tx_timer_list_start;
 800e94a:	4b5c      	ldr	r3, [pc, #368]	; (800eabc <_tx_timer_thread_entry+0x1cc>)
 800e94c:	681b      	ldr	r3, [r3, #0]
 800e94e:	4a59      	ldr	r2, [pc, #356]	; (800eab4 <_tx_timer_thread_entry+0x1c4>)
 800e950:	6013      	str	r3, [r2, #0]
            }

            /* Clear the expired flag.  */
            _tx_timer_expired =  TX_FALSE;
 800e952:	4b5b      	ldr	r3, [pc, #364]	; (800eac0 <_tx_timer_thread_entry+0x1d0>)
 800e954:	2200      	movs	r2, #0
 800e956:	601a      	str	r2, [r3, #0]
 800e958:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800e95a:	637b      	str	r3, [r7, #52]	; 0x34
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800e95c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800e95e:	f383 8810 	msr	PRIMASK, r3
}
 800e962:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800e964:	f3ef 8310 	mrs	r3, PRIMASK
 800e968:	63fb      	str	r3, [r7, #60]	; 0x3c
    return(posture);
 800e96a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    int_posture = __get_interrupt_posture();
 800e96c:	63bb      	str	r3, [r7, #56]	; 0x38
    __asm__ volatile ("CPSID i" : : : "memory");
 800e96e:	b672      	cpsid	i
    return(int_posture);
 800e970:	6bbb      	ldr	r3, [r7, #56]	; 0x38

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
 800e972:	66fb      	str	r3, [r7, #108]	; 0x6c

            /* Next, process the expiration of the associated timers at this
               time slot.  */
            while (expired_timers != TX_NULL)
 800e974:	e0cb      	b.n	800eb0e <_tx_timer_thread_entry+0x21e>
            {

                /* Something is on the list.  Remove it and process the expiration.  */
                current_timer =  expired_timers;
 800e976:	693b      	ldr	r3, [r7, #16]
 800e978:	657b      	str	r3, [r7, #84]	; 0x54

                /* Pickup the next timer.  */
                next_timer =  expired_timers -> tx_timer_internal_active_next;
 800e97a:	693b      	ldr	r3, [r7, #16]
 800e97c:	691b      	ldr	r3, [r3, #16]
 800e97e:	653b      	str	r3, [r7, #80]	; 0x50

                /* Set the reactivate_timer to NULL.  */
                reactivate_timer =  TX_NULL;
 800e980:	2300      	movs	r3, #0
 800e982:	60fb      	str	r3, [r7, #12]

                /* Determine if this is the only timer.  */
                if (current_timer == next_timer)
 800e984:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800e986:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e988:	429a      	cmp	r2, r3
 800e98a:	d102      	bne.n	800e992 <_tx_timer_thread_entry+0xa2>
                {

                    /* Yes, this is the only timer in the list.  */

                    /* Set the head pointer to NULL.  */
                    expired_timers =  TX_NULL;
 800e98c:	2300      	movs	r3, #0
 800e98e:	613b      	str	r3, [r7, #16]
 800e990:	e00e      	b.n	800e9b0 <_tx_timer_thread_entry+0xc0>
                {

                    /* No, not the only expired timer.  */

                    /* Remove this timer from the expired list.  */
                    previous_timer =                                   current_timer -> tx_timer_internal_active_previous;
 800e992:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e994:	695b      	ldr	r3, [r3, #20]
 800e996:	64fb      	str	r3, [r7, #76]	; 0x4c
                    next_timer -> tx_timer_internal_active_previous =  previous_timer;
 800e998:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e99a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800e99c:	615a      	str	r2, [r3, #20]
                    previous_timer -> tx_timer_internal_active_next =  next_timer;
 800e99e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800e9a0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800e9a2:	611a      	str	r2, [r3, #16]

                    /* Modify the next timer's list head to point at the current list head.  */
                    next_timer -> tx_timer_internal_list_head =  &expired_timers;
 800e9a4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e9a6:	f107 0210 	add.w	r2, r7, #16
 800e9aa:	619a      	str	r2, [r3, #24]

                    /* Set the list head pointer.  */
                    expired_timers =  next_timer;
 800e9ac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800e9ae:	613b      	str	r3, [r7, #16]

                /* In any case, the timer is now off of the expired list.  */

                /* Determine if the timer has expired or if it is just a really
                   big timer that needs to be placed in the list again.  */
                if (current_timer -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
 800e9b0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9b2:	681b      	ldr	r3, [r3, #0]
 800e9b4:	2b20      	cmp	r3, #32
 800e9b6:	d911      	bls.n	800e9dc <_tx_timer_thread_entry+0xec>
                    }
#endif

                    /* Decrement the remaining ticks of the timer.  */
                    current_timer -> tx_timer_internal_remaining_ticks =
                            current_timer -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES;
 800e9b8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9ba:	681b      	ldr	r3, [r3, #0]
 800e9bc:	f1a3 0220 	sub.w	r2, r3, #32
                    current_timer -> tx_timer_internal_remaining_ticks =
 800e9c0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9c2:	601a      	str	r2, [r3, #0]

                    /* Set the timeout function to NULL in order to bypass the
                       expiration.  */
                    timeout_function =  TX_NULL;
 800e9c4:	2300      	movs	r3, #0
 800e9c6:	66bb      	str	r3, [r7, #104]	; 0x68

                    /* Make the timer appear that it is still active while interrupts
                       are enabled.  This will permit proper processing of a timer
                       deactivate from an ISR.  */
                    current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
 800e9c8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9ca:	f107 020c 	add.w	r2, r7, #12
 800e9ce:	619a      	str	r2, [r3, #24]
                    current_timer -> tx_timer_internal_active_next =  current_timer;
 800e9d0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9d2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800e9d4:	611a      	str	r2, [r3, #16]

                    /* Setup the temporary timer list head pointer.  */
                    reactivate_timer =  current_timer;
 800e9d6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9d8:	60fb      	str	r3, [r7, #12]
 800e9da:	e01a      	b.n	800ea12 <_tx_timer_thread_entry+0x122>
                    }
#endif

                    /* Copy the calling function and ID into local variables before interrupts
                       are re-enabled.  */
                    timeout_function =  current_timer -> tx_timer_internal_timeout_function;
 800e9dc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9de:	689b      	ldr	r3, [r3, #8]
 800e9e0:	66bb      	str	r3, [r7, #104]	; 0x68
                    timeout_param =     current_timer -> tx_timer_internal_timeout_param;
 800e9e2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9e4:	68db      	ldr	r3, [r3, #12]
 800e9e6:	667b      	str	r3, [r7, #100]	; 0x64

                    /* Copy the reinitialize ticks into the remaining ticks.  */
                    current_timer -> tx_timer_internal_remaining_ticks =  current_timer -> tx_timer_internal_re_initialize_ticks;
 800e9e8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9ea:	685a      	ldr	r2, [r3, #4]
 800e9ec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9ee:	601a      	str	r2, [r3, #0]

                    /* Determine if the timer should be reactivated.  */
                    if (current_timer -> tx_timer_internal_remaining_ticks != ((ULONG) 0))
 800e9f0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9f2:	681b      	ldr	r3, [r3, #0]
 800e9f4:	2b00      	cmp	r3, #0
 800e9f6:	d009      	beq.n	800ea0c <_tx_timer_thread_entry+0x11c>

                        /* Make the timer appear that it is still active while processing
                           the expiration routine and with interrupts enabled.  This will
                           permit proper processing of a timer deactivate from both the
                           expiration routine and an ISR.  */
                        current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
 800e9f8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800e9fa:	f107 020c 	add.w	r2, r7, #12
 800e9fe:	619a      	str	r2, [r3, #24]
                        current_timer -> tx_timer_internal_active_next =  current_timer;
 800ea00:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ea02:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800ea04:	611a      	str	r2, [r3, #16]

                        /* Setup the temporary timer list head pointer.  */
                        reactivate_timer =  current_timer;
 800ea06:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ea08:	60fb      	str	r3, [r7, #12]
 800ea0a:	e002      	b.n	800ea12 <_tx_timer_thread_entry+0x122>
                    else
                    {

                        /* Set the list pointer of this timer to NULL.  This is used to indicate
                           the timer is no longer active.  */
                        current_timer -> tx_timer_internal_list_head =  TX_NULL;
 800ea0c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ea0e:	2200      	movs	r2, #0
 800ea10:	619a      	str	r2, [r3, #24]
                    }
                }

                /* Set pointer to indicate the expired timer that is currently being processed.  */
                _tx_timer_expired_timer_ptr =  current_timer;
 800ea12:	4a2c      	ldr	r2, [pc, #176]	; (800eac4 <_tx_timer_thread_entry+0x1d4>)
 800ea14:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ea16:	6013      	str	r3, [r2, #0]
 800ea18:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800ea1a:	633b      	str	r3, [r7, #48]	; 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ea1c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ea1e:	f383 8810 	msr	PRIMASK, r3
}
 800ea22:	bf00      	nop

                /* Restore interrupts for timer expiration call.  */
                TX_RESTORE

                /* Call the timer-expiration function, if non-NULL.  */
                if (timeout_function != TX_NULL)
 800ea24:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ea26:	2b00      	cmp	r3, #0
 800ea28:	d002      	beq.n	800ea30 <_tx_timer_thread_entry+0x140>
                {

                    (timeout_function) (timeout_param);
 800ea2a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800ea2c:	6e78      	ldr	r0, [r7, #100]	; 0x64
 800ea2e:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ea30:	f3ef 8310 	mrs	r3, PRIMASK
 800ea34:	62fb      	str	r3, [r7, #44]	; 0x2c
    return(posture);
 800ea36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    int_posture = __get_interrupt_posture();
 800ea38:	62bb      	str	r3, [r7, #40]	; 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
 800ea3a:	b672      	cpsid	i
    return(int_posture);
 800ea3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
                }

                /* Lockout interrupts again.  */
                TX_DISABLE
 800ea3e:	66fb      	str	r3, [r7, #108]	; 0x6c

                /* Clear expired timer pointer.  */
                _tx_timer_expired_timer_ptr =  TX_NULL;
 800ea40:	4b20      	ldr	r3, [pc, #128]	; (800eac4 <_tx_timer_thread_entry+0x1d4>)
 800ea42:	2200      	movs	r2, #0
 800ea44:	601a      	str	r2, [r3, #0]

                /* Determine if the timer needs to be reactivated.  */
                if (reactivate_timer == current_timer)
 800ea46:	68fb      	ldr	r3, [r7, #12]
 800ea48:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800ea4a:	429a      	cmp	r2, r3
 800ea4c:	d151      	bne.n	800eaf2 <_tx_timer_thread_entry+0x202>
#endif

#ifdef TX_REACTIVATE_INLINE

                    /* Calculate the amount of time remaining for the timer.  */
                    if (current_timer -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
 800ea4e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ea50:	681b      	ldr	r3, [r3, #0]
 800ea52:	2b20      	cmp	r3, #32
 800ea54:	d902      	bls.n	800ea5c <_tx_timer_thread_entry+0x16c>
                    {

                        /* Set expiration time to the maximum number of entries.  */
                        expiration_time =  TX_TIMER_ENTRIES - ((UINT) 1);
 800ea56:	231f      	movs	r3, #31
 800ea58:	65fb      	str	r3, [r7, #92]	; 0x5c
 800ea5a:	e003      	b.n	800ea64 <_tx_timer_thread_entry+0x174>
                    {

                        /* Timer value fits in the timer entries.  */

                        /* Set the expiration time.  */
                        expiration_time =  ((UINT) current_timer -> tx_timer_internal_remaining_ticks) - ((UINT) 1);
 800ea5c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ea5e:	681b      	ldr	r3, [r3, #0]
 800ea60:	3b01      	subs	r3, #1
 800ea62:	65fb      	str	r3, [r7, #92]	; 0x5c

                    /* At this point, we are ready to put the timer back on one of
                       the timer lists.  */

                    /* Calculate the proper place for the timer.  */
                    timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
 800ea64:	4b13      	ldr	r3, [pc, #76]	; (800eab4 <_tx_timer_thread_entry+0x1c4>)
 800ea66:	681a      	ldr	r2, [r3, #0]
 800ea68:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800ea6a:	009b      	lsls	r3, r3, #2
 800ea6c:	4413      	add	r3, r2
 800ea6e:	663b      	str	r3, [r7, #96]	; 0x60
                    if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
 800ea70:	4b11      	ldr	r3, [pc, #68]	; (800eab8 <_tx_timer_thread_entry+0x1c8>)
 800ea72:	681b      	ldr	r3, [r3, #0]
 800ea74:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800ea76:	429a      	cmp	r2, r3
 800ea78:	d30b      	bcc.n	800ea92 <_tx_timer_thread_entry+0x1a2>
                    {

                        /* Wrap from the beginning of the list.  */
                        delta =  TX_TIMER_POINTER_DIF(timer_list, _tx_timer_list_end);
 800ea7a:	4b0f      	ldr	r3, [pc, #60]	; (800eab8 <_tx_timer_thread_entry+0x1c8>)
 800ea7c:	681b      	ldr	r3, [r3, #0]
 800ea7e:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800ea80:	1ad3      	subs	r3, r2, r3
 800ea82:	109b      	asrs	r3, r3, #2
 800ea84:	64bb      	str	r3, [r7, #72]	; 0x48
                        timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
 800ea86:	4b0d      	ldr	r3, [pc, #52]	; (800eabc <_tx_timer_thread_entry+0x1cc>)
 800ea88:	681a      	ldr	r2, [r3, #0]
 800ea8a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ea8c:	009b      	lsls	r3, r3, #2
 800ea8e:	4413      	add	r3, r2
 800ea90:	663b      	str	r3, [r7, #96]	; 0x60
                    }

                    /* Now put the timer on this list.  */
                    if ((*timer_list) == TX_NULL)
 800ea92:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800ea94:	681b      	ldr	r3, [r3, #0]
 800ea96:	2b00      	cmp	r3, #0
 800ea98:	d116      	bne.n	800eac8 <_tx_timer_thread_entry+0x1d8>
                    {

                        /* This list is NULL, just put the new timer on it.  */

                        /* Setup the links in this timer.  */
                        current_timer -> tx_timer_internal_active_next =      current_timer;
 800ea9a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800ea9c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800ea9e:	611a      	str	r2, [r3, #16]
                        current_timer -> tx_timer_internal_active_previous =  current_timer;
 800eaa0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800eaa2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800eaa4:	615a      	str	r2, [r3, #20]

                        /* Setup the list head pointer.  */
                        *timer_list =  current_timer;
 800eaa6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800eaa8:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800eaaa:	601a      	str	r2, [r3, #0]
 800eaac:	e01e      	b.n	800eaec <_tx_timer_thread_entry+0x1fc>
 800eaae:	bf00      	nop
 800eab0:	4154494d 	.word	0x4154494d
 800eab4:	20006e38 	.word	0x20006e38
 800eab8:	20006e34 	.word	0x20006e34
 800eabc:	20006e30 	.word	0x20006e30
 800eac0:	20006e3c 	.word	0x20006e3c
 800eac4:	20006e48 	.word	0x20006e48
                    }
                    else
                    {

                        /* This list is not NULL, add current timer to the end. */
                        next_timer =                                          *timer_list;
 800eac8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 800eaca:	681b      	ldr	r3, [r3, #0]
 800eacc:	653b      	str	r3, [r7, #80]	; 0x50
                        previous_timer =                                      next_timer -> tx_timer_internal_active_previous;
 800eace:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ead0:	695b      	ldr	r3, [r3, #20]
 800ead2:	64fb      	str	r3, [r7, #76]	; 0x4c
                        previous_timer -> tx_timer_internal_active_next =     current_timer;
 800ead4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ead6:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800ead8:	611a      	str	r2, [r3, #16]
                        next_timer -> tx_timer_internal_active_previous =     current_timer;
 800eada:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800eadc:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800eade:	615a      	str	r2, [r3, #20]
                        current_timer -> tx_timer_internal_active_next =      next_timer;
 800eae0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800eae2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800eae4:	611a      	str	r2, [r3, #16]
                        current_timer -> tx_timer_internal_active_previous =  previous_timer;
 800eae6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800eae8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800eaea:	615a      	str	r2, [r3, #20]
                    }

                    /* Setup list head pointer.  */
                    current_timer -> tx_timer_internal_list_head =  timer_list;
 800eaec:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800eaee:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800eaf0:	619a      	str	r2, [r3, #24]
 800eaf2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800eaf4:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800eaf6:	69fb      	ldr	r3, [r7, #28]
 800eaf8:	f383 8810 	msr	PRIMASK, r3
}
 800eafc:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800eafe:	f3ef 8310 	mrs	r3, PRIMASK
 800eb02:	627b      	str	r3, [r7, #36]	; 0x24
    return(posture);
 800eb04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    int_posture = __get_interrupt_posture();
 800eb06:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
 800eb08:	b672      	cpsid	i
    return(int_posture);
 800eb0a:	6a3b      	ldr	r3, [r7, #32]

                /* Restore interrupts.  */
                TX_RESTORE

                /* Lockout interrupts again.  */
                TX_DISABLE
 800eb0c:	66fb      	str	r3, [r7, #108]	; 0x6c
            while (expired_timers != TX_NULL)
 800eb0e:	693b      	ldr	r3, [r7, #16]
 800eb10:	2b00      	cmp	r3, #0
 800eb12:	f47f af30 	bne.w	800e976 <_tx_timer_thread_entry+0x86>

            /* Finally, suspend this thread and wait for the next expiration.  */

            /* Determine if another expiration took place while we were in this
               thread.  If so, process another expiration.  */
            if (_tx_timer_expired == TX_FALSE)
 800eb16:	4b13      	ldr	r3, [pc, #76]	; (800eb64 <_tx_timer_thread_entry+0x274>)
 800eb18:	681b      	ldr	r3, [r3, #0]
 800eb1a:	2b00      	cmp	r3, #0
 800eb1c:	d116      	bne.n	800eb4c <_tx_timer_thread_entry+0x25c>
            {

                /* Otherwise, no timer expiration, so suspend the thread.  */

                /* Build pointer to the timer thread.  */
                thread_ptr =  &_tx_timer_thread;
 800eb1e:	4b12      	ldr	r3, [pc, #72]	; (800eb68 <_tx_timer_thread_entry+0x278>)
 800eb20:	65bb      	str	r3, [r7, #88]	; 0x58

                /* Set the status to suspending, in order to indicate the
                   suspension is in progress.  */
                thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 800eb22:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800eb24:	2203      	movs	r2, #3
 800eb26:	631a      	str	r2, [r3, #48]	; 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag. */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800eb28:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800eb2a:	2201      	movs	r2, #1
 800eb2c:	639a      	str	r2, [r3, #56]	; 0x38

                /* Increment the preempt disable count prior to suspending.  */
                _tx_thread_preempt_disable++;
 800eb2e:	4b0f      	ldr	r3, [pc, #60]	; (800eb6c <_tx_timer_thread_entry+0x27c>)
 800eb30:	681b      	ldr	r3, [r3, #0]
 800eb32:	3301      	adds	r3, #1
 800eb34:	4a0d      	ldr	r2, [pc, #52]	; (800eb6c <_tx_timer_thread_entry+0x27c>)
 800eb36:	6013      	str	r3, [r2, #0]
 800eb38:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800eb3a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800eb3c:	69bb      	ldr	r3, [r7, #24]
 800eb3e:	f383 8810 	msr	PRIMASK, r3
}
 800eb42:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 800eb44:	6db8      	ldr	r0, [r7, #88]	; 0x58
 800eb46:	f7ff fa39 	bl	800dfbc <_tx_thread_system_suspend>
 800eb4a:	e6dc      	b.n	800e906 <_tx_timer_thread_entry+0x16>
 800eb4c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800eb4e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800eb50:	697b      	ldr	r3, [r7, #20]
 800eb52:	f383 8810 	msr	PRIMASK, r3
}
 800eb56:	bf00      	nop
            TX_DISABLE
 800eb58:	e6d5      	b.n	800e906 <_tx_timer_thread_entry+0x16>

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif

}
 800eb5a:	bf00      	nop
 800eb5c:	3770      	adds	r7, #112	; 0x70
 800eb5e:	46bd      	mov	sp, r7
 800eb60:	bd80      	pop	{r7, pc}
 800eb62:	bf00      	nop
 800eb64:	20006e3c 	.word	0x20006e3c
 800eb68:	20006e4c 	.word	0x20006e4c
 800eb6c:	20006d9c 	.word	0x20006d9c

0800eb70 <_ux_device_stack_class_register>:
UINT  _ux_device_stack_class_register(UCHAR *class_name,
                        UINT (*class_entry_function)(struct UX_SLAVE_CLASS_COMMAND_STRUCT *),
                        ULONG configuration_number,
                        ULONG interface_number,
                        VOID *parameter)
{
 800eb70:	b580      	push	{r7, lr}
 800eb72:	b092      	sub	sp, #72	; 0x48
 800eb74:	af00      	add	r7, sp, #0
 800eb76:	60f8      	str	r0, [r7, #12]
 800eb78:	60b9      	str	r1, [r7, #8]
 800eb7a:	607a      	str	r2, [r7, #4]
 800eb7c:	603b      	str	r3, [r7, #0]

UX_SLAVE_CLASS              *class_inst;
UINT                        status;
UX_SLAVE_CLASS_COMMAND      command;
UINT                        class_name_length =  0;
 800eb7e:	2300      	movs	r3, #0
 800eb80:	613b      	str	r3, [r7, #16]
ULONG                       class_index;
#endif


    /* Get the length of the class name (exclude null-terminator).  */
    status =  _ux_utility_string_length_check(class_name, &class_name_length, UX_MAX_CLASS_NAME_LENGTH);
 800eb82:	f107 0310 	add.w	r3, r7, #16
 800eb86:	223f      	movs	r2, #63	; 0x3f
 800eb88:	4619      	mov	r1, r3
 800eb8a:	68f8      	ldr	r0, [r7, #12]
 800eb8c:	f000 ffe8 	bl	800fb60 <_ux_utility_string_length_check>
 800eb90:	6478      	str	r0, [r7, #68]	; 0x44
    if (status)
 800eb92:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800eb94:	2b00      	cmp	r3, #0
 800eb96:	d001      	beq.n	800eb9c <_ux_device_stack_class_register+0x2c>
        return(status);
 800eb98:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800eb9a:	e035      	b.n	800ec08 <_ux_device_stack_class_register+0x98>

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_CLASS_REGISTER, class_name, interface_number, parameter, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get first class.  */
    class_inst =  _ux_system_slave -> ux_system_slave_class_array;
 800eb9c:	4b1c      	ldr	r3, [pc, #112]	; (800ec10 <_ux_device_stack_class_register+0xa0>)
 800eb9e:	681b      	ldr	r3, [r3, #0]
 800eba0:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 800eba4:	643b      	str	r3, [r7, #64]	; 0x40
    for (class_index = 0; class_index < _ux_system_slave -> ux_system_slave_max_class; class_index++)
    {
#endif

        /* Check if this class is already used.  */
        if (class_inst -> ux_slave_class_status == UX_UNUSED)
 800eba6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800eba8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ebaa:	2b00      	cmp	r3, #0
 800ebac:	d12b      	bne.n	800ec06 <_ux_device_stack_class_register+0x96>

#if defined(UX_NAME_REFERENCED_BY_POINTER)
            class_inst -> ux_slave_class_name = (const UCHAR *)class_name;
#else
            /* We have found a free container for the class. Copy the name (with null-terminator).  */
            _ux_utility_memory_copy(class_inst -> ux_slave_class_name, class_name, class_name_length + 1); /* Use case of memcpy is verified. */
 800ebae:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800ebb0:	693b      	ldr	r3, [r7, #16]
 800ebb2:	3301      	adds	r3, #1
 800ebb4:	461a      	mov	r2, r3
 800ebb6:	68f9      	ldr	r1, [r7, #12]
 800ebb8:	f000 fdef 	bl	800f79a <_ux_utility_memory_copy>
#endif
            
            /* Memorize the entry function of this class.  */
            class_inst -> ux_slave_class_entry_function =  class_entry_function;
 800ebbc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ebbe:	68ba      	ldr	r2, [r7, #8]
 800ebc0:	645a      	str	r2, [r3, #68]	; 0x44

            /* Memorize the pointer to the application parameter.  */
            class_inst -> ux_slave_class_interface_parameter =  parameter;
 800ebc2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ebc4:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 800ebc6:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
            
            /* Memorize the configuration number on which this instance will be called.  */
            class_inst -> ux_slave_class_configuration_number =  configuration_number;
 800ebca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ebcc:	687a      	ldr	r2, [r7, #4]
 800ebce:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
            
            /* Memorize the interface number on which this instance will be called.  */
            class_inst -> ux_slave_class_interface_number =  interface_number;
 800ebd2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ebd4:	683a      	ldr	r2, [r7, #0]
 800ebd6:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
            
            /* Build all the fields of the Class Command to initialize the class.  */
            command.ux_slave_class_command_request    =  UX_SLAVE_CLASS_COMMAND_INITIALIZE;
 800ebda:	2305      	movs	r3, #5
 800ebdc:	617b      	str	r3, [r7, #20]
            command.ux_slave_class_command_parameter  =  parameter;
 800ebde:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800ebe0:	63bb      	str	r3, [r7, #56]	; 0x38
            command.ux_slave_class_command_class_ptr  =  class_inst;
 800ebe2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ebe4:	637b      	str	r3, [r7, #52]	; 0x34

            /* Call the class initialization routine.  */
            status = class_entry_function(&command);
 800ebe6:	f107 0214 	add.w	r2, r7, #20
 800ebea:	68bb      	ldr	r3, [r7, #8]
 800ebec:	4610      	mov	r0, r2
 800ebee:	4798      	blx	r3
 800ebf0:	6478      	str	r0, [r7, #68]	; 0x44
            
            /* Check the status.  */
            if (status != UX_SUCCESS)
 800ebf2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ebf4:	2b00      	cmp	r3, #0
 800ebf6:	d001      	beq.n	800ebfc <_ux_device_stack_class_register+0x8c>
                return(status);
 800ebf8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ebfa:	e005      	b.n	800ec08 <_ux_device_stack_class_register+0x98>
            
            /* Make this class used now.  */
            class_inst -> ux_slave_class_status = UX_USED;
 800ebfc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ebfe:	2201      	movs	r2, #1
 800ec00:	641a      	str	r2, [r3, #64]	; 0x40

            /* Return successful completion.  */
            return(UX_SUCCESS);
 800ec02:	2300      	movs	r3, #0
 800ec04:	e000      	b.n	800ec08 <_ux_device_stack_class_register+0x98>
        class_inst ++;
    }    
#endif

    /* No more entries in the class table.  */
    return(UX_MEMORY_INSUFFICIENT);
 800ec06:	2312      	movs	r3, #18
}
 800ec08:	4618      	mov	r0, r3
 800ec0a:	3748      	adds	r7, #72	; 0x48
 800ec0c:	46bd      	mov	sp, r7
 800ec0e:	bd80      	pop	{r7, pc}
 800ec10:	2000730c 	.word	0x2000730c

0800ec14 <_ux_device_stack_endpoint_stall>:
/*                                            added standalone support,   */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_endpoint_stall(UX_SLAVE_ENDPOINT *endpoint)
{
 800ec14:	b580      	push	{r7, lr}
 800ec16:	b088      	sub	sp, #32
 800ec18:	af00      	add	r7, sp, #0
 800ec1a:	6078      	str	r0, [r7, #4]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_ENDPOINT_STALL, endpoint, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
 800ec1c:	4b18      	ldr	r3, [pc, #96]	; (800ec80 <_ux_device_stack_endpoint_stall+0x6c>)
 800ec1e:	681b      	ldr	r3, [r3, #0]
 800ec20:	61bb      	str	r3, [r7, #24]

    /* Assume device is in an invalid state here in order to reduce code in following 
       section where interrupts are disabled.  */
    status =  UX_ERROR;
 800ec22:	23ff      	movs	r3, #255	; 0xff
 800ec24:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800ec26:	f3ef 8310 	mrs	r3, PRIMASK
 800ec2a:	613b      	str	r3, [r7, #16]
    return(posture);
 800ec2c:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
 800ec2e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
 800ec30:	b672      	cpsid	i
    return(int_posture);
 800ec32:	68fb      	ldr	r3, [r7, #12]

    /* Ensure we don't change the endpoint's state after disconnection routine
       resets it.  */
    UX_DISABLE
 800ec34:	617b      	str	r3, [r7, #20]

    /* Check if the device is in a valid state; as soon as the device is out 
       of the RESET state, transfers occur and thus endpoints may be stalled. */
    if (_ux_system_slave -> ux_system_slave_device.ux_slave_device_state != UX_DEVICE_RESET &&
 800ec36:	4b12      	ldr	r3, [pc, #72]	; (800ec80 <_ux_device_stack_endpoint_stall+0x6c>)
 800ec38:	681b      	ldr	r3, [r3, #0]
 800ec3a:	6a1b      	ldr	r3, [r3, #32]
 800ec3c:	2b00      	cmp	r3, #0
 800ec3e:	d013      	beq.n	800ec68 <_ux_device_stack_endpoint_stall+0x54>
        endpoint -> ux_slave_endpoint_state != UX_ENDPOINT_HALTED)
 800ec40:	687b      	ldr	r3, [r7, #4]
 800ec42:	685b      	ldr	r3, [r3, #4]
    if (_ux_system_slave -> ux_system_slave_device.ux_slave_device_state != UX_DEVICE_RESET &&
 800ec44:	2b02      	cmp	r3, #2
 800ec46:	d00f      	beq.n	800ec68 <_ux_device_stack_endpoint_stall+0x54>
    {

        /* Stall the endpoint.  */
        status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
 800ec48:	69bb      	ldr	r3, [r7, #24]
 800ec4a:	699b      	ldr	r3, [r3, #24]
 800ec4c:	687a      	ldr	r2, [r7, #4]
 800ec4e:	2114      	movs	r1, #20
 800ec50:	69b8      	ldr	r0, [r7, #24]
 800ec52:	4798      	blx	r3
 800ec54:	61f8      	str	r0, [r7, #28]

        /* Mark the endpoint state.  */
        if ((endpoint -> ux_slave_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) !=
 800ec56:	687b      	ldr	r3, [r7, #4]
 800ec58:	699b      	ldr	r3, [r3, #24]
 800ec5a:	f003 0303 	and.w	r3, r3, #3
 800ec5e:	2b00      	cmp	r3, #0
 800ec60:	d002      	beq.n	800ec68 <_ux_device_stack_endpoint_stall+0x54>
            UX_CONTROL_ENDPOINT)
            endpoint -> ux_slave_endpoint_state =  UX_ENDPOINT_HALTED;
 800ec62:	687b      	ldr	r3, [r7, #4]
 800ec64:	2202      	movs	r2, #2
 800ec66:	605a      	str	r2, [r3, #4]
 800ec68:	697b      	ldr	r3, [r7, #20]
 800ec6a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800ec6c:	68bb      	ldr	r3, [r7, #8]
 800ec6e:	f383 8810 	msr	PRIMASK, r3
}
 800ec72:	bf00      	nop

    /* Restore interrupts.  */
    UX_RESTORE

    /* Return completion status.  */
    return(status);       
 800ec74:	69fb      	ldr	r3, [r7, #28]
}
 800ec76:	4618      	mov	r0, r3
 800ec78:	3720      	adds	r7, #32
 800ec7a:	46bd      	mov	sp, r7
 800ec7c:	bd80      	pop	{r7, pc}
 800ec7e:	bf00      	nop
 800ec80:	2000730c 	.word	0x2000730c

0800ec84 <_ux_device_stack_initialize>:
UINT  _ux_device_stack_initialize(UCHAR * device_framework_high_speed, ULONG device_framework_length_high_speed,
                                  UCHAR * device_framework_full_speed, ULONG device_framework_length_full_speed,
                                  UCHAR * string_framework, ULONG string_framework_length,
                                  UCHAR * language_id_framework, ULONG language_id_framework_length,
                                  UINT (*ux_system_slave_change_function)(ULONG))
{
 800ec84:	b580      	push	{r7, lr}
 800ec86:	b094      	sub	sp, #80	; 0x50
 800ec88:	af00      	add	r7, sp, #0
 800ec8a:	60f8      	str	r0, [r7, #12]
 800ec8c:	60b9      	str	r1, [r7, #8]
 800ec8e:	607a      	str	r2, [r7, #4]
 800ec90:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_INITIALIZE, 0, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the device. */
    device =  &_ux_system_slave -> ux_system_slave_device;
 800ec92:	4b9a      	ldr	r3, [pc, #616]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ec94:	681b      	ldr	r3, [r3, #0]
 800ec96:	3320      	adds	r3, #32
 800ec98:	627b      	str	r3, [r7, #36]	; 0x24

    /* Store the high speed device framework address and length in the project structure.  */
    _ux_system_slave -> ux_system_slave_device_framework_high_speed =             device_framework_high_speed;
 800ec9a:	4b98      	ldr	r3, [pc, #608]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ec9c:	681b      	ldr	r3, [r3, #0]
 800ec9e:	68fa      	ldr	r2, [r7, #12]
 800eca0:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
    _ux_system_slave -> ux_system_slave_device_framework_length_high_speed =      device_framework_length_high_speed;
 800eca4:	4b95      	ldr	r3, [pc, #596]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800eca6:	681b      	ldr	r3, [r3, #0]
 800eca8:	68ba      	ldr	r2, [r7, #8]
 800ecaa:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c

    /* Store the string framework address and length in the project structure.  */
    _ux_system_slave -> ux_system_slave_device_framework_full_speed =             device_framework_full_speed;
 800ecae:	4b93      	ldr	r3, [pc, #588]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ecb0:	681b      	ldr	r3, [r3, #0]
 800ecb2:	687a      	ldr	r2, [r7, #4]
 800ecb4:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
    _ux_system_slave -> ux_system_slave_device_framework_length_full_speed =      device_framework_length_full_speed;
 800ecb8:	4b90      	ldr	r3, [pc, #576]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ecba:	681b      	ldr	r3, [r3, #0]
 800ecbc:	683a      	ldr	r2, [r7, #0]
 800ecbe:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134

    /* Store the string framework address and length in the project structure.  */
    _ux_system_slave -> ux_system_slave_string_framework =                         string_framework;
 800ecc2:	4b8e      	ldr	r3, [pc, #568]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ecc4:	681b      	ldr	r3, [r3, #0]
 800ecc6:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800ecc8:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    _ux_system_slave -> ux_system_slave_string_framework_length =                  string_framework_length;
 800eccc:	4b8b      	ldr	r3, [pc, #556]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ecce:	681b      	ldr	r3, [r3, #0]
 800ecd0:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 800ecd2:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144

    /* Store the language ID list in the project structure.  */
    _ux_system_slave -> ux_system_slave_language_id_framework =                 language_id_framework;
 800ecd6:	4b89      	ldr	r3, [pc, #548]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ecd8:	681b      	ldr	r3, [r3, #0]
 800ecda:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800ecdc:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    _ux_system_slave -> ux_system_slave_language_id_framework_length =          language_id_framework_length;
 800ece0:	4b86      	ldr	r3, [pc, #536]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ece2:	681b      	ldr	r3, [r3, #0]
 800ece4:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800ece6:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c

    /* Store the max number of slave class drivers in the project structure.  */
    UX_SYSTEM_DEVICE_MAX_CLASS_SET(UX_MAX_SLAVE_CLASS_DRIVER);
    
    /* Store the device state change function callback.  */
    _ux_system_slave -> ux_system_slave_change_function =  ux_system_slave_change_function;
 800ecea:	4b84      	ldr	r3, [pc, #528]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ecec:	681b      	ldr	r3, [r3, #0]
 800ecee:	6eba      	ldr	r2, [r7, #104]	; 0x68
 800ecf0:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0

    /* Allocate memory for the classes.
     * sizeof(UX_SLAVE_CLASS) * UX_MAX_SLAVE_CLASS_DRIVER) overflow is checked
     * outside of the function.
     */
    memory =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS) * UX_MAX_SLAVE_CLASS_DRIVER);
 800ecf4:	f44f 728a 	mov.w	r2, #276	; 0x114
 800ecf8:	2100      	movs	r1, #0
 800ecfa:	2000      	movs	r0, #0
 800ecfc:	f000 fc24 	bl	800f548 <_ux_utility_memory_allocate>
 800ed00:	6238      	str	r0, [r7, #32]
    if (memory == UX_NULL)
 800ed02:	6a3b      	ldr	r3, [r7, #32]
 800ed04:	2b00      	cmp	r3, #0
 800ed06:	d101      	bne.n	800ed0c <_ux_device_stack_initialize+0x88>
        return(UX_MEMORY_INSUFFICIENT);
 800ed08:	2312      	movs	r3, #18
 800ed0a:	e160      	b.n	800efce <_ux_device_stack_initialize+0x34a>
    
    /* Save this memory allocation in the USBX project.  */
    _ux_system_slave -> ux_system_slave_class_array =  (UX_SLAVE_CLASS *) ((void *) memory);
 800ed0c:	4b7b      	ldr	r3, [pc, #492]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ed0e:	681b      	ldr	r3, [r3, #0]
 800ed10:	6a3a      	ldr	r2, [r7, #32]
 800ed12:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158

    /* Allocate some memory for the Control Endpoint.  First get the address of the transfer request for the 
       control endpoint. */
    transfer_request =  &device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request;
 800ed16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ed18:	336c      	adds	r3, #108	; 0x6c
 800ed1a:	61fb      	str	r3, [r7, #28]

    /* Acquire a buffer for the size of the endpoint.  */
    transfer_request -> ux_slave_transfer_request_data_pointer =
          _ux_utility_memory_allocate(UX_NO_ALIGN, UX_CACHE_SAFE_MEMORY, UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH);
 800ed1c:	f44f 7280 	mov.w	r2, #256	; 0x100
 800ed20:	2101      	movs	r1, #1
 800ed22:	2000      	movs	r0, #0
 800ed24:	f000 fc10 	bl	800f548 <_ux_utility_memory_allocate>
 800ed28:	4602      	mov	r2, r0
    transfer_request -> ux_slave_transfer_request_data_pointer =
 800ed2a:	69fb      	ldr	r3, [r7, #28]
 800ed2c:	60da      	str	r2, [r3, #12]

    /* Ensure we have enough memory.  */
    if (transfer_request -> ux_slave_transfer_request_data_pointer == UX_NULL)
 800ed2e:	69fb      	ldr	r3, [r7, #28]
 800ed30:	68db      	ldr	r3, [r3, #12]
 800ed32:	2b00      	cmp	r3, #0
 800ed34:	d102      	bne.n	800ed3c <_ux_device_stack_initialize+0xb8>
        status = UX_MEMORY_INSUFFICIENT;
 800ed36:	2312      	movs	r3, #18
 800ed38:	64bb      	str	r3, [r7, #72]	; 0x48
 800ed3a:	e001      	b.n	800ed40 <_ux_device_stack_initialize+0xbc>
    else
        status = UX_SUCCESS;
 800ed3c:	2300      	movs	r3, #0
 800ed3e:	64bb      	str	r3, [r7, #72]	; 0x48
    interfaces_found = UX_MAX_SLAVE_INTERFACES;
    endpoints_found = UX_MAX_DEVICE_ENDPOINTS;
#else

    /* Reset all values we are using during the scanning of the framework.  */
    interfaces_found                   =  0;
 800ed40:	2300      	movs	r3, #0
 800ed42:	647b      	str	r3, [r7, #68]	; 0x44
    endpoints_found                    =  0;
 800ed44:	2300      	movs	r3, #0
 800ed46:	643b      	str	r3, [r7, #64]	; 0x40
    max_interface_number               =  0;
 800ed48:	2300      	movs	r3, #0
 800ed4a:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Go on to scan interfaces if no error.  */
    if (status == UX_SUCCESS)
 800ed4c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ed4e:	2b00      	cmp	r3, #0
 800ed50:	f040 8090 	bne.w	800ee74 <_ux_device_stack_initialize+0x1f0>
    {

        /* We need to determine the maximum number of interfaces and endpoints declared in the device framework.  
        This mechanism requires that both framework behave the same way regarding the number of interfaces
        and endpoints.  */
        device_framework        =  _ux_system_slave -> ux_system_slave_device_framework_full_speed;
 800ed54:	4b69      	ldr	r3, [pc, #420]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ed56:	681b      	ldr	r3, [r3, #0]
 800ed58:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
 800ed5c:	62fb      	str	r3, [r7, #44]	; 0x2c
        device_framework_length =  _ux_system_slave -> ux_system_slave_device_framework_length_full_speed;
 800ed5e:	4b67      	ldr	r3, [pc, #412]	; (800eefc <_ux_device_stack_initialize+0x278>)
 800ed60:	681b      	ldr	r3, [r3, #0]
 800ed62:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
 800ed66:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Reset all values we are using during the scanning of the framework.  */
        local_interfaces_found             =  0;
 800ed68:	2300      	movs	r3, #0
 800ed6a:	63bb      	str	r3, [r7, #56]	; 0x38
        local_endpoints_found              =  0;
 800ed6c:	2300      	movs	r3, #0
 800ed6e:	637b      	str	r3, [r7, #52]	; 0x34
        endpoints_in_interface_found       =  0;
 800ed70:	2300      	movs	r3, #0
 800ed72:	633b      	str	r3, [r7, #48]	; 0x30

        /* Parse the device framework and locate interfaces and endpoint descriptor(s).  */
        while (device_framework_length != 0)
 800ed74:	e054      	b.n	800ee20 <_ux_device_stack_initialize+0x19c>
        {

            /* Get the length of this descriptor.  */
            descriptor_length =  (ULONG) *device_framework;
 800ed76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ed78:	781b      	ldrb	r3, [r3, #0]
 800ed7a:	61bb      	str	r3, [r7, #24]
        
            /* And its type.  */
            descriptor_type =  *(device_framework + 1);
 800ed7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ed7e:	785b      	ldrb	r3, [r3, #1]
 800ed80:	75fb      	strb	r3, [r7, #23]
                    
            /* Check if this is an endpoint descriptor.  */
            switch(descriptor_type)
 800ed82:	7dfb      	ldrb	r3, [r7, #23]
 800ed84:	2b02      	cmp	r3, #2
 800ed86:	d029      	beq.n	800eddc <_ux_device_stack_initialize+0x158>
 800ed88:	2b04      	cmp	r3, #4
 800ed8a:	d13e      	bne.n	800ee0a <_ux_device_stack_initialize+0x186>

            case UX_INTERFACE_DESCRIPTOR_ITEM:

                /* Check if this is alternate setting 0. If not, do not add another interface found.  
                If this is alternate setting 0, reset the endpoints count for this interface.  */
                if (*(device_framework + 3) == 0)
 800ed8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ed8e:	3303      	adds	r3, #3
 800ed90:	781b      	ldrb	r3, [r3, #0]
 800ed92:	2b00      	cmp	r3, #0
 800ed94:	d10b      	bne.n	800edae <_ux_device_stack_initialize+0x12a>
                {

                    /* Add the cumulated number of endpoints in the previous interface.  */
                    local_endpoints_found += endpoints_in_interface_found;
 800ed96:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ed98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ed9a:	4413      	add	r3, r2
 800ed9c:	637b      	str	r3, [r7, #52]	; 0x34

                    /* Read the number of endpoints for this alternate setting.  */
                    endpoints_in_interface_found = (ULONG) *(device_framework + 4);
 800ed9e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800eda0:	3304      	adds	r3, #4
 800eda2:	781b      	ldrb	r3, [r3, #0]
 800eda4:	633b      	str	r3, [r7, #48]	; 0x30
                    
                    /* Increment the number of interfaces found in the current configuration.  */
                    local_interfaces_found++;
 800eda6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800eda8:	3301      	adds	r3, #1
 800edaa:	63bb      	str	r3, [r7, #56]	; 0x38
 800edac:	e00a      	b.n	800edc4 <_ux_device_stack_initialize+0x140>
                }                
                else
                {

                    /* Compare the number of endpoints found in this non 0 alternate setting.  */
                    if (endpoints_in_interface_found < (ULONG) *(device_framework + 4))
 800edae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800edb0:	3304      	adds	r3, #4
 800edb2:	781b      	ldrb	r3, [r3, #0]
 800edb4:	461a      	mov	r2, r3
 800edb6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800edb8:	4293      	cmp	r3, r2
 800edba:	d203      	bcs.n	800edc4 <_ux_device_stack_initialize+0x140>
                    
                        /* Adjust the number of maximum endpoints in this interface.  */
                        endpoints_in_interface_found = (ULONG) *(device_framework + 4);
 800edbc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800edbe:	3304      	adds	r3, #4
 800edc0:	781b      	ldrb	r3, [r3, #0]
 800edc2:	633b      	str	r3, [r7, #48]	; 0x30
                }

                /* Check and update max interface number.  */
                if (*(device_framework + 2) > max_interface_number)
 800edc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800edc6:	3302      	adds	r3, #2
 800edc8:	781b      	ldrb	r3, [r3, #0]
 800edca:	461a      	mov	r2, r3
 800edcc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800edce:	4293      	cmp	r3, r2
 800edd0:	d21d      	bcs.n	800ee0e <_ux_device_stack_initialize+0x18a>
                    max_interface_number = *(device_framework + 2);
 800edd2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800edd4:	3302      	adds	r3, #2
 800edd6:	781b      	ldrb	r3, [r3, #0]
 800edd8:	63fb      	str	r3, [r7, #60]	; 0x3c

                break;
 800edda:	e018      	b.n	800ee0e <_ux_device_stack_initialize+0x18a>

            case UX_CONFIGURATION_DESCRIPTOR_ITEM:

                /* Check if the number of interfaces found in this configuration is the maximum so far. */
                if (local_interfaces_found > interfaces_found)
 800eddc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800edde:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ede0:	429a      	cmp	r2, r3
 800ede2:	d901      	bls.n	800ede8 <_ux_device_stack_initialize+0x164>
                    
                    /* We need to adjust the number of maximum interfaces.  */
                    interfaces_found =  local_interfaces_found;
 800ede4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ede6:	647b      	str	r3, [r7, #68]	; 0x44

                /* We have a new configuration. We need to reset the number of local interfaces. */
                local_interfaces_found =  0;
 800ede8:	2300      	movs	r3, #0
 800edea:	63bb      	str	r3, [r7, #56]	; 0x38

                /* Add the cumulated number of endpoints in the previous interface.  */
                local_endpoints_found += endpoints_in_interface_found;
 800edec:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800edee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800edf0:	4413      	add	r3, r2
 800edf2:	637b      	str	r3, [r7, #52]	; 0x34

                /* Check if the number of endpoints found in the previous configuration is the maximum so far. */
                if (local_endpoints_found > endpoints_found)
 800edf4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800edf6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800edf8:	429a      	cmp	r2, r3
 800edfa:	d901      	bls.n	800ee00 <_ux_device_stack_initialize+0x17c>
                    
                    /* We need to adjust the number of maximum endpoints.  */
                    endpoints_found =  local_endpoints_found;
 800edfc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800edfe:	643b      	str	r3, [r7, #64]	; 0x40

                /* We have a new configuration. We need to reset the number of local endpoints. */
                local_endpoints_found         =  0;
 800ee00:	2300      	movs	r3, #0
 800ee02:	637b      	str	r3, [r7, #52]	; 0x34
                endpoints_in_interface_found  =  0;
 800ee04:	2300      	movs	r3, #0
 800ee06:	633b      	str	r3, [r7, #48]	; 0x30

                break;
 800ee08:	e002      	b.n	800ee10 <_ux_device_stack_initialize+0x18c>

            default:
                break;
 800ee0a:	bf00      	nop
 800ee0c:	e000      	b.n	800ee10 <_ux_device_stack_initialize+0x18c>
                break;
 800ee0e:	bf00      	nop
            }

            /* Adjust what is left of the device framework.  */
            device_framework_length -=  descriptor_length;
 800ee10:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800ee12:	69bb      	ldr	r3, [r7, #24]
 800ee14:	1ad3      	subs	r3, r2, r3
 800ee16:	62bb      	str	r3, [r7, #40]	; 0x28

            /* Point to the next descriptor.  */
            device_framework +=  descriptor_length;
 800ee18:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800ee1a:	69bb      	ldr	r3, [r7, #24]
 800ee1c:	4413      	add	r3, r2
 800ee1e:	62fb      	str	r3, [r7, #44]	; 0x2c
        while (device_framework_length != 0)
 800ee20:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ee22:	2b00      	cmp	r3, #0
 800ee24:	d1a7      	bne.n	800ed76 <_ux_device_stack_initialize+0xf2>
        }
        
        /* Add the cumulated number of endpoints in the previous interface.  */
        local_endpoints_found += endpoints_in_interface_found;
 800ee26:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ee28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ee2a:	4413      	add	r3, r2
 800ee2c:	637b      	str	r3, [r7, #52]	; 0x34

        /* Check if the number of endpoints found in the previous interface is the maximum so far. */
        if (local_endpoints_found > endpoints_found)
 800ee2e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ee30:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800ee32:	429a      	cmp	r2, r3
 800ee34:	d901      	bls.n	800ee3a <_ux_device_stack_initialize+0x1b6>
                    
            /* We need to adjust the number of maximum endpoints.  */
            endpoints_found =  local_endpoints_found;
 800ee36:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ee38:	643b      	str	r3, [r7, #64]	; 0x40


        /* Check if the number of interfaces found in this configuration is the maximum so far. */
        if (local_interfaces_found > interfaces_found)
 800ee3a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800ee3c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ee3e:	429a      	cmp	r2, r3
 800ee40:	d901      	bls.n	800ee46 <_ux_device_stack_initialize+0x1c2>
            
            /* We need to adjust the number of maximum interfaces.  */
            interfaces_found =  local_interfaces_found;
 800ee42:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ee44:	647b      	str	r3, [r7, #68]	; 0x44

        /* We do a sanity check on the finding. At least there must be one interface but endpoints are
        not necessary.  */
        if (interfaces_found == 0)
 800ee46:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ee48:	2b00      	cmp	r3, #0
 800ee4a:	d106      	bne.n	800ee5a <_ux_device_stack_initialize+0x1d6>
        {

            /* Error trap. */
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_INIT, UX_DESCRIPTOR_CORRUPTED);
 800ee4c:	2242      	movs	r2, #66	; 0x42
 800ee4e:	2103      	movs	r1, #3
 800ee50:	2002      	movs	r0, #2
 800ee52:	f000 f99b 	bl	800f18c <_ux_system_error_handler>

            /* If trace is enabled, insert this event into the trace buffer.  */
            UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_DESCRIPTOR_CORRUPTED, device_framework, 0, 0, UX_TRACE_ERRORS, 0, 0)

            status = UX_DESCRIPTOR_CORRUPTED;
 800ee56:	2342      	movs	r3, #66	; 0x42
 800ee58:	64bb      	str	r3, [r7, #72]	; 0x48
        }

        /* We do a sanity check on the finding. Max interface number should not exceed limit.  */
        if (status == UX_SUCCESS &&
 800ee5a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ee5c:	2b00      	cmp	r3, #0
 800ee5e:	d109      	bne.n	800ee74 <_ux_device_stack_initialize+0x1f0>
 800ee60:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800ee62:	2b0f      	cmp	r3, #15
 800ee64:	d906      	bls.n	800ee74 <_ux_device_stack_initialize+0x1f0>
            max_interface_number >= UX_MAX_SLAVE_INTERFACES)
        {

            /* Error trap. */
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_INIT, UX_MEMORY_INSUFFICIENT);
 800ee66:	2212      	movs	r2, #18
 800ee68:	2103      	movs	r1, #3
 800ee6a:	2002      	movs	r0, #2
 800ee6c:	f000 f98e 	bl	800f18c <_ux_system_error_handler>

            /* If trace is enabled, insert this event into the trace buffer.  */
            UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MEMORY_INSUFFICIENT, device_framework, 0, 0, UX_TRACE_ERRORS, 0, 0)

            status = UX_MEMORY_INSUFFICIENT;
 800ee70:	2312      	movs	r3, #18
 800ee72:	64bb      	str	r3, [r7, #72]	; 0x48
        }
    }
#endif

    /* Go on to allocate interfaces pool if no error.  */
    if (status == UX_SUCCESS)
 800ee74:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ee76:	2b00      	cmp	r3, #0
 800ee78:	d118      	bne.n	800eeac <_ux_device_stack_initialize+0x228>
    {

        /* Memorize both pool sizes.  */
        device -> ux_slave_device_interfaces_pool_number = interfaces_found;
 800ee7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ee7c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800ee7e:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
        device -> ux_slave_device_endpoints_pool_number  = endpoints_found;
 800ee82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ee84:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ee86:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

        /* We assign a pool for the interfaces.  */
        interfaces_pool =  _ux_utility_memory_allocate_mulc_safe(UX_NO_ALIGN, UX_REGULAR_MEMORY, interfaces_found, sizeof(UX_SLAVE_INTERFACE));
 800ee8a:	2338      	movs	r3, #56	; 0x38
 800ee8c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800ee8e:	2100      	movs	r1, #0
 800ee90:	2000      	movs	r0, #0
 800ee92:	f000 fc5d 	bl	800f750 <_ux_utility_memory_allocate_mulc_safe>
 800ee96:	6138      	str	r0, [r7, #16]
        if (interfaces_pool == UX_NULL)
 800ee98:	693b      	ldr	r3, [r7, #16]
 800ee9a:	2b00      	cmp	r3, #0
 800ee9c:	d102      	bne.n	800eea4 <_ux_device_stack_initialize+0x220>
            status = UX_MEMORY_INSUFFICIENT;
 800ee9e:	2312      	movs	r3, #18
 800eea0:	64bb      	str	r3, [r7, #72]	; 0x48
 800eea2:	e003      	b.n	800eeac <_ux_device_stack_initialize+0x228>
        else

            /* Save the interface pool address in the device container.  */
            device -> ux_slave_device_interfaces_pool =  interfaces_pool;
 800eea4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eea6:	693a      	ldr	r2, [r7, #16]
 800eea8:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    }

    /* Do we need an endpoint pool ?  */
    if (endpoints_found != 0 && status == UX_SUCCESS)
 800eeac:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800eeae:	2b00      	cmp	r3, #0
 800eeb0:	d045      	beq.n	800ef3e <_ux_device_stack_initialize+0x2ba>
 800eeb2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800eeb4:	2b00      	cmp	r3, #0
 800eeb6:	d142      	bne.n	800ef3e <_ux_device_stack_initialize+0x2ba>
    {

        /* We assign a pool for the endpoints.  */
        endpoints_pool =  _ux_utility_memory_allocate_mulc_safe(UX_NO_ALIGN, UX_REGULAR_MEMORY, endpoints_found, sizeof(UX_SLAVE_ENDPOINT));
 800eeb8:	2390      	movs	r3, #144	; 0x90
 800eeba:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800eebc:	2100      	movs	r1, #0
 800eebe:	2000      	movs	r0, #0
 800eec0:	f000 fc46 	bl	800f750 <_ux_utility_memory_allocate_mulc_safe>
 800eec4:	64f8      	str	r0, [r7, #76]	; 0x4c
        if (endpoints_pool == UX_NULL)
 800eec6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800eec8:	2b00      	cmp	r3, #0
 800eeca:	d102      	bne.n	800eed2 <_ux_device_stack_initialize+0x24e>
            status = UX_MEMORY_INSUFFICIENT;
 800eecc:	2312      	movs	r3, #18
 800eece:	64bb      	str	r3, [r7, #72]	; 0x48
        if (endpoints_pool == UX_NULL)
 800eed0:	e037      	b.n	800ef42 <_ux_device_stack_initialize+0x2be>
        else
        {

            /* Save the endpoint pool address in the device container.  */
            device -> ux_slave_device_endpoints_pool =  endpoints_pool;
 800eed2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800eed4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800eed6:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc

            /* We need to assign a transfer buffer to each endpoint. Each endpoint is assigned the
            maximum buffer size.  We also assign the semaphore used by the endpoint to synchronize transfer
            completion. */
            while (endpoints_pool < (device -> ux_slave_device_endpoints_pool + endpoints_found))
 800eeda:	e022      	b.n	800ef22 <_ux_device_stack_initialize+0x29e>
            {

                /* Obtain some memory.  */
                endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer = 
                                _ux_utility_memory_allocate(UX_NO_ALIGN, UX_CACHE_SAFE_MEMORY, UX_SLAVE_REQUEST_DATA_MAX_LENGTH);
 800eedc:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800eee0:	2101      	movs	r1, #1
 800eee2:	2000      	movs	r0, #0
 800eee4:	f000 fb30 	bl	800f548 <_ux_utility_memory_allocate>
 800eee8:	4602      	mov	r2, r0
                endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer = 
 800eeea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800eeec:	63da      	str	r2, [r3, #60]	; 0x3c

                /* Ensure we could allocate memory.  */
                if (endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer == UX_NULL)
 800eeee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800eef0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800eef2:	2b00      	cmp	r3, #0
 800eef4:	d104      	bne.n	800ef00 <_ux_device_stack_initialize+0x27c>
                {
                    status = UX_MEMORY_INSUFFICIENT;
 800eef6:	2312      	movs	r3, #18
 800eef8:	64bb      	str	r3, [r7, #72]	; 0x48
                    break;
 800eefa:	e01f      	b.n	800ef3c <_ux_device_stack_initialize+0x2b8>
 800eefc:	2000730c 	.word	0x2000730c
                }
        
                /* Create the semaphore for the endpoint.  */
                status =  _ux_device_semaphore_create(&endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_semaphore,
 800ef00:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ef02:	3360      	adds	r3, #96	; 0x60
 800ef04:	2200      	movs	r2, #0
 800ef06:	4934      	ldr	r1, [pc, #208]	; (800efd8 <_ux_device_stack_initialize+0x354>)
 800ef08:	4618      	mov	r0, r3
 800ef0a:	f000 fda4 	bl	800fa56 <_ux_utility_semaphore_create>
 800ef0e:	64b8      	str	r0, [r7, #72]	; 0x48
                                                    "ux_transfer_request_semaphore", 0);

                /* Check completion status.  */
                if (status != UX_SUCCESS)
 800ef10:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ef12:	2b00      	cmp	r3, #0
 800ef14:	d002      	beq.n	800ef1c <_ux_device_stack_initialize+0x298>
                {
                    status = UX_SEMAPHORE_ERROR;
 800ef16:	2315      	movs	r3, #21
 800ef18:	64bb      	str	r3, [r7, #72]	; 0x48
                    break;
 800ef1a:	e00f      	b.n	800ef3c <_ux_device_stack_initialize+0x2b8>
                }
        
                /* Next endpoint.  */
                endpoints_pool++;
 800ef1c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ef1e:	3390      	adds	r3, #144	; 0x90
 800ef20:	64fb      	str	r3, [r7, #76]	; 0x4c
            while (endpoints_pool < (device -> ux_slave_device_endpoints_pool + endpoints_found))
 800ef22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ef24:	f8d3 10fc 	ldr.w	r1, [r3, #252]	; 0xfc
 800ef28:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 800ef2a:	4613      	mov	r3, r2
 800ef2c:	00db      	lsls	r3, r3, #3
 800ef2e:	4413      	add	r3, r2
 800ef30:	011b      	lsls	r3, r3, #4
 800ef32:	440b      	add	r3, r1
 800ef34:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800ef36:	429a      	cmp	r2, r3
 800ef38:	d3d0      	bcc.n	800eedc <_ux_device_stack_initialize+0x258>
        if (endpoints_pool == UX_NULL)
 800ef3a:	e002      	b.n	800ef42 <_ux_device_stack_initialize+0x2be>
 800ef3c:	e001      	b.n	800ef42 <_ux_device_stack_initialize+0x2be>
            }
        }
    }
    else
        endpoints_pool = UX_NULL;
 800ef3e:	2300      	movs	r3, #0
 800ef40:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Return successful completion.  */
    if (status == UX_SUCCESS)
 800ef42:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800ef44:	2b00      	cmp	r3, #0
 800ef46:	d101      	bne.n	800ef4c <_ux_device_stack_initialize+0x2c8>
        return(UX_SUCCESS);
 800ef48:	2300      	movs	r3, #0
 800ef4a:	e040      	b.n	800efce <_ux_device_stack_initialize+0x34a>
    
    /* Free resources when there is error.  */

    /* Free device -> ux_slave_device_endpoints_pool.  */
    if (endpoints_pool)
 800ef4c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ef4e:	2b00      	cmp	r3, #0
 800ef50:	d021      	beq.n	800ef96 <_ux_device_stack_initialize+0x312>
    {

        /* In error cases creating endpoint resources, endpoints_pool is endpoint that failed.
         * Previously allocated things should be freed.  */
        while(endpoints_pool >= device -> ux_slave_device_endpoints_pool)
 800ef52:	e014      	b.n	800ef7e <_ux_device_stack_initialize+0x2fa>
        {

            /* Delete ux_slave_transfer_request_semaphore.  */
            if (_ux_device_semaphore_created(&endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_semaphore))
 800ef54:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ef56:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800ef58:	2b00      	cmp	r3, #0
 800ef5a:	d004      	beq.n	800ef66 <_ux_device_stack_initialize+0x2e2>
                _ux_device_semaphore_delete(&endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_semaphore);
 800ef5c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ef5e:	3360      	adds	r3, #96	; 0x60
 800ef60:	4618      	mov	r0, r3
 800ef62:	f000 fd91 	bl	800fa88 <_ux_utility_semaphore_delete>

            /* Free ux_slave_transfer_request_data_pointer buffer.  */
            if (endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer)
 800ef66:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ef68:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ef6a:	2b00      	cmp	r3, #0
 800ef6c:	d004      	beq.n	800ef78 <_ux_device_stack_initialize+0x2f4>
                _ux_utility_memory_free(endpoints_pool -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer);
 800ef6e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ef70:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ef72:	4618      	mov	r0, r3
 800ef74:	f000 fc30 	bl	800f7d8 <_ux_utility_memory_free>

            /* Move to previous endpoint.  */
            endpoints_pool --;
 800ef78:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ef7a:	3b90      	subs	r3, #144	; 0x90
 800ef7c:	64fb      	str	r3, [r7, #76]	; 0x4c
        while(endpoints_pool >= device -> ux_slave_device_endpoints_pool)
 800ef7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ef80:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800ef84:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 800ef86:	429a      	cmp	r2, r3
 800ef88:	d2e4      	bcs.n	800ef54 <_ux_device_stack_initialize+0x2d0>
        }

        _ux_utility_memory_free(device -> ux_slave_device_endpoints_pool);
 800ef8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ef8c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800ef90:	4618      	mov	r0, r3
 800ef92:	f000 fc21 	bl	800f7d8 <_ux_utility_memory_free>
    }

    /* Free device -> ux_slave_device_interfaces_pool.  */
    if (device -> ux_slave_device_interfaces_pool)
 800ef96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ef98:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800ef9c:	2b00      	cmp	r3, #0
 800ef9e:	d005      	beq.n	800efac <_ux_device_stack_initialize+0x328>
        _ux_utility_memory_free(device -> ux_slave_device_interfaces_pool);
 800efa0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800efa2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800efa6:	4618      	mov	r0, r3
 800efa8:	f000 fc16 	bl	800f7d8 <_ux_utility_memory_free>

    /* Free device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer.  */
    if (device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer)
 800efac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800efae:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800efb0:	2b00      	cmp	r3, #0
 800efb2:	d004      	beq.n	800efbe <_ux_device_stack_initialize+0x33a>
        _ux_utility_memory_free(device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer);
 800efb4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800efb6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800efb8:	4618      	mov	r0, r3
 800efba:	f000 fc0d 	bl	800f7d8 <_ux_utility_memory_free>

    /* Free _ux_system_slave -> ux_system_slave_class_array.  */
    _ux_utility_memory_free(_ux_system_slave -> ux_system_slave_class_array);
 800efbe:	4b07      	ldr	r3, [pc, #28]	; (800efdc <_ux_device_stack_initialize+0x358>)
 800efc0:	681b      	ldr	r3, [r3, #0]
 800efc2:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 800efc6:	4618      	mov	r0, r3
 800efc8:	f000 fc06 	bl	800f7d8 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(status);
 800efcc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
}
 800efce:	4618      	mov	r0, r3
 800efd0:	3750      	adds	r7, #80	; 0x50
 800efd2:	46bd      	mov	sp, r7
 800efd4:	bd80      	pop	{r7, pc}
 800efd6:	bf00      	nop
 800efd8:	080133d0 	.word	0x080133d0
 800efdc:	2000730c 	.word	0x2000730c

0800efe0 <_ux_device_stack_transfer_abort>:
/*                                            assigned aborting code,     */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_transfer_abort(UX_SLAVE_TRANSFER *transfer_request, ULONG completion_code)
{
 800efe0:	b580      	push	{r7, lr}
 800efe2:	b088      	sub	sp, #32
 800efe4:	af00      	add	r7, sp, #0
 800efe6:	6078      	str	r0, [r7, #4]
 800efe8:	6039      	str	r1, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_TRANSFER_ABORT, transfer_request, completion_code, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
 800efea:	4b19      	ldr	r3, [pc, #100]	; (800f050 <_ux_device_stack_transfer_abort+0x70>)
 800efec:	681b      	ldr	r3, [r3, #0]
 800efee:	61fb      	str	r3, [r7, #28]

    /* Sets the completion code due to bus reset.  */
    transfer_request -> ux_slave_transfer_request_completion_code = completion_code;
 800eff0:	687b      	ldr	r3, [r7, #4]
 800eff2:	683a      	ldr	r2, [r7, #0]
 800eff4:	625a      	str	r2, [r3, #36]	; 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800eff6:	f3ef 8310 	mrs	r3, PRIMASK
 800effa:	617b      	str	r3, [r7, #20]
    return(posture);
 800effc:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
 800effe:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
 800f000:	b672      	cpsid	i
    return(int_posture);
 800f002:	693b      	ldr	r3, [r7, #16]

    /* Ensure we're not preempted by the transfer completion ISR.  */
    UX_DISABLE
 800f004:	61bb      	str	r3, [r7, #24]

    /* It's possible the transfer already completed. Ensure it hasn't before doing the abort.  */
    if (transfer_request -> ux_slave_transfer_request_status == UX_TRANSFER_STATUS_PENDING)
 800f006:	687b      	ldr	r3, [r7, #4]
 800f008:	681b      	ldr	r3, [r3, #0]
 800f00a:	2b01      	cmp	r3, #1
 800f00c:	d114      	bne.n	800f038 <_ux_device_stack_transfer_abort+0x58>
    {

        /* Call the DCD if necessary for cleaning up the pending transfer.  */
        dcd -> ux_slave_dcd_function(dcd, UX_DCD_TRANSFER_ABORT, (VOID *) transfer_request);
 800f00e:	69fb      	ldr	r3, [r7, #28]
 800f010:	699b      	ldr	r3, [r3, #24]
 800f012:	687a      	ldr	r2, [r7, #4]
 800f014:	210d      	movs	r1, #13
 800f016:	69f8      	ldr	r0, [r7, #28]
 800f018:	4798      	blx	r3
 800f01a:	69bb      	ldr	r3, [r7, #24]
 800f01c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800f01e:	68fb      	ldr	r3, [r7, #12]
 800f020:	f383 8810 	msr	PRIMASK, r3
}
 800f024:	bf00      	nop

        /* We need to set the completion code for the transfer to aborted. Note
           that the transfer request function cannot simultaneously modify this 
           because if the transfer was pending, then the transfer's thread is 
           currently waiting for it to complete.  */
        transfer_request -> ux_slave_transfer_request_status =  UX_TRANSFER_STATUS_ABORT;
 800f026:	687b      	ldr	r3, [r7, #4]
 800f028:	2204      	movs	r2, #4
 800f02a:	601a      	str	r2, [r3, #0]

        /* Wake up the device driver who is waiting on the semaphore.  */
        _ux_device_semaphore_put(&transfer_request -> ux_slave_transfer_request_semaphore);
 800f02c:	687b      	ldr	r3, [r7, #4]
 800f02e:	3330      	adds	r3, #48	; 0x30
 800f030:	4618      	mov	r0, r3
 800f032:	f000 fd36 	bl	800faa2 <_ux_utility_semaphore_put>
 800f036:	e005      	b.n	800f044 <_ux_device_stack_transfer_abort+0x64>
 800f038:	69bb      	ldr	r3, [r7, #24]
 800f03a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800f03c:	68bb      	ldr	r3, [r7, #8]
 800f03e:	f383 8810 	msr	PRIMASK, r3
}
 800f042:	bf00      	nop
        /* Restore interrupts.  */
        UX_RESTORE
    }

    /* This function never fails.  */
    return(UX_SUCCESS);       
 800f044:	2300      	movs	r3, #0
}
 800f046:	4618      	mov	r0, r3
 800f048:	3720      	adds	r7, #32
 800f04a:	46bd      	mov	sp, r7
 800f04c:	bd80      	pop	{r7, pc}
 800f04e:	bf00      	nop
 800f050:	2000730c 	.word	0x2000730c

0800f054 <_ux_device_stack_transfer_all_request_abort>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_transfer_all_request_abort(UX_SLAVE_ENDPOINT *endpoint, ULONG completion_code)
{
 800f054:	b580      	push	{r7, lr}
 800f056:	b084      	sub	sp, #16
 800f058:	af00      	add	r7, sp, #0
 800f05a:	6078      	str	r0, [r7, #4]
 800f05c:	6039      	str	r1, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_TRANSFER_ALL_REQUEST_ABORT, endpoint, completion_code, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the transfer request for this endpoint.  */
    transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
 800f05e:	687b      	ldr	r3, [r7, #4]
 800f060:	3330      	adds	r3, #48	; 0x30
 800f062:	60fb      	str	r3, [r7, #12]
    
    /* Abort this request.  */
    _ux_device_stack_transfer_abort(transfer_request, completion_code);
 800f064:	6839      	ldr	r1, [r7, #0]
 800f066:	68f8      	ldr	r0, [r7, #12]
 800f068:	f7ff ffba 	bl	800efe0 <_ux_device_stack_transfer_abort>

    /* Return successful completion.  */
    return(UX_SUCCESS);
 800f06c:	2300      	movs	r3, #0
}
 800f06e:	4618      	mov	r0, r3
 800f070:	3710      	adds	r7, #16
 800f072:	46bd      	mov	sp, r7
 800f074:	bd80      	pop	{r7, pc}
	...

0800f078 <_ux_device_stack_transfer_request>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_stack_transfer_request(UX_SLAVE_TRANSFER *transfer_request, 
                                            ULONG slave_length, 
                                            ULONG host_length)
{
 800f078:	b580      	push	{r7, lr}
 800f07a:	b08e      	sub	sp, #56	; 0x38
 800f07c:	af00      	add	r7, sp, #0
 800f07e:	60f8      	str	r0, [r7, #12]
 800f080:	60b9      	str	r1, [r7, #8]
 800f082:	607a      	str	r2, [r7, #4]
UX_SLAVE_ENDPOINT       *endpoint;
ULONG                   device_state;


    /* Do we have to skip this transfer?  */
    if (transfer_request -> ux_slave_transfer_request_status_phase_ignore == UX_TRUE)
 800f084:	68fb      	ldr	r3, [r7, #12]
 800f086:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800f088:	2b01      	cmp	r3, #1
 800f08a:	d101      	bne.n	800f090 <_ux_device_stack_transfer_request+0x18>
        return(UX_SUCCESS);
 800f08c:	2300      	movs	r3, #0
 800f08e:	e077      	b.n	800f180 <_ux_device_stack_transfer_request+0x108>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
 800f090:	f3ef 8310 	mrs	r3, PRIMASK
 800f094:	623b      	str	r3, [r7, #32]
    return(posture);
 800f096:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
 800f098:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
 800f09a:	b672      	cpsid	i
    return(int_posture);
 800f09c:	69fb      	ldr	r3, [r7, #28]

    /* Disable interrupts to prevent the disconnection ISR from preempting us
       while we check the device state and set the transfer status.  */
    UX_DISABLE
 800f09e:	637b      	str	r3, [r7, #52]	; 0x34

    /* Get the device state.  */
    device_state =  _ux_system_slave -> ux_system_slave_device.ux_slave_device_state;
 800f0a0:	4b39      	ldr	r3, [pc, #228]	; (800f188 <_ux_device_stack_transfer_request+0x110>)
 800f0a2:	681b      	ldr	r3, [r3, #0]
 800f0a4:	6a1b      	ldr	r3, [r3, #32]
 800f0a6:	633b      	str	r3, [r7, #48]	; 0x30

    /* We can only transfer when the device is ATTACHED, ADDRESSED OR CONFIGURED.  */
    if ((device_state == UX_DEVICE_ATTACHED) || (device_state == UX_DEVICE_ADDRESSED)
 800f0a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f0aa:	2b01      	cmp	r3, #1
 800f0ac:	d005      	beq.n	800f0ba <_ux_device_stack_transfer_request+0x42>
 800f0ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f0b0:	2b02      	cmp	r3, #2
 800f0b2:	d002      	beq.n	800f0ba <_ux_device_stack_transfer_request+0x42>
            || (device_state == UX_DEVICE_CONFIGURED))
 800f0b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f0b6:	2b03      	cmp	r3, #3
 800f0b8:	d115      	bne.n	800f0e6 <_ux_device_stack_transfer_request+0x6e>

        /* Set the transfer to pending.  */
        transfer_request -> ux_slave_transfer_request_status =  UX_TRANSFER_STATUS_PENDING; 
 800f0ba:	68fb      	ldr	r3, [r7, #12]
 800f0bc:	2201      	movs	r2, #1
 800f0be:	601a      	str	r2, [r3, #0]
 800f0c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f0c2:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800f0c4:	69bb      	ldr	r3, [r7, #24]
 800f0c6:	f383 8810 	msr	PRIMASK, r3
}
 800f0ca:	bf00      	nop
                    
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_STACK_TRANSFER_REQUEST, transfer_request, 0, 0, 0, UX_TRACE_DEVICE_STACK_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
 800f0cc:	4b2e      	ldr	r3, [pc, #184]	; (800f188 <_ux_device_stack_transfer_request+0x110>)
 800f0ce:	681b      	ldr	r3, [r3, #0]
 800f0d0:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Get the endpoint associated with this transaction.  */
    endpoint =  transfer_request -> ux_slave_transfer_request_endpoint;
 800f0d2:	68fb      	ldr	r3, [r7, #12]
 800f0d4:	689b      	ldr	r3, [r3, #8]
 800f0d6:	62bb      	str	r3, [r7, #40]	; 0x28
    
    /* If the endpoint is non Control, check the endpoint direction and set the data phase direction.  */
    if ((endpoint -> ux_slave_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) != UX_CONTROL_ENDPOINT)
 800f0d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f0da:	699b      	ldr	r3, [r3, #24]
 800f0dc:	f003 0303 	and.w	r3, r3, #3
 800f0e0:	2b00      	cmp	r3, #0
 800f0e2:	d10b      	bne.n	800f0fc <_ux_device_stack_transfer_request+0x84>
 800f0e4:	e01b      	b.n	800f11e <_ux_device_stack_transfer_request+0xa6>
 800f0e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f0e8:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
 800f0ea:	697b      	ldr	r3, [r7, #20]
 800f0ec:	f383 8810 	msr	PRIMASK, r3
}
 800f0f0:	bf00      	nop
        return(UX_TRANSFER_NOT_READY);
 800f0f2:	2325      	movs	r3, #37	; 0x25
 800f0f4:	e044      	b.n	800f180 <_ux_device_stack_transfer_request+0x108>
        /* Check if the endpoint is STALLED. In this case, we must refuse the transaction until the endpoint
           has been reset by the host.  */
        while (endpoint -> ux_slave_endpoint_state == UX_ENDPOINT_HALTED)

            /* Wait for 100ms for endpoint to be reset by a CLEAR_FEATURE command.  */
            _ux_utility_delay_ms(100);
 800f0f6:	2064      	movs	r0, #100	; 0x64
 800f0f8:	f000 f91c 	bl	800f334 <_ux_utility_delay_ms>
        while (endpoint -> ux_slave_endpoint_state == UX_ENDPOINT_HALTED)
 800f0fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f0fe:	685b      	ldr	r3, [r3, #4]
 800f100:	2b02      	cmp	r3, #2
 800f102:	d0f8      	beq.n	800f0f6 <_ux_device_stack_transfer_request+0x7e>

        /* Isolate the direction from the endpoint address.  */
        if ((endpoint -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_IN)
 800f104:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f106:	695b      	ldr	r3, [r3, #20]
 800f108:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800f10c:	2b00      	cmp	r3, #0
 800f10e:	d003      	beq.n	800f118 <_ux_device_stack_transfer_request+0xa0>
            transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
 800f110:	68fb      	ldr	r3, [r7, #12]
 800f112:	2203      	movs	r2, #3
 800f114:	629a      	str	r2, [r3, #40]	; 0x28
 800f116:	e002      	b.n	800f11e <_ux_device_stack_transfer_request+0xa6>
        else    
            transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_IN;
 800f118:	68fb      	ldr	r3, [r7, #12]
 800f11a:	2202      	movs	r2, #2
 800f11c:	629a      	str	r2, [r3, #40]	; 0x28

    /* See if we need to force a zero length packet at the end of the transfer. 
       This happens on a DATA IN and when the host requested length is not met
       and the last packet is on a boundary. If slave_length is zero, then it is 
       a explicit ZLP request, no need to force ZLP.  */
    if ((transfer_request -> ux_slave_transfer_request_phase ==  UX_TRANSFER_PHASE_DATA_OUT) &&
 800f11e:	68fb      	ldr	r3, [r7, #12]
 800f120:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f122:	2b03      	cmp	r3, #3
 800f124:	d114      	bne.n	800f150 <_ux_device_stack_transfer_request+0xd8>
 800f126:	68bb      	ldr	r3, [r7, #8]
 800f128:	2b00      	cmp	r3, #0
 800f12a:	d011      	beq.n	800f150 <_ux_device_stack_transfer_request+0xd8>
        (slave_length != 0) && (host_length != slave_length) && 
 800f12c:	687a      	ldr	r2, [r7, #4]
 800f12e:	68bb      	ldr	r3, [r7, #8]
 800f130:	429a      	cmp	r2, r3
 800f132:	d00d      	beq.n	800f150 <_ux_device_stack_transfer_request+0xd8>
        (slave_length % endpoint -> ux_slave_endpoint_descriptor.wMaxPacketSize) == 0)
 800f134:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f136:	69da      	ldr	r2, [r3, #28]
 800f138:	68bb      	ldr	r3, [r7, #8]
 800f13a:	fbb3 f1f2 	udiv	r1, r3, r2
 800f13e:	fb01 f202 	mul.w	r2, r1, r2
 800f142:	1a9b      	subs	r3, r3, r2
        (slave_length != 0) && (host_length != slave_length) && 
 800f144:	2b00      	cmp	r3, #0
 800f146:	d103      	bne.n	800f150 <_ux_device_stack_transfer_request+0xd8>
    {

        /* If so force Zero Length Packet.  */
        transfer_request -> ux_slave_transfer_request_force_zlp =  UX_TRUE;
 800f148:	68fb      	ldr	r3, [r7, #12]
 800f14a:	2201      	movs	r2, #1
 800f14c:	651a      	str	r2, [r3, #80]	; 0x50
 800f14e:	e002      	b.n	800f156 <_ux_device_stack_transfer_request+0xde>
    }
    else
    {

        /* Condition is not met, do not force a Zero Length Packet.  */
        transfer_request -> ux_slave_transfer_request_force_zlp =  UX_FALSE;
 800f150:	68fb      	ldr	r3, [r7, #12]
 800f152:	2200      	movs	r2, #0
 800f154:	651a      	str	r2, [r3, #80]	; 0x50
    }

    /* Reset the number of bytes sent/received.  */
    transfer_request -> ux_slave_transfer_request_actual_length =  0;
 800f156:	68fb      	ldr	r3, [r7, #12]
 800f158:	2200      	movs	r2, #0
 800f15a:	619a      	str	r2, [r3, #24]

    /* Determine how many bytes to send in this transaction.  We keep track of the original
        length and have a working length.  */
    transfer_request -> ux_slave_transfer_request_requested_length =    slave_length;
 800f15c:	68fb      	ldr	r3, [r7, #12]
 800f15e:	68ba      	ldr	r2, [r7, #8]
 800f160:	615a      	str	r2, [r3, #20]
    transfer_request -> ux_slave_transfer_request_in_transfer_length =  slave_length;
 800f162:	68fb      	ldr	r3, [r7, #12]
 800f164:	68ba      	ldr	r2, [r7, #8]
 800f166:	61da      	str	r2, [r3, #28]

    /* Save the buffer pointer.  */
    transfer_request -> ux_slave_transfer_request_current_data_pointer =  
                            transfer_request -> ux_slave_transfer_request_data_pointer;
 800f168:	68fb      	ldr	r3, [r7, #12]
 800f16a:	68da      	ldr	r2, [r3, #12]
    transfer_request -> ux_slave_transfer_request_current_data_pointer =  
 800f16c:	68fb      	ldr	r3, [r7, #12]
 800f16e:	611a      	str	r2, [r3, #16]

    /* Call the DCD driver transfer function.   */
    status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_TRANSFER_REQUEST, transfer_request);
 800f170:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f172:	699b      	ldr	r3, [r3, #24]
 800f174:	68fa      	ldr	r2, [r7, #12]
 800f176:	210c      	movs	r1, #12
 800f178:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800f17a:	4798      	blx	r3
 800f17c:	6278      	str	r0, [r7, #36]	; 0x24

    /* And return the status.  */
    return(status);
 800f17e:	6a7b      	ldr	r3, [r7, #36]	; 0x24

#endif
}
 800f180:	4618      	mov	r0, r3
 800f182:	3738      	adds	r7, #56	; 0x38
 800f184:	46bd      	mov	sp, r7
 800f186:	bd80      	pop	{r7, pc}
 800f188:	2000730c 	.word	0x2000730c

0800f18c <_ux_system_error_handler>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID   _ux_system_error_handler(UINT system_level, UINT system_context, UINT error_code)
{
 800f18c:	b580      	push	{r7, lr}
 800f18e:	b084      	sub	sp, #16
 800f190:	af00      	add	r7, sp, #0
 800f192:	60f8      	str	r0, [r7, #12]
 800f194:	60b9      	str	r1, [r7, #8]
 800f196:	607a      	str	r2, [r7, #4]

    /* Save the last system error code.  */
    _ux_system -> ux_system_last_error =  error_code;
 800f198:	4b0c      	ldr	r3, [pc, #48]	; (800f1cc <_ux_system_error_handler+0x40>)
 800f19a:	681b      	ldr	r3, [r3, #0]
 800f19c:	687a      	ldr	r2, [r7, #4]
 800f19e:	651a      	str	r2, [r3, #80]	; 0x50
 
    /* Increment the total number of system errors.  */
    _ux_system -> ux_system_error_count++;
 800f1a0:	4b0a      	ldr	r3, [pc, #40]	; (800f1cc <_ux_system_error_handler+0x40>)
 800f1a2:	681b      	ldr	r3, [r3, #0]
 800f1a4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800f1a6:	3201      	adds	r2, #1
 800f1a8:	655a      	str	r2, [r3, #84]	; 0x54

    /* Is there an application call back function to call ? */
    if (_ux_system -> ux_system_error_callback_function != UX_NULL)
 800f1aa:	4b08      	ldr	r3, [pc, #32]	; (800f1cc <_ux_system_error_handler+0x40>)
 800f1ac:	681b      	ldr	r3, [r3, #0]
 800f1ae:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800f1b0:	2b00      	cmp	r3, #0
 800f1b2:	d006      	beq.n	800f1c2 <_ux_system_error_handler+0x36>
    {    

        /* The callback function is defined, call it.  */
        _ux_system -> ux_system_error_callback_function(system_level, system_context, error_code);
 800f1b4:	4b05      	ldr	r3, [pc, #20]	; (800f1cc <_ux_system_error_handler+0x40>)
 800f1b6:	681b      	ldr	r3, [r3, #0]
 800f1b8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800f1ba:	687a      	ldr	r2, [r7, #4]
 800f1bc:	68b9      	ldr	r1, [r7, #8]
 800f1be:	68f8      	ldr	r0, [r7, #12]
 800f1c0:	4798      	blx	r3
    }
}
 800f1c2:	bf00      	nop
 800f1c4:	3710      	adds	r7, #16
 800f1c6:	46bd      	mov	sp, r7
 800f1c8:	bd80      	pop	{r7, pc}
 800f1ca:	bf00      	nop
 800f1cc:	20007310 	.word	0x20007310

0800f1d0 <_ux_system_initialize>:
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_system_initialize(VOID *regular_memory_pool_start, ULONG regular_memory_size, 
                            VOID *cache_safe_memory_pool_start, ULONG cache_safe_memory_size)
{
 800f1d0:	b580      	push	{r7, lr}
 800f1d2:	b08a      	sub	sp, #40	; 0x28
 800f1d4:	af00      	add	r7, sp, #0
 800f1d6:	60f8      	str	r0, [r7, #12]
 800f1d8:	60b9      	str	r1, [r7, #8]
 800f1da:	607a      	str	r2, [r7, #4]
 800f1dc:	603b      	str	r3, [r7, #0]
UINT                status;
#endif


    /* Reset memory block */
    _ux_utility_memory_set(regular_memory_pool_start, 0, regular_memory_size); /* Use case of memset is verified. */
 800f1de:	68ba      	ldr	r2, [r7, #8]
 800f1e0:	2100      	movs	r1, #0
 800f1e2:	68f8      	ldr	r0, [r7, #12]
 800f1e4:	f000 fbd6 	bl	800f994 <_ux_utility_memory_set>

    /* Set the _ux_system structure at the start of our regular memory */
    _ux_system =  (UX_SYSTEM *) regular_memory_pool_start;
 800f1e8:	4a4f      	ldr	r2, [pc, #316]	; (800f328 <_ux_system_initialize+0x158>)
 800f1ea:	68fb      	ldr	r3, [r7, #12]
 800f1ec:	6013      	str	r3, [r2, #0]

    /* Add to the memory offset the size of the allocated block.  */
    memory_pool_offset = sizeof(UX_SYSTEM);
 800f1ee:	235c      	movs	r3, #92	; 0x5c
 800f1f0:	627b      	str	r3, [r7, #36]	; 0x24
#endif 

#ifndef UX_HOST_SIDE_ONLY

    /* Set the _ux_system_slave structure.  */
    _ux_system_slave =  (UX_SYSTEM_SLAVE *) (((UCHAR *) regular_memory_pool_start) + memory_pool_offset);
 800f1f2:	68fa      	ldr	r2, [r7, #12]
 800f1f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f1f6:	4413      	add	r3, r2
 800f1f8:	4a4c      	ldr	r2, [pc, #304]	; (800f32c <_ux_system_initialize+0x15c>)
 800f1fa:	6013      	str	r3, [r2, #0]

    /* Add to the memory offset the size of the allocated block.  */
    memory_pool_offset += (ULONG)sizeof(UX_SYSTEM_SLAVE);
 800f1fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f1fe:	f503 73e6 	add.w	r3, r3, #460	; 0x1cc
 800f202:	627b      	str	r3, [r7, #36]	; 0x24
    memory_pool_offset += (ULONG)sizeof(UX_SYSTEM_OTG);
#endif 


    /* Set the cache safe memory for the dynamic pool */
    _ux_system -> ux_system_regular_memory_pool_start =  (UX_MEMORY_BLOCK *) (((UCHAR *) regular_memory_pool_start) 
 800f204:	4b48      	ldr	r3, [pc, #288]	; (800f328 <_ux_system_initialize+0x158>)
 800f206:	681b      	ldr	r3, [r3, #0]
 800f208:	68f9      	ldr	r1, [r7, #12]
 800f20a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800f20c:	440a      	add	r2, r1
 800f20e:	601a      	str	r2, [r3, #0]
                                                            + memory_pool_offset);

    /* Make sure the regular memory pool is aligned properly */
    int_memory_pool_start =   (ALIGN_TYPE) _ux_system -> ux_system_regular_memory_pool_start;
 800f210:	4b45      	ldr	r3, [pc, #276]	; (800f328 <_ux_system_initialize+0x158>)
 800f212:	681b      	ldr	r3, [r3, #0]
 800f214:	681b      	ldr	r3, [r3, #0]
 800f216:	623b      	str	r3, [r7, #32]
    int_memory_pool_start +=  UX_ALIGN_MIN;
 800f218:	6a3b      	ldr	r3, [r7, #32]
 800f21a:	330f      	adds	r3, #15
 800f21c:	623b      	str	r3, [r7, #32]
    int_memory_pool_start &=  ~((ALIGN_TYPE)UX_ALIGN_MIN);
 800f21e:	6a3b      	ldr	r3, [r7, #32]
 800f220:	f023 030f 	bic.w	r3, r3, #15
 800f224:	623b      	str	r3, [r7, #32]
    
    /* Set the end of the regular memory pool.  */
    regular_memory_pool_end =  (void *) (((UCHAR *) regular_memory_pool_start) + regular_memory_size);
 800f226:	68fa      	ldr	r2, [r7, #12]
 800f228:	68bb      	ldr	r3, [r7, #8]
 800f22a:	4413      	add	r3, r2
 800f22c:	61fb      	str	r3, [r7, #28]

    /* Check if we have memory available.  */
    if (int_memory_pool_start >= (ALIGN_TYPE)regular_memory_pool_end)
 800f22e:	69fb      	ldr	r3, [r7, #28]
 800f230:	6a3a      	ldr	r2, [r7, #32]
 800f232:	429a      	cmp	r2, r3
 800f234:	d301      	bcc.n	800f23a <_ux_system_initialize+0x6a>
    {

        /* No memory available.  */
        return(UX_MEMORY_INSUFFICIENT);
 800f236:	2312      	movs	r3, #18
 800f238:	e071      	b.n	800f31e <_ux_system_initialize+0x14e>
    }

    /* Now, we have a project structure allocated, save the regular memory allocation details */
    _ux_system -> ux_system_regular_memory_pool_size =     (ULONG) (((ALIGN_TYPE) regular_memory_pool_end) - int_memory_pool_start);
 800f23a:	69f9      	ldr	r1, [r7, #28]
 800f23c:	4b3a      	ldr	r3, [pc, #232]	; (800f328 <_ux_system_initialize+0x158>)
 800f23e:	681b      	ldr	r3, [r3, #0]
 800f240:	6a3a      	ldr	r2, [r7, #32]
 800f242:	1a8a      	subs	r2, r1, r2
 800f244:	605a      	str	r2, [r3, #4]
    _ux_system -> ux_system_regular_memory_pool_free =     _ux_system -> ux_system_regular_memory_pool_size;
 800f246:	4b38      	ldr	r3, [pc, #224]	; (800f328 <_ux_system_initialize+0x158>)
 800f248:	681a      	ldr	r2, [r3, #0]
 800f24a:	4b37      	ldr	r3, [pc, #220]	; (800f328 <_ux_system_initialize+0x158>)
 800f24c:	681b      	ldr	r3, [r3, #0]
 800f24e:	6852      	ldr	r2, [r2, #4]
 800f250:	609a      	str	r2, [r3, #8]
    _ux_system -> ux_system_regular_memory_pool_start =    (UX_MEMORY_BLOCK *) int_memory_pool_start;
 800f252:	4b35      	ldr	r3, [pc, #212]	; (800f328 <_ux_system_initialize+0x158>)
 800f254:	681b      	ldr	r3, [r3, #0]
 800f256:	6a3a      	ldr	r2, [r7, #32]
 800f258:	601a      	str	r2, [r3, #0]

    /* Build the first free memory block */
    memory_block =                             _ux_system -> ux_system_regular_memory_pool_start;
 800f25a:	4b33      	ldr	r3, [pc, #204]	; (800f328 <_ux_system_initialize+0x158>)
 800f25c:	681b      	ldr	r3, [r3, #0]
 800f25e:	681b      	ldr	r3, [r3, #0]
 800f260:	61bb      	str	r3, [r7, #24]
    memory_block -> ux_memory_block_size =     _ux_system -> ux_system_regular_memory_pool_size - (ULONG)sizeof(UX_MEMORY_BLOCK);
 800f262:	4b31      	ldr	r3, [pc, #196]	; (800f328 <_ux_system_initialize+0x158>)
 800f264:	681b      	ldr	r3, [r3, #0]
 800f266:	685b      	ldr	r3, [r3, #4]
 800f268:	f1a3 0210 	sub.w	r2, r3, #16
 800f26c:	69bb      	ldr	r3, [r7, #24]
 800f26e:	601a      	str	r2, [r3, #0]
    memory_block -> ux_memory_block_status =   UX_MEMORY_UNUSED;
 800f270:	69bb      	ldr	r3, [r7, #24]
 800f272:	2200      	movs	r2, #0
 800f274:	605a      	str	r2, [r3, #4]

    /* Check the definition of the cache safe pool. If the application or controller do not require any cache safe memory,
       define the cached safe memory region as the regular memory region.  */
    if (cache_safe_memory_pool_start == UX_NULL)
 800f276:	687b      	ldr	r3, [r7, #4]
 800f278:	2b00      	cmp	r3, #0
 800f27a:	d112      	bne.n	800f2a2 <_ux_system_initialize+0xd2>
    {

        /* Cache safe memory is the same as regular memory.  */
        _ux_system -> ux_system_cache_safe_memory_pool_size =  _ux_system -> ux_system_regular_memory_pool_size;
 800f27c:	4b2a      	ldr	r3, [pc, #168]	; (800f328 <_ux_system_initialize+0x158>)
 800f27e:	681a      	ldr	r2, [r3, #0]
 800f280:	4b29      	ldr	r3, [pc, #164]	; (800f328 <_ux_system_initialize+0x158>)
 800f282:	681b      	ldr	r3, [r3, #0]
 800f284:	6852      	ldr	r2, [r2, #4]
 800f286:	611a      	str	r2, [r3, #16]
        _ux_system -> ux_system_cache_safe_memory_pool_free =  _ux_system -> ux_system_regular_memory_pool_free;
 800f288:	4b27      	ldr	r3, [pc, #156]	; (800f328 <_ux_system_initialize+0x158>)
 800f28a:	681a      	ldr	r2, [r3, #0]
 800f28c:	4b26      	ldr	r3, [pc, #152]	; (800f328 <_ux_system_initialize+0x158>)
 800f28e:	681b      	ldr	r3, [r3, #0]
 800f290:	6892      	ldr	r2, [r2, #8]
 800f292:	615a      	str	r2, [r3, #20]
        _ux_system -> ux_system_cache_safe_memory_pool_start = _ux_system -> ux_system_regular_memory_pool_start;
 800f294:	4b24      	ldr	r3, [pc, #144]	; (800f328 <_ux_system_initialize+0x158>)
 800f296:	681a      	ldr	r2, [r3, #0]
 800f298:	4b23      	ldr	r3, [pc, #140]	; (800f328 <_ux_system_initialize+0x158>)
 800f29a:	681b      	ldr	r3, [r3, #0]
 800f29c:	6812      	ldr	r2, [r2, #0]
 800f29e:	60da      	str	r2, [r3, #12]
 800f2a0:	e02f      	b.n	800f302 <_ux_system_initialize+0x132>
    }
    else
    {
    
        /* Make sure the cache safe memory pool is aligned properly */
        int_memory_pool_start =   (ALIGN_TYPE) cache_safe_memory_pool_start;
 800f2a2:	687b      	ldr	r3, [r7, #4]
 800f2a4:	623b      	str	r3, [r7, #32]
        int_memory_pool_start +=  UX_ALIGN_MIN;
 800f2a6:	6a3b      	ldr	r3, [r7, #32]
 800f2a8:	330f      	adds	r3, #15
 800f2aa:	623b      	str	r3, [r7, #32]
        int_memory_pool_start &=  ~((ALIGN_TYPE)UX_ALIGN_MIN);
 800f2ac:	6a3b      	ldr	r3, [r7, #32]
 800f2ae:	f023 030f 	bic.w	r3, r3, #15
 800f2b2:	623b      	str	r3, [r7, #32]
    
        /* Save the cache safe memory allocation details */
        _ux_system -> ux_system_cache_safe_memory_pool_size =     cache_safe_memory_size - UX_ALIGN_MIN;
 800f2b4:	4b1c      	ldr	r3, [pc, #112]	; (800f328 <_ux_system_initialize+0x158>)
 800f2b6:	681b      	ldr	r3, [r3, #0]
 800f2b8:	683a      	ldr	r2, [r7, #0]
 800f2ba:	3a0f      	subs	r2, #15
 800f2bc:	611a      	str	r2, [r3, #16]
        _ux_system -> ux_system_cache_safe_memory_pool_free =     _ux_system -> ux_system_cache_safe_memory_pool_size;
 800f2be:	4b1a      	ldr	r3, [pc, #104]	; (800f328 <_ux_system_initialize+0x158>)
 800f2c0:	681a      	ldr	r2, [r3, #0]
 800f2c2:	4b19      	ldr	r3, [pc, #100]	; (800f328 <_ux_system_initialize+0x158>)
 800f2c4:	681b      	ldr	r3, [r3, #0]
 800f2c6:	6912      	ldr	r2, [r2, #16]
 800f2c8:	615a      	str	r2, [r3, #20]
        _ux_system -> ux_system_cache_safe_memory_pool_start =    (UX_MEMORY_BLOCK *) int_memory_pool_start;
 800f2ca:	4b17      	ldr	r3, [pc, #92]	; (800f328 <_ux_system_initialize+0x158>)
 800f2cc:	681b      	ldr	r3, [r3, #0]
 800f2ce:	6a3a      	ldr	r2, [r7, #32]
 800f2d0:	60da      	str	r2, [r3, #12]
    
        /* Reset this memory block */
        _ux_utility_memory_set(_ux_system -> ux_system_cache_safe_memory_pool_start, 0, _ux_system -> ux_system_cache_safe_memory_pool_size); /* Use case of memset is verified. */
 800f2d2:	4b15      	ldr	r3, [pc, #84]	; (800f328 <_ux_system_initialize+0x158>)
 800f2d4:	681b      	ldr	r3, [r3, #0]
 800f2d6:	68d8      	ldr	r0, [r3, #12]
 800f2d8:	4b13      	ldr	r3, [pc, #76]	; (800f328 <_ux_system_initialize+0x158>)
 800f2da:	681b      	ldr	r3, [r3, #0]
 800f2dc:	691b      	ldr	r3, [r3, #16]
 800f2de:	461a      	mov	r2, r3
 800f2e0:	2100      	movs	r1, #0
 800f2e2:	f000 fb57 	bl	800f994 <_ux_utility_memory_set>
    
        /* Build the first free memory block */
        memory_block =                             _ux_system -> ux_system_cache_safe_memory_pool_start;
 800f2e6:	4b10      	ldr	r3, [pc, #64]	; (800f328 <_ux_system_initialize+0x158>)
 800f2e8:	681b      	ldr	r3, [r3, #0]
 800f2ea:	68db      	ldr	r3, [r3, #12]
 800f2ec:	61bb      	str	r3, [r7, #24]
        memory_block -> ux_memory_block_size =     _ux_system -> ux_system_cache_safe_memory_pool_size - (ULONG)sizeof(UX_MEMORY_BLOCK);
 800f2ee:	4b0e      	ldr	r3, [pc, #56]	; (800f328 <_ux_system_initialize+0x158>)
 800f2f0:	681b      	ldr	r3, [r3, #0]
 800f2f2:	691b      	ldr	r3, [r3, #16]
 800f2f4:	f1a3 0210 	sub.w	r2, r3, #16
 800f2f8:	69bb      	ldr	r3, [r7, #24]
 800f2fa:	601a      	str	r2, [r3, #0]
        memory_block -> ux_memory_block_status =   UX_MEMORY_UNUSED;
 800f2fc:	69bb      	ldr	r3, [r7, #24]
 800f2fe:	2200      	movs	r2, #0
 800f300:	605a      	str	r2, [r3, #4]
#endif

#if !defined(UX_STANDALONE)

    /* Create the Mutex object used by USBX to control critical sections.  */
    status =  _ux_system_mutex_create(&_ux_system -> ux_system_mutex, "ux_system_mutex");
 800f302:	4b09      	ldr	r3, [pc, #36]	; (800f328 <_ux_system_initialize+0x158>)
 800f304:	681b      	ldr	r3, [r3, #0]
 800f306:	331c      	adds	r3, #28
 800f308:	4909      	ldr	r1, [pc, #36]	; (800f330 <_ux_system_initialize+0x160>)
 800f30a:	4618      	mov	r0, r3
 800f30c:	f000 fb5c 	bl	800f9c8 <_ux_utility_mutex_create>
 800f310:	6178      	str	r0, [r7, #20]
    if(status != UX_SUCCESS)
 800f312:	697b      	ldr	r3, [r7, #20]
 800f314:	2b00      	cmp	r3, #0
 800f316:	d001      	beq.n	800f31c <_ux_system_initialize+0x14c>
        return(UX_MUTEX_ERROR);
 800f318:	2317      	movs	r3, #23
 800f31a:	e000      	b.n	800f31e <_ux_system_initialize+0x14e>
#endif

    return(UX_SUCCESS);
 800f31c:	2300      	movs	r3, #0
}
 800f31e:	4618      	mov	r0, r3
 800f320:	3728      	adds	r7, #40	; 0x28
 800f322:	46bd      	mov	sp, r7
 800f324:	bd80      	pop	{r7, pc}
 800f326:	bf00      	nop
 800f328:	20007310 	.word	0x20007310
 800f32c:	2000730c 	.word	0x2000730c
 800f330:	080133f0 	.word	0x080133f0

0800f334 <_ux_utility_delay_ms>:
/*                                            added standalone support,   */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_delay_ms(ULONG ms_wait)
{
 800f334:	b580      	push	{r7, lr}
 800f336:	b084      	sub	sp, #16
 800f338:	af00      	add	r7, sp, #0
 800f33a:	6078      	str	r0, [r7, #4]
    while(_ux_utility_time_elapsed(ticks, _ux_utility_time_get()) <
            UX_MS_TO_TICK_NON_ZERO(ms_wait));
#else

    /* translate ms into ticks. */
    ticks = (ULONG)(ms_wait * UX_PERIODIC_RATE) / 1000;
 800f33c:	687b      	ldr	r3, [r7, #4]
 800f33e:	2264      	movs	r2, #100	; 0x64
 800f340:	fb02 f303 	mul.w	r3, r2, r3
 800f344:	4a07      	ldr	r2, [pc, #28]	; (800f364 <_ux_utility_delay_ms+0x30>)
 800f346:	fba2 2303 	umull	r2, r3, r2, r3
 800f34a:	099b      	lsrs	r3, r3, #6
 800f34c:	60fb      	str	r3, [r7, #12]
    
    /* For safety add 1 to ticks.  */
    ticks++;
 800f34e:	68fb      	ldr	r3, [r7, #12]
 800f350:	3301      	adds	r3, #1
 800f352:	60fb      	str	r3, [r7, #12]

    /* Call ThreadX sleep function.  */
    tx_thread_sleep(ticks);
 800f354:	68f8      	ldr	r0, [r7, #12]
 800f356:	f7fe fb1d 	bl	800d994 <_tx_thread_sleep>
#endif

    /* Return completion status.  */
    return;
 800f35a:	bf00      	nop
}
 800f35c:	3710      	adds	r7, #16
 800f35e:	46bd      	mov	sp, r7
 800f360:	bd80      	pop	{r7, pc}
 800f362:	bf00      	nop
 800f364:	10624dd3 	.word	0x10624dd3

0800f368 <_ux_utility_event_flags_create>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_event_flags_create(UX_EVENT_FLAGS_GROUP*group_ptr, CHAR *name)
{
 800f368:	b580      	push	{r7, lr}
 800f36a:	b084      	sub	sp, #16
 800f36c:	af00      	add	r7, sp, #0
 800f36e:	6078      	str	r0, [r7, #4]
 800f370:	6039      	str	r1, [r7, #0]

UINT    status;

    /* Call ThreadX to create the event flags.  */
    status =  tx_event_flags_create(group_ptr, name);
 800f372:	6839      	ldr	r1, [r7, #0]
 800f374:	6878      	ldr	r0, [r7, #4]
 800f376:	f7fc fb4b 	bl	800ba10 <_tx_event_flags_create>
 800f37a:	60f8      	str	r0, [r7, #12]

    /* Check for status.  */
    if (status != UX_SUCCESS)
 800f37c:	68fb      	ldr	r3, [r7, #12]
 800f37e:	2b00      	cmp	r3, #0
 800f380:	d004      	beq.n	800f38c <_ux_utility_event_flags_create+0x24>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, UX_EVENT_ERROR);
 800f382:	2218      	movs	r2, #24
 800f384:	2108      	movs	r1, #8
 800f386:	2002      	movs	r0, #2
 800f388:	f7ff ff00 	bl	800f18c <_ux_system_error_handler>
        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_EVENT_ERROR, group_ptr, 0, 0, UX_TRACE_ERRORS, 0, 0)

    }
    /* Return completion status.  */
    return(status);
 800f38c:	68fb      	ldr	r3, [r7, #12]
}
 800f38e:	4618      	mov	r0, r3
 800f390:	3710      	adds	r7, #16
 800f392:	46bd      	mov	sp, r7
 800f394:	bd80      	pop	{r7, pc}

0800f396 <_ux_utility_event_flags_delete>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_event_flags_delete(UX_EVENT_FLAGS_GROUP*group_ptr)            
{
 800f396:	b580      	push	{r7, lr}
 800f398:	b084      	sub	sp, #16
 800f39a:	af00      	add	r7, sp, #0
 800f39c:	6078      	str	r0, [r7, #4]

UINT    status;

    /* Call ThreadX to delete the event flags.  */
    status =  tx_event_flags_delete(group_ptr);
 800f39e:	6878      	ldr	r0, [r7, #4]
 800f3a0:	f7fc fb84 	bl	800baac <_tx_event_flags_delete>
 800f3a4:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
 800f3a6:	68fb      	ldr	r3, [r7, #12]
}
 800f3a8:	4618      	mov	r0, r3
 800f3aa:	3710      	adds	r7, #16
 800f3ac:	46bd      	mov	sp, r7
 800f3ae:	bd80      	pop	{r7, pc}

0800f3b0 <_ux_utility_event_flags_get>:
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_event_flags_get(UX_EVENT_FLAGS_GROUP*group_ptr, ULONG requested_flags, 
                                        UINT get_option, ULONG *actual_flags_ptr, ULONG wait_option)
{
 800f3b0:	b580      	push	{r7, lr}
 800f3b2:	b088      	sub	sp, #32
 800f3b4:	af02      	add	r7, sp, #8
 800f3b6:	60f8      	str	r0, [r7, #12]
 800f3b8:	60b9      	str	r1, [r7, #8]
 800f3ba:	607a      	str	r2, [r7, #4]
 800f3bc:	603b      	str	r3, [r7, #0]

UINT    status;
ULONG   local_actual_flags_ptr;

    /* Call ThreadX to get the event flags.  */
    status =  tx_event_flags_get(group_ptr, requested_flags, get_option, &local_actual_flags_ptr, wait_option);
 800f3be:	f107 0210 	add.w	r2, r7, #16
 800f3c2:	6a3b      	ldr	r3, [r7, #32]
 800f3c4:	9300      	str	r3, [sp, #0]
 800f3c6:	4613      	mov	r3, r2
 800f3c8:	687a      	ldr	r2, [r7, #4]
 800f3ca:	68b9      	ldr	r1, [r7, #8]
 800f3cc:	68f8      	ldr	r0, [r7, #12]
 800f3ce:	f7fc fbfd 	bl	800bbcc <_tx_event_flags_get>
 800f3d2:	6178      	str	r0, [r7, #20]

    /* Update the actual flags.  */
    *actual_flags_ptr = local_actual_flags_ptr;
 800f3d4:	693a      	ldr	r2, [r7, #16]
 800f3d6:	683b      	ldr	r3, [r7, #0]
 800f3d8:	601a      	str	r2, [r3, #0]
    
    /* Return completion status.  */
    return(status);
 800f3da:	697b      	ldr	r3, [r7, #20]
}
 800f3dc:	4618      	mov	r0, r3
 800f3de:	3718      	adds	r7, #24
 800f3e0:	46bd      	mov	sp, r7
 800f3e2:	bd80      	pop	{r7, pc}

0800f3e4 <_ux_utility_event_flags_set>:
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_event_flags_set(UX_EVENT_FLAGS_GROUP*group_ptr, ULONG flags_to_set,
                                  UINT set_option)
{
 800f3e4:	b580      	push	{r7, lr}
 800f3e6:	b086      	sub	sp, #24
 800f3e8:	af00      	add	r7, sp, #0
 800f3ea:	60f8      	str	r0, [r7, #12]
 800f3ec:	60b9      	str	r1, [r7, #8]
 800f3ee:	607a      	str	r2, [r7, #4]

UINT    status;

    /* Call ThreadX to set the event flags.  */
    status =  tx_event_flags_set(group_ptr, flags_to_set, set_option);
 800f3f0:	687a      	ldr	r2, [r7, #4]
 800f3f2:	68b9      	ldr	r1, [r7, #8]
 800f3f4:	68f8      	ldr	r0, [r7, #12]
 800f3f6:	f7fc fcd3 	bl	800bda0 <_tx_event_flags_set>
 800f3fa:	6178      	str	r0, [r7, #20]

    /* Return completion status.  */
    return(status);
 800f3fc:	697b      	ldr	r3, [r7, #20]
}
 800f3fe:	4618      	mov	r0, r3
 800f400:	3718      	adds	r7, #24
 800f402:	46bd      	mov	sp, r7
 800f404:	bd80      	pop	{r7, pc}

0800f406 <_ux_utility_long_get>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG  _ux_utility_long_get(UCHAR * address)
{
 800f406:	b480      	push	{r7}
 800f408:	b085      	sub	sp, #20
 800f40a:	af00      	add	r7, sp, #0
 800f40c:	6078      	str	r0, [r7, #4]
ULONG    value;


    /* In order to make this function endian agnostic and memory alignment
       independent, we read a byte at a time from the address.  */
    value =   (ULONG) *address++;
 800f40e:	687b      	ldr	r3, [r7, #4]
 800f410:	1c5a      	adds	r2, r3, #1
 800f412:	607a      	str	r2, [r7, #4]
 800f414:	781b      	ldrb	r3, [r3, #0]
 800f416:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG)*address++ << 8;
 800f418:	687b      	ldr	r3, [r7, #4]
 800f41a:	1c5a      	adds	r2, r3, #1
 800f41c:	607a      	str	r2, [r7, #4]
 800f41e:	781b      	ldrb	r3, [r3, #0]
 800f420:	021b      	lsls	r3, r3, #8
 800f422:	68fa      	ldr	r2, [r7, #12]
 800f424:	4313      	orrs	r3, r2
 800f426:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG)*address++ << 16;
 800f428:	687b      	ldr	r3, [r7, #4]
 800f42a:	1c5a      	adds	r2, r3, #1
 800f42c:	607a      	str	r2, [r7, #4]
 800f42e:	781b      	ldrb	r3, [r3, #0]
 800f430:	041b      	lsls	r3, r3, #16
 800f432:	68fa      	ldr	r2, [r7, #12]
 800f434:	4313      	orrs	r3, r2
 800f436:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG)*address << 24;
 800f438:	687b      	ldr	r3, [r7, #4]
 800f43a:	781b      	ldrb	r3, [r3, #0]
 800f43c:	061b      	lsls	r3, r3, #24
 800f43e:	68fa      	ldr	r2, [r7, #12]
 800f440:	4313      	orrs	r3, r2
 800f442:	60fb      	str	r3, [r7, #12]

    /* Return 32-bit value.  */
    return(value);
 800f444:	68fb      	ldr	r3, [r7, #12]
}
 800f446:	4618      	mov	r0, r3
 800f448:	3714      	adds	r7, #20
 800f44a:	46bd      	mov	sp, r7
 800f44c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f450:	4770      	bx	lr

0800f452 <_ux_utility_long_get_big_endian>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG  _ux_utility_long_get_big_endian(UCHAR * address)
{
 800f452:	b480      	push	{r7}
 800f454:	b085      	sub	sp, #20
 800f456:	af00      	add	r7, sp, #0
 800f458:	6078      	str	r0, [r7, #4]

ULONG  value;


    /* We read a byte at a time from the address.  */
    value =  (ULONG) ((*address++) << 24);
 800f45a:	687b      	ldr	r3, [r7, #4]
 800f45c:	1c5a      	adds	r2, r3, #1
 800f45e:	607a      	str	r2, [r7, #4]
 800f460:	781b      	ldrb	r3, [r3, #0]
 800f462:	061b      	lsls	r3, r3, #24
 800f464:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG) ((*address++) << 16);
 800f466:	687b      	ldr	r3, [r7, #4]
 800f468:	1c5a      	adds	r2, r3, #1
 800f46a:	607a      	str	r2, [r7, #4]
 800f46c:	781b      	ldrb	r3, [r3, #0]
 800f46e:	041b      	lsls	r3, r3, #16
 800f470:	461a      	mov	r2, r3
 800f472:	68fb      	ldr	r3, [r7, #12]
 800f474:	4313      	orrs	r3, r2
 800f476:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG) ((*address++) << 8);
 800f478:	687b      	ldr	r3, [r7, #4]
 800f47a:	1c5a      	adds	r2, r3, #1
 800f47c:	607a      	str	r2, [r7, #4]
 800f47e:	781b      	ldrb	r3, [r3, #0]
 800f480:	021b      	lsls	r3, r3, #8
 800f482:	461a      	mov	r2, r3
 800f484:	68fb      	ldr	r3, [r7, #12]
 800f486:	4313      	orrs	r3, r2
 800f488:	60fb      	str	r3, [r7, #12]
    value |=  (ULONG) *address;
 800f48a:	687b      	ldr	r3, [r7, #4]
 800f48c:	781b      	ldrb	r3, [r3, #0]
 800f48e:	461a      	mov	r2, r3
 800f490:	68fb      	ldr	r3, [r7, #12]
 800f492:	4313      	orrs	r3, r2
 800f494:	60fb      	str	r3, [r7, #12]

    /* Return 32-bit value.  */
    return(value);
 800f496:	68fb      	ldr	r3, [r7, #12]
}
 800f498:	4618      	mov	r0, r3
 800f49a:	3714      	adds	r7, #20
 800f49c:	46bd      	mov	sp, r7
 800f49e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f4a2:	4770      	bx	lr

0800f4a4 <_ux_utility_long_put>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_long_put(UCHAR * address, ULONG value)
{
 800f4a4:	b480      	push	{r7}
 800f4a6:	b083      	sub	sp, #12
 800f4a8:	af00      	add	r7, sp, #0
 800f4aa:	6078      	str	r0, [r7, #4]
 800f4ac:	6039      	str	r1, [r7, #0]

    /* In order to make this function endian agnostic and memory alignment
       independent, we write a byte at a time from the address.  */
    *address++ =  (UCHAR) (value & 0xff);
 800f4ae:	687b      	ldr	r3, [r7, #4]
 800f4b0:	1c5a      	adds	r2, r3, #1
 800f4b2:	607a      	str	r2, [r7, #4]
 800f4b4:	683a      	ldr	r2, [r7, #0]
 800f4b6:	b2d2      	uxtb	r2, r2
 800f4b8:	701a      	strb	r2, [r3, #0]
    *address++ =  (UCHAR) ((value >> 8) & 0xff);
 800f4ba:	683b      	ldr	r3, [r7, #0]
 800f4bc:	0a19      	lsrs	r1, r3, #8
 800f4be:	687b      	ldr	r3, [r7, #4]
 800f4c0:	1c5a      	adds	r2, r3, #1
 800f4c2:	607a      	str	r2, [r7, #4]
 800f4c4:	b2ca      	uxtb	r2, r1
 800f4c6:	701a      	strb	r2, [r3, #0]
    *address++ =  (UCHAR) ((value >> 16) & 0xff);
 800f4c8:	683b      	ldr	r3, [r7, #0]
 800f4ca:	0c19      	lsrs	r1, r3, #16
 800f4cc:	687b      	ldr	r3, [r7, #4]
 800f4ce:	1c5a      	adds	r2, r3, #1
 800f4d0:	607a      	str	r2, [r7, #4]
 800f4d2:	b2ca      	uxtb	r2, r1
 800f4d4:	701a      	strb	r2, [r3, #0]
    *address =    (UCHAR) ((value >> 24) & 0xff);
 800f4d6:	683b      	ldr	r3, [r7, #0]
 800f4d8:	0e1b      	lsrs	r3, r3, #24
 800f4da:	b2da      	uxtb	r2, r3
 800f4dc:	687b      	ldr	r3, [r7, #4]
 800f4de:	701a      	strb	r2, [r3, #0]

    /* Return to caller.  */
    return;
 800f4e0:	bf00      	nop
}
 800f4e2:	370c      	adds	r7, #12
 800f4e4:	46bd      	mov	sp, r7
 800f4e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f4ea:	4770      	bx	lr

0800f4ec <_ux_utility_long_put_big_endian>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_long_put_big_endian(UCHAR * address, ULONG value)
{
 800f4ec:	b480      	push	{r7}
 800f4ee:	b085      	sub	sp, #20
 800f4f0:	af00      	add	r7, sp, #0
 800f4f2:	6078      	str	r0, [r7, #4]
 800f4f4:	6039      	str	r1, [r7, #0]

ULONG   low_word_value;
ULONG   high_word_value;

    /* First we swap the value words.  */
    low_word_value =  value >> 16;
 800f4f6:	683b      	ldr	r3, [r7, #0]
 800f4f8:	0c1b      	lsrs	r3, r3, #16
 800f4fa:	60fb      	str	r3, [r7, #12]
    high_word_value =  value << 16;
 800f4fc:	683b      	ldr	r3, [r7, #0]
 800f4fe:	041b      	lsls	r3, r3, #16
 800f500:	60bb      	str	r3, [r7, #8]
    value =  high_word_value | low_word_value;
 800f502:	68ba      	ldr	r2, [r7, #8]
 800f504:	68fb      	ldr	r3, [r7, #12]
 800f506:	4313      	orrs	r3, r2
 800f508:	603b      	str	r3, [r7, #0]

    /* In order to make this function endian agnostic and memory alignment
       independent, we write a byte at a time from the address.  */
    *address++ =  (UCHAR) ((value >> 8) & 0xff);
 800f50a:	683b      	ldr	r3, [r7, #0]
 800f50c:	0a19      	lsrs	r1, r3, #8
 800f50e:	687b      	ldr	r3, [r7, #4]
 800f510:	1c5a      	adds	r2, r3, #1
 800f512:	607a      	str	r2, [r7, #4]
 800f514:	b2ca      	uxtb	r2, r1
 800f516:	701a      	strb	r2, [r3, #0]
    *address++ =  (UCHAR) (value & 0xff);
 800f518:	687b      	ldr	r3, [r7, #4]
 800f51a:	1c5a      	adds	r2, r3, #1
 800f51c:	607a      	str	r2, [r7, #4]
 800f51e:	683a      	ldr	r2, [r7, #0]
 800f520:	b2d2      	uxtb	r2, r2
 800f522:	701a      	strb	r2, [r3, #0]
    *address++ =  (UCHAR) ((value >> 24 ) & 0xff);
 800f524:	683b      	ldr	r3, [r7, #0]
 800f526:	0e19      	lsrs	r1, r3, #24
 800f528:	687b      	ldr	r3, [r7, #4]
 800f52a:	1c5a      	adds	r2, r3, #1
 800f52c:	607a      	str	r2, [r7, #4]
 800f52e:	b2ca      	uxtb	r2, r1
 800f530:	701a      	strb	r2, [r3, #0]
    *address   =  (UCHAR) ((value >> 16) & 0xff);
 800f532:	683b      	ldr	r3, [r7, #0]
 800f534:	0c1b      	lsrs	r3, r3, #16
 800f536:	b2da      	uxtb	r2, r3
 800f538:	687b      	ldr	r3, [r7, #4]
 800f53a:	701a      	strb	r2, [r3, #0]

    /* Return to caller.  */
    return;
 800f53c:	bf00      	nop
}
 800f53e:	3714      	adds	r7, #20
 800f540:	46bd      	mov	sp, r7
 800f542:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f546:	4770      	bx	lr

0800f548 <_ux_utility_memory_allocate>:
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  *_ux_utility_memory_allocate(ULONG memory_alignment, ULONG memory_cache_flag,
                                   ULONG memory_size_requested)
{
 800f548:	b580      	push	{r7, lr}
 800f54a:	b08c      	sub	sp, #48	; 0x30
 800f54c:	af00      	add	r7, sp, #0
 800f54e:	60f8      	str	r0, [r7, #12]
 800f550:	60b9      	str	r1, [r7, #8]
 800f552:	607a      	str	r2, [r7, #4]
UCHAR               *memory_buffer;
ALIGN_TYPE          int_memory_buffer;


    /* Get the mutex as this is a critical section.  */
    _ux_system_mutex_on(&_ux_system -> ux_system_mutex);
 800f554:	4b7d      	ldr	r3, [pc, #500]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f556:	681b      	ldr	r3, [r3, #0]
 800f558:	331c      	adds	r3, #28
 800f55a:	4618      	mov	r0, r3
 800f55c:	f000 fa64 	bl	800fa28 <_ux_utility_mutex_on>
    }

#else

    /* Check if safe alignment requested, in this case switch to UX_NO_ALIGN.  */
    if (memory_alignment == UX_SAFE_ALIGN)
 800f560:	68fb      	ldr	r3, [r7, #12]
 800f562:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f566:	d101      	bne.n	800f56c <_ux_utility_memory_allocate+0x24>
        memory_alignment = UX_NO_ALIGN;
 800f568:	2300      	movs	r3, #0
 800f56a:	60fb      	str	r3, [r7, #12]
    
#endif

    /* Ensure the alignment meats the minimum.  */
    if (memory_alignment < UX_ALIGN_MIN)
 800f56c:	68fb      	ldr	r3, [r7, #12]
 800f56e:	2b0e      	cmp	r3, #14
 800f570:	d801      	bhi.n	800f576 <_ux_utility_memory_allocate+0x2e>
        memory_alignment =  UX_ALIGN_MIN;
 800f572:	230f      	movs	r3, #15
 800f574:	60fb      	str	r3, [r7, #12]

    /* Adjust the memory alignment since our macros are one minus the desired alignment.
       Also determine the amount of extra memory we need for the alignment, which is one
       minus the actual alignment.  */
    memory_for_alignment =  memory_alignment;
 800f576:	68fb      	ldr	r3, [r7, #12]
 800f578:	627b      	str	r3, [r7, #36]	; 0x24
    memory_alignment++;
 800f57a:	68fb      	ldr	r3, [r7, #12]
 800f57c:	3301      	adds	r3, #1
 800f57e:	60fb      	str	r3, [r7, #12]
       now is that the memory block might not be a size that is a multiple of 16, so we need
       to add the amount of memory required such that the memory buffer after the block has 
       the correct alignment. For example, if the memory block has a size of 24, then we need
       to make sure it is placed on an 8-byte alignment that is after a 16-byte alignment so
       that the memory right after the memory block is 16-byte aligned (8 + 24 = 32).  */
    memory_size_requested =  (memory_size_requested +    UX_ALIGN_MIN) & (~(ULONG)UX_ALIGN_MIN);
 800f580:	687b      	ldr	r3, [r7, #4]
 800f582:	330f      	adds	r3, #15
 800f584:	f023 030f 	bic.w	r3, r3, #15
 800f588:	607b      	str	r3, [r7, #4]
    /* Try to find the best block for this memory by requesting the maximum amount of
       memory we'll need which is calculated as follows: the amount memory requested by
       the caller plus the maximum amount of memory wasted due to alignment plus 2 memory
       blocks structs - one for the new memory block we'll create for the user block and one
       that we might create if there is extra memory after doing the alignment.  */
    memory_block =  _ux_utility_memory_free_block_best_get(memory_cache_flag, memory_size_requested + memory_for_alignment + (ULONG)sizeof(UX_MEMORY_BLOCK));
 800f58a:	687a      	ldr	r2, [r7, #4]
 800f58c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f58e:	4413      	add	r3, r2
 800f590:	3310      	adds	r3, #16
 800f592:	4619      	mov	r1, r3
 800f594:	68b8      	ldr	r0, [r7, #8]
 800f596:	f000 f9bb 	bl	800f910 <_ux_utility_memory_free_block_best_get>
 800f59a:	62f8      	str	r0, [r7, #44]	; 0x2c

    /* If the block returned is NULL, there is no free memory in the pool
       for that size. */
    if (memory_block == UX_NULL)
 800f59c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f59e:	2b00      	cmp	r3, #0
 800f5a0:	d10c      	bne.n	800f5bc <_ux_utility_memory_allocate+0x74>
    {

        /* Release the protection.  */
        _ux_system_mutex_off(&_ux_system -> ux_system_mutex);
 800f5a2:	4b6a      	ldr	r3, [pc, #424]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f5a4:	681b      	ldr	r3, [r3, #0]
 800f5a6:	331c      	adds	r3, #28
 800f5a8:	4618      	mov	r0, r3
 800f5aa:	f000 fa32 	bl	800fa12 <_ux_utility_mutex_off>

        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MEMORY_INSUFFICIENT, memory_size_requested, 0, 0, UX_TRACE_ERRORS, 0, 0)

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, UX_MEMORY_INSUFFICIENT);
 800f5ae:	2212      	movs	r2, #18
 800f5b0:	2108      	movs	r1, #8
 800f5b2:	2002      	movs	r0, #2
 800f5b4:	f7ff fdea 	bl	800f18c <_ux_system_error_handler>

        /* Return NULL to indicate no block was found.  */
        return(UX_NULL);
 800f5b8:	2300      	movs	r3, #0
 800f5ba:	e0c3      	b.n	800f744 <_ux_utility_memory_allocate+0x1fc>
    }

    /* Get the memory buffer for this block.  */
    int_memory_buffer = (ALIGN_TYPE) ((UCHAR *) memory_block + sizeof(UX_MEMORY_BLOCK));
 800f5bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f5be:	3310      	adds	r3, #16
 800f5c0:	623b      	str	r3, [r7, #32]

    /* Are we already aligned?  */
    if ((int_memory_buffer & (memory_alignment - 1)) == 0)
 800f5c2:	68fb      	ldr	r3, [r7, #12]
 800f5c4:	1e5a      	subs	r2, r3, #1
 800f5c6:	6a3b      	ldr	r3, [r7, #32]
 800f5c8:	4013      	ands	r3, r2
 800f5ca:	2b00      	cmp	r3, #0
 800f5cc:	d126      	bne.n	800f61c <_ux_utility_memory_allocate+0xd4>
    {

        /* Setup the new memory block.  */
        new_memory_block =  (UX_MEMORY_BLOCK *) ((UCHAR *) memory_block + sizeof(UX_MEMORY_BLOCK) + memory_size_requested);
 800f5ce:	687b      	ldr	r3, [r7, #4]
 800f5d0:	3310      	adds	r3, #16
 800f5d2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800f5d4:	4413      	add	r3, r2
 800f5d6:	61fb      	str	r3, [r7, #28]
        new_memory_block -> ux_memory_block_next =  memory_block -> ux_memory_block_next;
 800f5d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f5da:	689a      	ldr	r2, [r3, #8]
 800f5dc:	69fb      	ldr	r3, [r7, #28]
 800f5de:	609a      	str	r2, [r3, #8]
        new_memory_block -> ux_memory_block_previous =  memory_block;
 800f5e0:	69fb      	ldr	r3, [r7, #28]
 800f5e2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800f5e4:	60da      	str	r2, [r3, #12]
        new_memory_block -> ux_memory_block_size =  memory_block -> ux_memory_block_size - memory_size_requested - (ULONG)sizeof(UX_MEMORY_BLOCK);
 800f5e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f5e8:	681a      	ldr	r2, [r3, #0]
 800f5ea:	687b      	ldr	r3, [r7, #4]
 800f5ec:	1ad3      	subs	r3, r2, r3
 800f5ee:	f1a3 0210 	sub.w	r2, r3, #16
 800f5f2:	69fb      	ldr	r3, [r7, #28]
 800f5f4:	601a      	str	r2, [r3, #0]
        new_memory_block -> ux_memory_block_status =  UX_MEMORY_UNUSED;
 800f5f6:	69fb      	ldr	r3, [r7, #28]
 800f5f8:	2200      	movs	r2, #0
 800f5fa:	605a      	str	r2, [r3, #4]

        /* Update the current memory block.  */
        memory_block -> ux_memory_block_size =  memory_size_requested;
 800f5fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f5fe:	687a      	ldr	r2, [r7, #4]
 800f600:	601a      	str	r2, [r3, #0]
        memory_block -> ux_memory_block_next =  new_memory_block;
 800f602:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f604:	69fa      	ldr	r2, [r7, #28]
 800f606:	609a      	str	r2, [r3, #8]
        memory_block -> ux_memory_block_status =  UX_MEMORY_USED | memory_cache_flag;
 800f608:	68bb      	ldr	r3, [r7, #8]
 800f60a:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 800f60e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f610:	605a      	str	r2, [r3, #4]

        /* Declare how much memory we removed from the pool.  */
        memory_removed_from_pool =  memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 800f612:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f614:	681b      	ldr	r3, [r3, #0]
 800f616:	3310      	adds	r3, #16
 800f618:	62bb      	str	r3, [r7, #40]	; 0x28
 800f61a:	e05e      	b.n	800f6da <_ux_utility_memory_allocate+0x192>
    {

        /* Align the buffer. The first thing we do is increment by the size of a
           memory block because we have to make sure we have enough memory for at
           least that.  */
        int_memory_buffer +=  (ULONG)sizeof(UX_MEMORY_BLOCK);
 800f61c:	6a3b      	ldr	r3, [r7, #32]
 800f61e:	3310      	adds	r3, #16
 800f620:	623b      	str	r3, [r7, #32]
        int_memory_buffer +=  memory_alignment - 1;
 800f622:	68fa      	ldr	r2, [r7, #12]
 800f624:	6a3b      	ldr	r3, [r7, #32]
 800f626:	4413      	add	r3, r2
 800f628:	3b01      	subs	r3, #1
 800f62a:	623b      	str	r3, [r7, #32]
        int_memory_buffer &=  ~(((ALIGN_TYPE) memory_alignment) - 1);
 800f62c:	68fb      	ldr	r3, [r7, #12]
 800f62e:	425b      	negs	r3, r3
 800f630:	6a3a      	ldr	r2, [r7, #32]
 800f632:	4013      	ands	r3, r2
 800f634:	623b      	str	r3, [r7, #32]

        /* Setup the new memory block. Note that its size is updated again later.  */
        new_memory_block =  (UX_MEMORY_BLOCK *) (int_memory_buffer - (ULONG)sizeof(UX_MEMORY_BLOCK));
 800f636:	6a3b      	ldr	r3, [r7, #32]
 800f638:	3b10      	subs	r3, #16
 800f63a:	61fb      	str	r3, [r7, #28]
        new_memory_block -> ux_memory_block_previous =  memory_block;
 800f63c:	69fb      	ldr	r3, [r7, #28]
 800f63e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800f640:	60da      	str	r2, [r3, #12]
        new_memory_block -> ux_memory_block_next =  memory_block -> ux_memory_block_next;
 800f642:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f644:	689a      	ldr	r2, [r3, #8]
 800f646:	69fb      	ldr	r3, [r7, #28]
 800f648:	609a      	str	r2, [r3, #8]
        new_memory_block -> ux_memory_block_size =  memory_block -> ux_memory_block_size;
 800f64a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f64c:	681a      	ldr	r2, [r3, #0]
 800f64e:	69fb      	ldr	r3, [r7, #28]
 800f650:	601a      	str	r2, [r3, #0]
        new_memory_block -> ux_memory_block_status =  UX_MEMORY_USED | memory_cache_flag;
 800f652:	68bb      	ldr	r3, [r7, #8]
 800f654:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 800f658:	69fb      	ldr	r3, [r7, #28]
 800f65a:	605a      	str	r2, [r3, #4]

        /* Update the current memory block.  */
        int_memory_buffer =  (ALIGN_TYPE) ((UCHAR *) memory_block + sizeof(UX_MEMORY_BLOCK));
 800f65c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f65e:	3310      	adds	r3, #16
 800f660:	623b      	str	r3, [r7, #32]
        memory_block -> ux_memory_block_next =  new_memory_block;
 800f662:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f664:	69fa      	ldr	r2, [r7, #28]
 800f666:	609a      	str	r2, [r3, #8]
        memory_block -> ux_memory_block_size =  (ULONG) ((ALIGN_TYPE) new_memory_block - int_memory_buffer);
 800f668:	69fa      	ldr	r2, [r7, #28]
 800f66a:	6a3b      	ldr	r3, [r7, #32]
 800f66c:	1ad2      	subs	r2, r2, r3
 800f66e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f670:	601a      	str	r2, [r3, #0]

        /* Update the new memory block's size.  */
        new_memory_block -> ux_memory_block_size -=  (memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK));
 800f672:	69fb      	ldr	r3, [r7, #28]
 800f674:	681a      	ldr	r2, [r3, #0]
 800f676:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f678:	681b      	ldr	r3, [r3, #0]
 800f67a:	1ad3      	subs	r3, r2, r3
 800f67c:	f1a3 0210 	sub.w	r2, r3, #16
 800f680:	69fb      	ldr	r3, [r7, #28]
 800f682:	601a      	str	r2, [r3, #0]

        /* Calculate how much memory is leftover in the new memory block after doing
           the alignment.  */
        leftover =  new_memory_block -> ux_memory_block_size - memory_size_requested;
 800f684:	69fb      	ldr	r3, [r7, #28]
 800f686:	681a      	ldr	r2, [r3, #0]
 800f688:	687b      	ldr	r3, [r7, #4]
 800f68a:	1ad3      	subs	r3, r2, r3
 800f68c:	61bb      	str	r3, [r7, #24]

        /* Can we fit another block after the new block? */
        if (leftover > sizeof(UX_MEMORY_BLOCK))
 800f68e:	69bb      	ldr	r3, [r7, #24]
 800f690:	2b10      	cmp	r3, #16
 800f692:	d91c      	bls.n	800f6ce <_ux_utility_memory_allocate+0x186>
        {

            /* Setup the leftover memory block.  */
            leftover_memory_block = (UX_MEMORY_BLOCK *) (((ALIGN_TYPE) new_memory_block + sizeof(UX_MEMORY_BLOCK) + memory_size_requested) & 0xFFFFFFFFu);
 800f694:	69fa      	ldr	r2, [r7, #28]
 800f696:	687b      	ldr	r3, [r7, #4]
 800f698:	4413      	add	r3, r2
 800f69a:	3310      	adds	r3, #16
 800f69c:	617b      	str	r3, [r7, #20]
            leftover_memory_block -> ux_memory_block_next =  new_memory_block -> ux_memory_block_next;
 800f69e:	69fb      	ldr	r3, [r7, #28]
 800f6a0:	689a      	ldr	r2, [r3, #8]
 800f6a2:	697b      	ldr	r3, [r7, #20]
 800f6a4:	609a      	str	r2, [r3, #8]
            leftover_memory_block -> ux_memory_block_previous =  new_memory_block;
 800f6a6:	697b      	ldr	r3, [r7, #20]
 800f6a8:	69fa      	ldr	r2, [r7, #28]
 800f6aa:	60da      	str	r2, [r3, #12]
            leftover_memory_block -> ux_memory_block_size =  leftover - (ULONG)sizeof(UX_MEMORY_BLOCK);
 800f6ac:	69bb      	ldr	r3, [r7, #24]
 800f6ae:	f1a3 0210 	sub.w	r2, r3, #16
 800f6b2:	697b      	ldr	r3, [r7, #20]
 800f6b4:	601a      	str	r2, [r3, #0]
            leftover_memory_block -> ux_memory_block_status =  UX_MEMORY_UNUSED;
 800f6b6:	697b      	ldr	r3, [r7, #20]
 800f6b8:	2200      	movs	r2, #0
 800f6ba:	605a      	str	r2, [r3, #4]

            new_memory_block -> ux_memory_block_next =  leftover_memory_block;
 800f6bc:	69fb      	ldr	r3, [r7, #28]
 800f6be:	697a      	ldr	r2, [r7, #20]
 800f6c0:	609a      	str	r2, [r3, #8]
            new_memory_block -> ux_memory_block_size -=  leftover;
 800f6c2:	69fb      	ldr	r3, [r7, #28]
 800f6c4:	681a      	ldr	r2, [r3, #0]
 800f6c6:	69bb      	ldr	r3, [r7, #24]
 800f6c8:	1ad2      	subs	r2, r2, r3
 800f6ca:	69fb      	ldr	r3, [r7, #28]
 800f6cc:	601a      	str	r2, [r3, #0]
        }

        /* Declare how much memory we removed from the pool.  */
        memory_removed_from_pool =  new_memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 800f6ce:	69fb      	ldr	r3, [r7, #28]
 800f6d0:	681b      	ldr	r3, [r3, #0]
 800f6d2:	3310      	adds	r3, #16
 800f6d4:	62bb      	str	r3, [r7, #40]	; 0x28

        /* The new memory block is the one we give to the user.  */
        memory_block =  new_memory_block;
 800f6d6:	69fb      	ldr	r3, [r7, #28]
 800f6d8:	62fb      	str	r3, [r7, #44]	; 0x2c
    }

    /* The memory to be returned is after the block header.  */
    memory_buffer =  ((UCHAR *) memory_block) + sizeof(UX_MEMORY_BLOCK);
 800f6da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f6dc:	3310      	adds	r3, #16
 800f6de:	613b      	str	r3, [r7, #16]

    /* Clear the memory block.  */
    _ux_utility_memory_set(memory_buffer, 0, memory_size_requested); /* Use case of memset is verified. */
 800f6e0:	687a      	ldr	r2, [r7, #4]
 800f6e2:	2100      	movs	r1, #0
 800f6e4:	6938      	ldr	r0, [r7, #16]
 800f6e6:	f000 f955 	bl	800f994 <_ux_utility_memory_set>

    /* Update the memory free in the pool.  */
    if (_ux_system -> ux_system_cache_safe_memory_pool_start == _ux_system -> ux_system_regular_memory_pool_start)
 800f6ea:	4b18      	ldr	r3, [pc, #96]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f6ec:	681b      	ldr	r3, [r3, #0]
 800f6ee:	68da      	ldr	r2, [r3, #12]
 800f6f0:	4b16      	ldr	r3, [pc, #88]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f6f2:	681b      	ldr	r3, [r3, #0]
 800f6f4:	681b      	ldr	r3, [r3, #0]
 800f6f6:	429a      	cmp	r2, r3
 800f6f8:	d108      	bne.n	800f70c <_ux_utility_memory_allocate+0x1c4>
    {

        /* There is only one memory pool.  */
        _ux_system -> ux_system_regular_memory_pool_free -= memory_removed_from_pool;
 800f6fa:	4b14      	ldr	r3, [pc, #80]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f6fc:	681b      	ldr	r3, [r3, #0]
 800f6fe:	6899      	ldr	r1, [r3, #8]
 800f700:	4b12      	ldr	r3, [pc, #72]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f702:	681b      	ldr	r3, [r3, #0]
 800f704:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f706:	1a8a      	subs	r2, r1, r2
 800f708:	609a      	str	r2, [r3, #8]
 800f70a:	e014      	b.n	800f736 <_ux_utility_memory_allocate+0x1ee>
    }
    else
    {

       switch (memory_cache_flag)
 800f70c:	68bb      	ldr	r3, [r7, #8]
 800f70e:	2b01      	cmp	r3, #1
 800f710:	d108      	bne.n	800f724 <_ux_utility_memory_allocate+0x1dc>
       {

            case UX_CACHE_SAFE_MEMORY:
                /* Update the amount of free memory in the cache safe memory pool.  */
                _ux_system -> ux_system_cache_safe_memory_pool_free -= memory_removed_from_pool;
 800f712:	4b0e      	ldr	r3, [pc, #56]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f714:	681b      	ldr	r3, [r3, #0]
 800f716:	6959      	ldr	r1, [r3, #20]
 800f718:	4b0c      	ldr	r3, [pc, #48]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f71a:	681b      	ldr	r3, [r3, #0]
 800f71c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f71e:	1a8a      	subs	r2, r1, r2
 800f720:	615a      	str	r2, [r3, #20]

            break;
 800f722:	e008      	b.n	800f736 <_ux_utility_memory_allocate+0x1ee>

            default:
                /* Update the amount of free memory in the regular memory pool.  */
                _ux_system -> ux_system_regular_memory_pool_free -= memory_removed_from_pool;
 800f724:	4b09      	ldr	r3, [pc, #36]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f726:	681b      	ldr	r3, [r3, #0]
 800f728:	6899      	ldr	r1, [r3, #8]
 800f72a:	4b08      	ldr	r3, [pc, #32]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f72c:	681b      	ldr	r3, [r3, #0]
 800f72e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800f730:	1a8a      	subs	r2, r1, r2
 800f732:	609a      	str	r2, [r3, #8]
            break;
 800f734:	bf00      	nop
        _ux_system -> ux_system_cache_safe_memory_pool_min_free = _ux_system -> ux_system_cache_safe_memory_pool_free;

#endif

    /* Release the protection.  */
    _ux_system_mutex_off(&_ux_system -> ux_system_mutex);
 800f736:	4b05      	ldr	r3, [pc, #20]	; (800f74c <_ux_utility_memory_allocate+0x204>)
 800f738:	681b      	ldr	r3, [r3, #0]
 800f73a:	331c      	adds	r3, #28
 800f73c:	4618      	mov	r0, r3
 800f73e:	f000 f968 	bl	800fa12 <_ux_utility_mutex_off>

    /* The memory block pointer contains a memory area properly
       aligned.  */
    return(memory_buffer);
 800f742:	693b      	ldr	r3, [r7, #16]
}                                
 800f744:	4618      	mov	r0, r3
 800f746:	3730      	adds	r7, #48	; 0x30
 800f748:	46bd      	mov	sp, r7
 800f74a:	bd80      	pop	{r7, pc}
 800f74c:	20007310 	.word	0x20007310

0800f750 <_ux_utility_memory_allocate_mulc_safe>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID* _ux_utility_memory_allocate_mulc_safe(ULONG align,ULONG cache,ULONG size_mul_v,ULONG size_mul_c)
{
 800f750:	b580      	push	{r7, lr}
 800f752:	b084      	sub	sp, #16
 800f754:	af00      	add	r7, sp, #0
 800f756:	60f8      	str	r0, [r7, #12]
 800f758:	60b9      	str	r1, [r7, #8]
 800f75a:	607a      	str	r2, [r7, #4]
 800f75c:	603b      	str	r3, [r7, #0]
    return UX_UTILITY_MEMORY_ALLOCATE_MULC_SAFE(align, cache, size_mul_v, size_mul_c);
 800f75e:	683b      	ldr	r3, [r7, #0]
 800f760:	2b00      	cmp	r3, #0
 800f762:	d00a      	beq.n	800f77a <_ux_utility_memory_allocate_mulc_safe+0x2a>
 800f764:	2100      	movs	r1, #0
 800f766:	687a      	ldr	r2, [r7, #4]
 800f768:	683b      	ldr	r3, [r7, #0]
 800f76a:	fba3 2302 	umull	r2, r3, r3, r2
 800f76e:	2b00      	cmp	r3, #0
 800f770:	d000      	beq.n	800f774 <_ux_utility_memory_allocate_mulc_safe+0x24>
 800f772:	2101      	movs	r1, #1
 800f774:	460b      	mov	r3, r1
 800f776:	2b00      	cmp	r3, #0
 800f778:	d10a      	bne.n	800f790 <_ux_utility_memory_allocate_mulc_safe+0x40>
 800f77a:	687b      	ldr	r3, [r7, #4]
 800f77c:	683a      	ldr	r2, [r7, #0]
 800f77e:	fb02 f303 	mul.w	r3, r2, r3
 800f782:	461a      	mov	r2, r3
 800f784:	68b9      	ldr	r1, [r7, #8]
 800f786:	68f8      	ldr	r0, [r7, #12]
 800f788:	f7ff fede 	bl	800f548 <_ux_utility_memory_allocate>
 800f78c:	4603      	mov	r3, r0
 800f78e:	e000      	b.n	800f792 <_ux_utility_memory_allocate_mulc_safe+0x42>
 800f790:	2300      	movs	r3, #0
}
 800f792:	4618      	mov	r0, r3
 800f794:	3710      	adds	r7, #16
 800f796:	46bd      	mov	sp, r7
 800f798:	bd80      	pop	{r7, pc}

0800f79a <_ux_utility_memory_copy>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_memory_copy(VOID *memory_destination, VOID *memory_source, ULONG length)
{
 800f79a:	b480      	push	{r7}
 800f79c:	b087      	sub	sp, #28
 800f79e:	af00      	add	r7, sp, #0
 800f7a0:	60f8      	str	r0, [r7, #12]
 800f7a2:	60b9      	str	r1, [r7, #8]
 800f7a4:	607a      	str	r2, [r7, #4]

UCHAR *   source;
UCHAR *   destination;

    /* Setup byte oriented source and destination pointers.  */
    source =  (UCHAR *) memory_source;
 800f7a6:	68bb      	ldr	r3, [r7, #8]
 800f7a8:	617b      	str	r3, [r7, #20]
    destination =  (UCHAR *) memory_destination;
 800f7aa:	68fb      	ldr	r3, [r7, #12]
 800f7ac:	613b      	str	r3, [r7, #16]

    /* Loop to perform the copy.  */
    while(length--)
 800f7ae:	e007      	b.n	800f7c0 <_ux_utility_memory_copy+0x26>
    {

        /* Copy one byte.  */
        *destination++ =  *source++;
 800f7b0:	697a      	ldr	r2, [r7, #20]
 800f7b2:	1c53      	adds	r3, r2, #1
 800f7b4:	617b      	str	r3, [r7, #20]
 800f7b6:	693b      	ldr	r3, [r7, #16]
 800f7b8:	1c59      	adds	r1, r3, #1
 800f7ba:	6139      	str	r1, [r7, #16]
 800f7bc:	7812      	ldrb	r2, [r2, #0]
 800f7be:	701a      	strb	r2, [r3, #0]
    while(length--)
 800f7c0:	687b      	ldr	r3, [r7, #4]
 800f7c2:	1e5a      	subs	r2, r3, #1
 800f7c4:	607a      	str	r2, [r7, #4]
 800f7c6:	2b00      	cmp	r3, #0
 800f7c8:	d1f2      	bne.n	800f7b0 <_ux_utility_memory_copy+0x16>
    }

    /* Return to caller.  */
    return; 
 800f7ca:	bf00      	nop
}
 800f7cc:	371c      	adds	r7, #28
 800f7ce:	46bd      	mov	sp, r7
 800f7d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f7d4:	4770      	bx	lr
	...

0800f7d8 <_ux_utility_memory_free>:
/*                                            added standalone support,   */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_memory_free(VOID *memory)
{
 800f7d8:	b580      	push	{r7, lr}
 800f7da:	b086      	sub	sp, #24
 800f7dc:	af00      	add	r7, sp, #0
 800f7de:	6078      	str	r0, [r7, #4]
UCHAR               *regular_start, *regular_end;
UCHAR               *cache_safe_start, *cache_safe_end;
#endif

    /* Get the mutex as this is a critical section.  */
    _ux_system_mutex_on(&_ux_system -> ux_system_mutex);
 800f7e0:	4b49      	ldr	r3, [pc, #292]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f7e2:	681b      	ldr	r3, [r3, #0]
 800f7e4:	331c      	adds	r3, #28
 800f7e6:	4618      	mov	r0, r3
 800f7e8:	f000 f91e 	bl	800fa28 <_ux_utility_mutex_on>
    }
#endif

    /* The memory block for this memory pointer is located right before the
       memory.  */
    memory_block =  (UX_MEMORY_BLOCK *) (((UCHAR *) memory) - sizeof(UX_MEMORY_BLOCK));
 800f7ec:	687b      	ldr	r3, [r7, #4]
 800f7ee:	3b10      	subs	r3, #16
 800f7f0:	617b      	str	r3, [r7, #20]
    
    /* Keep track of the memory returned to the pool.  */
    memory_size_returned = memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 800f7f2:	697b      	ldr	r3, [r7, #20]
 800f7f4:	681b      	ldr	r3, [r3, #0]
 800f7f6:	3310      	adds	r3, #16
 800f7f8:	60fb      	str	r3, [r7, #12]

    /* Check this memory block to see if it valid.  */
    if (memory_block -> ux_memory_block_status != (UX_MEMORY_USED | UX_REGULAR_MEMORY) &&
 800f7fa:	697b      	ldr	r3, [r7, #20]
 800f7fc:	685b      	ldr	r3, [r3, #4]
 800f7fe:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800f802:	d010      	beq.n	800f826 <_ux_utility_memory_free+0x4e>
        memory_block -> ux_memory_block_status != (UX_MEMORY_USED | UX_CACHE_SAFE_MEMORY))
 800f804:	697b      	ldr	r3, [r7, #20]
 800f806:	685b      	ldr	r3, [r3, #4]
    if (memory_block -> ux_memory_block_status != (UX_MEMORY_USED | UX_REGULAR_MEMORY) &&
 800f808:	4a40      	ldr	r2, [pc, #256]	; (800f90c <_ux_utility_memory_free+0x134>)
 800f80a:	4293      	cmp	r3, r2
 800f80c:	d00b      	beq.n	800f826 <_ux_utility_memory_free+0x4e>
    {

        /* Not valid. Release the protection.  */
        _ux_system_mutex_off(&_ux_system -> ux_system_mutex);
 800f80e:	4b3e      	ldr	r3, [pc, #248]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f810:	681b      	ldr	r3, [r3, #0]
 800f812:	331c      	adds	r3, #28
 800f814:	4618      	mov	r0, r3
 800f816:	f000 f8fc 	bl	800fa12 <_ux_utility_mutex_off>

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, UX_MEMORY_CORRUPTED);
 800f81a:	2219      	movs	r2, #25
 800f81c:	2108      	movs	r1, #8
 800f81e:	2002      	movs	r0, #2
 800f820:	f7ff fcb4 	bl	800f18c <_ux_system_error_handler>

        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MEMORY_CORRUPTED, memory, 0, 0, UX_TRACE_ERRORS, 0, 0)

        /* Return to caller.  */
        return;
 800f824:	e06c      	b.n	800f900 <_ux_utility_memory_free+0x128>
        _ux_system -> ux_system_cache_safe_memory_pool_alloc_total -= memory_block -> ux_memory_block_size;
    }
#endif

    /* We mark this memory block as being unused.  */
    memory_block -> ux_memory_block_status =  UX_MEMORY_UNUSED;
 800f826:	697b      	ldr	r3, [r7, #20]
 800f828:	2200      	movs	r2, #0
 800f82a:	605a      	str	r2, [r3, #4]
    
    /* Now we must concatenate as many free blocks as possible,
       that include the blocks before and the blocks after the current
       block.  Scan memory backwards.  */

     while (memory_block -> ux_memory_block_previous !=UX_NULL)
 800f82c:	e007      	b.n	800f83e <_ux_utility_memory_free+0x66>
     {

        /* Check if the block is free.  */            
        if (memory_block -> ux_memory_block_previous -> ux_memory_block_status == UX_MEMORY_UNUSED)
 800f82e:	697b      	ldr	r3, [r7, #20]
 800f830:	68db      	ldr	r3, [r3, #12]
 800f832:	685b      	ldr	r3, [r3, #4]
 800f834:	2b00      	cmp	r3, #0
 800f836:	d107      	bne.n	800f848 <_ux_utility_memory_free+0x70>

            /* The memory block before is free. This will be our starting point to 
               concatenate memory.  */
            memory_block =  memory_block -> ux_memory_block_previous;
 800f838:	697b      	ldr	r3, [r7, #20]
 800f83a:	68db      	ldr	r3, [r3, #12]
 800f83c:	617b      	str	r3, [r7, #20]
     while (memory_block -> ux_memory_block_previous !=UX_NULL)
 800f83e:	697b      	ldr	r3, [r7, #20]
 800f840:	68db      	ldr	r3, [r3, #12]
 800f842:	2b00      	cmp	r3, #0
 800f844:	d1f3      	bne.n	800f82e <_ux_utility_memory_free+0x56>
 800f846:	e000      	b.n	800f84a <_ux_utility_memory_free+0x72>

        else

            /* The previous memory block is not free.  */
            break;
 800f848:	bf00      	nop
    }

    /* The pointer to the memory block is now our first free block. We use this 
       starting address to concatenate all the contiguous memory block.  */
    next_block =  memory_block -> ux_memory_block_next;
 800f84a:	697b      	ldr	r3, [r7, #20]
 800f84c:	689b      	ldr	r3, [r3, #8]
 800f84e:	613b      	str	r3, [r7, #16]
    while (next_block != UX_NULL)
 800f850:	e01a      	b.n	800f888 <_ux_utility_memory_free+0xb0>
    {

        /* Determine if the memory block is used.  */
        if (next_block -> ux_memory_block_status != UX_MEMORY_UNUSED)
 800f852:	693b      	ldr	r3, [r7, #16]
 800f854:	685b      	ldr	r3, [r3, #4]
 800f856:	2b00      	cmp	r3, #0
 800f858:	d006      	beq.n	800f868 <_ux_utility_memory_free+0x90>
        {

            /* Yes, move to next block.  */
            memory_block -> ux_memory_block_next =  next_block;
 800f85a:	697b      	ldr	r3, [r7, #20]
 800f85c:	693a      	ldr	r2, [r7, #16]
 800f85e:	609a      	str	r2, [r3, #8]
            next_block -> ux_memory_block_previous =  memory_block;
 800f860:	693b      	ldr	r3, [r7, #16]
 800f862:	697a      	ldr	r2, [r7, #20]
 800f864:	60da      	str	r2, [r3, #12]
            break;
 800f866:	e012      	b.n	800f88e <_ux_utility_memory_free+0xb6>
        }

        memory_block -> ux_memory_block_next =  next_block -> ux_memory_block_next;
 800f868:	693b      	ldr	r3, [r7, #16]
 800f86a:	689a      	ldr	r2, [r3, #8]
 800f86c:	697b      	ldr	r3, [r7, #20]
 800f86e:	609a      	str	r2, [r3, #8]
        memory_block -> ux_memory_block_size +=  next_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 800f870:	697b      	ldr	r3, [r7, #20]
 800f872:	681a      	ldr	r2, [r3, #0]
 800f874:	693b      	ldr	r3, [r7, #16]
 800f876:	681b      	ldr	r3, [r3, #0]
 800f878:	4413      	add	r3, r2
 800f87a:	f103 0210 	add.w	r2, r3, #16
 800f87e:	697b      	ldr	r3, [r7, #20]
 800f880:	601a      	str	r2, [r3, #0]
        next_block =  next_block -> ux_memory_block_next;                       
 800f882:	693b      	ldr	r3, [r7, #16]
 800f884:	689b      	ldr	r3, [r3, #8]
 800f886:	613b      	str	r3, [r7, #16]
    while (next_block != UX_NULL)
 800f888:	693b      	ldr	r3, [r7, #16]
 800f88a:	2b00      	cmp	r3, #0
 800f88c:	d1e1      	bne.n	800f852 <_ux_utility_memory_free+0x7a>
    }

    /* Update the memory free in the appropriate pool.  We need to know if this 
       block is in regular memory or cache safe memory.  */
    if(_ux_system -> ux_system_cache_safe_memory_pool_start == _ux_system -> ux_system_regular_memory_pool_start)
 800f88e:	4b1e      	ldr	r3, [pc, #120]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f890:	681b      	ldr	r3, [r3, #0]
 800f892:	68da      	ldr	r2, [r3, #12]
 800f894:	4b1c      	ldr	r3, [pc, #112]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f896:	681b      	ldr	r3, [r3, #0]
 800f898:	681b      	ldr	r3, [r3, #0]
 800f89a:	429a      	cmp	r2, r3
 800f89c:	d108      	bne.n	800f8b0 <_ux_utility_memory_free+0xd8>
    {

        /* There is only one regular memory pool.  */
        _ux_system -> ux_system_regular_memory_pool_free += memory_size_returned;
 800f89e:	4b1a      	ldr	r3, [pc, #104]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f8a0:	681b      	ldr	r3, [r3, #0]
 800f8a2:	6899      	ldr	r1, [r3, #8]
 800f8a4:	4b18      	ldr	r3, [pc, #96]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f8a6:	681b      	ldr	r3, [r3, #0]
 800f8a8:	68fa      	ldr	r2, [r7, #12]
 800f8aa:	440a      	add	r2, r1
 800f8ac:	609a      	str	r2, [r3, #8]
 800f8ae:	e020      	b.n	800f8f2 <_ux_utility_memory_free+0x11a>
    }
    else
    {

        /* Which pool is this memory in ?  */
        memory_address = (UCHAR *) _ux_system -> ux_system_regular_memory_pool_start;
 800f8b0:	4b15      	ldr	r3, [pc, #84]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f8b2:	681b      	ldr	r3, [r3, #0]
 800f8b4:	681b      	ldr	r3, [r3, #0]
 800f8b6:	60bb      	str	r3, [r7, #8]
        
        /* If the memory address is in this range, we are in the regular memory pool.  */
        if ((UCHAR *) memory_block >= memory_address && (UCHAR *) memory_block < (memory_address + _ux_system -> ux_system_regular_memory_pool_size))
 800f8b8:	697a      	ldr	r2, [r7, #20]
 800f8ba:	68bb      	ldr	r3, [r7, #8]
 800f8bc:	429a      	cmp	r2, r3
 800f8be:	d310      	bcc.n	800f8e2 <_ux_utility_memory_free+0x10a>
 800f8c0:	4b11      	ldr	r3, [pc, #68]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f8c2:	681b      	ldr	r3, [r3, #0]
 800f8c4:	685b      	ldr	r3, [r3, #4]
 800f8c6:	68ba      	ldr	r2, [r7, #8]
 800f8c8:	4413      	add	r3, r2
 800f8ca:	697a      	ldr	r2, [r7, #20]
 800f8cc:	429a      	cmp	r2, r3
 800f8ce:	d208      	bcs.n	800f8e2 <_ux_utility_memory_free+0x10a>

            /* Update the regular memory pool.  */
            _ux_system -> ux_system_regular_memory_pool_free += memory_size_returned;
 800f8d0:	4b0d      	ldr	r3, [pc, #52]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f8d2:	681b      	ldr	r3, [r3, #0]
 800f8d4:	6899      	ldr	r1, [r3, #8]
 800f8d6:	4b0c      	ldr	r3, [pc, #48]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f8d8:	681b      	ldr	r3, [r3, #0]
 800f8da:	68fa      	ldr	r2, [r7, #12]
 800f8dc:	440a      	add	r2, r1
 800f8de:	609a      	str	r2, [r3, #8]
 800f8e0:	e007      	b.n	800f8f2 <_ux_utility_memory_free+0x11a>

        else
        
            /* Update the cache safe memory pool.  */
            _ux_system -> ux_system_cache_safe_memory_pool_free += memory_size_returned;
 800f8e2:	4b09      	ldr	r3, [pc, #36]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f8e4:	681b      	ldr	r3, [r3, #0]
 800f8e6:	6959      	ldr	r1, [r3, #20]
 800f8e8:	4b07      	ldr	r3, [pc, #28]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f8ea:	681b      	ldr	r3, [r3, #0]
 800f8ec:	68fa      	ldr	r2, [r7, #12]
 800f8ee:	440a      	add	r2, r1
 800f8f0:	615a      	str	r2, [r3, #20]
        
    }

    /* Release the protection.  */
    _ux_system_mutex_off(&_ux_system -> ux_system_mutex);
 800f8f2:	4b05      	ldr	r3, [pc, #20]	; (800f908 <_ux_utility_memory_free+0x130>)
 800f8f4:	681b      	ldr	r3, [r3, #0]
 800f8f6:	331c      	adds	r3, #28
 800f8f8:	4618      	mov	r0, r3
 800f8fa:	f000 f88a 	bl	800fa12 <_ux_utility_mutex_off>

    /* Return to caller.  */
    return;
 800f8fe:	bf00      	nop
}
 800f900:	3718      	adds	r7, #24
 800f902:	46bd      	mov	sp, r7
 800f904:	bd80      	pop	{r7, pc}
 800f906:	bf00      	nop
 800f908:	20007310 	.word	0x20007310
 800f90c:	80000001 	.word	0x80000001

0800f910 <_ux_utility_memory_free_block_best_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UX_MEMORY_BLOCK  *_ux_utility_memory_free_block_best_get(ULONG memory_cache_flag, 
                                                        ULONG memory_size_requested)
{
 800f910:	b480      	push	{r7}
 800f912:	b085      	sub	sp, #20
 800f914:	af00      	add	r7, sp, #0
 800f916:	6078      	str	r0, [r7, #4]
 800f918:	6039      	str	r1, [r7, #0]
UX_MEMORY_BLOCK     *memory_block;
UX_MEMORY_BLOCK     *best_memory_block;
    

    /* Reset the free memory block.  */
    best_memory_block =  UX_NULL;
 800f91a:	2300      	movs	r3, #0
 800f91c:	60bb      	str	r3, [r7, #8]
    
    /* Check the type of memory we need.  */
    switch (memory_cache_flag)
 800f91e:	687b      	ldr	r3, [r7, #4]
 800f920:	2b00      	cmp	r3, #0
 800f922:	d003      	beq.n	800f92c <_ux_utility_memory_free_block_best_get+0x1c>
 800f924:	687b      	ldr	r3, [r7, #4]
 800f926:	2b01      	cmp	r3, #1
 800f928:	d005      	beq.n	800f936 <_ux_utility_memory_free_block_best_get+0x26>
 800f92a:	e009      	b.n	800f940 <_ux_utility_memory_free_block_best_get+0x30>
    {

        case UX_REGULAR_MEMORY            :

            /* Start at the beginning of the regular memory pool.  */
            memory_block =  _ux_system -> ux_system_regular_memory_pool_start;
 800f92c:	4b18      	ldr	r3, [pc, #96]	; (800f990 <_ux_utility_memory_free_block_best_get+0x80>)
 800f92e:	681b      	ldr	r3, [r3, #0]
 800f930:	681b      	ldr	r3, [r3, #0]
 800f932:	60fb      	str	r3, [r7, #12]
            break;
 800f934:	e006      	b.n	800f944 <_ux_utility_memory_free_block_best_get+0x34>
            
        case UX_CACHE_SAFE_MEMORY       :

            /* Start at the beginning of the cache safe memory pool.  */
            memory_block =  _ux_system -> ux_system_cache_safe_memory_pool_start;
 800f936:	4b16      	ldr	r3, [pc, #88]	; (800f990 <_ux_utility_memory_free_block_best_get+0x80>)
 800f938:	681b      	ldr	r3, [r3, #0]
 800f93a:	68db      	ldr	r3, [r3, #12]
 800f93c:	60fb      	str	r3, [r7, #12]
            break;
 800f93e:	e001      	b.n	800f944 <_ux_utility_memory_free_block_best_get+0x34>
        
        default                            :
        
            /* Wrong memory type.  */
            return(UX_NULL);
 800f940:	2300      	movs	r3, #0
 800f942:	e01e      	b.n	800f982 <_ux_utility_memory_free_block_best_get+0x72>

    }

    /* Loop on all memory blocks from the beginning.  */
    while (memory_block != UX_NULL)
 800f944:	e019      	b.n	800f97a <_ux_utility_memory_free_block_best_get+0x6a>
    {

        /* Check the memory block status.  */
        if (memory_block -> ux_memory_block_status == UX_MEMORY_UNUSED)
 800f946:	68fb      	ldr	r3, [r7, #12]
 800f948:	685b      	ldr	r3, [r3, #4]
 800f94a:	2b00      	cmp	r3, #0
 800f94c:	d112      	bne.n	800f974 <_ux_utility_memory_free_block_best_get+0x64>
        {

            /* Check the size of this free block and see if it will 
               fit the memory requirement.  */
            if (memory_block -> ux_memory_block_size > memory_size_requested)
 800f94e:	68fb      	ldr	r3, [r7, #12]
 800f950:	681b      	ldr	r3, [r3, #0]
 800f952:	683a      	ldr	r2, [r7, #0]
 800f954:	429a      	cmp	r2, r3
 800f956:	d20d      	bcs.n	800f974 <_ux_utility_memory_free_block_best_get+0x64>
            {
                
                /* This memory block will do. Now see if it is the best.
                   The best memory block is the one whose memory is closest
                   to the memory requested.  */
                if (best_memory_block == UX_NULL)
 800f958:	68bb      	ldr	r3, [r7, #8]
 800f95a:	2b00      	cmp	r3, #0
 800f95c:	d102      	bne.n	800f964 <_ux_utility_memory_free_block_best_get+0x54>

                    /* Initialize the best block with the first free one.  */
                    best_memory_block =  memory_block;
 800f95e:	68fb      	ldr	r3, [r7, #12]
 800f960:	60bb      	str	r3, [r7, #8]
 800f962:	e007      	b.n	800f974 <_ux_utility_memory_free_block_best_get+0x64>
                else
                {

                    if (memory_block -> ux_memory_block_size < best_memory_block -> ux_memory_block_size)
 800f964:	68fb      	ldr	r3, [r7, #12]
 800f966:	681a      	ldr	r2, [r3, #0]
 800f968:	68bb      	ldr	r3, [r7, #8]
 800f96a:	681b      	ldr	r3, [r3, #0]
 800f96c:	429a      	cmp	r2, r3
 800f96e:	d201      	bcs.n	800f974 <_ux_utility_memory_free_block_best_get+0x64>

                        /* We have discovered a better fit block.  */
                        best_memory_block =  memory_block;
 800f970:	68fb      	ldr	r3, [r7, #12]
 800f972:	60bb      	str	r3, [r7, #8]
                }                    
            }
        }

        /* Search the next free block until the end.  */            
        memory_block =  memory_block -> ux_memory_block_next;
 800f974:	68fb      	ldr	r3, [r7, #12]
 800f976:	689b      	ldr	r3, [r3, #8]
 800f978:	60fb      	str	r3, [r7, #12]
    while (memory_block != UX_NULL)
 800f97a:	68fb      	ldr	r3, [r7, #12]
 800f97c:	2b00      	cmp	r3, #0
 800f97e:	d1e2      	bne.n	800f946 <_ux_utility_memory_free_block_best_get+0x36>
    }

    /* If no free memory block was found, the return value will be NULL.  */
    return(best_memory_block);        
 800f980:	68bb      	ldr	r3, [r7, #8]
}                                
 800f982:	4618      	mov	r0, r3
 800f984:	3714      	adds	r7, #20
 800f986:	46bd      	mov	sp, r7
 800f988:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f98c:	4770      	bx	lr
 800f98e:	bf00      	nop
 800f990:	20007310 	.word	0x20007310

0800f994 <_ux_utility_memory_set>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_memory_set(VOID *destination, UCHAR value, ULONG length)
{
 800f994:	b480      	push	{r7}
 800f996:	b087      	sub	sp, #28
 800f998:	af00      	add	r7, sp, #0
 800f99a:	60f8      	str	r0, [r7, #12]
 800f99c:	460b      	mov	r3, r1
 800f99e:	607a      	str	r2, [r7, #4]
 800f9a0:	72fb      	strb	r3, [r7, #11]

UCHAR *    work_ptr;


    /* Setup the working pointer */
    work_ptr =  (UCHAR *) destination;
 800f9a2:	68fb      	ldr	r3, [r7, #12]
 800f9a4:	617b      	str	r3, [r7, #20]

    /* Loop to set the memory.  */
    while(length--)
 800f9a6:	e004      	b.n	800f9b2 <_ux_utility_memory_set+0x1e>
    {

        /* Set a byte.  */
        *work_ptr++ =  value;
 800f9a8:	697b      	ldr	r3, [r7, #20]
 800f9aa:	1c5a      	adds	r2, r3, #1
 800f9ac:	617a      	str	r2, [r7, #20]
 800f9ae:	7afa      	ldrb	r2, [r7, #11]
 800f9b0:	701a      	strb	r2, [r3, #0]
    while(length--)
 800f9b2:	687b      	ldr	r3, [r7, #4]
 800f9b4:	1e5a      	subs	r2, r3, #1
 800f9b6:	607a      	str	r2, [r7, #4]
 800f9b8:	2b00      	cmp	r3, #0
 800f9ba:	d1f5      	bne.n	800f9a8 <_ux_utility_memory_set+0x14>
    }

    /* Return to caller.  */
    return; 
 800f9bc:	bf00      	nop
}
 800f9be:	371c      	adds	r7, #28
 800f9c0:	46bd      	mov	sp, r7
 800f9c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9c6:	4770      	bx	lr

0800f9c8 <_ux_utility_mutex_create>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_mutex_create(UX_MUTEX *mutex, CHAR *mutex_name)
{
 800f9c8:	b580      	push	{r7, lr}
 800f9ca:	b084      	sub	sp, #16
 800f9cc:	af00      	add	r7, sp, #0
 800f9ce:	6078      	str	r0, [r7, #4]
 800f9d0:	6039      	str	r1, [r7, #0]

UINT    status;


    /* Call ThreadX to create the Mutex object.  */
    status =  tx_mutex_create(mutex, (CHAR *) mutex_name, TX_NO_INHERIT);   
 800f9d2:	2200      	movs	r2, #0
 800f9d4:	6839      	ldr	r1, [r7, #0]
 800f9d6:	6878      	ldr	r0, [r7, #4]
 800f9d8:	f7fc fce4 	bl	800c3a4 <_tx_mutex_create>
 800f9dc:	60f8      	str	r0, [r7, #12]

    /* Check for status.  */
    if (status != UX_SUCCESS)
 800f9de:	68fb      	ldr	r3, [r7, #12]
 800f9e0:	2b00      	cmp	r3, #0
 800f9e2:	d004      	beq.n	800f9ee <_ux_utility_mutex_create+0x26>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
 800f9e4:	68fa      	ldr	r2, [r7, #12]
 800f9e6:	2108      	movs	r1, #8
 800f9e8:	2002      	movs	r0, #2
 800f9ea:	f7ff fbcf 	bl	800f18c <_ux_system_error_handler>
        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MUTEX_ERROR, mutex, 0, 0, UX_TRACE_ERRORS, 0, 0)

    }
    /* Return completion status.  */
    return(status);
 800f9ee:	68fb      	ldr	r3, [r7, #12]
}
 800f9f0:	4618      	mov	r0, r3
 800f9f2:	3710      	adds	r7, #16
 800f9f4:	46bd      	mov	sp, r7
 800f9f6:	bd80      	pop	{r7, pc}

0800f9f8 <_ux_utility_mutex_delete>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_mutex_delete(UX_MUTEX *mutex)
{
 800f9f8:	b580      	push	{r7, lr}
 800f9fa:	b084      	sub	sp, #16
 800f9fc:	af00      	add	r7, sp, #0
 800f9fe:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Call ThreadX to delete the Mutex object.  */
    status =  tx_mutex_delete(mutex);
 800fa00:	6878      	ldr	r0, [r7, #4]
 800fa02:	f7fc fd29 	bl	800c458 <_tx_mutex_delete>
 800fa06:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
 800fa08:	68fb      	ldr	r3, [r7, #12]
}
 800fa0a:	4618      	mov	r0, r3
 800fa0c:	3710      	adds	r7, #16
 800fa0e:	46bd      	mov	sp, r7
 800fa10:	bd80      	pop	{r7, pc}

0800fa12 <_ux_utility_mutex_off>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_mutex_off(UX_MUTEX *mutex)
{
 800fa12:	b580      	push	{r7, lr}
 800fa14:	b082      	sub	sp, #8
 800fa16:	af00      	add	r7, sp, #0
 800fa18:	6078      	str	r0, [r7, #4]

    /* Call ThreadX to release protection.  */
    tx_mutex_put(mutex);
 800fa1a:	6878      	ldr	r0, [r7, #4]
 800fa1c:	f7fd f83e 	bl	800ca9c <_tx_mutex_put>

    /* Return to caller.  */
    return;
 800fa20:	bf00      	nop
}
 800fa22:	3708      	adds	r7, #8
 800fa24:	46bd      	mov	sp, r7
 800fa26:	bd80      	pop	{r7, pc}

0800fa28 <_ux_utility_mutex_on>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_mutex_on(UX_MUTEX *mutex)
{
 800fa28:	b580      	push	{r7, lr}
 800fa2a:	b084      	sub	sp, #16
 800fa2c:	af00      	add	r7, sp, #0
 800fa2e:	6078      	str	r0, [r7, #4]

UINT    status;

    /* Call ThreadX to get system mutex.  */
    status =  tx_mutex_get(mutex, TX_WAIT_FOREVER);
 800fa30:	f04f 31ff 	mov.w	r1, #4294967295
 800fa34:	6878      	ldr	r0, [r7, #4]
 800fa36:	f7fc fdb9 	bl	800c5ac <_tx_mutex_get>
 800fa3a:	60f8      	str	r0, [r7, #12]

    /* Check for status.  */
    if (status != UX_SUCCESS)
 800fa3c:	68fb      	ldr	r3, [r7, #12]
 800fa3e:	2b00      	cmp	r3, #0
 800fa40:	d005      	beq.n	800fa4e <_ux_utility_mutex_on+0x26>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
 800fa42:	68fa      	ldr	r2, [r7, #12]
 800fa44:	2108      	movs	r1, #8
 800fa46:	2002      	movs	r0, #2
 800fa48:	f7ff fba0 	bl	800f18c <_ux_system_error_handler>
    }

    /* Return to caller.  */
    return;
 800fa4c:	bf00      	nop
 800fa4e:	bf00      	nop
}
 800fa50:	3710      	adds	r7, #16
 800fa52:	46bd      	mov	sp, r7
 800fa54:	bd80      	pop	{r7, pc}

0800fa56 <_ux_utility_semaphore_create>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_semaphore_create(UX_SEMAPHORE *semaphore, CHAR *semaphore_name, UINT initial_count)
{
 800fa56:	b580      	push	{r7, lr}
 800fa58:	b086      	sub	sp, #24
 800fa5a:	af00      	add	r7, sp, #0
 800fa5c:	60f8      	str	r0, [r7, #12]
 800fa5e:	60b9      	str	r1, [r7, #8]
 800fa60:	607a      	str	r2, [r7, #4]

UINT    status;

    /* Call ThreadX to create the semaphore.  */
    status =  tx_semaphore_create(semaphore, (CHAR *) semaphore_name, initial_count);
 800fa62:	687a      	ldr	r2, [r7, #4]
 800fa64:	68b9      	ldr	r1, [r7, #8]
 800fa66:	68f8      	ldr	r0, [r7, #12]
 800fa68:	f7fd fab2 	bl	800cfd0 <_tx_semaphore_create>
 800fa6c:	6178      	str	r0, [r7, #20]

    /* Check for status.  */
    if (status != UX_SUCCESS)
 800fa6e:	697b      	ldr	r3, [r7, #20]
 800fa70:	2b00      	cmp	r3, #0
 800fa72:	d004      	beq.n	800fa7e <_ux_utility_semaphore_create+0x28>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
 800fa74:	697a      	ldr	r2, [r7, #20]
 800fa76:	2108      	movs	r1, #8
 800fa78:	2002      	movs	r0, #2
 800fa7a:	f7ff fb87 	bl	800f18c <_ux_system_error_handler>
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_SEMAPHORE_ERROR, semaphore, 0, 0, UX_TRACE_ERRORS, 0, 0)

    }

    /* Return completion status.  */
    return(status);
 800fa7e:	697b      	ldr	r3, [r7, #20]
}
 800fa80:	4618      	mov	r0, r3
 800fa82:	3718      	adds	r7, #24
 800fa84:	46bd      	mov	sp, r7
 800fa86:	bd80      	pop	{r7, pc}

0800fa88 <_ux_utility_semaphore_delete>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_semaphore_delete(UX_SEMAPHORE *semaphore)
{
 800fa88:	b580      	push	{r7, lr}
 800fa8a:	b084      	sub	sp, #16
 800fa8c:	af00      	add	r7, sp, #0
 800fa8e:	6078      	str	r0, [r7, #4]

UINT    status;

    /* Call ThreadX Semaphore delete function.  */
    status =  tx_semaphore_delete(semaphore);
 800fa90:	6878      	ldr	r0, [r7, #4]
 800fa92:	f7fd faef 	bl	800d074 <_tx_semaphore_delete>
 800fa96:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
 800fa98:	68fb      	ldr	r3, [r7, #12]
}
 800fa9a:	4618      	mov	r0, r3
 800fa9c:	3710      	adds	r7, #16
 800fa9e:	46bd      	mov	sp, r7
 800faa0:	bd80      	pop	{r7, pc}

0800faa2 <_ux_utility_semaphore_put>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_semaphore_put(UX_SEMAPHORE *semaphore)
{
 800faa2:	b580      	push	{r7, lr}
 800faa4:	b084      	sub	sp, #16
 800faa6:	af00      	add	r7, sp, #0
 800faa8:	6078      	str	r0, [r7, #4]

UINT    status;

    /* Put a ThreadX semaphore.  */
    status =  tx_semaphore_put(semaphore);
 800faaa:	6878      	ldr	r0, [r7, #4]
 800faac:	f7fd fb72 	bl	800d194 <_tx_semaphore_put>
 800fab0:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
 800fab2:	68fb      	ldr	r3, [r7, #12]
}
 800fab4:	4618      	mov	r0, r3
 800fab6:	3710      	adds	r7, #16
 800fab8:	46bd      	mov	sp, r7
 800faba:	bd80      	pop	{r7, pc}

0800fabc <_ux_utility_short_get>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG  _ux_utility_short_get(UCHAR * address)
{
 800fabc:	b480      	push	{r7}
 800fabe:	b085      	sub	sp, #20
 800fac0:	af00      	add	r7, sp, #0
 800fac2:	6078      	str	r0, [r7, #4]
USHORT   value;


    /* In order to make this function endian agnostic and memory alignment
       independent, we read a byte at a time from the address.  */
    value =  (USHORT) *address++;
 800fac4:	687b      	ldr	r3, [r7, #4]
 800fac6:	1c5a      	adds	r2, r3, #1
 800fac8:	607a      	str	r2, [r7, #4]
 800faca:	781b      	ldrb	r3, [r3, #0]
 800facc:	81fb      	strh	r3, [r7, #14]
    value |=  (USHORT)(*address << 8);
 800face:	687b      	ldr	r3, [r7, #4]
 800fad0:	781b      	ldrb	r3, [r3, #0]
 800fad2:	b29b      	uxth	r3, r3
 800fad4:	021b      	lsls	r3, r3, #8
 800fad6:	b29a      	uxth	r2, r3
 800fad8:	89fb      	ldrh	r3, [r7, #14]
 800fada:	4313      	orrs	r3, r2
 800fadc:	81fb      	strh	r3, [r7, #14]

    /* Return to caller.  */
    return((ULONG) value);
 800fade:	89fb      	ldrh	r3, [r7, #14]
}
 800fae0:	4618      	mov	r0, r3
 800fae2:	3714      	adds	r7, #20
 800fae4:	46bd      	mov	sp, r7
 800fae6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800faea:	4770      	bx	lr

0800faec <_ux_utility_short_get_big_endian>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
ULONG   _ux_utility_short_get_big_endian(UCHAR * address)
{
 800faec:	b480      	push	{r7}
 800faee:	b085      	sub	sp, #20
 800faf0:	af00      	add	r7, sp, #0
 800faf2:	6078      	str	r0, [r7, #4]

USHORT  value;

    /* We read a byte at a time from the address.  */
    value =  (USHORT)((*address++) << 8);
 800faf4:	687b      	ldr	r3, [r7, #4]
 800faf6:	1c5a      	adds	r2, r3, #1
 800faf8:	607a      	str	r2, [r7, #4]
 800fafa:	781b      	ldrb	r3, [r3, #0]
 800fafc:	b29b      	uxth	r3, r3
 800fafe:	021b      	lsls	r3, r3, #8
 800fb00:	81fb      	strh	r3, [r7, #14]
    value =  (USHORT)(value | *address);
 800fb02:	687b      	ldr	r3, [r7, #4]
 800fb04:	781b      	ldrb	r3, [r3, #0]
 800fb06:	b29a      	uxth	r2, r3
 800fb08:	89fb      	ldrh	r3, [r7, #14]
 800fb0a:	4313      	orrs	r3, r2
 800fb0c:	81fb      	strh	r3, [r7, #14]

    /* Return 16-bit value.  */
    return((ULONG) value);
 800fb0e:	89fb      	ldrh	r3, [r7, #14]
}
 800fb10:	4618      	mov	r0, r3
 800fb12:	3714      	adds	r7, #20
 800fb14:	46bd      	mov	sp, r7
 800fb16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb1a:	4770      	bx	lr

0800fb1c <_ux_utility_short_put_big_endian>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_short_put_big_endian(UCHAR * address, USHORT value)
{
 800fb1c:	b480      	push	{r7}
 800fb1e:	b085      	sub	sp, #20
 800fb20:	af00      	add	r7, sp, #0
 800fb22:	6078      	str	r0, [r7, #4]
 800fb24:	460b      	mov	r3, r1
 800fb26:	807b      	strh	r3, [r7, #2]
USHORT  low_byte_value;
USHORT  high_byte_value;

    
    /* First we swap the value bytes. */
    low_byte_value =  value >> 8;
 800fb28:	887b      	ldrh	r3, [r7, #2]
 800fb2a:	0a1b      	lsrs	r3, r3, #8
 800fb2c:	81fb      	strh	r3, [r7, #14]
    high_byte_value =  (USHORT)(value<< 8);
 800fb2e:	887b      	ldrh	r3, [r7, #2]
 800fb30:	021b      	lsls	r3, r3, #8
 800fb32:	81bb      	strh	r3, [r7, #12]
    value =  high_byte_value | low_byte_value;
 800fb34:	89ba      	ldrh	r2, [r7, #12]
 800fb36:	89fb      	ldrh	r3, [r7, #14]
 800fb38:	4313      	orrs	r3, r2
 800fb3a:	807b      	strh	r3, [r7, #2]

    /* In order to make this function endian agnostic and memory alignment
       independent, we write a byte at a time from the address.  */
    *address++ =  (UCHAR) (value & 0xff);
 800fb3c:	687b      	ldr	r3, [r7, #4]
 800fb3e:	1c5a      	adds	r2, r3, #1
 800fb40:	607a      	str	r2, [r7, #4]
 800fb42:	887a      	ldrh	r2, [r7, #2]
 800fb44:	b2d2      	uxtb	r2, r2
 800fb46:	701a      	strb	r2, [r3, #0]
    *address=     (UCHAR) ((value >> 8) & 0xff);
 800fb48:	887b      	ldrh	r3, [r7, #2]
 800fb4a:	0a1b      	lsrs	r3, r3, #8
 800fb4c:	b29b      	uxth	r3, r3
 800fb4e:	b2da      	uxtb	r2, r3
 800fb50:	687b      	ldr	r3, [r7, #4]
 800fb52:	701a      	strb	r2, [r3, #0]

    /* Return to caller. */
    return;
 800fb54:	bf00      	nop
}
 800fb56:	3714      	adds	r7, #20
 800fb58:	46bd      	mov	sp, r7
 800fb5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb5e:	4770      	bx	lr

0800fb60 <_ux_utility_string_length_check>:
/*  07-29-2022     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_string_length_check(UCHAR *string, UINT *string_length_ptr, UINT max_string_length)
{
 800fb60:	b580      	push	{r7, lr}
 800fb62:	b086      	sub	sp, #24
 800fb64:	af00      	add	r7, sp, #0
 800fb66:	60f8      	str	r0, [r7, #12]
 800fb68:	60b9      	str	r1, [r7, #8]
 800fb6a:	607a      	str	r2, [r7, #4]

UINT    string_length;


    if (string == UX_NULL)
 800fb6c:	68fb      	ldr	r3, [r7, #12]
 800fb6e:	2b00      	cmp	r3, #0
 800fb70:	d101      	bne.n	800fb76 <_ux_utility_string_length_check+0x16>
        return(UX_ERROR);
 800fb72:	23ff      	movs	r3, #255	; 0xff
 800fb74:	e01d      	b.n	800fbb2 <_ux_utility_string_length_check+0x52>

    string_length = 0;
 800fb76:	2300      	movs	r3, #0
 800fb78:	617b      	str	r3, [r7, #20]

    while (1)
    {

        if (string[string_length] == '\0')
 800fb7a:	68fa      	ldr	r2, [r7, #12]
 800fb7c:	697b      	ldr	r3, [r7, #20]
 800fb7e:	4413      	add	r3, r2
 800fb80:	781b      	ldrb	r3, [r3, #0]
 800fb82:	2b00      	cmp	r3, #0
 800fb84:	d00d      	beq.n	800fba2 <_ux_utility_string_length_check+0x42>
            break;

        string_length++;
 800fb86:	697b      	ldr	r3, [r7, #20]
 800fb88:	3301      	adds	r3, #1
 800fb8a:	617b      	str	r3, [r7, #20]
        if (string_length > max_string_length)
 800fb8c:	697a      	ldr	r2, [r7, #20]
 800fb8e:	687b      	ldr	r3, [r7, #4]
 800fb90:	429a      	cmp	r2, r3
 800fb92:	d9f2      	bls.n	800fb7a <_ux_utility_string_length_check+0x1a>
        {

            /* Error trap. */
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, UX_ERROR);
 800fb94:	22ff      	movs	r2, #255	; 0xff
 800fb96:	2108      	movs	r1, #8
 800fb98:	2002      	movs	r0, #2
 800fb9a:	f7ff faf7 	bl	800f18c <_ux_system_error_handler>

            return(UX_ERROR);
 800fb9e:	23ff      	movs	r3, #255	; 0xff
 800fba0:	e007      	b.n	800fbb2 <_ux_utility_string_length_check+0x52>
            break;
 800fba2:	bf00      	nop
        }
    }

    if (string_length_ptr)
 800fba4:	68bb      	ldr	r3, [r7, #8]
 800fba6:	2b00      	cmp	r3, #0
 800fba8:	d002      	beq.n	800fbb0 <_ux_utility_string_length_check+0x50>
        *string_length_ptr = string_length;
 800fbaa:	68bb      	ldr	r3, [r7, #8]
 800fbac:	697a      	ldr	r2, [r7, #20]
 800fbae:	601a      	str	r2, [r3, #0]

    return(UX_SUCCESS); 
 800fbb0:	2300      	movs	r3, #0
}
 800fbb2:	4618      	mov	r0, r3
 800fbb4:	3718      	adds	r7, #24
 800fbb6:	46bd      	mov	sp, r7
 800fbb8:	bd80      	pop	{r7, pc}

0800fbba <_ux_utility_thread_create>:
UINT  _ux_utility_thread_create(UX_THREAD *thread_ptr, CHAR *name, 
                VOID (*entry_function)(ULONG), ULONG entry_input,
                VOID *stack_start, ULONG stack_size, 
                UINT priority, UINT preempt_threshold,
                ULONG time_slice, UINT auto_start)
{
 800fbba:	b580      	push	{r7, lr}
 800fbbc:	b08c      	sub	sp, #48	; 0x30
 800fbbe:	af06      	add	r7, sp, #24
 800fbc0:	60f8      	str	r0, [r7, #12]
 800fbc2:	60b9      	str	r1, [r7, #8]
 800fbc4:	607a      	str	r2, [r7, #4]
 800fbc6:	603b      	str	r3, [r7, #0]

UINT    status;


    /* Call ThreadX to create USBX thread.  */
    status =  tx_thread_create(thread_ptr,name,entry_function,entry_input,
 800fbc8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800fbca:	9305      	str	r3, [sp, #20]
 800fbcc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800fbce:	9304      	str	r3, [sp, #16]
 800fbd0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fbd2:	9303      	str	r3, [sp, #12]
 800fbd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fbd6:	9302      	str	r3, [sp, #8]
 800fbd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fbda:	9301      	str	r3, [sp, #4]
 800fbdc:	6a3b      	ldr	r3, [r7, #32]
 800fbde:	9300      	str	r3, [sp, #0]
 800fbe0:	683b      	ldr	r3, [r7, #0]
 800fbe2:	687a      	ldr	r2, [r7, #4]
 800fbe4:	68b9      	ldr	r1, [r7, #8]
 800fbe6:	68f8      	ldr	r0, [r7, #12]
 800fbe8:	f7fd fb2c 	bl	800d244 <_tx_thread_create>
 800fbec:	6178      	str	r0, [r7, #20]
                    stack_start,stack_size, priority,preempt_threshold,time_slice,auto_start);

    /* Check for status.  */
    if (status != UX_SUCCESS)
 800fbee:	697b      	ldr	r3, [r7, #20]
 800fbf0:	2b00      	cmp	r3, #0
 800fbf2:	d004      	beq.n	800fbfe <_ux_utility_thread_create+0x44>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
 800fbf4:	697a      	ldr	r2, [r7, #20]
 800fbf6:	2108      	movs	r1, #8
 800fbf8:	2002      	movs	r0, #2
 800fbfa:	f7ff fac7 	bl	800f18c <_ux_system_error_handler>
        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_THREAD_ERROR, thread_ptr, 0, 0, UX_TRACE_ERRORS, 0, 0)

    }
    /* Return completion status.  */
    return(status);
 800fbfe:	697b      	ldr	r3, [r7, #20]
}
 800fc00:	4618      	mov	r0, r3
 800fc02:	3718      	adds	r7, #24
 800fc04:	46bd      	mov	sp, r7
 800fc06:	bd80      	pop	{r7, pc}

0800fc08 <_ux_utility_thread_delete>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_thread_delete(UX_THREAD *thread_ptr)
{
 800fc08:	b580      	push	{r7, lr}
 800fc0a:	b084      	sub	sp, #16
 800fc0c:	af00      	add	r7, sp, #0
 800fc0e:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Call ThreadX to terminate the USBX thread.  */
    tx_thread_terminate(thread_ptr);
 800fc10:	6878      	ldr	r0, [r7, #4]
 800fc12:	f7fe faeb 	bl	800e1ec <_tx_thread_terminate>

    /* Call ThreadX to delete the USBX thread.  */
    status =  tx_thread_delete(thread_ptr);
 800fc16:	6878      	ldr	r0, [r7, #4]
 800fc18:	f7fd fc0a 	bl	800d430 <_tx_thread_delete>
 800fc1c:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
 800fc1e:	68fb      	ldr	r3, [r7, #12]
}
 800fc20:	4618      	mov	r0, r3
 800fc22:	3710      	adds	r7, #16
 800fc24:	46bd      	mov	sp, r7
 800fc26:	bd80      	pop	{r7, pc}

0800fc28 <_ux_utility_thread_relinquish>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_thread_relinquish(VOID)
{
 800fc28:	b580      	push	{r7, lr}
 800fc2a:	af00      	add	r7, sp, #0

    /* Call ThreadX to relinquish a USBX thread.  */
    tx_thread_relinquish();
 800fc2c:	f7fd fd02 	bl	800d634 <_tx_thread_relinquish>

}
 800fc30:	bf00      	nop
 800fc32:	bd80      	pop	{r7, pc}

0800fc34 <_ux_utility_thread_resume>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_thread_resume(UX_THREAD *thread_ptr)
{
 800fc34:	b580      	push	{r7, lr}
 800fc36:	b084      	sub	sp, #16
 800fc38:	af00      	add	r7, sp, #0
 800fc3a:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Call ThreadX to resume USBX thread.  */
    status =  tx_thread_resume(thread_ptr);
 800fc3c:	6878      	ldr	r0, [r7, #4]
 800fc3e:	f7fd fd5f 	bl	800d700 <_tx_thread_resume>
 800fc42:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
 800fc44:	68fb      	ldr	r3, [r7, #12]
}
 800fc46:	4618      	mov	r0, r3
 800fc48:	3710      	adds	r7, #16
 800fc4a:	46bd      	mov	sp, r7
 800fc4c:	bd80      	pop	{r7, pc}

0800fc4e <_ux_utility_thread_suspend>:
/*                                            off in standalone build,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_thread_suspend(UX_THREAD *thread_ptr)
{
 800fc4e:	b580      	push	{r7, lr}
 800fc50:	b084      	sub	sp, #16
 800fc52:	af00      	add	r7, sp, #0
 800fc54:	6078      	str	r0, [r7, #4]

UINT    status;


    /* Call ThreadX to suspend USBX thread.  */
    status =  tx_thread_suspend(thread_ptr);
 800fc56:	6878      	ldr	r0, [r7, #4]
 800fc58:	f7fd ff1c 	bl	800da94 <_tx_thread_suspend>
 800fc5c:	60f8      	str	r0, [r7, #12]

    /* Return completion status.  */
    return(status);
 800fc5e:	68fb      	ldr	r3, [r7, #12]
}
 800fc60:	4618      	mov	r0, r3
 800fc62:	3710      	adds	r7, #16
 800fc64:	46bd      	mov	sp, r7
 800fc66:	bd80      	pop	{r7, pc}

0800fc68 <_ux_device_class_hid_activate>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_activate(UX_SLAVE_CLASS_COMMAND *command)
{
 800fc68:	b580      	push	{r7, lr}
 800fc6a:	b088      	sub	sp, #32
 800fc6c:	af00      	add	r7, sp, #0
 800fc6e:	6078      	str	r0, [r7, #4]

UX_SLAVE_INTERFACE                      *interface_ptr;
UX_SLAVE_CLASS                          *class_ptr;
UX_SLAVE_CLASS_HID                      *hid;
UX_SLAVE_ENDPOINT                       *endpoint_interrupt;
UX_SLAVE_ENDPOINT                       *endpoint_in = UX_NULL;
 800fc70:	2300      	movs	r3, #0
 800fc72:	61bb      	str	r3, [r7, #24]
#if defined(UX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT)
UX_SLAVE_ENDPOINT                       *endpoint_out = UX_NULL;
 800fc74:	2300      	movs	r3, #0
 800fc76:	617b      	str	r3, [r7, #20]
#endif

    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
 800fc78:	687b      	ldr	r3, [r7, #4]
 800fc7a:	6a1b      	ldr	r3, [r3, #32]
 800fc7c:	613b      	str	r3, [r7, #16]

    /* Get the class instance in the container.  */
    hid =  (UX_SLAVE_CLASS_HID *) class_ptr -> ux_slave_class_instance;
 800fc7e:	693b      	ldr	r3, [r7, #16]
 800fc80:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800fc82:	60fb      	str	r3, [r7, #12]

    /* Get the interface that owns this instance.  */
    interface_ptr =  (UX_SLAVE_INTERFACE  *) command -> ux_slave_class_command_interface;
 800fc84:	687b      	ldr	r3, [r7, #4]
 800fc86:	689b      	ldr	r3, [r3, #8]
 800fc88:	60bb      	str	r3, [r7, #8]

    /* Store the class instance into the interface.  */
    interface_ptr -> ux_slave_interface_class_instance =  (VOID *)hid;
 800fc8a:	68bb      	ldr	r3, [r7, #8]
 800fc8c:	68fa      	ldr	r2, [r7, #12]
 800fc8e:	609a      	str	r2, [r3, #8]

    /* Now the opposite, store the interface in the class instance.  */
    hid -> ux_slave_class_hid_interface =  interface_ptr;
 800fc90:	68fb      	ldr	r3, [r7, #12]
 800fc92:	68ba      	ldr	r2, [r7, #8]
 800fc94:	601a      	str	r2, [r3, #0]

    /* Locate the endpoints.  */
    endpoint_interrupt =  interface_ptr -> ux_slave_interface_first_endpoint;
 800fc96:	68bb      	ldr	r3, [r7, #8]
 800fc98:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800fc9a:	61fb      	str	r3, [r7, #28]

    /* Check if interrupt IN endpoint exists.  */
    while (endpoint_interrupt != UX_NULL)
 800fc9c:	e019      	b.n	800fcd2 <_ux_device_class_hid_activate+0x6a>
    {
        if ((endpoint_interrupt -> ux_slave_endpoint_descriptor.bmAttributes &
 800fc9e:	69fb      	ldr	r3, [r7, #28]
 800fca0:	699b      	ldr	r3, [r3, #24]
 800fca2:	f003 0303 	and.w	r3, r3, #3
 800fca6:	2b03      	cmp	r3, #3
 800fca8:	d110      	bne.n	800fccc <_ux_device_class_hid_activate+0x64>
             UX_MASK_ENDPOINT_TYPE) == UX_INTERRUPT_ENDPOINT)
        {
            if ((endpoint_interrupt -> ux_slave_endpoint_descriptor.bEndpointAddress &
 800fcaa:	69fb      	ldr	r3, [r7, #28]
 800fcac:	695b      	ldr	r3, [r3, #20]
 800fcae:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800fcb2:	2b00      	cmp	r3, #0
 800fcb4:	d005      	beq.n	800fcc2 <_ux_device_class_hid_activate+0x5a>
                 UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_IN)
            {

                /* It's interrupt IN endpoint we need.  */
                endpoint_in = endpoint_interrupt;
 800fcb6:	69fb      	ldr	r3, [r7, #28]
 800fcb8:	61bb      	str	r3, [r7, #24]
#if defined(UX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT)
                if (endpoint_out != UX_NULL)
 800fcba:	697b      	ldr	r3, [r7, #20]
 800fcbc:	2b00      	cmp	r3, #0
 800fcbe:	d005      	beq.n	800fccc <_ux_device_class_hid_activate+0x64>
#endif
                    break;
 800fcc0:	e00c      	b.n	800fcdc <_ux_device_class_hid_activate+0x74>
#if defined(UX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT)
            else
            {

                /* It's optional interrupt OUT endpoint.  */
                endpoint_out = endpoint_interrupt;
 800fcc2:	69fb      	ldr	r3, [r7, #28]
 800fcc4:	617b      	str	r3, [r7, #20]
                if (endpoint_in != UX_NULL)
 800fcc6:	69bb      	ldr	r3, [r7, #24]
 800fcc8:	2b00      	cmp	r3, #0
 800fcca:	d106      	bne.n	800fcda <_ux_device_class_hid_activate+0x72>
            }
#endif
        }

        /* Try next endpoint.  */
        endpoint_interrupt =  endpoint_interrupt -> ux_slave_endpoint_next_endpoint;
 800fccc:	69fb      	ldr	r3, [r7, #28]
 800fcce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800fcd0:	61fb      	str	r3, [r7, #28]
    while (endpoint_interrupt != UX_NULL)
 800fcd2:	69fb      	ldr	r3, [r7, #28]
 800fcd4:	2b00      	cmp	r3, #0
 800fcd6:	d1e2      	bne.n	800fc9e <_ux_device_class_hid_activate+0x36>
 800fcd8:	e000      	b.n	800fcdc <_ux_device_class_hid_activate+0x74>
                    break;
 800fcda:	bf00      	nop
    }

    /* Check if we found right endpoint.  */
    if (endpoint_in == UX_NULL)
 800fcdc:	69bb      	ldr	r3, [r7, #24]
 800fcde:	2b00      	cmp	r3, #0
 800fce0:	d101      	bne.n	800fce6 <_ux_device_class_hid_activate+0x7e>
        return (UX_ERROR);
 800fce2:	23ff      	movs	r3, #255	; 0xff
 800fce4:	e03e      	b.n	800fd64 <_ux_device_class_hid_activate+0xfc>
    UX_ASSERT(UX_DEVICE_CLASS_HID_EVENT_BUFFER_LENGTH >=
              endpoint_in -> ux_slave_endpoint_transfer_request.
                            ux_slave_transfer_request_transfer_length);

    /* Default HID protocol is report protocol.  */
    hid -> ux_device_class_hid_protocol = UX_DEVICE_CLASS_HID_PROTOCOL_REPORT;
 800fce6:	68fb      	ldr	r3, [r7, #12]
 800fce8:	2201      	movs	r2, #1
 800fcea:	655a      	str	r2, [r3, #84]	; 0x54

    /* Save the endpoints in the hid instance.  */
    hid -> ux_device_class_hid_interrupt_endpoint         = endpoint_in;
 800fcec:	68fb      	ldr	r3, [r7, #12]
 800fcee:	69ba      	ldr	r2, [r7, #24]
 800fcf0:	605a      	str	r2, [r3, #4]

#if defined(UX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT)

    /* Save endpoint OUT.  */
    hid -> ux_device_class_hid_read_endpoint              = endpoint_out;
 800fcf2:	68fb      	ldr	r3, [r7, #12]
 800fcf4:	697a      	ldr	r2, [r7, #20]
 800fcf6:	669a      	str	r2, [r3, #104]	; 0x68

    /* Resume receiver thread/task (if present).  */
    if (hid -> ux_device_class_hid_receiver && endpoint_out)
 800fcf8:	68fb      	ldr	r3, [r7, #12]
 800fcfa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800fcfc:	2b00      	cmp	r3, #0
 800fcfe:	d023      	beq.n	800fd48 <_ux_device_class_hid_activate+0xe0>
 800fd00:	697b      	ldr	r3, [r7, #20]
 800fd02:	2b00      	cmp	r3, #0
 800fd04:	d020      	beq.n	800fd48 <_ux_device_class_hid_activate+0xe0>
    {

        /* Reset events.  */
        hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_event_save_pos =
            hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_events;
 800fd06:	68fb      	ldr	r3, [r7, #12]
 800fd08:	6eda      	ldr	r2, [r3, #108]	; 0x6c
        hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_event_save_pos =
 800fd0a:	68fb      	ldr	r3, [r7, #12]
 800fd0c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
            hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_events;
 800fd0e:	68d2      	ldr	r2, [r2, #12]
        hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_event_save_pos =
 800fd10:	619a      	str	r2, [r3, #24]
        hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_event_read_pos =
            hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_events;
 800fd12:	68fb      	ldr	r3, [r7, #12]
 800fd14:	6eda      	ldr	r2, [r3, #108]	; 0x6c
        hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_event_read_pos =
 800fd16:	68fb      	ldr	r3, [r7, #12]
 800fd18:	6edb      	ldr	r3, [r3, #108]	; 0x6c
            hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_events;
 800fd1a:	68d2      	ldr	r2, [r2, #12]
        hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_event_read_pos =
 800fd1c:	615a      	str	r2, [r3, #20]
        _ux_utility_memory_set(
            hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_events, 0x00,
 800fd1e:	68fb      	ldr	r3, [r7, #12]
 800fd20:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800fd22:	68d8      	ldr	r0, [r3, #12]
            (ALIGN_TYPE)hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_events_end -
 800fd24:	68fb      	ldr	r3, [r7, #12]
 800fd26:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800fd28:	691b      	ldr	r3, [r3, #16]
 800fd2a:	461a      	mov	r2, r3
            (ALIGN_TYPE)hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_events); /* Use case of memset is verified. */
 800fd2c:	68fb      	ldr	r3, [r7, #12]
 800fd2e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800fd30:	68db      	ldr	r3, [r3, #12]
        _ux_utility_memory_set(
 800fd32:	1ad3      	subs	r3, r2, r3
 800fd34:	461a      	mov	r2, r3
 800fd36:	2100      	movs	r1, #0
 800fd38:	f7ff fe2c 	bl	800f994 <_ux_utility_memory_set>

#if !defined(UX_DEVICE_STANDALONE)

        /* Resume thread.  */
        _ux_utility_thread_resume(&hid -> ux_device_class_hid_receiver -> ux_device_class_hid_receiver_thread);
 800fd3c:	68fb      	ldr	r3, [r7, #12]
 800fd3e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800fd40:	331c      	adds	r3, #28
 800fd42:	4618      	mov	r0, r3
 800fd44:	f7ff ff76 	bl	800fc34 <_ux_utility_thread_resume>
#endif

#if !defined(UX_DEVICE_STANDALONE)

    /* Resume thread.  */
    _ux_device_thread_resume(&class_ptr -> ux_slave_class_thread);
 800fd48:	693b      	ldr	r3, [r7, #16]
 800fd4a:	3350      	adds	r3, #80	; 0x50
 800fd4c:	4618      	mov	r0, r3
 800fd4e:	f7ff ff71 	bl	800fc34 <_ux_utility_thread_resume>
    hid -> ux_device_class_hid_event_state = UX_STATE_RESET;
#endif


    /* If there is a activate function call it.  */
    if (hid -> ux_slave_class_hid_instance_activate != UX_NULL)
 800fd52:	68fb      	ldr	r3, [r7, #12]
 800fd54:	695b      	ldr	r3, [r3, #20]
 800fd56:	2b00      	cmp	r3, #0
 800fd58:	d003      	beq.n	800fd62 <_ux_device_class_hid_activate+0xfa>
    {

        /* Invoke the application.  */
        hid -> ux_slave_class_hid_instance_activate(hid);
 800fd5a:	68fb      	ldr	r3, [r7, #12]
 800fd5c:	695b      	ldr	r3, [r3, #20]
 800fd5e:	68f8      	ldr	r0, [r7, #12]
 800fd60:	4798      	blx	r3

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_REGISTER(UX_TRACE_DEVICE_OBJECT_TYPE_INTERFACE, hid, 0, 0, 0)

    /* Return completion status.  */
    return(UX_SUCCESS);
 800fd62:	2300      	movs	r3, #0
}
 800fd64:	4618      	mov	r0, r3
 800fd66:	3720      	adds	r7, #32
 800fd68:	46bd      	mov	sp, r7
 800fd6a:	bd80      	pop	{r7, pc}

0800fd6c <_ux_device_class_hid_control_request>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_control_request(UX_SLAVE_CLASS_COMMAND *command)
{
 800fd6c:	b580      	push	{r7, lr}
 800fd6e:	b08c      	sub	sp, #48	; 0x30
 800fd70:	af00      	add	r7, sp, #0
 800fd72:	6078      	str	r0, [r7, #4]
ULONG                       descriptor_type;
UCHAR                       duration;
UX_SLAVE_CLASS_HID          *hid;

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
 800fd74:	4b5a      	ldr	r3, [pc, #360]	; (800fee0 <_ux_device_class_hid_control_request+0x174>)
 800fd76:	681b      	ldr	r3, [r3, #0]
 800fd78:	3320      	adds	r3, #32
 800fd7a:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Get the pointer to the transfer request associated with the control endpoint.  */
    transfer_request =  &device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request;
 800fd7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800fd7e:	336c      	adds	r3, #108	; 0x6c
 800fd80:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Extract all necessary fields of the request.  */
    request =  *(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_REQUEST);
 800fd82:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fd84:	f893 3055 	ldrb.w	r3, [r3, #85]	; 0x55
 800fd88:	627b      	str	r3, [r7, #36]	; 0x24
    request_value  =   _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_VALUE);
 800fd8a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fd8c:	3354      	adds	r3, #84	; 0x54
 800fd8e:	3302      	adds	r3, #2
 800fd90:	4618      	mov	r0, r3
 800fd92:	f7ff fe93 	bl	800fabc <_ux_utility_short_get>
 800fd96:	6238      	str	r0, [r7, #32]
    request_index  =   _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_INDEX);
 800fd98:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fd9a:	3354      	adds	r3, #84	; 0x54
 800fd9c:	3304      	adds	r3, #4
 800fd9e:	4618      	mov	r0, r3
 800fda0:	f7ff fe8c 	bl	800fabc <_ux_utility_short_get>
 800fda4:	61f8      	str	r0, [r7, #28]
    request_length =   _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_LENGTH);
 800fda6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fda8:	3354      	adds	r3, #84	; 0x54
 800fdaa:	3306      	adds	r3, #6
 800fdac:	4618      	mov	r0, r3
 800fdae:	f7ff fe85 	bl	800fabc <_ux_utility_short_get>
 800fdb2:	61b8      	str	r0, [r7, #24]

    /* Duration - upper byte of wValue.  */
    duration       =   *(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_VALUE + 1);
 800fdb4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fdb6:	f893 3057 	ldrb.w	r3, [r3, #87]	; 0x57
 800fdba:	75fb      	strb	r3, [r7, #23]
    
     /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
 800fdbc:	687b      	ldr	r3, [r7, #4]
 800fdbe:	6a1b      	ldr	r3, [r3, #32]
 800fdc0:	613b      	str	r3, [r7, #16]
    
    /* Get the storage instance from this class container.  */
    hid =  (UX_SLAVE_CLASS_HID *) class_ptr -> ux_slave_class_instance;
 800fdc2:	693b      	ldr	r3, [r7, #16]
 800fdc4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800fdc6:	60fb      	str	r3, [r7, #12]

    /* Here we proceed only the standard request we know of at the device level.  */
    switch (request)
 800fdc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fdca:	3b01      	subs	r3, #1
 800fdcc:	2b0a      	cmp	r3, #10
 800fdce:	d87e      	bhi.n	800fece <_ux_device_class_hid_control_request+0x162>
 800fdd0:	a201      	add	r2, pc, #4	; (adr r2, 800fdd8 <_ux_device_class_hid_control_request+0x6c>)
 800fdd2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fdd6:	bf00      	nop
 800fdd8:	0800fe05 	.word	0x0800fe05
 800fddc:	0800fe37 	.word	0x0800fe37
 800fde0:	0800feaf 	.word	0x0800feaf
 800fde4:	0800fecf 	.word	0x0800fecf
 800fde8:	0800fecf 	.word	0x0800fecf
 800fdec:	0800fe29 	.word	0x0800fe29
 800fdf0:	0800fecf 	.word	0x0800fecf
 800fdf4:	0800fecf 	.word	0x0800fecf
 800fdf8:	0800fe13 	.word	0x0800fe13
 800fdfc:	0800fe37 	.word	0x0800fe37
 800fe00:	0800fec7 	.word	0x0800fec7
    {

        case UX_DEVICE_CLASS_HID_COMMAND_GET_REPORT:

            /* Send the requested report to the host.  */
            _ux_device_class_hid_report_get(hid, request_value, request_index, request_length);
 800fe04:	69bb      	ldr	r3, [r7, #24]
 800fe06:	69fa      	ldr	r2, [r7, #28]
 800fe08:	6a39      	ldr	r1, [r7, #32]
 800fe0a:	68f8      	ldr	r0, [r7, #12]
 800fe0c:	f000 fc66 	bl	80106dc <_ux_device_class_hid_report_get>
            break;
 800fe10:	e060      	b.n	800fed4 <_ux_device_class_hid_control_request+0x168>

        case UX_DEVICE_CLASS_HID_COMMAND_SET_REPORT:

            /* Extract the descriptor type.  */
            descriptor_type =  (request_value & 0xff00) >> 8;
 800fe12:	6a3b      	ldr	r3, [r7, #32]
 800fe14:	0a1b      	lsrs	r3, r3, #8
 800fe16:	b2db      	uxtb	r3, r3
 800fe18:	60bb      	str	r3, [r7, #8]

            /* Get the requested report from the host.  */
            _ux_device_class_hid_report_set(hid, descriptor_type, request_index, request_length);
 800fe1a:	69bb      	ldr	r3, [r7, #24]
 800fe1c:	69fa      	ldr	r2, [r7, #28]
 800fe1e:	68b9      	ldr	r1, [r7, #8]
 800fe20:	68f8      	ldr	r0, [r7, #12]
 800fe22:	f000 fcdf 	bl	80107e4 <_ux_device_class_hid_report_set>
            break;
 800fe26:	e055      	b.n	800fed4 <_ux_device_class_hid_control_request+0x168>

        case UX_GET_DESCRIPTOR:

            /* Send the requested descriptor to the host.  */
            _ux_device_class_hid_descriptor_send(hid, request_value, request_index, request_length);
 800fe28:	69bb      	ldr	r3, [r7, #24]
 800fe2a:	69fa      	ldr	r2, [r7, #28]
 800fe2c:	6a39      	ldr	r1, [r7, #32]
 800fe2e:	68f8      	ldr	r0, [r7, #12]
 800fe30:	f000 f878 	bl	800ff24 <_ux_device_class_hid_descriptor_send>
            break;            
 800fe34:	e04e      	b.n	800fed4 <_ux_device_class_hid_control_request+0x168>
        case UX_DEVICE_CLASS_HID_COMMAND_GET_IDLE:
        case UX_DEVICE_CLASS_HID_COMMAND_SET_IDLE:

            /* Ignore Report ID for now.  */

            if (request == UX_DEVICE_CLASS_HID_COMMAND_GET_IDLE)
 800fe36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800fe38:	2b02      	cmp	r3, #2
 800fe3a:	d10b      	bne.n	800fe54 <_ux_device_class_hid_control_request+0xe8>
            {

                /* Send the idle rate.  */
                *transfer_request -> ux_slave_transfer_request_data_pointer = (UCHAR)hid -> ux_device_class_hid_event_idle_rate;
 800fe3c:	68fb      	ldr	r3, [r7, #12]
 800fe3e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800fe40:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800fe42:	68db      	ldr	r3, [r3, #12]
 800fe44:	b2d2      	uxtb	r2, r2
 800fe46:	701a      	strb	r2, [r3, #0]
                _ux_device_stack_transfer_request(transfer_request, 1, request_length);
 800fe48:	69ba      	ldr	r2, [r7, #24]
 800fe4a:	2101      	movs	r1, #1
 800fe4c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800fe4e:	f7ff f913 	bl	800f078 <_ux_device_stack_transfer_request>
                        _ux_device_event_flags_set(&hid -> ux_device_class_hid_event_flags_group, UX_DEVICE_CLASS_HID_NEW_IDLE_RATE, UX_OR);
#endif
                    }
                }
            }
            break;
 800fe52:	e03e      	b.n	800fed2 <_ux_device_class_hid_control_request+0x166>
                if ((UCHAR)hid -> ux_device_class_hid_event_idle_rate != duration)
 800fe54:	68fb      	ldr	r3, [r7, #12]
 800fe56:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800fe58:	b2db      	uxtb	r3, r3
 800fe5a:	7dfa      	ldrb	r2, [r7, #23]
 800fe5c:	429a      	cmp	r2, r3
 800fe5e:	d038      	beq.n	800fed2 <_ux_device_class_hid_control_request+0x166>
                    hid -> ux_device_class_hid_event_idle_rate = duration;
 800fe60:	7dfa      	ldrb	r2, [r7, #23]
 800fe62:	68fb      	ldr	r3, [r7, #12]
 800fe64:	64da      	str	r2, [r3, #76]	; 0x4c
                    if (duration == 0)
 800fe66:	7dfb      	ldrb	r3, [r7, #23]
 800fe68:	2b00      	cmp	r3, #0
 800fe6a:	d104      	bne.n	800fe76 <_ux_device_class_hid_control_request+0x10a>
                        hid -> ux_device_class_hid_event_wait_timeout = UX_WAIT_FOREVER;
 800fe6c:	68fb      	ldr	r3, [r7, #12]
 800fe6e:	f04f 32ff 	mov.w	r2, #4294967295
 800fe72:	651a      	str	r2, [r3, #80]	; 0x50
            break;
 800fe74:	e02d      	b.n	800fed2 <_ux_device_class_hid_control_request+0x166>
                        hid -> ux_device_class_hid_event_wait_timeout = (ULONG)UX_MS_TO_TICK((ULONG)duration << 2u);
 800fe76:	7dfb      	ldrb	r3, [r7, #23]
 800fe78:	f44f 72c8 	mov.w	r2, #400	; 0x190
 800fe7c:	fb02 f303 	mul.w	r3, r2, r3
 800fe80:	4a18      	ldr	r2, [pc, #96]	; (800fee4 <_ux_device_class_hid_control_request+0x178>)
 800fe82:	fba2 2303 	umull	r2, r3, r2, r3
 800fe86:	099a      	lsrs	r2, r3, #6
 800fe88:	68fb      	ldr	r3, [r7, #12]
 800fe8a:	651a      	str	r2, [r3, #80]	; 0x50
                        if (hid -> ux_device_class_hid_event_wait_timeout == 0)
 800fe8c:	68fb      	ldr	r3, [r7, #12]
 800fe8e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800fe90:	2b00      	cmp	r3, #0
 800fe92:	d104      	bne.n	800fe9e <_ux_device_class_hid_control_request+0x132>
                            hid -> ux_device_class_hid_event_wait_timeout ++;
 800fe94:	68fb      	ldr	r3, [r7, #12]
 800fe96:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800fe98:	1c5a      	adds	r2, r3, #1
 800fe9a:	68fb      	ldr	r3, [r7, #12]
 800fe9c:	651a      	str	r2, [r3, #80]	; 0x50
                        _ux_device_event_flags_set(&hid -> ux_device_class_hid_event_flags_group, UX_DEVICE_CLASS_HID_NEW_IDLE_RATE, UX_OR);
 800fe9e:	68fb      	ldr	r3, [r7, #12]
 800fea0:	3328      	adds	r3, #40	; 0x28
 800fea2:	2200      	movs	r2, #0
 800fea4:	2102      	movs	r1, #2
 800fea6:	4618      	mov	r0, r3
 800fea8:	f7ff fa9c 	bl	800f3e4 <_ux_utility_event_flags_set>
            break;
 800feac:	e011      	b.n	800fed2 <_ux_device_class_hid_control_request+0x166>

        case UX_DEVICE_CLASS_HID_COMMAND_GET_PROTOCOL:

            /* Send the protocol.  */
            *transfer_request -> ux_slave_transfer_request_data_pointer = (UCHAR)hid -> ux_device_class_hid_protocol;
 800feae:	68fb      	ldr	r3, [r7, #12]
 800feb0:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800feb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800feb4:	68db      	ldr	r3, [r3, #12]
 800feb6:	b2d2      	uxtb	r2, r2
 800feb8:	701a      	strb	r2, [r3, #0]
            _ux_device_stack_transfer_request(transfer_request, 1, request_length);
 800feba:	69ba      	ldr	r2, [r7, #24]
 800febc:	2101      	movs	r1, #1
 800febe:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800fec0:	f7ff f8da 	bl	800f078 <_ux_device_stack_transfer_request>
            break;
 800fec4:	e006      	b.n	800fed4 <_ux_device_class_hid_control_request+0x168>

        case UX_DEVICE_CLASS_HID_COMMAND_SET_PROTOCOL:

            /* Accept the protocol.  */
            hid -> ux_device_class_hid_protocol = request_value;
 800fec6:	68fb      	ldr	r3, [r7, #12]
 800fec8:	6a3a      	ldr	r2, [r7, #32]
 800feca:	655a      	str	r2, [r3, #84]	; 0x54
            break;
 800fecc:	e002      	b.n	800fed4 <_ux_device_class_hid_control_request+0x168>

        default:

            /* Unknown function. It's not handled.  */
            return(UX_ERROR);
 800fece:	23ff      	movs	r3, #255	; 0xff
 800fed0:	e001      	b.n	800fed6 <_ux_device_class_hid_control_request+0x16a>
            break;
 800fed2:	bf00      	nop
    }

    /* It's handled.  */
    return(UX_SUCCESS);
 800fed4:	2300      	movs	r3, #0
}
 800fed6:	4618      	mov	r0, r3
 800fed8:	3730      	adds	r7, #48	; 0x30
 800feda:	46bd      	mov	sp, r7
 800fedc:	bd80      	pop	{r7, pc}
 800fede:	bf00      	nop
 800fee0:	2000730c 	.word	0x2000730c
 800fee4:	10624dd3 	.word	0x10624dd3

0800fee8 <_ux_device_class_hid_deactivate>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_deactivate(UX_SLAVE_CLASS_COMMAND *command)
{
 800fee8:	b580      	push	{r7, lr}
 800feea:	b084      	sub	sp, #16
 800feec:	af00      	add	r7, sp, #0
 800feee:	6078      	str	r0, [r7, #4]
                                          
UX_SLAVE_CLASS_HID         *hid;
UX_SLAVE_CLASS             *class_ptr;

    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
 800fef0:	687b      	ldr	r3, [r7, #4]
 800fef2:	6a1b      	ldr	r3, [r3, #32]
 800fef4:	60fb      	str	r3, [r7, #12]

    /* Get the class instance in the container.  */
    hid = (UX_SLAVE_CLASS_HID *) class_ptr -> ux_slave_class_instance;
 800fef6:	68fb      	ldr	r3, [r7, #12]
 800fef8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800fefa:	60bb      	str	r3, [r7, #8]

    /* Terminate the transactions pending on the endpoints.  */
    _ux_device_stack_transfer_all_request_abort(hid -> ux_device_class_hid_interrupt_endpoint, UX_TRANSFER_BUS_RESET);
 800fefc:	68bb      	ldr	r3, [r7, #8]
 800fefe:	685b      	ldr	r3, [r3, #4]
 800ff00:	2126      	movs	r1, #38	; 0x26
 800ff02:	4618      	mov	r0, r3
 800ff04:	f7ff f8a6 	bl	800f054 <_ux_device_stack_transfer_all_request_abort>

    /* If there is a deactivate function call it.  */
    if (hid -> ux_slave_class_hid_instance_deactivate != UX_NULL)
 800ff08:	68bb      	ldr	r3, [r7, #8]
 800ff0a:	699b      	ldr	r3, [r3, #24]
 800ff0c:	2b00      	cmp	r3, #0
 800ff0e:	d003      	beq.n	800ff18 <_ux_device_class_hid_deactivate+0x30>
    {
        /* Invoke the application.  */
        hid -> ux_slave_class_hid_instance_deactivate(hid);
 800ff10:	68bb      	ldr	r3, [r7, #8]
 800ff12:	699b      	ldr	r3, [r3, #24]
 800ff14:	68b8      	ldr	r0, [r7, #8]
 800ff16:	4798      	blx	r3

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_UNREGISTER(hid);

    /* Return completion status.  */
    return(UX_SUCCESS);
 800ff18:	2300      	movs	r3, #0
}
 800ff1a:	4618      	mov	r0, r3
 800ff1c:	3710      	adds	r7, #16
 800ff1e:	46bd      	mov	sp, r7
 800ff20:	bd80      	pop	{r7, pc}
	...

0800ff24 <_ux_device_class_hid_descriptor_send>:
/*                                            resulting in version 6.1.8  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_descriptor_send(UX_SLAVE_CLASS_HID *hid, ULONG descriptor_type, 
                                            ULONG request_index, ULONG host_length)
{
 800ff24:	b580      	push	{r7, lr}
 800ff26:	b08e      	sub	sp, #56	; 0x38
 800ff28:	af00      	add	r7, sp, #0
 800ff2a:	60f8      	str	r0, [r7, #12]
 800ff2c:	60b9      	str	r1, [r7, #8]
 800ff2e:	607a      	str	r2, [r7, #4]
 800ff30:	603b      	str	r3, [r7, #0]
UX_SLAVE_TRANSFER               *transfer_request;
UX_SLAVE_ENDPOINT               *endpoint;
UCHAR *                         device_framework;
UCHAR *                         device_framework_end;
ULONG                           descriptor_length;
UINT                            status =  UX_ERROR;
 800ff32:	23ff      	movs	r3, #255	; 0xff
 800ff34:	633b      	str	r3, [r7, #48]	; 0x30
ULONG                           length;
UCHAR                           interface_number = 0xFF;
 800ff36:	23ff      	movs	r3, #255	; 0xff
 800ff38:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_HID_DESCRIPTOR_SEND, hid, descriptor_type, request_index, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Get the pointer to the DCD.  */
    dcd =  &_ux_system_slave -> ux_system_slave_dcd;
 800ff3c:	4b5a      	ldr	r3, [pc, #360]	; (80100a8 <_ux_device_class_hid_descriptor_send+0x184>)
 800ff3e:	681b      	ldr	r3, [r3, #0]
 800ff40:	627b      	str	r3, [r7, #36]	; 0x24

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
 800ff42:	4b59      	ldr	r3, [pc, #356]	; (80100a8 <_ux_device_class_hid_descriptor_send+0x184>)
 800ff44:	681b      	ldr	r3, [r3, #0]
 800ff46:	3320      	adds	r3, #32
 800ff48:	623b      	str	r3, [r7, #32]
    
    /* Get the control endpoint associated with the device.  */
    endpoint =  &device -> ux_slave_device_control_endpoint;
 800ff4a:	6a3b      	ldr	r3, [r7, #32]
 800ff4c:	333c      	adds	r3, #60	; 0x3c
 800ff4e:	61fb      	str	r3, [r7, #28]

    /* Get the pointer to the transfer request associated with the endpoint.  */
    transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
 800ff50:	69fb      	ldr	r3, [r7, #28]
 800ff52:	3330      	adds	r3, #48	; 0x30
 800ff54:	61bb      	str	r3, [r7, #24]

    /* Set the direction to OUT.  */
    transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
 800ff56:	69bb      	ldr	r3, [r7, #24]
 800ff58:	2203      	movs	r2, #3
 800ff5a:	629a      	str	r2, [r3, #40]	; 0x28
    
    /* Shift the descriptor type in the low byte field.  */
    descriptor_type =  (UCHAR) ((descriptor_type >> 8) & 0xff);
 800ff5c:	68bb      	ldr	r3, [r7, #8]
 800ff5e:	0a1b      	lsrs	r3, r3, #8
 800ff60:	b2db      	uxtb	r3, r3
 800ff62:	60bb      	str	r3, [r7, #8]

    /* What type of descriptor do we need to return?  */
    switch (descriptor_type)
 800ff64:	68bb      	ldr	r3, [r7, #8]
 800ff66:	2b21      	cmp	r3, #33	; 0x21
 800ff68:	d003      	beq.n	800ff72 <_ux_device_class_hid_descriptor_send+0x4e>
 800ff6a:	68bb      	ldr	r3, [r7, #8]
 800ff6c:	2b22      	cmp	r3, #34	; 0x22
 800ff6e:	d060      	beq.n	8010032 <_ux_device_class_hid_descriptor_send+0x10e>
 800ff70:	e08b      	b.n	801008a <_ux_device_class_hid_descriptor_send+0x166>
    {

    case UX_DEVICE_CLASS_HID_DESCRIPTOR_HID:
    
        /* We should have a HID descriptor as part of the config descriptor.  */
        device_framework =  _ux_system_slave -> ux_system_slave_device_framework;
 800ff72:	4b4d      	ldr	r3, [pc, #308]	; (80100a8 <_ux_device_class_hid_descriptor_send+0x184>)
 800ff74:	681b      	ldr	r3, [r3, #0]
 800ff76:	f8d3 3128 	ldr.w	r3, [r3, #296]	; 0x128
 800ff7a:	637b      	str	r3, [r7, #52]	; 0x34
        device_framework_end = device_framework + _ux_system_slave -> ux_system_slave_device_framework_length;
 800ff7c:	4b4a      	ldr	r3, [pc, #296]	; (80100a8 <_ux_device_class_hid_descriptor_send+0x184>)
 800ff7e:	681b      	ldr	r3, [r3, #0]
 800ff80:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
 800ff84:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800ff86:	4413      	add	r3, r2
 800ff88:	613b      	str	r3, [r7, #16]

        /* Parse the device framework and locate the HID descriptor.  
           There is only one HID descriptor.  */
        while (device_framework < device_framework_end)
 800ff8a:	e042      	b.n	8010012 <_ux_device_class_hid_descriptor_send+0xee>
        {

            /* Get the type of the current descriptor.  */
            descriptor_type =  *(device_framework + 1);
 800ff8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ff8e:	3301      	adds	r3, #1
 800ff90:	781b      	ldrb	r3, [r3, #0]
 800ff92:	60bb      	str	r3, [r7, #8]

            /* And its length.  */
            descriptor_length =  (ULONG) *device_framework;
 800ff94:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ff96:	781b      	ldrb	r3, [r3, #0]
 800ff98:	617b      	str	r3, [r7, #20]

            /* Save interface number for later check.  */
            if (descriptor_type == UX_INTERFACE_DESCRIPTOR_ITEM)
 800ff9a:	68bb      	ldr	r3, [r7, #8]
 800ff9c:	2b04      	cmp	r3, #4
 800ff9e:	d103      	bne.n	800ffa8 <_ux_device_class_hid_descriptor_send+0x84>
                interface_number = *(device_framework + 2);
 800ffa0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ffa2:	789b      	ldrb	r3, [r3, #2]
 800ffa4:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

            /* Check if this is a HID report descriptor.  */
            if ((descriptor_type == UX_DEVICE_CLASS_HID_DESCRIPTOR_HID) &&
 800ffa8:	68bb      	ldr	r3, [r7, #8]
 800ffaa:	2b21      	cmp	r3, #33	; 0x21
 800ffac:	d12d      	bne.n	801000a <_ux_device_class_hid_descriptor_send+0xe6>
                (interface_number == (UCHAR)request_index))
 800ffae:	687b      	ldr	r3, [r7, #4]
 800ffb0:	b2db      	uxtb	r3, r3
            if ((descriptor_type == UX_DEVICE_CLASS_HID_DESCRIPTOR_HID) &&
 800ffb2:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
 800ffb6:	429a      	cmp	r2, r3
 800ffb8:	d127      	bne.n	801000a <_ux_device_class_hid_descriptor_send+0xe6>
            {

                /* Ensure the host does not demand a length beyond our descriptor (Windows does that)
                   and do not return more than what is allowed.  */
                if (descriptor_length < host_length)
 800ffba:	697a      	ldr	r2, [r7, #20]
 800ffbc:	683b      	ldr	r3, [r7, #0]
 800ffbe:	429a      	cmp	r2, r3
 800ffc0:	d202      	bcs.n	800ffc8 <_ux_device_class_hid_descriptor_send+0xa4>
                    length =  descriptor_length;
 800ffc2:	697b      	ldr	r3, [r7, #20]
 800ffc4:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ffc6:	e001      	b.n	800ffcc <_ux_device_class_hid_descriptor_send+0xa8>
                else                            
                    length =  host_length;                
 800ffc8:	683b      	ldr	r3, [r7, #0]
 800ffca:	62fb      	str	r3, [r7, #44]	; 0x2c

                /* Check buffer length, since descriptor length may exceed buffer...  */
                if (length > UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH)
 800ffcc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ffce:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800ffd2:	d90c      	bls.n	800ffee <_ux_device_class_hid_descriptor_send+0xca>
                {

                    /* Error trap. */
                    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_MEMORY_INSUFFICIENT);
 800ffd4:	2212      	movs	r2, #18
 800ffd6:	2107      	movs	r1, #7
 800ffd8:	2002      	movs	r0, #2
 800ffda:	f7ff f8d7 	bl	800f18c <_ux_system_error_handler>

                    /* If trace is enabled, insert this event into the trace buffer.  */
                    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MEMORY_INSUFFICIENT, hid, 0, 0, UX_TRACE_ERRORS, 0, 0)

                    /* Stall the endpoint.  */
                    status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
 800ffde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ffe0:	699b      	ldr	r3, [r3, #24]
 800ffe2:	69fa      	ldr	r2, [r7, #28]
 800ffe4:	2114      	movs	r1, #20
 800ffe6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800ffe8:	4798      	blx	r3
 800ffea:	6338      	str	r0, [r7, #48]	; 0x30
                    break;
 800ffec:	e015      	b.n	801001a <_ux_device_class_hid_descriptor_send+0xf6>
                }

                /* Copy the device descriptor into the transfer request memory.  */
                _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer, 
 800ffee:	69bb      	ldr	r3, [r7, #24]
 800fff0:	68db      	ldr	r3, [r3, #12]
 800fff2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800fff4:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800fff6:	4618      	mov	r0, r3
 800fff8:	f7ff fbcf 	bl	800f79a <_ux_utility_memory_copy>
                                            device_framework, length); /* Use case of memcpy is verified. */

                /* We can return the configuration descriptor.  */
                status =  _ux_device_stack_transfer_request(transfer_request, length, host_length);
 800fffc:	683a      	ldr	r2, [r7, #0]
 800fffe:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8010000:	69b8      	ldr	r0, [r7, #24]
 8010002:	f7ff f839 	bl	800f078 <_ux_device_stack_transfer_request>
 8010006:	6338      	str	r0, [r7, #48]	; 0x30
                break;
 8010008:	e007      	b.n	801001a <_ux_device_class_hid_descriptor_send+0xf6>
                
            }

            /* Point to the next descriptor.  */
            device_framework +=  descriptor_length;
 801000a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801000c:	697b      	ldr	r3, [r7, #20]
 801000e:	4413      	add	r3, r2
 8010010:	637b      	str	r3, [r7, #52]	; 0x34
        while (device_framework < device_framework_end)
 8010012:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8010014:	693b      	ldr	r3, [r7, #16]
 8010016:	429a      	cmp	r2, r3
 8010018:	d3b8      	bcc.n	800ff8c <_ux_device_class_hid_descriptor_send+0x68>
        }

        /* Stall the endpoint if not found or corrupt.  */
        if (device_framework >= device_framework_end)
 801001a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801001c:	693b      	ldr	r3, [r7, #16]
 801001e:	429a      	cmp	r2, r3
 8010020:	d33b      	bcc.n	801009a <_ux_device_class_hid_descriptor_send+0x176>
            status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
 8010022:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010024:	699b      	ldr	r3, [r3, #24]
 8010026:	69fa      	ldr	r2, [r7, #28]
 8010028:	2114      	movs	r1, #20
 801002a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801002c:	4798      	blx	r3
 801002e:	6338      	str	r0, [r7, #48]	; 0x30

        break;
 8010030:	e033      	b.n	801009a <_ux_device_class_hid_descriptor_send+0x176>

    case UX_DEVICE_CLASS_HID_DESCRIPTOR_REPORT:
        
        /* Get the length of entire configuration descriptor.  */
        descriptor_length =  hid -> ux_device_class_hid_report_length;
 8010032:	68fb      	ldr	r3, [r7, #12]
 8010034:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010036:	617b      	str	r3, [r7, #20]

        /* Ensure the host does not demand a length beyond our descriptor (Windows does that)
           and do not return more than what is allowed.  */
        if (descriptor_length < host_length)
 8010038:	697a      	ldr	r2, [r7, #20]
 801003a:	683b      	ldr	r3, [r7, #0]
 801003c:	429a      	cmp	r2, r3
 801003e:	d202      	bcs.n	8010046 <_ux_device_class_hid_descriptor_send+0x122>
            length =  descriptor_length;
 8010040:	697b      	ldr	r3, [r7, #20]
 8010042:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010044:	e001      	b.n	801004a <_ux_device_class_hid_descriptor_send+0x126>
        else                            
            length =  host_length;                
 8010046:	683b      	ldr	r3, [r7, #0]
 8010048:	62fb      	str	r3, [r7, #44]	; 0x2c

        /* Check buffer length, since total descriptors length may exceed buffer...  */
        if (length > UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH)
 801004a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801004c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8010050:	d90c      	bls.n	801006c <_ux_device_class_hid_descriptor_send+0x148>
        {

            /* Error trap. */
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_MEMORY_INSUFFICIENT);
 8010052:	2212      	movs	r2, #18
 8010054:	2107      	movs	r1, #7
 8010056:	2002      	movs	r0, #2
 8010058:	f7ff f898 	bl	800f18c <_ux_system_error_handler>

            /* If trace is enabled, insert this event into the trace buffer.  */
            UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MEMORY_INSUFFICIENT, hid, 0, 0, UX_TRACE_ERRORS, 0, 0)

            /* Stall the endpoint.  */
            status =  dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
 801005c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801005e:	699b      	ldr	r3, [r3, #24]
 8010060:	69fa      	ldr	r2, [r7, #28]
 8010062:	2114      	movs	r1, #20
 8010064:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010066:	4798      	blx	r3
 8010068:	6338      	str	r0, [r7, #48]	; 0x30
            break;
 801006a:	e017      	b.n	801009c <_ux_device_class_hid_descriptor_send+0x178>
        }

        /* Copy the device descriptor into the transfer request memory.  */
        _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer, 
 801006c:	69bb      	ldr	r3, [r7, #24]
 801006e:	68d8      	ldr	r0, [r3, #12]
                                    hid -> ux_device_class_hid_report_address, length); /* Use case of memcpy is verified. */
 8010070:	68fb      	ldr	r3, [r7, #12]
 8010072:	69db      	ldr	r3, [r3, #28]
        _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer, 
 8010074:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8010076:	4619      	mov	r1, r3
 8010078:	f7ff fb8f 	bl	800f79a <_ux_utility_memory_copy>

        /* We can return the report descriptor.  */
        status =  _ux_device_stack_transfer_request(transfer_request, length, host_length);
 801007c:	683a      	ldr	r2, [r7, #0]
 801007e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8010080:	69b8      	ldr	r0, [r7, #24]
 8010082:	f7fe fff9 	bl	800f078 <_ux_device_stack_transfer_request>
 8010086:	6338      	str	r0, [r7, #48]	; 0x30
        break;
 8010088:	e008      	b.n	801009c <_ux_device_class_hid_descriptor_send+0x178>
        /* Not treated for now.  Fall through and Stall endpoint.  */
        
    default:

        /* Stall the endpoint.  */
        dcd -> ux_slave_dcd_function(dcd, UX_DCD_STALL_ENDPOINT, endpoint);
 801008a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801008c:	699b      	ldr	r3, [r3, #24]
 801008e:	69fa      	ldr	r2, [r7, #28]
 8010090:	2114      	movs	r1, #20
 8010092:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010094:	4798      	blx	r3
        return(UX_ERROR);
 8010096:	23ff      	movs	r3, #255	; 0xff
 8010098:	e001      	b.n	801009e <_ux_device_class_hid_descriptor_send+0x17a>
        break;
 801009a:	bf00      	nop
    }

    /* Return the status to the caller.  */
    return(status);
 801009c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
 801009e:	4618      	mov	r0, r3
 80100a0:	3738      	adds	r7, #56	; 0x38
 80100a2:	46bd      	mov	sp, r7
 80100a4:	bd80      	pop	{r7, pc}
 80100a6:	bf00      	nop
 80100a8:	2000730c 	.word	0x2000730c

080100ac <_ux_device_class_hid_entry>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_entry(UX_SLAVE_CLASS_COMMAND *command)
{
 80100ac:	b580      	push	{r7, lr}
 80100ae:	b084      	sub	sp, #16
 80100b0:	af00      	add	r7, sp, #0
 80100b2:	6078      	str	r0, [r7, #4]
UINT        status;


    /* The command request will tell us we need to do here, either a enumeration
       query, an activation or a deactivation.  */
    switch (command -> ux_slave_class_command_request)
 80100b4:	687b      	ldr	r3, [r7, #4]
 80100b6:	681b      	ldr	r3, [r3, #0]
 80100b8:	3b01      	subs	r3, #1
 80100ba:	2b06      	cmp	r3, #6
 80100bc:	d836      	bhi.n	801012c <_ux_device_class_hid_entry+0x80>
 80100be:	a201      	add	r2, pc, #4	; (adr r2, 80100c4 <_ux_device_class_hid_entry+0x18>)
 80100c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80100c4:	080100f9 	.word	0x080100f9
 80100c8:	08010109 	.word	0x08010109
 80100cc:	08010115 	.word	0x08010115
 80100d0:	08010121 	.word	0x08010121
 80100d4:	080100e1 	.word	0x080100e1
 80100d8:	0801012d 	.word	0x0801012d
 80100dc:	080100ed 	.word	0x080100ed
    {

    case UX_SLAVE_CLASS_COMMAND_INITIALIZE:

        /* Call the init function of the HID class.  */
        status =  _ux_device_class_hid_initialize(command);
 80100e0:	6878      	ldr	r0, [r7, #4]
 80100e2:	f000 f873 	bl	80101cc <_ux_device_class_hid_initialize>
 80100e6:	60f8      	str	r0, [r7, #12]
        
        /* Return the completion status.  */
        return(status);
 80100e8:	68fb      	ldr	r3, [r7, #12]
 80100ea:	e020      	b.n	801012e <_ux_device_class_hid_entry+0x82>

    case UX_SLAVE_CLASS_COMMAND_UNINITIALIZE:

        /* Call the init function of the HID class.  */
        status =  _ux_device_class_hid_uninitialize(command);
 80100ec:	6878      	ldr	r0, [r7, #4]
 80100ee:	f000 fbc3 	bl	8010878 <_ux_device_class_hid_uninitialize>
 80100f2:	60f8      	str	r0, [r7, #12]
        
        /* Return the completion status.  */
        return(status);
 80100f4:	68fb      	ldr	r3, [r7, #12]
 80100f6:	e01a      	b.n	801012e <_ux_device_class_hid_entry+0x82>

    case UX_SLAVE_CLASS_COMMAND_QUERY:

        /* Check the CLASS definition in the interface descriptor. */
        if (command -> ux_slave_class_command_class == UX_DEVICE_CLASS_HID_CLASS)
 80100f8:	687b      	ldr	r3, [r7, #4]
 80100fa:	695b      	ldr	r3, [r3, #20]
 80100fc:	2b03      	cmp	r3, #3
 80100fe:	d101      	bne.n	8010104 <_ux_device_class_hid_entry+0x58>
            return(UX_SUCCESS);
 8010100:	2300      	movs	r3, #0
 8010102:	e014      	b.n	801012e <_ux_device_class_hid_entry+0x82>
        else
            return(UX_NO_CLASS_MATCH);
 8010104:	2357      	movs	r3, #87	; 0x57
 8010106:	e012      	b.n	801012e <_ux_device_class_hid_entry+0x82>
    case UX_SLAVE_CLASS_COMMAND_ACTIVATE:

        /* The activate command is used when the host has sent a SET_CONFIGURATION command
           and this interface has to be mounted. Both Bulk endpoints have to be mounted
           and the hid thread needs to be activated.  */
        status =  _ux_device_class_hid_activate(command);
 8010108:	6878      	ldr	r0, [r7, #4]
 801010a:	f7ff fdad 	bl	800fc68 <_ux_device_class_hid_activate>
 801010e:	60f8      	str	r0, [r7, #12]

        /* Return the completion status.  */
        return(status);
 8010110:	68fb      	ldr	r3, [r7, #12]
 8010112:	e00c      	b.n	801012e <_ux_device_class_hid_entry+0x82>

    case UX_SLAVE_CLASS_COMMAND_DEACTIVATE:

        /* The deactivate command is used when the device has been extracted.
           The device endpoints have to be dismounted and the hid thread canceled.  */
        status =  _ux_device_class_hid_deactivate(command);
 8010114:	6878      	ldr	r0, [r7, #4]
 8010116:	f7ff fee7 	bl	800fee8 <_ux_device_class_hid_deactivate>
 801011a:	60f8      	str	r0, [r7, #12]
        
        /* Return the completion status.  */
        return(status);
 801011c:	68fb      	ldr	r3, [r7, #12]
 801011e:	e006      	b.n	801012e <_ux_device_class_hid_entry+0x82>

    case UX_SLAVE_CLASS_COMMAND_REQUEST:

        /* The request command is used when the host sends a command on the control endpoint.  */
        status = _ux_device_class_hid_control_request(command);
 8010120:	6878      	ldr	r0, [r7, #4]
 8010122:	f7ff fe23 	bl	800fd6c <_ux_device_class_hid_control_request>
 8010126:	60f8      	str	r0, [r7, #12]

        /* Return the completion status.  */
        return(status);
 8010128:	68fb      	ldr	r3, [r7, #12]
 801012a:	e000      	b.n	801012e <_ux_device_class_hid_entry+0x82>

        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

        /* Return an error.  */
        return(UX_FUNCTION_NOT_SUPPORTED);
 801012c:	2354      	movs	r3, #84	; 0x54
    }   
}
 801012e:	4618      	mov	r0, r3
 8010130:	3710      	adds	r7, #16
 8010132:	46bd      	mov	sp, r7
 8010134:	bd80      	pop	{r7, pc}
 8010136:	bf00      	nop

08010138 <_ux_device_class_hid_event_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_event_get(UX_SLAVE_CLASS_HID *hid, 
                                      UX_SLAVE_CLASS_HID_EVENT *hid_event)
{
 8010138:	b580      	push	{r7, lr}
 801013a:	b084      	sub	sp, #16
 801013c:	af00      	add	r7, sp, #0
 801013e:	6078      	str	r0, [r7, #4]
 8010140:	6039      	str	r1, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_HID_EVENT_GET, hid, hid_event, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Get the pointer to the device.  */                   
    device =  &_ux_system_slave -> ux_system_slave_device;
 8010142:	4b21      	ldr	r3, [pc, #132]	; (80101c8 <_ux_device_class_hid_event_get+0x90>)
 8010144:	681b      	ldr	r3, [r3, #0]
 8010146:	3320      	adds	r3, #32
 8010148:	60fb      	str	r3, [r7, #12]
    
    /* Check the device state.  */
    if (device -> ux_slave_device_state != UX_DEVICE_CONFIGURED)
 801014a:	68fb      	ldr	r3, [r7, #12]
 801014c:	681b      	ldr	r3, [r3, #0]
 801014e:	2b03      	cmp	r3, #3
 8010150:	d001      	beq.n	8010156 <_ux_device_class_hid_event_get+0x1e>
        return(UX_DEVICE_HANDLE_UNKNOWN);
 8010152:	2350      	movs	r3, #80	; 0x50
 8010154:	e033      	b.n	80101be <_ux_device_class_hid_event_get+0x86>

    /* Check if the head and the tail of the event array is the same.  */
    if (hid -> ux_device_class_hid_event_array_head == 
 8010156:	687b      	ldr	r3, [r7, #4]
 8010158:	6dda      	ldr	r2, [r3, #92]	; 0x5c
        hid -> ux_device_class_hid_event_array_tail)
 801015a:	687b      	ldr	r3, [r7, #4]
 801015c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    if (hid -> ux_device_class_hid_event_array_head == 
 801015e:	429a      	cmp	r2, r3
 8010160:	d101      	bne.n	8010166 <_ux_device_class_hid_event_get+0x2e>

        /* No event to report.  */
        return(UX_ERROR);        
 8010162:	23ff      	movs	r3, #255	; 0xff
 8010164:	e02b      	b.n	80101be <_ux_device_class_hid_event_get+0x86>

    /* There is an event to report, get the current pointer to the event.  */
    current_hid_event =  hid -> ux_device_class_hid_event_array_tail;
 8010166:	687b      	ldr	r3, [r7, #4]
 8010168:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 801016a:	60bb      	str	r3, [r7, #8]

    /* Keep the event data length inside buffer area.  */
    if (current_hid_event -> ux_device_class_hid_event_length > UX_DEVICE_CLASS_HID_EVENT_BUFFER_LENGTH)
 801016c:	68bb      	ldr	r3, [r7, #8]
 801016e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010170:	2b20      	cmp	r3, #32
 8010172:	d902      	bls.n	801017a <_ux_device_class_hid_event_get+0x42>
        current_hid_event -> ux_device_class_hid_event_length = UX_DEVICE_CLASS_HID_EVENT_BUFFER_LENGTH;
 8010174:	68bb      	ldr	r3, [r7, #8]
 8010176:	2220      	movs	r2, #32
 8010178:	629a      	str	r2, [r3, #40]	; 0x28

    /* fill in the event structure from the user.  */
    hid_event -> ux_device_class_hid_event_length =  current_hid_event -> ux_device_class_hid_event_length;
 801017a:	68bb      	ldr	r3, [r7, #8]
 801017c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801017e:	683b      	ldr	r3, [r7, #0]
 8010180:	629a      	str	r2, [r3, #40]	; 0x28
    _ux_utility_memory_copy(hid_event -> ux_device_class_hid_event_buffer, current_hid_event -> ux_device_class_hid_event_buffer,
 8010182:	683b      	ldr	r3, [r7, #0]
 8010184:	f103 0008 	add.w	r0, r3, #8
 8010188:	68bb      	ldr	r3, [r7, #8]
 801018a:	f103 0108 	add.w	r1, r3, #8
 801018e:	68bb      	ldr	r3, [r7, #8]
 8010190:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8010192:	461a      	mov	r2, r3
 8010194:	f7ff fb01 	bl	800f79a <_ux_utility_memory_copy>
                                current_hid_event -> ux_device_class_hid_event_length); /* Use case of memcpy is verified. */

    /* Adjust the tail pointer.  Check if we are at the end.  */
    if ((current_hid_event + 1) == hid -> ux_device_class_hid_event_array_end)
 8010198:	68bb      	ldr	r3, [r7, #8]
 801019a:	f103 022c 	add.w	r2, r3, #44	; 0x2c
 801019e:	687b      	ldr	r3, [r7, #4]
 80101a0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80101a2:	429a      	cmp	r2, r3
 80101a4:	d104      	bne.n	80101b0 <_ux_device_class_hid_event_get+0x78>

        /* We are at the end, go back to the beginning.  */
        hid -> ux_device_class_hid_event_array_tail =  hid -> ux_device_class_hid_event_array;
 80101a6:	687b      	ldr	r3, [r7, #4]
 80101a8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80101aa:	687b      	ldr	r3, [r7, #4]
 80101ac:	661a      	str	r2, [r3, #96]	; 0x60
 80101ae:	e005      	b.n	80101bc <_ux_device_class_hid_event_get+0x84>
        
    else        
        /* We are not at the end, increment the tail position.  */
        hid -> ux_device_class_hid_event_array_tail++;
 80101b0:	687b      	ldr	r3, [r7, #4]
 80101b2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80101b4:	f103 022c 	add.w	r2, r3, #44	; 0x2c
 80101b8:	687b      	ldr	r3, [r7, #4]
 80101ba:	661a      	str	r2, [r3, #96]	; 0x60

    /* Return event status to the user.  */
    return(UX_SUCCESS);
 80101bc:	2300      	movs	r3, #0
}
 80101be:	4618      	mov	r0, r3
 80101c0:	3710      	adds	r7, #16
 80101c2:	46bd      	mov	sp, r7
 80101c4:	bd80      	pop	{r7, pc}
 80101c6:	bf00      	nop
 80101c8:	2000730c 	.word	0x2000730c

080101cc <_ux_device_class_hid_initialize>:
/*                                            fixed compile warnings,     */
/*                                            resulting in version 6.2.0  */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_initialize(UX_SLAVE_CLASS_COMMAND *command)
{
 80101cc:	b580      	push	{r7, lr}
 80101ce:	b08c      	sub	sp, #48	; 0x30
 80101d0:	af06      	add	r7, sp, #24
 80101d2:	6078      	str	r0, [r7, #4]
                                          
UX_SLAVE_CLASS_HID                      *hid;
UX_SLAVE_CLASS_HID_PARAMETER            *hid_parameter;
UX_SLAVE_CLASS                          *class_ptr;
UINT                                    status = UX_SUCCESS;
 80101d4:	2300      	movs	r3, #0
 80101d6:	617b      	str	r3, [r7, #20]


    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
 80101d8:	687b      	ldr	r3, [r7, #4]
 80101da:	6a1b      	ldr	r3, [r3, #32]
 80101dc:	613b      	str	r3, [r7, #16]

    /* Create an instance of the device hid class.  */
    hid =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS_HID));
 80101de:	22a4      	movs	r2, #164	; 0xa4
 80101e0:	2100      	movs	r1, #0
 80101e2:	2000      	movs	r0, #0
 80101e4:	f7ff f9b0 	bl	800f548 <_ux_utility_memory_allocate>
 80101e8:	60f8      	str	r0, [r7, #12]

    /* Check for successful allocation.  */
    if (hid == UX_NULL)
 80101ea:	68fb      	ldr	r3, [r7, #12]
 80101ec:	2b00      	cmp	r3, #0
 80101ee:	d101      	bne.n	80101f4 <_ux_device_class_hid_initialize+0x28>
        return(UX_MEMORY_INSUFFICIENT);
 80101f0:	2312      	movs	r3, #18
 80101f2:	e0c8      	b.n	8010386 <_ux_device_class_hid_initialize+0x1ba>

    /* Save the address of the HID instance inside the HID container.  */
    class_ptr -> ux_slave_class_instance = (VOID *) hid;
 80101f4:	693b      	ldr	r3, [r7, #16]
 80101f6:	68fa      	ldr	r2, [r7, #12]
 80101f8:	649a      	str	r2, [r3, #72]	; 0x48

#if !defined(UX_DEVICE_STANDALONE)

    /* Allocate some memory for the thread stack. */
    class_ptr -> ux_slave_class_thread_stack =  
            _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_DEVICE_CLASS_HID_THREAD_STACK_SIZE);
 80101fa:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80101fe:	2100      	movs	r1, #0
 8010200:	2000      	movs	r0, #0
 8010202:	f7ff f9a1 	bl	800f548 <_ux_utility_memory_allocate>
 8010206:	4602      	mov	r2, r0
    class_ptr -> ux_slave_class_thread_stack =  
 8010208:	693b      	ldr	r3, [r7, #16]
 801020a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    
    /* Check for successful allocation.  */
    if (class_ptr -> ux_slave_class_thread_stack == UX_NULL)
 801020e:	693b      	ldr	r3, [r7, #16]
 8010210:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8010214:	2b00      	cmp	r3, #0
 8010216:	d101      	bne.n	801021c <_ux_device_class_hid_initialize+0x50>
        status = UX_MEMORY_INSUFFICIENT;
 8010218:	2312      	movs	r3, #18
 801021a:	617b      	str	r3, [r7, #20]

    /* This instance needs to be running in a different thread. So start
       a new thread. We pass a pointer to the class to the new thread.  This thread
       does not start until we have a instance of the class. */
    if (status == UX_SUCCESS)
 801021c:	697b      	ldr	r3, [r7, #20]
 801021e:	2b00      	cmp	r3, #0
 8010220:	d118      	bne.n	8010254 <_ux_device_class_hid_initialize+0x88>
        status =  _ux_device_thread_create(&class_ptr -> ux_slave_class_thread, "ux_slave_hid_thread", 
 8010222:	693b      	ldr	r3, [r7, #16]
 8010224:	f103 0050 	add.w	r0, r3, #80	; 0x50
 8010228:	693a      	ldr	r2, [r7, #16]
 801022a:	693b      	ldr	r3, [r7, #16]
 801022c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8010230:	2100      	movs	r1, #0
 8010232:	9105      	str	r1, [sp, #20]
 8010234:	2100      	movs	r1, #0
 8010236:	9104      	str	r1, [sp, #16]
 8010238:	2114      	movs	r1, #20
 801023a:	9103      	str	r1, [sp, #12]
 801023c:	2114      	movs	r1, #20
 801023e:	9102      	str	r1, [sp, #8]
 8010240:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8010244:	9101      	str	r1, [sp, #4]
 8010246:	9300      	str	r3, [sp, #0]
 8010248:	4613      	mov	r3, r2
 801024a:	4a51      	ldr	r2, [pc, #324]	; (8010390 <_ux_device_class_hid_initialize+0x1c4>)
 801024c:	4951      	ldr	r1, [pc, #324]	; (8010394 <_ux_device_class_hid_initialize+0x1c8>)
 801024e:	f7ff fcb4 	bl	800fbba <_ux_utility_thread_create>
 8010252:	6178      	str	r0, [r7, #20]
    /* Set task function.  */
    class_ptr -> ux_slave_class_task_function = _ux_device_class_hid_tasks_run;
#endif

    /* Check the creation of this thread.  */
    if (status == UX_SUCCESS)
 8010254:	697b      	ldr	r3, [r7, #20]
 8010256:	2b00      	cmp	r3, #0
 8010258:	f040 8081 	bne.w	801035e <_ux_device_class_hid_initialize+0x192>
#if !defined(UX_DEVICE_STANDALONE)
        UX_THREAD_EXTENSION_PTR_SET(&(class_ptr -> ux_slave_class_thread), class_ptr)
#endif

        /* Get the pointer to the application parameters for the hid class.  */
        hid_parameter =  command -> ux_slave_class_command_parameter;
 801025c:	687b      	ldr	r3, [r7, #4]
 801025e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010260:	60bb      	str	r3, [r7, #8]

        /* Store all the application parameter information about the report.  */
        hid -> ux_device_class_hid_report_address             = hid_parameter -> ux_device_class_hid_parameter_report_address;
 8010262:	68bb      	ldr	r3, [r7, #8]
 8010264:	689a      	ldr	r2, [r3, #8]
 8010266:	68fb      	ldr	r3, [r7, #12]
 8010268:	61da      	str	r2, [r3, #28]
        hid -> ux_device_class_hid_report_length              = hid_parameter -> ux_device_class_hid_parameter_report_length;
 801026a:	68bb      	ldr	r3, [r7, #8]
 801026c:	691a      	ldr	r2, [r3, #16]
 801026e:	68fb      	ldr	r3, [r7, #12]
 8010270:	625a      	str	r2, [r3, #36]	; 0x24
        hid -> ux_device_class_hid_report_id                  = hid_parameter -> ux_device_class_hid_parameter_report_id;
 8010272:	68bb      	ldr	r3, [r7, #8]
 8010274:	68da      	ldr	r2, [r3, #12]
 8010276:	68fb      	ldr	r3, [r7, #12]
 8010278:	621a      	str	r2, [r3, #32]

        /* Store the callback function.  */
        hid -> ux_device_class_hid_callback                   = hid_parameter -> ux_device_class_hid_parameter_callback;
 801027a:	68bb      	ldr	r3, [r7, #8]
 801027c:	695a      	ldr	r2, [r3, #20]
 801027e:	68fb      	ldr	r3, [r7, #12]
 8010280:	60da      	str	r2, [r3, #12]
        hid -> ux_device_class_hid_get_callback               = hid_parameter -> ux_device_class_hid_parameter_get_callback;
 8010282:	68bb      	ldr	r3, [r7, #8]
 8010284:	699a      	ldr	r2, [r3, #24]
 8010286:	68fb      	ldr	r3, [r7, #12]
 8010288:	611a      	str	r2, [r3, #16]

        /* Create the event array.  */
        hid -> ux_device_class_hid_event_array =  _ux_utility_memory_allocate_mulc_safe(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS_HID_EVENT), UX_DEVICE_CLASS_HID_MAX_EVENTS_QUEUE);
 801028a:	2310      	movs	r3, #16
 801028c:	222c      	movs	r2, #44	; 0x2c
 801028e:	2100      	movs	r1, #0
 8010290:	2000      	movs	r0, #0
 8010292:	f7ff fa5d 	bl	800f750 <_ux_utility_memory_allocate_mulc_safe>
 8010296:	4602      	mov	r2, r0
 8010298:	68fb      	ldr	r3, [r7, #12]
 801029a:	659a      	str	r2, [r3, #88]	; 0x58

        /* Check for successful allocation.  */
        if (hid -> ux_device_class_hid_event_array != UX_NULL)
 801029c:	68fb      	ldr	r3, [r7, #12]
 801029e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80102a0:	2b00      	cmp	r3, #0
 80102a2:	d054      	beq.n	801034e <_ux_device_class_hid_initialize+0x182>
        {

            /* Initialize the head and tail of the notification round robin buffers. 
               At first, the head and tail are pointing to the beginning of the array.  */
            hid -> ux_device_class_hid_event_array_head =  hid -> ux_device_class_hid_event_array;
 80102a4:	68fb      	ldr	r3, [r7, #12]
 80102a6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80102a8:	68fb      	ldr	r3, [r7, #12]
 80102aa:	65da      	str	r2, [r3, #92]	; 0x5c
            hid -> ux_device_class_hid_event_array_tail =  hid -> ux_device_class_hid_event_array;
 80102ac:	68fb      	ldr	r3, [r7, #12]
 80102ae:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80102b0:	68fb      	ldr	r3, [r7, #12]
 80102b2:	661a      	str	r2, [r3, #96]	; 0x60
            hid -> ux_device_class_hid_event_array_end  =  hid -> ux_device_class_hid_event_array + UX_DEVICE_CLASS_HID_MAX_EVENTS_QUEUE;
 80102b4:	68fb      	ldr	r3, [r7, #12]
 80102b6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80102b8:	f503 7230 	add.w	r2, r3, #704	; 0x2c0
 80102bc:	68fb      	ldr	r3, [r7, #12]
 80102be:	665a      	str	r2, [r3, #100]	; 0x64

            /* Store the start and stop signals if needed by the application.  */
            hid -> ux_slave_class_hid_instance_activate = hid_parameter -> ux_slave_class_hid_instance_activate;
 80102c0:	68bb      	ldr	r3, [r7, #8]
 80102c2:	681a      	ldr	r2, [r3, #0]
 80102c4:	68fb      	ldr	r3, [r7, #12]
 80102c6:	615a      	str	r2, [r3, #20]
            hid -> ux_slave_class_hid_instance_deactivate = hid_parameter -> ux_slave_class_hid_instance_deactivate;
 80102c8:	68bb      	ldr	r3, [r7, #8]
 80102ca:	685a      	ldr	r2, [r3, #4]
 80102cc:	68fb      	ldr	r3, [r7, #12]
 80102ce:	619a      	str	r2, [r3, #24]

            /* By default no event wait timeout.  */
            hid -> ux_device_class_hid_event_wait_timeout = UX_WAIT_FOREVER;
 80102d0:	68fb      	ldr	r3, [r7, #12]
 80102d2:	f04f 32ff 	mov.w	r2, #4294967295
 80102d6:	651a      	str	r2, [r3, #80]	; 0x50

#if !defined(UX_DEVICE_STANDALONE)

            /* Create a event flag group for the hid class to synchronize with the event interrupt thread.  */
            status =  _ux_utility_event_flags_create(&hid -> ux_device_class_hid_event_flags_group, "ux_device_class_hid_event_flag");
 80102d8:	68fb      	ldr	r3, [r7, #12]
 80102da:	3328      	adds	r3, #40	; 0x28
 80102dc:	492e      	ldr	r1, [pc, #184]	; (8010398 <_ux_device_class_hid_initialize+0x1cc>)
 80102de:	4618      	mov	r0, r3
 80102e0:	f7ff f842 	bl	800f368 <_ux_utility_event_flags_create>
 80102e4:	6178      	str	r0, [r7, #20]

            /* Check status.  */
            if (status != UX_SUCCESS)
 80102e6:	697b      	ldr	r3, [r7, #20]
 80102e8:	2b00      	cmp	r3, #0
 80102ea:	d002      	beq.n	80102f2 <_ux_device_class_hid_initialize+0x126>
                status = UX_EVENT_ERROR;
 80102ec:	2318      	movs	r3, #24
 80102ee:	617b      	str	r3, [r7, #20]
 80102f0:	e027      	b.n	8010342 <_ux_device_class_hid_initialize+0x176>
#if defined(UX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT)

#if !defined(UX_DEVICE_STANDALONE)

                /* Create a mutex for reading reentry check.  */
                status = _ux_utility_mutex_create(&hid -> ux_device_class_hid_read_mutex,
 80102f2:	68fb      	ldr	r3, [r7, #12]
 80102f4:	3370      	adds	r3, #112	; 0x70
 80102f6:	4929      	ldr	r1, [pc, #164]	; (801039c <_ux_device_class_hid_initialize+0x1d0>)
 80102f8:	4618      	mov	r0, r3
 80102fa:	f7ff fb65 	bl	800f9c8 <_ux_utility_mutex_create>
 80102fe:	6178      	str	r0, [r7, #20]
                                                  "ux_device_class_hid_read_mutex");
                if (status == UX_SUCCESS)
 8010300:	697b      	ldr	r3, [r7, #20]
 8010302:	2b00      	cmp	r3, #0
 8010304:	d116      	bne.n	8010334 <_ux_device_class_hid_initialize+0x168>
                {
#endif

                    /* If receiver is enabled by parameter, initialize it.  */
                    if (hid_parameter -> ux_device_class_hid_parameter_receiver_initialize)
 8010306:	68bb      	ldr	r3, [r7, #8]
 8010308:	69db      	ldr	r3, [r3, #28]
 801030a:	2b00      	cmp	r3, #0
 801030c:	d007      	beq.n	801031e <_ux_device_class_hid_initialize+0x152>
                    {

                        /* Allocate buffer for receiver and receiver events.  */
                        status = hid_parameter ->
 801030e:	68bb      	ldr	r3, [r7, #8]
 8010310:	69db      	ldr	r3, [r3, #28]
                                ux_device_class_hid_parameter_receiver_initialize(hid,
                                                hid_parameter,
                                                &hid -> ux_device_class_hid_receiver);
 8010312:	68fa      	ldr	r2, [r7, #12]
 8010314:	326c      	adds	r2, #108	; 0x6c
                        status = hid_parameter ->
 8010316:	68b9      	ldr	r1, [r7, #8]
 8010318:	68f8      	ldr	r0, [r7, #12]
 801031a:	4798      	blx	r3
 801031c:	6178      	str	r0, [r7, #20]
                    }

                    /* Done success, return.  */
                    if (status == UX_SUCCESS)
 801031e:	697b      	ldr	r3, [r7, #20]
 8010320:	2b00      	cmp	r3, #0
 8010322:	d101      	bne.n	8010328 <_ux_device_class_hid_initialize+0x15c>
                        return(status);
 8010324:	697b      	ldr	r3, [r7, #20]
 8010326:	e02e      	b.n	8010386 <_ux_device_class_hid_initialize+0x1ba>

#if !defined(UX_DEVICE_STANDALONE)

                    /* There is error, delete mutex.  */
                    _ux_device_mutex_delete(&hid -> ux_device_class_hid_read_mutex);
 8010328:	68fb      	ldr	r3, [r7, #12]
 801032a:	3370      	adds	r3, #112	; 0x70
 801032c:	4618      	mov	r0, r3
 801032e:	f7ff fb63 	bl	800f9f8 <_ux_utility_mutex_delete>
 8010332:	e001      	b.n	8010338 <_ux_device_class_hid_initialize+0x16c>
                }
                else
                    status = UX_MUTEX_ERROR;
 8010334:	2317      	movs	r3, #23
 8010336:	617b      	str	r3, [r7, #20]

                /* There is error, delete event flags.  */
                _ux_utility_event_flags_delete(&hid -> ux_device_class_hid_event_flags_group);
 8010338:	68fb      	ldr	r3, [r7, #12]
 801033a:	3328      	adds	r3, #40	; 0x28
 801033c:	4618      	mov	r0, r3
 801033e:	f7ff f82a 	bl	800f396 <_ux_utility_event_flags_delete>
#if !defined(UX_DEVICE_STANDALONE) || defined(UX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT)

            /* There is still initialization activities after array creation,
             * and some error occurs in this stage.  */
            /* Free allocated event array memory.  */
            _ux_utility_memory_free(hid -> ux_device_class_hid_event_array);
 8010342:	68fb      	ldr	r3, [r7, #12]
 8010344:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010346:	4618      	mov	r0, r3
 8010348:	f7ff fa46 	bl	800f7d8 <_ux_utility_memory_free>
 801034c:	e001      	b.n	8010352 <_ux_device_class_hid_initialize+0x186>
#endif

        }
        else
            status =  UX_MEMORY_INSUFFICIENT;
 801034e:	2312      	movs	r3, #18
 8010350:	617b      	str	r3, [r7, #20]

#if !defined(UX_DEVICE_STANDALONE)

        /* Delete thread.  */
        _ux_device_thread_delete(&class_ptr -> ux_slave_class_thread);
 8010352:	693b      	ldr	r3, [r7, #16]
 8010354:	3350      	adds	r3, #80	; 0x50
 8010356:	4618      	mov	r0, r3
 8010358:	f7ff fc56 	bl	800fc08 <_ux_utility_thread_delete>
 801035c:	e001      	b.n	8010362 <_ux_device_class_hid_initialize+0x196>
#endif
    }
    else
        status = (UX_THREAD_ERROR);
 801035e:	2316      	movs	r3, #22
 8010360:	617b      	str	r3, [r7, #20]

#if !defined(UX_DEVICE_STANDALONE)

    /* Free stack. */
    if (class_ptr -> ux_slave_class_thread_stack)
 8010362:	693b      	ldr	r3, [r7, #16]
 8010364:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8010368:	2b00      	cmp	r3, #0
 801036a:	d005      	beq.n	8010378 <_ux_device_class_hid_initialize+0x1ac>
        _ux_utility_memory_free(class_ptr -> ux_slave_class_thread_stack);
 801036c:	693b      	ldr	r3, [r7, #16]
 801036e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8010372:	4618      	mov	r0, r3
 8010374:	f7ff fa30 	bl	800f7d8 <_ux_utility_memory_free>
#endif

    /* Unmount instance. */
    class_ptr -> ux_slave_class_instance =  UX_NULL;
 8010378:	693b      	ldr	r3, [r7, #16]
 801037a:	2200      	movs	r2, #0
 801037c:	649a      	str	r2, [r3, #72]	; 0x48

    /* Free HID instance. */
    _ux_utility_memory_free(hid);
 801037e:	68f8      	ldr	r0, [r7, #12]
 8010380:	f7ff fa2a 	bl	800f7d8 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(status);
 8010384:	697b      	ldr	r3, [r7, #20]
}
 8010386:	4618      	mov	r0, r3
 8010388:	3718      	adds	r7, #24
 801038a:	46bd      	mov	sp, r7
 801038c:	bd80      	pop	{r7, pc}
 801038e:	bf00      	nop
 8010390:	080103a1 	.word	0x080103a1
 8010394:	08013400 	.word	0x08013400
 8010398:	08013414 	.word	0x08013414
 801039c:	08013434 	.word	0x08013434

080103a0 <_ux_device_class_hid_interrupt_thread>:
/*                                            off for standalone compile, */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_device_class_hid_interrupt_thread(ULONG hid_class)
{
 80103a0:	b580      	push	{r7, lr}
 80103a2:	b096      	sub	sp, #88	; 0x58
 80103a4:	af02      	add	r7, sp, #8
 80103a6:	6078      	str	r0, [r7, #4]
UCHAR                       *buffer;
ULONG                       actual_flags;


    /* Cast properly the hid instance.  */
    UX_THREAD_EXTENSION_PTR_GET(class_ptr, UX_SLAVE_CLASS, hid_class)
 80103a8:	687b      	ldr	r3, [r7, #4]
 80103aa:	64fb      	str	r3, [r7, #76]	; 0x4c
    
    /* Get the hid instance from this class container.  */
    hid =  (UX_SLAVE_CLASS_HID *) class_ptr -> ux_slave_class_instance;
 80103ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80103ae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80103b0:	64bb      	str	r3, [r7, #72]	; 0x48
    
    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
 80103b2:	4b3d      	ldr	r3, [pc, #244]	; (80104a8 <_ux_device_class_hid_interrupt_thread+0x108>)
 80103b4:	681b      	ldr	r3, [r3, #0]
 80103b6:	3320      	adds	r3, #32
 80103b8:	647b      	str	r3, [r7, #68]	; 0x44
    /* This thread runs forever but can be suspended or resumed.  */
    while(1)
    {

        /* All HID events are on the interrupt endpoint IN, from the host.  */
        transfer_request_in =  &hid -> ux_device_class_hid_interrupt_endpoint -> ux_slave_endpoint_transfer_request;
 80103ba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80103bc:	685b      	ldr	r3, [r3, #4]
 80103be:	3330      	adds	r3, #48	; 0x30
 80103c0:	643b      	str	r3, [r7, #64]	; 0x40

        /* As long as the device is in the CONFIGURED state.  */
        while (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
 80103c2:	e064      	b.n	801048e <_ux_device_class_hid_interrupt_thread+0xee>
        { 

            /* Wait until we have a event sent by the application
               or a change in the idle state to send last or empty report.  */
            status =  _ux_utility_event_flags_get(&hid -> ux_device_class_hid_event_flags_group,
 80103c4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80103c6:	f103 0028 	add.w	r0, r3, #40	; 0x28
 80103ca:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80103cc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80103ce:	f107 0208 	add.w	r2, r7, #8
 80103d2:	9300      	str	r3, [sp, #0]
 80103d4:	4613      	mov	r3, r2
 80103d6:	2201      	movs	r2, #1
 80103d8:	2103      	movs	r1, #3
 80103da:	f7fe ffe9 	bl	800f3b0 <_ux_utility_event_flags_get>
 80103de:	63f8      	str	r0, [r7, #60]	; 0x3c
                                                    UX_DEVICE_CLASS_HID_EVENTS_MASK, UX_OR_CLEAR, &actual_flags,
                                                    hid -> ux_device_class_hid_event_wait_timeout);

            /* If there is no event, check if we have timeout defined.  */
            if (status == UX_NO_EVENTS)
 80103e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80103e2:	2b07      	cmp	r3, #7
 80103e4:	d124      	bne.n	8010430 <_ux_device_class_hid_interrupt_thread+0x90>
            {

                /* There is no event exists on timeout, insert last.  */

                /* Check if no request been ready.  */
                if (transfer_request_in -> ux_slave_transfer_request_requested_length == 0)
 80103e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80103e8:	695b      	ldr	r3, [r3, #20]
 80103ea:	2b00      	cmp	r3, #0
 80103ec:	d10b      	bne.n	8010406 <_ux_device_class_hid_interrupt_thread+0x66>
                {

                    /* Assume the request use whole interrupt transfer payload.  */
                    transfer_request_in -> ux_slave_transfer_request_requested_length =
                            transfer_request_in -> ux_slave_transfer_request_transfer_length;
 80103ee:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80103f0:	6a1a      	ldr	r2, [r3, #32]
                    transfer_request_in -> ux_slave_transfer_request_requested_length =
 80103f2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80103f4:	615a      	str	r2, [r3, #20]

                    /* Set the data to zeros.  */
                    _ux_utility_memory_set(
                        transfer_request_in -> ux_slave_transfer_request_data_pointer, 0,
 80103f6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80103f8:	68d8      	ldr	r0, [r3, #12]
                    _ux_utility_memory_set(
 80103fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80103fc:	695b      	ldr	r3, [r3, #20]
 80103fe:	461a      	mov	r2, r3
 8010400:	2100      	movs	r1, #0
 8010402:	f7ff fac7 	bl	800f994 <_ux_utility_memory_set>
                        transfer_request_in -> ux_slave_transfer_request_requested_length); /* Use case of memset is verified. */
                }

                /* Send the request to the device controller.  */
                status =  _ux_device_stack_transfer_request(transfer_request_in, 
 8010406:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010408:	6959      	ldr	r1, [r3, #20]
 801040a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801040c:	695b      	ldr	r3, [r3, #20]
 801040e:	461a      	mov	r2, r3
 8010410:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8010412:	f7fe fe31 	bl	800f078 <_ux_device_stack_transfer_request>
 8010416:	63f8      	str	r0, [r7, #60]	; 0x3c
                                transfer_request_in -> ux_slave_transfer_request_requested_length,
                                transfer_request_in -> ux_slave_transfer_request_requested_length);

                /* Check error code. We don't want to invoke the error callback
                   if the device was disconnected, since that's expected.  */
                if (status != UX_SUCCESS && status != UX_TRANSFER_BUS_RESET)
 8010418:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801041a:	2b00      	cmp	r3, #0
 801041c:	d037      	beq.n	801048e <_ux_device_class_hid_interrupt_thread+0xee>
 801041e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010420:	2b26      	cmp	r3, #38	; 0x26
 8010422:	d034      	beq.n	801048e <_ux_device_class_hid_interrupt_thread+0xee>

                    /* Error trap. */
                    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, status);
 8010424:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010426:	2107      	movs	r1, #7
 8010428:	2002      	movs	r0, #2
 801042a:	f7fe feaf 	bl	800f18c <_ux_system_error_handler>

                /* Next: check events.  */
                continue;
 801042e:	e02e      	b.n	801048e <_ux_device_class_hid_interrupt_thread+0xee>
            }

            /* Check the completion code. */
            if (status != UX_SUCCESS)
 8010430:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010432:	2b00      	cmp	r3, #0
 8010434:	d022      	beq.n	801047c <_ux_device_class_hid_interrupt_thread+0xdc>
            {

                /* Error trap. */
                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, status);
 8010436:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010438:	2107      	movs	r1, #7
 801043a:	2002      	movs	r0, #2
 801043c:	f7fe fea6 	bl	800f18c <_ux_system_error_handler>

                /* Do not proceed.  */
                return;
 8010440:	e02f      	b.n	80104a2 <_ux_device_class_hid_interrupt_thread+0x102>
            /* Check if we have an event to report.  */
            while (_ux_device_class_hid_event_get(hid, &hid_event) == UX_SUCCESS)
            {

                /* Prepare the event data payload from the hid event structure.  Get a pointer to the buffer area.  */
                buffer =  transfer_request_in -> ux_slave_transfer_request_data_pointer;
 8010442:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010444:	68db      	ldr	r3, [r3, #12]
 8010446:	63bb      	str	r3, [r7, #56]	; 0x38
            
                /* Copy the event buffer into the target buffer.  */
                _ux_utility_memory_copy(buffer, hid_event.ux_device_class_hid_event_buffer, hid_event.ux_device_class_hid_event_length); /* Use case of memcpy is verified. */
 8010448:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801044a:	f107 030c 	add.w	r3, r7, #12
 801044e:	3308      	adds	r3, #8
 8010450:	4619      	mov	r1, r3
 8010452:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8010454:	f7ff f9a1 	bl	800f79a <_ux_utility_memory_copy>
            
                /* Send the request to the device controller.  */
                status =  _ux_device_stack_transfer_request(transfer_request_in, hid_event.ux_device_class_hid_event_length, 
 8010458:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801045a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801045c:	4619      	mov	r1, r3
 801045e:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8010460:	f7fe fe0a 	bl	800f078 <_ux_device_stack_transfer_request>
 8010464:	63f8      	str	r0, [r7, #60]	; 0x3c
                                                                hid_event.ux_device_class_hid_event_length);
                
                /* Check error code. We don't want to invoke the error callback
                   if the device was disconnected, since that's expected.  */
                if (status != UX_SUCCESS && status != UX_TRANSFER_BUS_RESET)
 8010466:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010468:	2b00      	cmp	r3, #0
 801046a:	d007      	beq.n	801047c <_ux_device_class_hid_interrupt_thread+0xdc>
 801046c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801046e:	2b26      	cmp	r3, #38	; 0x26
 8010470:	d004      	beq.n	801047c <_ux_device_class_hid_interrupt_thread+0xdc>

                    /* Error trap. */
                    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, status);
 8010472:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010474:	2107      	movs	r1, #7
 8010476:	2002      	movs	r0, #2
 8010478:	f7fe fe88 	bl	800f18c <_ux_system_error_handler>
            while (_ux_device_class_hid_event_get(hid, &hid_event) == UX_SUCCESS)
 801047c:	f107 030c 	add.w	r3, r7, #12
 8010480:	4619      	mov	r1, r3
 8010482:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 8010484:	f7ff fe58 	bl	8010138 <_ux_device_class_hid_event_get>
 8010488:	4603      	mov	r3, r0
 801048a:	2b00      	cmp	r3, #0
 801048c:	d0d9      	beq.n	8010442 <_ux_device_class_hid_interrupt_thread+0xa2>
        while (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
 801048e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010490:	681b      	ldr	r3, [r3, #0]
 8010492:	2b03      	cmp	r3, #3
 8010494:	d096      	beq.n	80103c4 <_ux_device_class_hid_interrupt_thread+0x24>
            }                
        }
             
        /* We need to suspend ourselves. We will be resumed by the device enumeration module.  */
        _ux_device_thread_suspend(&class_ptr -> ux_slave_class_thread);
 8010496:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010498:	3350      	adds	r3, #80	; 0x50
 801049a:	4618      	mov	r0, r3
 801049c:	f7ff fbd7 	bl	800fc4e <_ux_utility_thread_suspend>
        transfer_request_in =  &hid -> ux_device_class_hid_interrupt_endpoint -> ux_slave_endpoint_transfer_request;
 80104a0:	e78b      	b.n	80103ba <_ux_device_class_hid_interrupt_thread+0x1a>
    }
}
 80104a2:	3750      	adds	r7, #80	; 0x50
 80104a4:	46bd      	mov	sp, r7
 80104a6:	bd80      	pop	{r7, pc}
 80104a8:	2000730c 	.word	0x2000730c

080104ac <_ux_device_class_hid_receiver_initialize>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_receiver_initialize(UX_SLAVE_CLASS_HID *hid,
                                    UX_SLAVE_CLASS_HID_PARAMETER *parameter,
                                    UX_DEVICE_CLASS_HID_RECEIVER **receiver)
{
 80104ac:	b580      	push	{r7, lr}
 80104ae:	b090      	sub	sp, #64	; 0x40
 80104b0:	af06      	add	r7, sp, #24
 80104b2:	60f8      	str	r0, [r7, #12]
 80104b4:	60b9      	str	r1, [r7, #8]
 80104b6:	607a      	str	r2, [r7, #4]
UCHAR                                   *memory_receiver;
UCHAR                                   *memory_events;
#if !defined(UX_DEVICE_STANDALONE)
UCHAR                                   *memory_stack;
#endif
UINT                                    status = UX_SUCCESS;
 80104b8:	2300      	movs	r3, #0
 80104ba:	627b      	str	r3, [r7, #36]	; 0x24
    /* Allocate memory for receiver and receiver events.  */

    /* Memory of thread stack and receiver instance.  */
#if !defined(UX_DEVICE_STANDALONE)
    UX_ASSERT(!UX_OVERFLOW_CHECK_ADD_ULONG(UX_DEVICE_CLASS_HID_RECEIVER_THREAD_STACK_SIZE, sizeof(UX_DEVICE_CLASS_HID_RECEIVER)));
    memory_size = UX_DEVICE_CLASS_HID_RECEIVER_THREAD_STACK_SIZE +
 80104bc:	f240 43cc 	movw	r3, #1228	; 0x4cc
 80104c0:	623b      	str	r3, [r7, #32]
    memory_size = sizeof(UX_DEVICE_CLASS_HID_RECEIVER);
#endif
    UX_ASSERT(!UX_OVERFLOW_CHECK_ADD_ULONG(parameter -> ux_device_class_hid_parameter_receiver_event_max_length, sizeof(ULONG)));

    /* Memory of events.  */
    events_size  = parameter -> ux_device_class_hid_parameter_receiver_event_max_length + sizeof(ULONG);
 80104c2:	68bb      	ldr	r3, [r7, #8]
 80104c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80104c6:	3304      	adds	r3, #4
 80104c8:	61fb      	str	r3, [r7, #28]
    UX_ASSERT(!UX_OVERFLOW_CHECK_MULV_ULONG(events_size, parameter -> ux_device_class_hid_parameter_receiver_event_max_number));
    events_size *= parameter -> ux_device_class_hid_parameter_receiver_event_max_number;
 80104ca:	68bb      	ldr	r3, [r7, #8]
 80104cc:	6a1a      	ldr	r2, [r3, #32]
 80104ce:	69fb      	ldr	r3, [r7, #28]
 80104d0:	fb02 f303 	mul.w	r3, r2, r3
 80104d4:	61fb      	str	r3, [r7, #28]
    UX_ASSERT(!UX_OVERFLOW_CHECK_ADD_ULONG(memory_size, events_size));
    memory_size += events_size;
 80104d6:	6a3a      	ldr	r2, [r7, #32]
 80104d8:	69fb      	ldr	r3, [r7, #28]
 80104da:	4413      	add	r3, r2
 80104dc:	623b      	str	r3, [r7, #32]

    /* Allocate memory.  */
    memory_receiver = _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, memory_size);
 80104de:	6a3a      	ldr	r2, [r7, #32]
 80104e0:	2100      	movs	r1, #0
 80104e2:	2000      	movs	r0, #0
 80104e4:	f7ff f830 	bl	800f548 <_ux_utility_memory_allocate>
 80104e8:	61b8      	str	r0, [r7, #24]
    if (memory_receiver == UX_NULL)
 80104ea:	69bb      	ldr	r3, [r7, #24]
 80104ec:	2b00      	cmp	r3, #0
 80104ee:	d101      	bne.n	80104f4 <_ux_device_class_hid_receiver_initialize+0x48>
        return(UX_MEMORY_INSUFFICIENT);
 80104f0:	2312      	movs	r3, #18
 80104f2:	e058      	b.n	80105a6 <_ux_device_class_hid_receiver_initialize+0xfa>
#if !defined(UX_DEVICE_STANDALONE)
    memory_stack = memory_receiver + sizeof(UX_DEVICE_CLASS_HID_RECEIVER);
 80104f4:	69bb      	ldr	r3, [r7, #24]
 80104f6:	33cc      	adds	r3, #204	; 0xcc
 80104f8:	617b      	str	r3, [r7, #20]
    memory_events = memory_stack + UX_DEVICE_CLASS_HID_RECEIVER_THREAD_STACK_SIZE;
 80104fa:	697b      	ldr	r3, [r7, #20]
 80104fc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010500:	613b      	str	r3, [r7, #16]
#else
    memory_events = memory_receiver + sizeof(UX_DEVICE_CLASS_HID_RECEIVER);
#endif

    /* Store receiver instance pointer.  */
    (*receiver) = (UX_DEVICE_CLASS_HID_RECEIVER *)memory_receiver;
 8010502:	687b      	ldr	r3, [r7, #4]
 8010504:	69ba      	ldr	r2, [r7, #24]
 8010506:	601a      	str	r2, [r3, #0]
#if !defined(UX_DEVICE_STANDALONE)

    /* This instance needs to be running in a different thread. So start
       a new thread. We pass a pointer to the class to the new thread.  This thread
       does not start until we have a instance of the class. */
    if (status == UX_SUCCESS)
 8010508:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801050a:	2b00      	cmp	r3, #0
 801050c:	d117      	bne.n	801053e <_ux_device_class_hid_receiver_initialize+0x92>
        status =  _ux_utility_thread_create(&(*receiver) -> ux_device_class_hid_receiver_thread,
 801050e:	687b      	ldr	r3, [r7, #4]
 8010510:	681b      	ldr	r3, [r3, #0]
 8010512:	f103 001c 	add.w	r0, r3, #28
 8010516:	68fa      	ldr	r2, [r7, #12]
 8010518:	2300      	movs	r3, #0
 801051a:	9305      	str	r3, [sp, #20]
 801051c:	2300      	movs	r3, #0
 801051e:	9304      	str	r3, [sp, #16]
 8010520:	2314      	movs	r3, #20
 8010522:	9303      	str	r3, [sp, #12]
 8010524:	2314      	movs	r3, #20
 8010526:	9302      	str	r3, [sp, #8]
 8010528:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801052c:	9301      	str	r3, [sp, #4]
 801052e:	697b      	ldr	r3, [r7, #20]
 8010530:	9300      	str	r3, [sp, #0]
 8010532:	4613      	mov	r3, r2
 8010534:	4a1e      	ldr	r2, [pc, #120]	; (80105b0 <_ux_device_class_hid_receiver_initialize+0x104>)
 8010536:	491f      	ldr	r1, [pc, #124]	; (80105b4 <_ux_device_class_hid_receiver_initialize+0x108>)
 8010538:	f7ff fb3f 	bl	800fbba <_ux_utility_thread_create>
 801053c:	6278      	str	r0, [r7, #36]	; 0x24
                    UX_DEVICE_CLASS_HID_RECEIVER_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_CLASS,
                    UX_THREAD_PRIORITY_CLASS, UX_NO_TIME_SLICE, UX_DONT_START);
#endif

    /* Check the creation of this thread.  */
    if (status == UX_SUCCESS)
 801053e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010540:	2b00      	cmp	r3, #0
 8010542:	d125      	bne.n	8010590 <_ux_device_class_hid_receiver_initialize+0xe4>
        hid -> ux_device_class_hid_read_state = UX_DEVICE_CLASS_HID_RECEIVER_START;
        (*receiver) -> ux_device_class_hid_receiver_tasks_run = _ux_device_class_hid_receiver_tasks_run;
#endif

        /* Initialize event buffer size.  */
        (*receiver) -> ux_device_class_hid_receiver_event_buffer_size =
 8010544:	687b      	ldr	r3, [r7, #4]
 8010546:	681b      	ldr	r3, [r3, #0]
                    parameter -> ux_device_class_hid_parameter_receiver_event_max_length;
 8010548:	68ba      	ldr	r2, [r7, #8]
 801054a:	6a52      	ldr	r2, [r2, #36]	; 0x24
        (*receiver) -> ux_device_class_hid_receiver_event_buffer_size =
 801054c:	609a      	str	r2, [r3, #8]

        /* Initialize events.  */
        (*receiver) -> ux_device_class_hid_receiver_events =
 801054e:	687b      	ldr	r3, [r7, #4]
 8010550:	681b      	ldr	r3, [r3, #0]
 8010552:	693a      	ldr	r2, [r7, #16]
 8010554:	60da      	str	r2, [r3, #12]
                        (UX_DEVICE_CLASS_HID_RECEIVED_EVENT *)(memory_events);
        (*receiver) -> ux_device_class_hid_receiver_events_end =
 8010556:	687b      	ldr	r3, [r7, #4]
 8010558:	681b      	ldr	r3, [r3, #0]
                        (UX_DEVICE_CLASS_HID_RECEIVED_EVENT *)(memory_receiver + memory_size);
 801055a:	69b9      	ldr	r1, [r7, #24]
 801055c:	6a3a      	ldr	r2, [r7, #32]
 801055e:	440a      	add	r2, r1
        (*receiver) -> ux_device_class_hid_receiver_events_end =
 8010560:	611a      	str	r2, [r3, #16]
        (*receiver) -> ux_device_class_hid_receiver_event_read_pos =
                    (*receiver) -> ux_device_class_hid_receiver_events;
 8010562:	687b      	ldr	r3, [r7, #4]
 8010564:	681a      	ldr	r2, [r3, #0]
        (*receiver) -> ux_device_class_hid_receiver_event_read_pos =
 8010566:	687b      	ldr	r3, [r7, #4]
 8010568:	681b      	ldr	r3, [r3, #0]
                    (*receiver) -> ux_device_class_hid_receiver_events;
 801056a:	68d2      	ldr	r2, [r2, #12]
        (*receiver) -> ux_device_class_hid_receiver_event_read_pos =
 801056c:	615a      	str	r2, [r3, #20]
        (*receiver) -> ux_device_class_hid_receiver_event_save_pos =
                    (*receiver) -> ux_device_class_hid_receiver_events;
 801056e:	687b      	ldr	r3, [r7, #4]
 8010570:	681a      	ldr	r2, [r3, #0]
        (*receiver) -> ux_device_class_hid_receiver_event_save_pos =
 8010572:	687b      	ldr	r3, [r7, #4]
 8010574:	681b      	ldr	r3, [r3, #0]
                    (*receiver) -> ux_device_class_hid_receiver_events;
 8010576:	68d2      	ldr	r2, [r2, #12]
        (*receiver) -> ux_device_class_hid_receiver_event_save_pos =
 8010578:	619a      	str	r2, [r3, #24]

        /* Initialize uninitialize function.  */
        (*receiver) -> ux_device_class_hid_receiver_uninitialize = _ux_device_class_hid_receiver_uninitialize;
 801057a:	687b      	ldr	r3, [r7, #4]
 801057c:	681b      	ldr	r3, [r3, #0]
 801057e:	4a0e      	ldr	r2, [pc, #56]	; (80105b8 <_ux_device_class_hid_receiver_initialize+0x10c>)
 8010580:	601a      	str	r2, [r3, #0]

        /* Initialize callback function.  */
        (*receiver) -> ux_device_class_hid_receiver_event_callback =
 8010582:	687b      	ldr	r3, [r7, #4]
 8010584:	681b      	ldr	r3, [r3, #0]
                    parameter -> ux_device_class_hid_parameter_receiver_event_callback;
 8010586:	68ba      	ldr	r2, [r7, #8]
 8010588:	6a92      	ldr	r2, [r2, #40]	; 0x28
        (*receiver) -> ux_device_class_hid_receiver_event_callback =
 801058a:	605a      	str	r2, [r3, #4]

        /* Done success.  */
        return(UX_SUCCESS);
 801058c:	2300      	movs	r3, #0
 801058e:	e00a      	b.n	80105a6 <_ux_device_class_hid_receiver_initialize+0xfa>
    }
    else
        status = (UX_THREAD_ERROR);
 8010590:	2316      	movs	r3, #22
 8010592:	627b      	str	r3, [r7, #36]	; 0x24

    /* Free allocated memory. */
    _ux_utility_memory_free(*receiver);
 8010594:	687b      	ldr	r3, [r7, #4]
 8010596:	681b      	ldr	r3, [r3, #0]
 8010598:	4618      	mov	r0, r3
 801059a:	f7ff f91d 	bl	800f7d8 <_ux_utility_memory_free>
    (*receiver) =  UX_NULL;
 801059e:	687b      	ldr	r3, [r7, #4]
 80105a0:	2200      	movs	r2, #0
 80105a2:	601a      	str	r2, [r3, #0]

    /* Return completion status.  */
    return(status);
 80105a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
#endif
}
 80105a6:	4618      	mov	r0, r3
 80105a8:	3728      	adds	r7, #40	; 0x28
 80105aa:	46bd      	mov	sp, r7
 80105ac:	bd80      	pop	{r7, pc}
 80105ae:	bf00      	nop
 80105b0:	080105bd 	.word	0x080105bd
 80105b4:	08013454 	.word	0x08013454
 80105b8:	080106bd 	.word	0x080106bd

080105bc <_ux_device_class_hid_receiver_thread>:
/*                                            added receiver callback,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_device_class_hid_receiver_thread(ULONG hid_instance)
{
 80105bc:	b580      	push	{r7, lr}
 80105be:	b08e      	sub	sp, #56	; 0x38
 80105c0:	af02      	add	r7, sp, #8
 80105c2:	6078      	str	r0, [r7, #4]
UCHAR                               *buffer;
ULONG                               temp;


    /* Cast properly the hid instance.  */
    UX_THREAD_EXTENSION_PTR_GET(hid, UX_SLAVE_CLASS_HID, hid_instance)
 80105c4:	687b      	ldr	r3, [r7, #4]
 80105c6:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
 80105c8:	4b3b      	ldr	r3, [pc, #236]	; (80106b8 <_ux_device_class_hid_receiver_thread+0xfc>)
 80105ca:	681b      	ldr	r3, [r3, #0]
 80105cc:	3320      	adds	r3, #32
 80105ce:	627b      	str	r3, [r7, #36]	; 0x24

    /* Get receiver instance.  */
    receiver = hid -> ux_device_class_hid_receiver;
 80105d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105d2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80105d4:	623b      	str	r3, [r7, #32]
    /* This thread runs forever but can be suspended or resumed.  */
    while(1)
    {

        /* Check device state.  */
        if (device -> ux_slave_device_state != UX_DEVICE_CONFIGURED)
 80105d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105d8:	681b      	ldr	r3, [r3, #0]
 80105da:	2b03      	cmp	r3, #3
 80105dc:	d005      	beq.n	80105ea <_ux_device_class_hid_receiver_thread+0x2e>
        {

            /* We need to suspend ourselves. We will be resumed by the device enumeration module.  */
            _ux_utility_thread_suspend(&receiver -> ux_device_class_hid_receiver_thread);
 80105de:	6a3b      	ldr	r3, [r7, #32]
 80105e0:	331c      	adds	r3, #28
 80105e2:	4618      	mov	r0, r3
 80105e4:	f7ff fb33 	bl	800fc4e <_ux_utility_thread_suspend>
            continue;
 80105e8:	e064      	b.n	80106b4 <_ux_device_class_hid_receiver_thread+0xf8>
        }

        /* Check if there is buffer available.  */
        pos = receiver -> ux_device_class_hid_receiver_event_save_pos;
 80105ea:	6a3b      	ldr	r3, [r7, #32]
 80105ec:	699b      	ldr	r3, [r3, #24]
 80105ee:	61fb      	str	r3, [r7, #28]
        if (pos -> ux_device_class_hid_received_event_length != 0)
 80105f0:	69fb      	ldr	r3, [r7, #28]
 80105f2:	681b      	ldr	r3, [r3, #0]
 80105f4:	2b00      	cmp	r3, #0
 80105f6:	d00e      	beq.n	8010616 <_ux_device_class_hid_receiver_thread+0x5a>
        {

            /* Wait before check again.  */
            status = _ux_utility_event_flags_get(
 80105f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80105fa:	f103 0028 	add.w	r0, r3, #40	; 0x28
 80105fe:	f107 030c 	add.w	r3, r7, #12
 8010602:	2264      	movs	r2, #100	; 0x64
 8010604:	9200      	str	r2, [sp, #0]
 8010606:	2201      	movs	r2, #1
 8010608:	2104      	movs	r1, #4
 801060a:	f7fe fed1 	bl	800f3b0 <_ux_utility_event_flags_get>
 801060e:	61b8      	str	r0, [r7, #24]
                                &hid -> ux_device_class_hid_event_flags_group,
                                UX_DEVICE_CLASS_HID_RECEIVER_RESTART,
                                UX_OR_CLEAR, &temp, 100);
            if (status != UX_SUCCESS)
 8010610:	69bb      	ldr	r3, [r7, #24]
 8010612:	2b00      	cmp	r3, #0
 8010614:	d14d      	bne.n	80106b2 <_ux_device_class_hid_receiver_thread+0xf6>
                continue;
            }
        }

        /* Event buffer available, issue request to get data.  */
        transfer = &hid -> ux_device_class_hid_read_endpoint -> ux_slave_endpoint_transfer_request;
 8010616:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010618:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 801061a:	3330      	adds	r3, #48	; 0x30
 801061c:	617b      	str	r3, [r7, #20]

        /* Protect read.  */
        _ux_device_mutex_on(&hid -> ux_device_class_hid_read_mutex);
 801061e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010620:	3370      	adds	r3, #112	; 0x70
 8010622:	4618      	mov	r0, r3
 8010624:	f7ff fa00 	bl	800fa28 <_ux_utility_mutex_on>

        /* Issue the transfer request.  */
        status = _ux_device_stack_transfer_request(transfer, 
 8010628:	6a3b      	ldr	r3, [r7, #32]
 801062a:	6899      	ldr	r1, [r3, #8]
 801062c:	6a3b      	ldr	r3, [r7, #32]
 801062e:	689b      	ldr	r3, [r3, #8]
 8010630:	461a      	mov	r2, r3
 8010632:	6978      	ldr	r0, [r7, #20]
 8010634:	f7fe fd20 	bl	800f078 <_ux_device_stack_transfer_request>
 8010638:	61b8      	str	r0, [r7, #24]
                    receiver -> ux_device_class_hid_receiver_event_buffer_size,
                    receiver -> ux_device_class_hid_receiver_event_buffer_size);

        /* Check status and ignore ZLPs.  */
        if ((status != UX_SUCCESS) ||
 801063a:	69bb      	ldr	r3, [r7, #24]
 801063c:	2b00      	cmp	r3, #0
 801063e:	d103      	bne.n	8010648 <_ux_device_class_hid_receiver_thread+0x8c>
            (transfer -> ux_slave_transfer_request_actual_length == 0))
 8010640:	697b      	ldr	r3, [r7, #20]
 8010642:	699b      	ldr	r3, [r3, #24]
        if ((status != UX_SUCCESS) ||
 8010644:	2b00      	cmp	r3, #0
 8010646:	d105      	bne.n	8010654 <_ux_device_class_hid_receiver_thread+0x98>
        {
            _ux_device_mutex_off(&hid -> ux_device_class_hid_read_mutex);
 8010648:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801064a:	3370      	adds	r3, #112	; 0x70
 801064c:	4618      	mov	r0, r3
 801064e:	f7ff f9e0 	bl	800fa12 <_ux_utility_mutex_off>
            continue;
 8010652:	e02f      	b.n	80106b4 <_ux_device_class_hid_receiver_thread+0xf8>
        }

        /* Save received event data and length.  */
        buffer = (UCHAR *)&pos -> ux_device_class_hid_received_event_data;
 8010654:	69fb      	ldr	r3, [r7, #28]
 8010656:	3304      	adds	r3, #4
 8010658:	613b      	str	r3, [r7, #16]
        temp = transfer -> ux_slave_transfer_request_actual_length;
 801065a:	697b      	ldr	r3, [r7, #20]
 801065c:	699b      	ldr	r3, [r3, #24]
 801065e:	60fb      	str	r3, [r7, #12]
        _ux_utility_memory_copy(buffer,
                        transfer -> ux_slave_transfer_request_data_pointer,
 8010660:	697b      	ldr	r3, [r7, #20]
 8010662:	68db      	ldr	r3, [r3, #12]
        _ux_utility_memory_copy(buffer,
 8010664:	68fa      	ldr	r2, [r7, #12]
 8010666:	4619      	mov	r1, r3
 8010668:	6938      	ldr	r0, [r7, #16]
 801066a:	f7ff f896 	bl	800f79a <_ux_utility_memory_copy>
                        temp); /* Use case of memcpy is verified. */

        /* Unprotect read.  */
        _ux_device_mutex_off(&hid -> ux_device_class_hid_read_mutex);
 801066e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010670:	3370      	adds	r3, #112	; 0x70
 8010672:	4618      	mov	r0, r3
 8010674:	f7ff f9cd 	bl	800fa12 <_ux_utility_mutex_off>

        /* Advance the save position.  */
        next_pos = (UCHAR *)pos + receiver -> ux_device_class_hid_receiver_event_buffer_size + sizeof(ULONG);
 8010678:	6a3b      	ldr	r3, [r7, #32]
 801067a:	689b      	ldr	r3, [r3, #8]
 801067c:	3304      	adds	r3, #4
 801067e:	69fa      	ldr	r2, [r7, #28]
 8010680:	4413      	add	r3, r2
 8010682:	62fb      	str	r3, [r7, #44]	; 0x2c
        if (next_pos >= (UCHAR *)receiver -> ux_device_class_hid_receiver_events_end)
 8010684:	6a3b      	ldr	r3, [r7, #32]
 8010686:	691b      	ldr	r3, [r3, #16]
 8010688:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801068a:	429a      	cmp	r2, r3
 801068c:	d302      	bcc.n	8010694 <_ux_device_class_hid_receiver_thread+0xd8>
            next_pos = (UCHAR *)receiver -> ux_device_class_hid_receiver_events;
 801068e:	6a3b      	ldr	r3, [r7, #32]
 8010690:	68db      	ldr	r3, [r3, #12]
 8010692:	62fb      	str	r3, [r7, #44]	; 0x2c
        receiver -> ux_device_class_hid_receiver_event_save_pos = (UX_DEVICE_CLASS_HID_RECEIVED_EVENT *)next_pos;
 8010694:	6a3b      	ldr	r3, [r7, #32]
 8010696:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8010698:	619a      	str	r2, [r3, #24]

        /* Save received data length (it's valid now).  */
        pos -> ux_device_class_hid_received_event_length = temp;
 801069a:	68fa      	ldr	r2, [r7, #12]
 801069c:	69fb      	ldr	r3, [r7, #28]
 801069e:	601a      	str	r2, [r3, #0]

        /* Notify application that a event is received.  */
        if (receiver -> ux_device_class_hid_receiver_event_callback)
 80106a0:	6a3b      	ldr	r3, [r7, #32]
 80106a2:	685b      	ldr	r3, [r3, #4]
 80106a4:	2b00      	cmp	r3, #0
 80106a6:	d096      	beq.n	80105d6 <_ux_device_class_hid_receiver_thread+0x1a>
            receiver -> ux_device_class_hid_receiver_event_callback(hid);
 80106a8:	6a3b      	ldr	r3, [r7, #32]
 80106aa:	685b      	ldr	r3, [r3, #4]
 80106ac:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80106ae:	4798      	blx	r3
 80106b0:	e791      	b.n	80105d6 <_ux_device_class_hid_receiver_thread+0x1a>
                continue;
 80106b2:	bf00      	nop
        if (device -> ux_slave_device_state != UX_DEVICE_CONFIGURED)
 80106b4:	e78f      	b.n	80105d6 <_ux_device_class_hid_receiver_thread+0x1a>
 80106b6:	bf00      	nop
 80106b8:	2000730c 	.word	0x2000730c

080106bc <_ux_device_class_hid_receiver_uninitialize>:
/*                                                                        */
/*  01-31-2022     Chaoqiong Xiao           Initial Version 6.1.10        */
/*                                                                        */
/**************************************************************************/
VOID _ux_device_class_hid_receiver_uninitialize(UX_DEVICE_CLASS_HID_RECEIVER *receiver)
{
 80106bc:	b580      	push	{r7, lr}
 80106be:	b082      	sub	sp, #8
 80106c0:	af00      	add	r7, sp, #0
 80106c2:	6078      	str	r0, [r7, #4]

#if !defined(UX_DEVICE_STANDALONE)

    /* Delete receiver thread.  */
    _ux_utility_thread_delete(&receiver -> ux_device_class_hid_receiver_thread);
 80106c4:	687b      	ldr	r3, [r7, #4]
 80106c6:	331c      	adds	r3, #28
 80106c8:	4618      	mov	r0, r3
 80106ca:	f7ff fa9d 	bl	800fc08 <_ux_utility_thread_delete>
#endif

    /* Free receiver and events memory.  */
    _ux_utility_memory_free(receiver);
 80106ce:	6878      	ldr	r0, [r7, #4]
 80106d0:	f7ff f882 	bl	800f7d8 <_ux_utility_memory_free>
}
 80106d4:	bf00      	nop
 80106d6:	3708      	adds	r7, #8
 80106d8:	46bd      	mov	sp, r7
 80106da:	bd80      	pop	{r7, pc}

080106dc <_ux_device_class_hid_report_get>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_report_get(UX_SLAVE_CLASS_HID *hid, ULONG descriptor_type, 
                                            ULONG request_index, ULONG host_length)
{
 80106dc:	b580      	push	{r7, lr}
 80106de:	b096      	sub	sp, #88	; 0x58
 80106e0:	af00      	add	r7, sp, #0
 80106e2:	60f8      	str	r0, [r7, #12]
 80106e4:	60b9      	str	r1, [r7, #8]
 80106e6:	607a      	str	r2, [r7, #4]
 80106e8:	603b      	str	r3, [r7, #0]
UCHAR                           report_id;
UCHAR                           report_type;
UX_SLAVE_CLASS_HID_EVENT        hid_event;
ULONG                           hid_event_length;
UCHAR                           *buffer;
UINT                            status =  UX_ERROR;
 80106ea:	23ff      	movs	r3, #255	; 0xff
 80106ec:	653b      	str	r3, [r7, #80]	; 0x50

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_HID_REPORT_GET, hid, descriptor_type, request_index, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
 80106ee:	4b3c      	ldr	r3, [pc, #240]	; (80107e0 <_ux_device_class_hid_report_get+0x104>)
 80106f0:	681b      	ldr	r3, [r3, #0]
 80106f2:	3320      	adds	r3, #32
 80106f4:	64fb      	str	r3, [r7, #76]	; 0x4c
    
    /* Get the control endpoint associated with the device.  */
    endpoint =  &device -> ux_slave_device_control_endpoint;
 80106f6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80106f8:	333c      	adds	r3, #60	; 0x3c
 80106fa:	64bb      	str	r3, [r7, #72]	; 0x48

    /* Get the pointer to the transfer request associated with the endpoint.  */
    transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
 80106fc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80106fe:	3330      	adds	r3, #48	; 0x30
 8010700:	647b      	str	r3, [r7, #68]	; 0x44

    /* Get report ID (wValue.lower) and report type (wValue.higher).  */
    report_id   = *(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_VALUE + 0);
 8010702:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010704:	f893 3056 	ldrb.w	r3, [r3, #86]	; 0x56
 8010708:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    report_type = *(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_VALUE + 1);
 801070c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801070e:	f893 3057 	ldrb.w	r3, [r3, #87]	; 0x57
 8010712:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42

    /* Set the direction to OUT.  */
    transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
 8010716:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010718:	2203      	movs	r2, #3
 801071a:	629a      	str	r2, [r3, #40]	; 0x28

    /* Prepare the event data payload from the hid event structure.  Get a pointer to the buffer area.  */
    buffer =  transfer_request -> ux_slave_transfer_request_data_pointer;
 801071c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801071e:	68db      	ldr	r3, [r3, #12]
 8010720:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Initialize event fields.  */
    hid_event.ux_device_class_hid_event_report_id   = report_id;
 8010722:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 8010726:	613b      	str	r3, [r7, #16]
    hid_event.ux_device_class_hid_event_report_type = report_type;
 8010728:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 801072c:	617b      	str	r3, [r7, #20]
    hid_event.ux_device_class_hid_event_length      = UX_DEVICE_CLASS_HID_EVENT_BUFFER_LENGTH;
 801072e:	2320      	movs	r3, #32
 8010730:	63bb      	str	r3, [r7, #56]	; 0x38

    /* If it's input report without ID try to get it from event queue head.  */
    if (report_type == UX_DEVICE_CLASS_HID_REPORT_TYPE_INPUT &&
 8010732:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 8010736:	2b01      	cmp	r3, #1
 8010738:	d10b      	bne.n	8010752 <_ux_device_class_hid_report_get+0x76>
        hid -> ux_device_class_hid_report_id != UX_TRUE)
 801073a:	68fb      	ldr	r3, [r7, #12]
 801073c:	6a1b      	ldr	r3, [r3, #32]
    if (report_type == UX_DEVICE_CLASS_HID_REPORT_TYPE_INPUT &&
 801073e:	2b01      	cmp	r3, #1
 8010740:	d007      	beq.n	8010752 <_ux_device_class_hid_report_get+0x76>

        /* Check if we have an event to report.  */
        status = _ux_device_class_hid_event_get(hid, &hid_event);
 8010742:	f107 0310 	add.w	r3, r7, #16
 8010746:	4619      	mov	r1, r3
 8010748:	68f8      	ldr	r0, [r7, #12]
 801074a:	f7ff fcf5 	bl	8010138 <_ux_device_class_hid_event_get>
 801074e:	6538      	str	r0, [r7, #80]	; 0x50
 8010750:	e00b      	b.n	801076a <_ux_device_class_hid_report_get+0x8e>
    /* Try to get event from application callback.  */
    else
    {
        
        /* Let application fill event.  */
        if (hid -> ux_device_class_hid_get_callback != UX_NULL)
 8010752:	68fb      	ldr	r3, [r7, #12]
 8010754:	691b      	ldr	r3, [r3, #16]
 8010756:	2b00      	cmp	r3, #0
 8010758:	d007      	beq.n	801076a <_ux_device_class_hid_report_get+0x8e>
            status = hid -> ux_device_class_hid_get_callback(hid, &hid_event);
 801075a:	68fb      	ldr	r3, [r7, #12]
 801075c:	691b      	ldr	r3, [r3, #16]
 801075e:	f107 0210 	add.w	r2, r7, #16
 8010762:	4611      	mov	r1, r2
 8010764:	68f8      	ldr	r0, [r7, #12]
 8010766:	4798      	blx	r3
 8010768:	6538      	str	r0, [r7, #80]	; 0x50
    }

    if (status == UX_SUCCESS)
 801076a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801076c:	2b00      	cmp	r3, #0
 801076e:	d11d      	bne.n	80107ac <_ux_device_class_hid_report_get+0xd0>
    {

        /* Get the length to send back to the host.  */
        if (host_length < hid_event.ux_device_class_hid_event_length)
 8010770:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010772:	683a      	ldr	r2, [r7, #0]
 8010774:	429a      	cmp	r2, r3
 8010776:	d202      	bcs.n	801077e <_ux_device_class_hid_report_get+0xa2>
            hid_event_length =  host_length;
 8010778:	683b      	ldr	r3, [r7, #0]
 801077a:	657b      	str	r3, [r7, #84]	; 0x54
 801077c:	e001      	b.n	8010782 <_ux_device_class_hid_report_get+0xa6>
        else
            hid_event_length =  hid_event.ux_device_class_hid_event_length;
 801077e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010780:	657b      	str	r3, [r7, #84]	; 0x54
        if (hid_event_length > UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH)
 8010782:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010784:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8010788:	d902      	bls.n	8010790 <_ux_device_class_hid_report_get+0xb4>
            hid_event_length = UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH;
 801078a:	f44f 7380 	mov.w	r3, #256	; 0x100
 801078e:	657b      	str	r3, [r7, #84]	; 0x54

        /* First reset it.  */
        _ux_utility_memory_set(buffer, 0, hid_event_length); /* Use case of memset is verified. */
 8010790:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8010792:	2100      	movs	r1, #0
 8010794:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8010796:	f7ff f8fd 	bl	800f994 <_ux_utility_memory_set>

        /* Copy the event buffer into the target buffer.  */
        _ux_utility_memory_copy(buffer, hid_event.ux_device_class_hid_event_buffer, hid_event_length); /* Use case of memcpy is verified. */
 801079a:	f107 0310 	add.w	r3, r7, #16
 801079e:	3308      	adds	r3, #8
 80107a0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80107a2:	4619      	mov	r1, r3
 80107a4:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80107a6:	f7fe fff8 	bl	800f79a <_ux_utility_memory_copy>
 80107aa:	e00d      	b.n	80107c8 <_ux_device_class_hid_report_get+0xec>
    {

        /* There's no event, so send back zero'd memory.  */

        /* Get the length to send back to the host.  */
        if (host_length < UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH)
 80107ac:	683b      	ldr	r3, [r7, #0]
 80107ae:	2bff      	cmp	r3, #255	; 0xff
 80107b0:	d802      	bhi.n	80107b8 <_ux_device_class_hid_report_get+0xdc>
            hid_event_length =  host_length;
 80107b2:	683b      	ldr	r3, [r7, #0]
 80107b4:	657b      	str	r3, [r7, #84]	; 0x54
 80107b6:	e002      	b.n	80107be <_ux_device_class_hid_report_get+0xe2>
        else
            hid_event_length =  UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH;
 80107b8:	f44f 7380 	mov.w	r3, #256	; 0x100
 80107bc:	657b      	str	r3, [r7, #84]	; 0x54

        /* Reset it.  */
        _ux_utility_memory_set(buffer, 0, hid_event_length); /* Use case of memset is verified. */
 80107be:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 80107c0:	2100      	movs	r1, #0
 80107c2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 80107c4:	f7ff f8e6 	bl	800f994 <_ux_utility_memory_set>
    }

    /* We can send the report.  */
    status =  _ux_device_stack_transfer_request(transfer_request, hid_event_length, host_length);
 80107c8:	683a      	ldr	r2, [r7, #0]
 80107ca:	6d79      	ldr	r1, [r7, #84]	; 0x54
 80107cc:	6c78      	ldr	r0, [r7, #68]	; 0x44
 80107ce:	f7fe fc53 	bl	800f078 <_ux_device_stack_transfer_request>
 80107d2:	6538      	str	r0, [r7, #80]	; 0x50

    /* Return the status to the caller.  */
    return(status);
 80107d4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
}
 80107d6:	4618      	mov	r0, r3
 80107d8:	3758      	adds	r7, #88	; 0x58
 80107da:	46bd      	mov	sp, r7
 80107dc:	bd80      	pop	{r7, pc}
 80107de:	bf00      	nop
 80107e0:	2000730c 	.word	0x2000730c

080107e4 <_ux_device_class_hid_report_set>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_report_set(UX_SLAVE_CLASS_HID *hid, ULONG descriptor_type, 
                                            ULONG request_index, ULONG host_length)
{
 80107e4:	b580      	push	{r7, lr}
 80107e6:	b094      	sub	sp, #80	; 0x50
 80107e8:	af00      	add	r7, sp, #0
 80107ea:	60f8      	str	r0, [r7, #12]
 80107ec:	60b9      	str	r1, [r7, #8]
 80107ee:	607a      	str	r2, [r7, #4]
 80107f0:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_HID_REPORT_SET, hid, descriptor_type, request_index, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
 80107f2:	4b20      	ldr	r3, [pc, #128]	; (8010874 <_ux_device_class_hid_report_set+0x90>)
 80107f4:	681b      	ldr	r3, [r3, #0]
 80107f6:	3320      	adds	r3, #32
 80107f8:	64bb      	str	r3, [r7, #72]	; 0x48
    
    /* Get the control endpoint associated with the device.  */
    endpoint =  &device -> ux_slave_device_control_endpoint;
 80107fa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80107fc:	333c      	adds	r3, #60	; 0x3c
 80107fe:	647b      	str	r3, [r7, #68]	; 0x44

    /* Get the pointer to the transfer request associated with the endpoint.  */
    transfer_request =  &endpoint -> ux_slave_endpoint_transfer_request;
 8010800:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8010802:	3330      	adds	r3, #48	; 0x30
 8010804:	643b      	str	r3, [r7, #64]	; 0x40
    
    /* Set the event type to OUTPUT.  */
    hid_event.ux_device_class_hid_event_report_type =  descriptor_type;
 8010806:	68bb      	ldr	r3, [r7, #8]
 8010808:	61bb      	str	r3, [r7, #24]
    
    /* Get HID data address.  */
    hid_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
 801080a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801080c:	68db      	ldr	r3, [r3, #12]
 801080e:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Check for report ID in this HID descriptor.  */
    if (hid -> ux_device_class_hid_report_id == UX_TRUE)
 8010810:	68fb      	ldr	r3, [r7, #12]
 8010812:	6a1b      	ldr	r3, [r3, #32]
 8010814:	2b01      	cmp	r3, #1
 8010816:	d10a      	bne.n	801082e <_ux_device_class_hid_report_set+0x4a>
    {
        /* Set the report ID, First byte of data payload.  */
        hid_event.ux_device_class_hid_event_report_id = (ULONG) *hid_buffer;
 8010818:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801081a:	781b      	ldrb	r3, [r3, #0]
 801081c:	617b      	str	r3, [r7, #20]

        /* Set the length = total length - report ID. */
        hid_event.ux_device_class_hid_event_length = transfer_request -> ux_slave_transfer_request_actual_length -1;
 801081e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010820:	699b      	ldr	r3, [r3, #24]
 8010822:	3b01      	subs	r3, #1
 8010824:	63fb      	str	r3, [r7, #60]	; 0x3c
    
        /* Set HID data after report ID.  */
        hid_buffer++;
 8010826:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010828:	3301      	adds	r3, #1
 801082a:	64fb      	str	r3, [r7, #76]	; 0x4c
 801082c:	e004      	b.n	8010838 <_ux_device_class_hid_report_set+0x54>
    }
        
    else
    {    
        /* Set the report ID, not used here.  */
        hid_event.ux_device_class_hid_event_report_id = 0;
 801082e:	2300      	movs	r3, #0
 8010830:	617b      	str	r3, [r7, #20]

        /* Set the length.  */
        hid_event.ux_device_class_hid_event_length = transfer_request -> ux_slave_transfer_request_actual_length;
 8010832:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8010834:	699b      	ldr	r3, [r3, #24]
 8010836:	63fb      	str	r3, [r7, #60]	; 0x3c
    }
        
    /* Copy the buffer received from the host.  Check for overflow. */
    if (hid_event.ux_device_class_hid_event_length > UX_DEVICE_CLASS_HID_EVENT_BUFFER_LENGTH)
 8010838:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801083a:	2b20      	cmp	r3, #32
 801083c:	d901      	bls.n	8010842 <_ux_device_class_hid_report_set+0x5e>
    
        /* Overflow detected.  */
        hid_event.ux_device_class_hid_event_length = UX_DEVICE_CLASS_HID_EVENT_BUFFER_LENGTH;        
 801083e:	2320      	movs	r3, #32
 8010840:	63fb      	str	r3, [r7, #60]	; 0x3c
        
    /* Now we can safely copy the payload.  */
    _ux_utility_memory_copy(hid_event.ux_device_class_hid_event_buffer, hid_buffer, 
 8010842:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8010844:	f107 0314 	add.w	r3, r7, #20
 8010848:	3308      	adds	r3, #8
 801084a:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 801084c:	4618      	mov	r0, r3
 801084e:	f7fe ffa4 	bl	800f79a <_ux_utility_memory_copy>
                                hid_event.ux_device_class_hid_event_length); /* Use case of memcpy is verified. */

    /* If there is a callback defined by the application, send the hid event to it.  */
    if (hid -> ux_device_class_hid_callback != UX_NULL)
 8010852:	68fb      	ldr	r3, [r7, #12]
 8010854:	68db      	ldr	r3, [r3, #12]
 8010856:	2b00      	cmp	r3, #0
 8010858:	d006      	beq.n	8010868 <_ux_device_class_hid_report_set+0x84>
    
        /* Callback exists. */
        hid -> ux_device_class_hid_callback(hid, &hid_event);
 801085a:	68fb      	ldr	r3, [r7, #12]
 801085c:	68db      	ldr	r3, [r3, #12]
 801085e:	f107 0214 	add.w	r2, r7, #20
 8010862:	4611      	mov	r1, r2
 8010864:	68f8      	ldr	r0, [r7, #12]
 8010866:	4798      	blx	r3
        
    /* Return the status to the caller.  */
    return(UX_SUCCESS);
 8010868:	2300      	movs	r3, #0
}
 801086a:	4618      	mov	r0, r3
 801086c:	3750      	adds	r7, #80	; 0x50
 801086e:	46bd      	mov	sp, r7
 8010870:	bd80      	pop	{r7, pc}
 8010872:	bf00      	nop
 8010874:	2000730c 	.word	0x2000730c

08010878 <_ux_device_class_hid_uninitialize>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_hid_uninitialize(UX_SLAVE_CLASS_COMMAND *command)
{
 8010878:	b580      	push	{r7, lr}
 801087a:	b084      	sub	sp, #16
 801087c:	af00      	add	r7, sp, #0
 801087e:	6078      	str	r0, [r7, #4]
UX_SLAVE_CLASS_HID                      *hid;
UX_SLAVE_CLASS                          *class_ptr;


    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
 8010880:	687b      	ldr	r3, [r7, #4]
 8010882:	6a1b      	ldr	r3, [r3, #32]
 8010884:	60fb      	str	r3, [r7, #12]

    /* Get the class instance in the container.  */
    hid = (UX_SLAVE_CLASS_HID *) class_ptr -> ux_slave_class_instance;
 8010886:	68fb      	ldr	r3, [r7, #12]
 8010888:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801088a:	60bb      	str	r3, [r7, #8]

#if !defined(UX_DEVICE_STANDALONE)

    /* Remove HID thread.  */
    _ux_device_thread_delete(&class_ptr -> ux_slave_class_thread);
 801088c:	68fb      	ldr	r3, [r7, #12]
 801088e:	3350      	adds	r3, #80	; 0x50
 8010890:	4618      	mov	r0, r3
 8010892:	f7ff f9b9 	bl	800fc08 <_ux_utility_thread_delete>

    /* Remove the thread used by HID.  */
    _ux_utility_memory_free(class_ptr -> ux_slave_class_thread_stack);
 8010896:	68fb      	ldr	r3, [r7, #12]
 8010898:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 801089c:	4618      	mov	r0, r3
 801089e:	f7fe ff9b 	bl	800f7d8 <_ux_utility_memory_free>

    /* Delete the event flag group for the hid class.  */
    _ux_device_event_flags_delete(&hid -> ux_device_class_hid_event_flags_group);
 80108a2:	68bb      	ldr	r3, [r7, #8]
 80108a4:	3328      	adds	r3, #40	; 0x28
 80108a6:	4618      	mov	r0, r3
 80108a8:	f7fe fd75 	bl	800f396 <_ux_utility_event_flags_delete>
#endif

    /* Free memory for the array. */
    _ux_utility_memory_free(hid -> ux_device_class_hid_event_array);
 80108ac:	68bb      	ldr	r3, [r7, #8]
 80108ae:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80108b0:	4618      	mov	r0, r3
 80108b2:	f7fe ff91 	bl	800f7d8 <_ux_utility_memory_free>
#if defined(UX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT)

#if !defined(UX_DEVICE_STANDALONE)

    /* Free read mutex.  */
    _ux_device_mutex_delete(&hid -> ux_device_class_hid_read_mutex);
 80108b6:	68bb      	ldr	r3, [r7, #8]
 80108b8:	3370      	adds	r3, #112	; 0x70
 80108ba:	4618      	mov	r0, r3
 80108bc:	f7ff f89c 	bl	800f9f8 <_ux_utility_mutex_delete>
#endif

    /* Uninitialize receiver.  */
    if (hid -> ux_device_class_hid_receiver)
 80108c0:	68bb      	ldr	r3, [r7, #8]
 80108c2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80108c4:	2b00      	cmp	r3, #0
 80108c6:	d006      	beq.n	80108d6 <_ux_device_class_hid_uninitialize+0x5e>
        hid -> ux_device_class_hid_receiver ->
 80108c8:	68bb      	ldr	r3, [r7, #8]
 80108ca:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80108cc:	681b      	ldr	r3, [r3, #0]
 80108ce:	68ba      	ldr	r2, [r7, #8]
 80108d0:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 80108d2:	4610      	mov	r0, r2
 80108d4:	4798      	blx	r3
            ux_device_class_hid_receiver_uninitialize(hid -> ux_device_class_hid_receiver);
#endif

    /* Free the resources.  */
    _ux_utility_memory_free(hid);
 80108d6:	68b8      	ldr	r0, [r7, #8]
 80108d8:	f7fe ff7e 	bl	800f7d8 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(UX_SUCCESS);
 80108dc:	2300      	movs	r3, #0
}
 80108de:	4618      	mov	r0, r3
 80108e0:	3710      	adds	r7, #16
 80108e2:	46bd      	mov	sp, r7
 80108e4:	bd80      	pop	{r7, pc}

080108e6 <_ux_device_class_storage_activate>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_activate(UX_SLAVE_CLASS_COMMAND *command)
{
 80108e6:	b580      	push	{r7, lr}
 80108e8:	b086      	sub	sp, #24
 80108ea:	af00      	add	r7, sp, #0
 80108ec:	6078      	str	r0, [r7, #4]
                                          
UINT                                    status = UX_SUCCESS;
 80108ee:	2300      	movs	r3, #0
 80108f0:	617b      	str	r3, [r7, #20]
UX_SLAVE_ENDPOINT                       *endpoint;
#endif


    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
 80108f2:	687b      	ldr	r3, [r7, #4]
 80108f4:	6a1b      	ldr	r3, [r3, #32]
 80108f6:	613b      	str	r3, [r7, #16]

    /* Get the class instance in the container.  */
    storage = (UX_SLAVE_CLASS_STORAGE *)class_ptr -> ux_slave_class_instance;
 80108f8:	693b      	ldr	r3, [r7, #16]
 80108fa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80108fc:	60fb      	str	r3, [r7, #12]

    /* Get the interface that owns this instance.  */
    interface_ptr =  (UX_SLAVE_INTERFACE  *) command -> ux_slave_class_command_interface;
 80108fe:	687b      	ldr	r3, [r7, #4]
 8010900:	689b      	ldr	r3, [r3, #8]
 8010902:	60bb      	str	r3, [r7, #8]
    
    /* Store the class instance into the interface.  */
    interface_ptr -> ux_slave_interface_class_instance =  (VOID *)storage;
 8010904:	68bb      	ldr	r3, [r7, #8]
 8010906:	68fa      	ldr	r2, [r7, #12]
 8010908:	609a      	str	r2, [r3, #8]
         
    /* Now the opposite, store the interface in the class instance.  */
    storage -> ux_slave_class_storage_interface =  interface_ptr;
 801090a:	68fb      	ldr	r3, [r7, #12]
 801090c:	68ba      	ldr	r2, [r7, #8]
 801090e:	601a      	str	r2, [r3, #0]

#if !defined(UX_DEVICE_STANDALONE)

    /* Resume thread.  */
    _ux_device_thread_resume(&class_ptr -> ux_slave_class_thread); 
 8010910:	693b      	ldr	r3, [r7, #16]
 8010912:	3350      	adds	r3, #80	; 0x50
 8010914:	4618      	mov	r0, r3
 8010916:	f7ff f98d 	bl	800fc34 <_ux_utility_thread_resume>

    status = UX_SUCCESS;
#endif

    /* If there is a activate function call it.  */
    if (storage -> ux_slave_class_storage_instance_activate != UX_NULL)
 801091a:	68fb      	ldr	r3, [r7, #12]
 801091c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801091e:	2b00      	cmp	r3, #0
 8010920:	d003      	beq.n	801092a <_ux_device_class_storage_activate+0x44>
    {        
        /* Invoke the application.  */
        storage -> ux_slave_class_storage_instance_activate(storage);
 8010922:	68fb      	ldr	r3, [r7, #12]
 8010924:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8010926:	68f8      	ldr	r0, [r7, #12]
 8010928:	4798      	blx	r3

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_REGISTER(UX_TRACE_DEVICE_OBJECT_TYPE_INTERFACE, storage, 0, 0, 0)

    /* Return completion status.  */
    return(status);
 801092a:	697b      	ldr	r3, [r7, #20]
}
 801092c:	4618      	mov	r0, r3
 801092e:	3718      	adds	r7, #24
 8010930:	46bd      	mov	sp, r7
 8010932:	bd80      	pop	{r7, pc}

08010934 <_ux_device_class_storage_control_request>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_control_request(UX_SLAVE_CLASS_COMMAND *command)
{
 8010934:	b580      	push	{r7, lr}
 8010936:	b08c      	sub	sp, #48	; 0x30
 8010938:	af00      	add	r7, sp, #0
 801093a:	6078      	str	r0, [r7, #4]
UX_SLAVE_ENDPOINT           *endpoint_in;
UX_SLAVE_ENDPOINT           *endpoint_out;


    /* Get the pointer to the device.  */
    device =  &_ux_system_slave -> ux_system_slave_device;
 801093c:	4b39      	ldr	r3, [pc, #228]	; (8010a24 <_ux_device_class_storage_control_request+0xf0>)
 801093e:	681b      	ldr	r3, [r3, #0]
 8010940:	3320      	adds	r3, #32
 8010942:	627b      	str	r3, [r7, #36]	; 0x24

    /* Get the pointer to the transfer request associated with the control endpoint.  */
    transfer_request =  &device -> ux_slave_device_control_endpoint.ux_slave_endpoint_transfer_request;
 8010944:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010946:	336c      	adds	r3, #108	; 0x6c
 8010948:	623b      	str	r3, [r7, #32]
    
    /* Extract the request type from the SETUP packet..   */
    request =  *(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_REQUEST);
 801094a:	6a3b      	ldr	r3, [r7, #32]
 801094c:	f893 3055 	ldrb.w	r3, [r3, #85]	; 0x55
 8010950:	61fb      	str	r3, [r7, #28]
    request_value = _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_VALUE);
 8010952:	6a3b      	ldr	r3, [r7, #32]
 8010954:	3354      	adds	r3, #84	; 0x54
 8010956:	3302      	adds	r3, #2
 8010958:	4618      	mov	r0, r3
 801095a:	f7ff f8af 	bl	800fabc <_ux_utility_short_get>
 801095e:	61b8      	str	r0, [r7, #24]
    request_length = _ux_utility_short_get(transfer_request -> ux_slave_transfer_request_setup + UX_SETUP_LENGTH);
 8010960:	6a3b      	ldr	r3, [r7, #32]
 8010962:	3354      	adds	r3, #84	; 0x54
 8010964:	3306      	adds	r3, #6
 8010966:	4618      	mov	r0, r3
 8010968:	f7ff f8a8 	bl	800fabc <_ux_utility_short_get>
 801096c:	6178      	str	r0, [r7, #20]

    /* Check if wValue is valid.  */
    if (request_value != 0)
 801096e:	69bb      	ldr	r3, [r7, #24]
 8010970:	2b00      	cmp	r3, #0
 8010972:	d001      	beq.n	8010978 <_ux_device_class_storage_control_request+0x44>
        return(UX_ERROR);
 8010974:	23ff      	movs	r3, #255	; 0xff
 8010976:	e050      	b.n	8010a1a <_ux_device_class_storage_control_request+0xe6>

    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
 8010978:	687b      	ldr	r3, [r7, #4]
 801097a:	6a1b      	ldr	r3, [r3, #32]
 801097c:	613b      	str	r3, [r7, #16]
    
    /* Get the storage instance from this class container.  */
    storage =  (UX_SLAVE_CLASS_STORAGE *) class_ptr -> ux_slave_class_instance;
 801097e:	693b      	ldr	r3, [r7, #16]
 8010980:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8010982:	60fb      	str	r3, [r7, #12]

    /* Here we proceed only the standard request we know of at the device level.  */
    switch (request)
 8010984:	69fb      	ldr	r3, [r7, #28]
 8010986:	2bfe      	cmp	r3, #254	; 0xfe
 8010988:	d02e      	beq.n	80109e8 <_ux_device_class_storage_control_request+0xb4>
 801098a:	69fb      	ldr	r3, [r7, #28]
 801098c:	2bff      	cmp	r3, #255	; 0xff
 801098e:	d141      	bne.n	8010a14 <_ux_device_class_storage_control_request+0xe0>
    {

    case UX_SLAVE_CLASS_STORAGE_RESET:

        /* Check if wLength is valid.  */
        if (request_length != 0)
 8010990:	697b      	ldr	r3, [r7, #20]
 8010992:	2b00      	cmp	r3, #0
 8010994:	d001      	beq.n	801099a <_ux_device_class_storage_control_request+0x66>
            return(UX_ERROR);
 8010996:	23ff      	movs	r3, #255	; 0xff
 8010998:	e03f      	b.n	8010a1a <_ux_device_class_storage_control_request+0xe6>
        endpoint_in = storage -> ux_device_class_storage_ep_in;
        endpoint_out = storage -> ux_device_class_storage_ep_out;
#else

        /* We need the interface to the class.  */
        interface_ptr =  storage -> ux_slave_class_storage_interface;
 801099a:	68fb      	ldr	r3, [r7, #12]
 801099c:	681b      	ldr	r3, [r3, #0]
 801099e:	60bb      	str	r3, [r7, #8]

        /* Locate the endpoints.  */
        endpoint_in =  interface_ptr -> ux_slave_interface_first_endpoint;
 80109a0:	68bb      	ldr	r3, [r7, #8]
 80109a2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80109a4:	62fb      	str	r3, [r7, #44]	; 0x2c
        
        /* Check the endpoint direction, if IN we have the correct endpoint.  */
        if ((endpoint_in -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) != UX_ENDPOINT_IN)
 80109a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80109a8:	695b      	ldr	r3, [r3, #20]
 80109aa:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80109ae:	2b00      	cmp	r3, #0
 80109b0:	d105      	bne.n	80109be <_ux_device_class_storage_control_request+0x8a>
        {

            /* Wrong direction, we found the OUT endpoint first.  */
            endpoint_out =  endpoint_in;
 80109b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80109b4:	62bb      	str	r3, [r7, #40]	; 0x28
                
            /* So the next endpoint has to be the IN endpoint.  */
            endpoint_in =  endpoint_out -> ux_slave_endpoint_next_endpoint;
 80109b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80109b8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80109ba:	62fb      	str	r3, [r7, #44]	; 0x2c
 80109bc:	e002      	b.n	80109c4 <_ux_device_class_storage_control_request+0x90>
        }
        else
        {

            /* We found the endpoint IN first, so next endpoint is OUT.  */
            endpoint_out =  endpoint_in -> ux_slave_endpoint_next_endpoint;
 80109be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80109c0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80109c2:	62bb      	str	r3, [r7, #40]	; 0x28
        }
#endif

        /* First cancel any transfer on the endpoint OUT, from the host.  */
        transfer_request =  &endpoint_out -> ux_slave_endpoint_transfer_request;
 80109c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80109c6:	3330      	adds	r3, #48	; 0x30
 80109c8:	623b      	str	r3, [r7, #32]
        _ux_device_stack_transfer_abort(transfer_request, UX_TRANSFER_APPLICATION_RESET);
 80109ca:	2128      	movs	r1, #40	; 0x28
 80109cc:	6a38      	ldr	r0, [r7, #32]
 80109ce:	f7fe fb07 	bl	800efe0 <_ux_device_stack_transfer_abort>

        /* Then cancel any transfer on the endpoint IN, from the host.  */
        transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
 80109d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80109d4:	3330      	adds	r3, #48	; 0x30
 80109d6:	623b      	str	r3, [r7, #32]
        _ux_device_stack_transfer_abort(transfer_request, UX_TRANSFER_APPLICATION_RESET);
 80109d8:	2128      	movs	r1, #40	; 0x28
 80109da:	6a38      	ldr	r0, [r7, #32]
 80109dc:	f7fe fb00 	bl	800efe0 <_ux_device_stack_transfer_abort>

        /* Reset phase error.  */
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 80109e0:	68fb      	ldr	r3, [r7, #12]
 80109e2:	2200      	movs	r2, #0
 80109e4:	651a      	str	r2, [r3, #80]	; 0x50

        break;
 80109e6:	e017      	b.n	8010a18 <_ux_device_class_storage_control_request+0xe4>

    case UX_SLAVE_CLASS_STORAGE_GET_MAX_LUN:

        /* Check if wLength is valid.  */
        if (request_length < 1)
 80109e8:	697b      	ldr	r3, [r7, #20]
 80109ea:	2b00      	cmp	r3, #0
 80109ec:	d101      	bne.n	80109f2 <_ux_device_class_storage_control_request+0xbe>
            return(UX_ERROR);
 80109ee:	23ff      	movs	r3, #255	; 0xff
 80109f0:	e013      	b.n	8010a1a <_ux_device_class_storage_control_request+0xe6>

        /* Set the value of the number of LUN in the buffer. The max number of LUN is the
           number of declared LUN - 1.  */
        *transfer_request -> ux_slave_transfer_request_data_pointer =  (UCHAR)(storage -> ux_slave_class_storage_number_lun -1);
 80109f2:	68fb      	ldr	r3, [r7, #12]
 80109f4:	685b      	ldr	r3, [r3, #4]
 80109f6:	b2da      	uxtb	r2, r3
 80109f8:	6a3b      	ldr	r3, [r7, #32]
 80109fa:	68db      	ldr	r3, [r3, #12]
 80109fc:	3a01      	subs	r2, #1
 80109fe:	b2d2      	uxtb	r2, r2
 8010a00:	701a      	strb	r2, [r3, #0]

        /* Set the phase of the transfer to data out.  */
        transfer_request -> ux_slave_transfer_request_phase =  UX_TRANSFER_PHASE_DATA_OUT;
 8010a02:	6a3b      	ldr	r3, [r7, #32]
 8010a04:	2203      	movs	r2, #3
 8010a06:	629a      	str	r2, [r3, #40]	; 0x28

        /* We can return the LUN number.  */
        _ux_device_stack_transfer_request(transfer_request, 1, 1);
 8010a08:	2201      	movs	r2, #1
 8010a0a:	2101      	movs	r1, #1
 8010a0c:	6a38      	ldr	r0, [r7, #32]
 8010a0e:	f7fe fb33 	bl	800f078 <_ux_device_stack_transfer_request>
        break;
 8010a12:	e001      	b.n	8010a18 <_ux_device_class_storage_control_request+0xe4>

    default:

        /* Unknown function. It's not handled.  */
        return(UX_ERROR);
 8010a14:	23ff      	movs	r3, #255	; 0xff
 8010a16:	e000      	b.n	8010a1a <_ux_device_class_storage_control_request+0xe6>
    }

    /* It's handled.  */
    return(UX_SUCCESS);
 8010a18:	2300      	movs	r3, #0
}
 8010a1a:	4618      	mov	r0, r3
 8010a1c:	3730      	adds	r7, #48	; 0x30
 8010a1e:	46bd      	mov	sp, r7
 8010a20:	bd80      	pop	{r7, pc}
 8010a22:	bf00      	nop
 8010a24:	2000730c 	.word	0x2000730c

08010a28 <_ux_device_class_storage_csw_send>:
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_csw_send(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                UX_SLAVE_ENDPOINT *endpoint_in, UCHAR csw_status)
{
 8010a28:	b580      	push	{r7, lr}
 8010a2a:	b088      	sub	sp, #32
 8010a2c:	af00      	add	r7, sp, #0
 8010a2e:	60f8      	str	r0, [r7, #12]
 8010a30:	60b9      	str	r1, [r7, #8]
 8010a32:	607a      	str	r2, [r7, #4]
 8010a34:	70fb      	strb	r3, [r7, #3]

UINT                    status = UX_SUCCESS;
 8010a36:	2300      	movs	r3, #0
 8010a38:	61fb      	str	r3, [r7, #28]
    storage -> ux_device_class_storage_ep_in -> ux_slave_endpoint_transfer_request.
            ux_slave_transfer_request_data_pointer = storage -> ux_device_class_storage_buffer[1];
#endif

    /* If CSW skipped, just return.  */
    if (UX_DEVICE_CLASS_STORAGE_CSW_SKIP(&storage -> ux_slave_class_storage_csw_status))
 8010a3a:	68fb      	ldr	r3, [r7, #12]
 8010a3c:	3350      	adds	r3, #80	; 0x50
 8010a3e:	3303      	adds	r3, #3
 8010a40:	781b      	ldrb	r3, [r3, #0]
 8010a42:	2b00      	cmp	r3, #0
 8010a44:	d001      	beq.n	8010a4a <_ux_device_class_storage_csw_send+0x22>
        return(UX_SUCCESS);
 8010a46:	2300      	movs	r3, #0
 8010a48:	e02c      	b.n	8010aa4 <_ux_device_class_storage_csw_send+0x7c>

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
 8010a4a:	687b      	ldr	r3, [r7, #4]
 8010a4c:	3330      	adds	r3, #48	; 0x30
 8010a4e:	61bb      	str	r3, [r7, #24]

    /* Get CSW buffer pointer.  */
    csw_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
 8010a50:	69bb      	ldr	r3, [r7, #24]
 8010a52:	68db      	ldr	r3, [r3, #12]
 8010a54:	617b      	str	r3, [r7, #20]

    /* Ensure it is cleaned.  */
    _ux_utility_memory_set(csw_buffer, 0, UX_SLAVE_CLASS_STORAGE_CSW_LENGTH); /* Use case of memset is verified. */
 8010a56:	220d      	movs	r2, #13
 8010a58:	2100      	movs	r1, #0
 8010a5a:	6978      	ldr	r0, [r7, #20]
 8010a5c:	f7fe ff9a 	bl	800f994 <_ux_utility_memory_set>

    /* Store the signature of the CSW.  */
    _ux_utility_long_put(&csw_buffer[UX_SLAVE_CLASS_STORAGE_CSW_SIGNATURE], UX_SLAVE_CLASS_STORAGE_CSW_SIGNATURE_MASK);
 8010a60:	4912      	ldr	r1, [pc, #72]	; (8010aac <_ux_device_class_storage_csw_send+0x84>)
 8010a62:	6978      	ldr	r0, [r7, #20]
 8010a64:	f7fe fd1e 	bl	800f4a4 <_ux_utility_long_put>

    /* Store the SCSI tag from the CBW.  */
    _ux_utility_long_put(&csw_buffer[UX_SLAVE_CLASS_STORAGE_CSW_TAG], storage -> ux_slave_class_storage_scsi_tag);
 8010a68:	697b      	ldr	r3, [r7, #20]
 8010a6a:	1d1a      	adds	r2, r3, #4
 8010a6c:	68fb      	ldr	r3, [r7, #12]
 8010a6e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8010a70:	4619      	mov	r1, r3
 8010a72:	4610      	mov	r0, r2
 8010a74:	f7fe fd16 	bl	800f4a4 <_ux_utility_long_put>

    /* Store the dCSWDataResidue.  */
    _ux_utility_long_put(&csw_buffer[UX_SLAVE_CLASS_STORAGE_CSW_DATA_RESIDUE], storage -> ux_slave_class_storage_csw_residue);
 8010a78:	697b      	ldr	r3, [r7, #20]
 8010a7a:	f103 0208 	add.w	r2, r3, #8
 8010a7e:	68fb      	ldr	r3, [r7, #12]
 8010a80:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010a82:	4619      	mov	r1, r3
 8010a84:	4610      	mov	r0, r2
 8010a86:	f7fe fd0d 	bl	800f4a4 <_ux_utility_long_put>

    /* Store the status of the previous operation.  */
    csw_buffer[UX_SLAVE_CLASS_STORAGE_CSW_STATUS] = (UCHAR)storage -> ux_slave_class_storage_csw_status;
 8010a8a:	68fb      	ldr	r3, [r7, #12]
 8010a8c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010a8e:	697b      	ldr	r3, [r7, #20]
 8010a90:	330c      	adds	r3, #12
 8010a92:	b2d2      	uxtb	r2, r2
 8010a94:	701a      	strb	r2, [r3, #0]

    /* We may be in a special state machine condition where the endpoint is stalled waiting for
       a CLEAR_FEATURE.  We will wait until the host clears the endpoint.  
       The transfer_request function does that.  */
    /* Send the CSW back to the host.  */
    status =  _ux_device_stack_transfer_request(transfer_request, UX_SLAVE_CLASS_STORAGE_CSW_LENGTH, 
 8010a96:	220d      	movs	r2, #13
 8010a98:	210d      	movs	r1, #13
 8010a9a:	69b8      	ldr	r0, [r7, #24]
 8010a9c:	f7fe faec 	bl	800f078 <_ux_device_stack_transfer_request>
 8010aa0:	61f8      	str	r0, [r7, #28]
                                    UX_SLAVE_CLASS_STORAGE_CSW_LENGTH);
#endif

    /* Return completion status.  */
    return(status);
 8010aa2:	69fb      	ldr	r3, [r7, #28]
}
 8010aa4:	4618      	mov	r0, r3
 8010aa6:	3720      	adds	r7, #32
 8010aa8:	46bd      	mov	sp, r7
 8010aaa:	bd80      	pop	{r7, pc}
 8010aac:	53425355 	.word	0x53425355

08010ab0 <_ux_device_class_storage_deactivate>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_deactivate(UX_SLAVE_CLASS_COMMAND *command)
{
 8010ab0:	b580      	push	{r7, lr}
 8010ab2:	b086      	sub	sp, #24
 8010ab4:	af00      	add	r7, sp, #0
 8010ab6:	6078      	str	r0, [r7, #4]
UX_SLAVE_ENDPOINT           *endpoint_in;
UX_SLAVE_ENDPOINT           *endpoint_out;
UX_SLAVE_CLASS              *class_ptr;

    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
 8010ab8:	687b      	ldr	r3, [r7, #4]
 8010aba:	6a1b      	ldr	r3, [r3, #32]
 8010abc:	60fb      	str	r3, [r7, #12]

    /* Get the class instance in the container.  */
    storage = (UX_SLAVE_CLASS_STORAGE *)class_ptr -> ux_slave_class_instance;
 8010abe:	68fb      	ldr	r3, [r7, #12]
 8010ac0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8010ac2:	60bb      	str	r3, [r7, #8]
    endpoint_in -> ux_slave_endpoint_transfer_request.ux_slave_transfer_request_data_pointer =
                                storage -> ux_device_class_storage_buffer[1];
#else

    /* Locate the endpoints.  */
    endpoint_in =  storage -> ux_slave_class_storage_interface -> ux_slave_interface_first_endpoint;
 8010ac4:	68bb      	ldr	r3, [r7, #8]
 8010ac6:	681b      	ldr	r3, [r3, #0]
 8010ac8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8010aca:	617b      	str	r3, [r7, #20]
    
    /* Check the endpoint direction, if IN we have the correct endpoint.  */
    if ((endpoint_in -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) != UX_ENDPOINT_IN)
 8010acc:	697b      	ldr	r3, [r7, #20]
 8010ace:	695b      	ldr	r3, [r3, #20]
 8010ad0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8010ad4:	2b00      	cmp	r3, #0
 8010ad6:	d105      	bne.n	8010ae4 <_ux_device_class_storage_deactivate+0x34>
    {

        /* Wrong direction, we found the OUT endpoint first.  */
        endpoint_out =  endpoint_in;
 8010ad8:	697b      	ldr	r3, [r7, #20]
 8010ada:	613b      	str	r3, [r7, #16]
            
        /* So the next endpoint has to be the IN endpoint.  */
        endpoint_in =  endpoint_out -> ux_slave_endpoint_next_endpoint;
 8010adc:	693b      	ldr	r3, [r7, #16]
 8010ade:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010ae0:	617b      	str	r3, [r7, #20]
 8010ae2:	e002      	b.n	8010aea <_ux_device_class_storage_deactivate+0x3a>
    }
    else
    {

        /* We found the endpoint IN first, so next endpoint is OUT.  */
        endpoint_out =  endpoint_in -> ux_slave_endpoint_next_endpoint;
 8010ae4:	697b      	ldr	r3, [r7, #20]
 8010ae6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010ae8:	613b      	str	r3, [r7, #16]
    }
        
    /* Terminate the transactions pending on the endpoints.  */
    _ux_device_stack_transfer_all_request_abort(endpoint_in, UX_TRANSFER_BUS_RESET);
 8010aea:	2126      	movs	r1, #38	; 0x26
 8010aec:	6978      	ldr	r0, [r7, #20]
 8010aee:	f7fe fab1 	bl	800f054 <_ux_device_stack_transfer_all_request_abort>
    _ux_device_stack_transfer_all_request_abort(endpoint_out, UX_TRANSFER_BUS_RESET);
 8010af2:	2126      	movs	r1, #38	; 0x26
 8010af4:	6938      	ldr	r0, [r7, #16]
 8010af6:	f7fe faad 	bl	800f054 <_ux_device_stack_transfer_all_request_abort>
#endif

    /* If there is a deactivate function call it.  */
    if (storage -> ux_slave_class_storage_instance_deactivate != UX_NULL)
 8010afa:	68bb      	ldr	r3, [r7, #8]
 8010afc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010afe:	2b00      	cmp	r3, #0
 8010b00:	d003      	beq.n	8010b0a <_ux_device_class_storage_deactivate+0x5a>
    {

        /* Invoke the application.  */
        storage -> ux_slave_class_storage_instance_deactivate(storage);
 8010b02:	68bb      	ldr	r3, [r7, #8]
 8010b04:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010b06:	68b8      	ldr	r0, [r7, #8]
 8010b08:	4798      	blx	r3

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_UNREGISTER(storage);

    /* Return completion status.  */
    return(UX_SUCCESS);
 8010b0a:	2300      	movs	r3, #0
}
 8010b0c:	4618      	mov	r0, r3
 8010b0e:	3718      	adds	r7, #24
 8010b10:	46bd      	mov	sp, r7
 8010b12:	bd80      	pop	{r7, pc}

08010b14 <_ux_device_class_storage_entry>:
/*  09-30-2020     Chaoqiong Xiao           Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_entry(UX_SLAVE_CLASS_COMMAND *command)
{
 8010b14:	b580      	push	{r7, lr}
 8010b16:	b084      	sub	sp, #16
 8010b18:	af00      	add	r7, sp, #0
 8010b1a:	6078      	str	r0, [r7, #4]
UINT        status;


    /* The command request will tell us we need to do here, either a enumeration
       query, an activation or a deactivation.  */
    switch (command -> ux_slave_class_command_request)
 8010b1c:	687b      	ldr	r3, [r7, #4]
 8010b1e:	681b      	ldr	r3, [r3, #0]
 8010b20:	3b01      	subs	r3, #1
 8010b22:	2b06      	cmp	r3, #6
 8010b24:	d836      	bhi.n	8010b94 <_ux_device_class_storage_entry+0x80>
 8010b26:	a201      	add	r2, pc, #4	; (adr r2, 8010b2c <_ux_device_class_storage_entry+0x18>)
 8010b28:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010b2c:	08010b61 	.word	0x08010b61
 8010b30:	08010b71 	.word	0x08010b71
 8010b34:	08010b7d 	.word	0x08010b7d
 8010b38:	08010b89 	.word	0x08010b89
 8010b3c:	08010b49 	.word	0x08010b49
 8010b40:	08010b95 	.word	0x08010b95
 8010b44:	08010b55 	.word	0x08010b55
    {

    case UX_SLAVE_CLASS_COMMAND_INITIALIZE:

        /* Call the init function of the Storage class.  */
        status =  _ux_device_class_storage_initialize(command);
 8010b48:	6878      	ldr	r0, [r7, #4]
 8010b4a:	f000 f84b 	bl	8010be4 <_ux_device_class_storage_initialize>
 8010b4e:	60f8      	str	r0, [r7, #12]
        
        /* Return the completion status.  */
        return(status);
 8010b50:	68fb      	ldr	r3, [r7, #12]
 8010b52:	e025      	b.n	8010ba0 <_ux_device_class_storage_entry+0x8c>
        
    case UX_SLAVE_CLASS_COMMAND_UNINITIALIZE:

        /* Call the init function of the Storage class.  */
        status =  _ux_device_class_storage_uninitialize(command);
 8010b54:	6878      	ldr	r0, [r7, #4]
 8010b56:	f001 f907 	bl	8011d68 <_ux_device_class_storage_uninitialize>
 8010b5a:	60f8      	str	r0, [r7, #12]
        
        /* Return the completion status.  */
        return(status);
 8010b5c:	68fb      	ldr	r3, [r7, #12]
 8010b5e:	e01f      	b.n	8010ba0 <_ux_device_class_storage_entry+0x8c>
        

    case UX_SLAVE_CLASS_COMMAND_QUERY:

        /* Check the CLASS definition in the interface descriptor. */
        if (command -> ux_slave_class_command_class == UX_SLAVE_CLASS_STORAGE_CLASS)
 8010b60:	687b      	ldr	r3, [r7, #4]
 8010b62:	695b      	ldr	r3, [r3, #20]
 8010b64:	2b08      	cmp	r3, #8
 8010b66:	d101      	bne.n	8010b6c <_ux_device_class_storage_entry+0x58>
            return(UX_SUCCESS);
 8010b68:	2300      	movs	r3, #0
 8010b6a:	e019      	b.n	8010ba0 <_ux_device_class_storage_entry+0x8c>
        else
            return(UX_NO_CLASS_MATCH);
 8010b6c:	2357      	movs	r3, #87	; 0x57
 8010b6e:	e017      	b.n	8010ba0 <_ux_device_class_storage_entry+0x8c>
    case UX_SLAVE_CLASS_COMMAND_ACTIVATE:

        /* The activate command is used when the host has sent a SET_CONFIGURATION command
           and this interface has to be mounted. Both Bulk endpoints have to be mounted
           and the storage thread needs to be activated.  */
        status =  _ux_device_class_storage_activate(command);
 8010b70:	6878      	ldr	r0, [r7, #4]
 8010b72:	f7ff feb8 	bl	80108e6 <_ux_device_class_storage_activate>
 8010b76:	60f8      	str	r0, [r7, #12]

        /* Return the completion status.  */
        return(status);
 8010b78:	68fb      	ldr	r3, [r7, #12]
 8010b7a:	e011      	b.n	8010ba0 <_ux_device_class_storage_entry+0x8c>

    case UX_SLAVE_CLASS_COMMAND_DEACTIVATE:

        /* The deactivate command is used when the device has been extracted.
           The device endpoints have to be dismounted and the storage thread canceled.  */
        status =  _ux_device_class_storage_deactivate(command);
 8010b7c:	6878      	ldr	r0, [r7, #4]
 8010b7e:	f7ff ff97 	bl	8010ab0 <_ux_device_class_storage_deactivate>
 8010b82:	60f8      	str	r0, [r7, #12]
        
        /* Return the completion status.  */
        return(status);
 8010b84:	68fb      	ldr	r3, [r7, #12]
 8010b86:	e00b      	b.n	8010ba0 <_ux_device_class_storage_entry+0x8c>

    case UX_SLAVE_CLASS_COMMAND_REQUEST:

        /* The request command is used when the host sends a command on the control endpoint.  */
        status = _ux_device_class_storage_control_request(command);
 8010b88:	6878      	ldr	r0, [r7, #4]
 8010b8a:	f7ff fed3 	bl	8010934 <_ux_device_class_storage_control_request>
 8010b8e:	60f8      	str	r0, [r7, #12]

        /* Return the completion status.  */
        return(status);
 8010b90:	68fb      	ldr	r3, [r7, #12]
 8010b92:	e005      	b.n	8010ba0 <_ux_device_class_storage_entry+0x8c>

    default: 

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_FUNCTION_NOT_SUPPORTED);
 8010b94:	2254      	movs	r2, #84	; 0x54
 8010b96:	2107      	movs	r1, #7
 8010b98:	2002      	movs	r0, #2
 8010b9a:	f7fe faf7 	bl	800f18c <_ux_system_error_handler>

        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

        /* Return an error.  */
        return(UX_FUNCTION_NOT_SUPPORTED);
 8010b9e:	2354      	movs	r3, #84	; 0x54
    }   
}
 8010ba0:	4618      	mov	r0, r3
 8010ba2:	3710      	adds	r7, #16
 8010ba4:	46bd      	mov	sp, r7
 8010ba6:	bd80      	pop	{r7, pc}

08010ba8 <_ux_device_class_storage_format>:
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_format(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb)
{
 8010ba8:	b580      	push	{r7, lr}
 8010baa:	b084      	sub	sp, #16
 8010bac:	af00      	add	r7, sp, #0
 8010bae:	60f8      	str	r0, [r7, #12]
 8010bb0:	60b9      	str	r1, [r7, #8]
 8010bb2:	607a      	str	r2, [r7, #4]
 8010bb4:	603b      	str	r3, [r7, #0]

#if !defined(UX_DEVICE_STANDALONE)

    /* This command is not yet supported. So Stall the endpoint. We stall the
       OUT endpoint because we expect the host to send parameters.  */
    _ux_device_stack_endpoint_stall(endpoint_out);
 8010bb6:	6838      	ldr	r0, [r7, #0]
 8010bb8:	f7fe f82c 	bl	800ec14 <_ux_device_stack_endpoint_stall>

    UX_PARAMETER_NOT_USED(endpoint_out);
#endif

    /* And update the REQUEST_SENSE codes.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
 8010bbc:	68f9      	ldr	r1, [r7, #12]
 8010bbe:	68ba      	ldr	r2, [r7, #8]
 8010bc0:	4613      	mov	r3, r2
 8010bc2:	00db      	lsls	r3, r3, #3
 8010bc4:	1a9b      	subs	r3, r3, r2
 8010bc6:	00db      	lsls	r3, r3, #3
 8010bc8:	440b      	add	r3, r1
 8010bca:	3320      	adds	r3, #32
 8010bcc:	4a04      	ldr	r2, [pc, #16]	; (8010be0 <_ux_device_class_storage_format+0x38>)
 8010bce:	601a      	str	r2, [r3, #0]
                                               UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x05,0x26,0x01);

    /* Now we set the CSW with failure.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
 8010bd0:	68fb      	ldr	r3, [r7, #12]
 8010bd2:	2201      	movs	r2, #1
 8010bd4:	651a      	str	r2, [r3, #80]	; 0x50

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* Return not supported error.  */
    return(UX_FUNCTION_NOT_SUPPORTED);
 8010bd6:	2354      	movs	r3, #84	; 0x54
}
 8010bd8:	4618      	mov	r0, r3
 8010bda:	3710      	adds	r7, #16
 8010bdc:	46bd      	mov	sp, r7
 8010bde:	bd80      	pop	{r7, pc}
 8010be0:	00012605 	.word	0x00012605

08010be4 <_ux_device_class_storage_initialize>:
/*                                            added standalone support,   */
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_initialize(UX_SLAVE_CLASS_COMMAND *command)
{
 8010be4:	b580      	push	{r7, lr}
 8010be6:	b08e      	sub	sp, #56	; 0x38
 8010be8:	af06      	add	r7, sp, #24
 8010bea:	6078      	str	r0, [r7, #4]

UINT                                    status = UX_SUCCESS;
 8010bec:	2300      	movs	r3, #0
 8010bee:	61fb      	str	r3, [r7, #28]
UX_SLAVE_CLASS                          *class_inst;
ULONG                                   lun_index;


    /* Get the pointer to the application parameters for the storage class.  */
    storage_parameter =  command -> ux_slave_class_command_parameter;
 8010bf0:	687b      	ldr	r3, [r7, #4]
 8010bf2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010bf4:	617b      	str	r3, [r7, #20]

    /* Ensure the number of LUN declared by the caller does not exceed the
       max number allowed for LUN storage.  */
    if (storage_parameter -> ux_slave_class_storage_parameter_number_lun > UX_MAX_SLAVE_LUN)
 8010bf6:	697b      	ldr	r3, [r7, #20]
 8010bf8:	689b      	ldr	r3, [r3, #8]
 8010bfa:	2b01      	cmp	r3, #1
 8010bfc:	d901      	bls.n	8010c02 <_ux_device_class_storage_initialize+0x1e>
        return UX_ERROR;
 8010bfe:	23ff      	movs	r3, #255	; 0xff
 8010c00:	e166      	b.n	8010ed0 <_ux_device_class_storage_initialize+0x2ec>

    /* Get the class container.  */
    class_inst =  command -> ux_slave_class_command_class_ptr;
 8010c02:	687b      	ldr	r3, [r7, #4]
 8010c04:	6a1b      	ldr	r3, [r3, #32]
 8010c06:	613b      	str	r3, [r7, #16]

    /* Create an instance of the device storage class.  */
    storage =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_SLAVE_CLASS_STORAGE));
 8010c08:	226c      	movs	r2, #108	; 0x6c
 8010c0a:	2100      	movs	r1, #0
 8010c0c:	2000      	movs	r0, #0
 8010c0e:	f7fe fc9b 	bl	800f548 <_ux_utility_memory_allocate>
 8010c12:	60f8      	str	r0, [r7, #12]

    /* Check for successful allocation.  */
    if (storage == UX_NULL)
 8010c14:	68fb      	ldr	r3, [r7, #12]
 8010c16:	2b00      	cmp	r3, #0
 8010c18:	d101      	bne.n	8010c1e <_ux_device_class_storage_initialize+0x3a>
        return(UX_MEMORY_INSUFFICIENT);
 8010c1a:	2312      	movs	r3, #18
 8010c1c:	e158      	b.n	8010ed0 <_ux_device_class_storage_initialize+0x2ec>

#if !defined(UX_DEVICE_STANDALONE)

    /* Allocate some memory for the thread stack. */
    class_inst -> ux_slave_class_thread_stack = _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_THREAD_STACK_SIZE);
 8010c1e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8010c22:	2100      	movs	r1, #0
 8010c24:	2000      	movs	r0, #0
 8010c26:	f7fe fc8f 	bl	800f548 <_ux_utility_memory_allocate>
 8010c2a:	4602      	mov	r2, r0
 8010c2c:	693b      	ldr	r3, [r7, #16]
 8010c2e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

    /* If it's OK, create thread.  */
    if (class_inst -> ux_slave_class_thread_stack != UX_NULL)
 8010c32:	693b      	ldr	r3, [r7, #16]
 8010c34:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8010c38:	2b00      	cmp	r3, #0
 8010c3a:	d019      	beq.n	8010c70 <_ux_device_class_storage_initialize+0x8c>

        /* This instance needs to be running in a different thread. So start
           a new thread. We pass a pointer to the class to the new thread.  This thread
           does not start until we have a instance of the class. */
        status =  _ux_device_thread_create(&class_inst -> ux_slave_class_thread, "ux_slave_storage_thread",
 8010c3c:	693b      	ldr	r3, [r7, #16]
 8010c3e:	f103 0050 	add.w	r0, r3, #80	; 0x50
 8010c42:	693a      	ldr	r2, [r7, #16]
 8010c44:	693b      	ldr	r3, [r7, #16]
 8010c46:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8010c4a:	2100      	movs	r1, #0
 8010c4c:	9105      	str	r1, [sp, #20]
 8010c4e:	2100      	movs	r1, #0
 8010c50:	9104      	str	r1, [sp, #16]
 8010c52:	2114      	movs	r1, #20
 8010c54:	9103      	str	r1, [sp, #12]
 8010c56:	2114      	movs	r1, #20
 8010c58:	9102      	str	r1, [sp, #8]
 8010c5a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8010c5e:	9101      	str	r1, [sp, #4]
 8010c60:	9300      	str	r3, [sp, #0]
 8010c62:	4613      	mov	r3, r2
 8010c64:	4a9c      	ldr	r2, [pc, #624]	; (8010ed8 <_ux_device_class_storage_initialize+0x2f4>)
 8010c66:	499d      	ldr	r1, [pc, #628]	; (8010edc <_ux_device_class_storage_initialize+0x2f8>)
 8010c68:	f7fe ffa7 	bl	800fbba <_ux_utility_thread_create>
 8010c6c:	61f8      	str	r0, [r7, #28]
 8010c6e:	e001      	b.n	8010c74 <_ux_device_class_storage_initialize+0x90>
                    _ux_device_class_storage_thread,
                    (ULONG) (ALIGN_TYPE) class_inst, (VOID *) class_inst -> ux_slave_class_thread_stack,
                    UX_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_CLASS,
                    UX_THREAD_PRIORITY_CLASS, UX_NO_TIME_SLICE, UX_DONT_START);
    else
        status = UX_MEMORY_INSUFFICIENT;
 8010c70:	2312      	movs	r3, #18
 8010c72:	61fb      	str	r3, [r7, #28]

    status = UX_SUCCESS;
#endif

    /* If thread resources allocated, go on.  */
    if (status == UX_SUCCESS)
 8010c74:	69fb      	ldr	r3, [r7, #28]
 8010c76:	2b00      	cmp	r3, #0
 8010c78:	f040 811b 	bne.w	8010eb2 <_ux_device_class_storage_initialize+0x2ce>
    {

        UX_THREAD_EXTENSION_PTR_SET(&(class_inst -> ux_slave_class_thread), class_inst)

        /* Store the number of LUN declared.  */
        storage -> ux_slave_class_storage_number_lun = storage_parameter -> ux_slave_class_storage_parameter_number_lun;
 8010c7c:	697b      	ldr	r3, [r7, #20]
 8010c7e:	689a      	ldr	r2, [r3, #8]
 8010c80:	68fb      	ldr	r3, [r7, #12]
 8010c82:	605a      	str	r2, [r3, #4]

        /* Copy each individual LUN parameters.  */
        for (lun_index = 0; lun_index < storage -> ux_slave_class_storage_number_lun; lun_index++)
 8010c84:	2300      	movs	r3, #0
 8010c86:	61bb      	str	r3, [r7, #24]
 8010c88:	e0c8      	b.n	8010e1c <_ux_device_class_storage_initialize+0x238>
        {

            /* Check block length size. */
            if (storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_block_length > UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE)
 8010c8a:	6979      	ldr	r1, [r7, #20]
 8010c8c:	69ba      	ldr	r2, [r7, #24]
 8010c8e:	4613      	mov	r3, r2
 8010c90:	00db      	lsls	r3, r3, #3
 8010c92:	1a9b      	subs	r3, r3, r2
 8010c94:	00db      	lsls	r3, r3, #3
 8010c96:	440b      	add	r3, r1
 8010c98:	3310      	adds	r3, #16
 8010c9a:	681b      	ldr	r3, [r3, #0]
 8010c9c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8010ca0:	d902      	bls.n	8010ca8 <_ux_device_class_storage_initialize+0xc4>
            {
                /* Cannot proceed.  */
                status = (UX_MEMORY_INSUFFICIENT);
 8010ca2:	2312      	movs	r3, #18
 8010ca4:	61fb      	str	r3, [r7, #28]
                break;
 8010ca6:	e0bf      	b.n	8010e28 <_ux_device_class_storage_initialize+0x244>
            }

            /* Store all the application parameter information about the media.  */
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_last_lba       = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_last_lba;
 8010ca8:	6979      	ldr	r1, [r7, #20]
 8010caa:	69ba      	ldr	r2, [r7, #24]
 8010cac:	4613      	mov	r3, r2
 8010cae:	00db      	lsls	r3, r3, #3
 8010cb0:	1a9b      	subs	r3, r3, r2
 8010cb2:	00db      	lsls	r3, r3, #3
 8010cb4:	440b      	add	r3, r1
 8010cb6:	330c      	adds	r3, #12
 8010cb8:	6819      	ldr	r1, [r3, #0]
 8010cba:	68f8      	ldr	r0, [r7, #12]
 8010cbc:	69ba      	ldr	r2, [r7, #24]
 8010cbe:	4613      	mov	r3, r2
 8010cc0:	00db      	lsls	r3, r3, #3
 8010cc2:	1a9b      	subs	r3, r3, r2
 8010cc4:	00db      	lsls	r3, r3, #3
 8010cc6:	4403      	add	r3, r0
 8010cc8:	3308      	adds	r3, #8
 8010cca:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_block_length   = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_block_length;
 8010ccc:	6979      	ldr	r1, [r7, #20]
 8010cce:	69ba      	ldr	r2, [r7, #24]
 8010cd0:	4613      	mov	r3, r2
 8010cd2:	00db      	lsls	r3, r3, #3
 8010cd4:	1a9b      	subs	r3, r3, r2
 8010cd6:	00db      	lsls	r3, r3, #3
 8010cd8:	440b      	add	r3, r1
 8010cda:	3310      	adds	r3, #16
 8010cdc:	6819      	ldr	r1, [r3, #0]
 8010cde:	68f8      	ldr	r0, [r7, #12]
 8010ce0:	69ba      	ldr	r2, [r7, #24]
 8010ce2:	4613      	mov	r3, r2
 8010ce4:	00db      	lsls	r3, r3, #3
 8010ce6:	1a9b      	subs	r3, r3, r2
 8010ce8:	00db      	lsls	r3, r3, #3
 8010cea:	4403      	add	r3, r0
 8010cec:	330c      	adds	r3, #12
 8010cee:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_type           = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_type;
 8010cf0:	6979      	ldr	r1, [r7, #20]
 8010cf2:	69ba      	ldr	r2, [r7, #24]
 8010cf4:	4613      	mov	r3, r2
 8010cf6:	00db      	lsls	r3, r3, #3
 8010cf8:	1a9b      	subs	r3, r3, r2
 8010cfa:	00db      	lsls	r3, r3, #3
 8010cfc:	440b      	add	r3, r1
 8010cfe:	3314      	adds	r3, #20
 8010d00:	6819      	ldr	r1, [r3, #0]
 8010d02:	68f8      	ldr	r0, [r7, #12]
 8010d04:	69ba      	ldr	r2, [r7, #24]
 8010d06:	4613      	mov	r3, r2
 8010d08:	00db      	lsls	r3, r3, #3
 8010d0a:	1a9b      	subs	r3, r3, r2
 8010d0c:	00db      	lsls	r3, r3, #3
 8010d0e:	4403      	add	r3, r0
 8010d10:	3310      	adds	r3, #16
 8010d12:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_removable_flag = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_removable_flag;
 8010d14:	6979      	ldr	r1, [r7, #20]
 8010d16:	69ba      	ldr	r2, [r7, #24]
 8010d18:	4613      	mov	r3, r2
 8010d1a:	00db      	lsls	r3, r3, #3
 8010d1c:	1a9b      	subs	r3, r3, r2
 8010d1e:	00db      	lsls	r3, r3, #3
 8010d20:	440b      	add	r3, r1
 8010d22:	3318      	adds	r3, #24
 8010d24:	6819      	ldr	r1, [r3, #0]
 8010d26:	68f8      	ldr	r0, [r7, #12]
 8010d28:	69ba      	ldr	r2, [r7, #24]
 8010d2a:	4613      	mov	r3, r2
 8010d2c:	00db      	lsls	r3, r3, #3
 8010d2e:	1a9b      	subs	r3, r3, r2
 8010d30:	00db      	lsls	r3, r3, #3
 8010d32:	4403      	add	r3, r0
 8010d34:	3314      	adds	r3, #20
 8010d36:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_read_only_flag = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_read_only_flag;
 8010d38:	6979      	ldr	r1, [r7, #20]
 8010d3a:	69ba      	ldr	r2, [r7, #24]
 8010d3c:	4613      	mov	r3, r2
 8010d3e:	00db      	lsls	r3, r3, #3
 8010d40:	1a9b      	subs	r3, r3, r2
 8010d42:	00db      	lsls	r3, r3, #3
 8010d44:	440b      	add	r3, r1
 8010d46:	331c      	adds	r3, #28
 8010d48:	6819      	ldr	r1, [r3, #0]
 8010d4a:	68f8      	ldr	r0, [r7, #12]
 8010d4c:	69ba      	ldr	r2, [r7, #24]
 8010d4e:	4613      	mov	r3, r2
 8010d50:	00db      	lsls	r3, r3, #3
 8010d52:	1a9b      	subs	r3, r3, r2
 8010d54:	00db      	lsls	r3, r3, #3
 8010d56:	4403      	add	r3, r0
 8010d58:	3318      	adds	r3, #24
 8010d5a:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_read           = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_read;
 8010d5c:	6979      	ldr	r1, [r7, #20]
 8010d5e:	69ba      	ldr	r2, [r7, #24]
 8010d60:	4613      	mov	r3, r2
 8010d62:	00db      	lsls	r3, r3, #3
 8010d64:	1a9b      	subs	r3, r3, r2
 8010d66:	00db      	lsls	r3, r3, #3
 8010d68:	440b      	add	r3, r1
 8010d6a:	3330      	adds	r3, #48	; 0x30
 8010d6c:	6819      	ldr	r1, [r3, #0]
 8010d6e:	68f8      	ldr	r0, [r7, #12]
 8010d70:	69ba      	ldr	r2, [r7, #24]
 8010d72:	4613      	mov	r3, r2
 8010d74:	00db      	lsls	r3, r3, #3
 8010d76:	1a9b      	subs	r3, r3, r2
 8010d78:	00db      	lsls	r3, r3, #3
 8010d7a:	4403      	add	r3, r0
 8010d7c:	332c      	adds	r3, #44	; 0x2c
 8010d7e:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_flush          = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_flush;
 8010d80:	6979      	ldr	r1, [r7, #20]
 8010d82:	69ba      	ldr	r2, [r7, #24]
 8010d84:	4613      	mov	r3, r2
 8010d86:	00db      	lsls	r3, r3, #3
 8010d88:	1a9b      	subs	r3, r3, r2
 8010d8a:	00db      	lsls	r3, r3, #3
 8010d8c:	440b      	add	r3, r1
 8010d8e:	3338      	adds	r3, #56	; 0x38
 8010d90:	6819      	ldr	r1, [r3, #0]
 8010d92:	68f8      	ldr	r0, [r7, #12]
 8010d94:	69ba      	ldr	r2, [r7, #24]
 8010d96:	4613      	mov	r3, r2
 8010d98:	00db      	lsls	r3, r3, #3
 8010d9a:	1a9b      	subs	r3, r3, r2
 8010d9c:	00db      	lsls	r3, r3, #3
 8010d9e:	4403      	add	r3, r0
 8010da0:	3334      	adds	r3, #52	; 0x34
 8010da2:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_write          = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_write;
 8010da4:	6979      	ldr	r1, [r7, #20]
 8010da6:	69ba      	ldr	r2, [r7, #24]
 8010da8:	4613      	mov	r3, r2
 8010daa:	00db      	lsls	r3, r3, #3
 8010dac:	1a9b      	subs	r3, r3, r2
 8010dae:	00db      	lsls	r3, r3, #3
 8010db0:	440b      	add	r3, r1
 8010db2:	3334      	adds	r3, #52	; 0x34
 8010db4:	6819      	ldr	r1, [r3, #0]
 8010db6:	68f8      	ldr	r0, [r7, #12]
 8010db8:	69ba      	ldr	r2, [r7, #24]
 8010dba:	4613      	mov	r3, r2
 8010dbc:	00db      	lsls	r3, r3, #3
 8010dbe:	1a9b      	subs	r3, r3, r2
 8010dc0:	00db      	lsls	r3, r3, #3
 8010dc2:	4403      	add	r3, r0
 8010dc4:	3330      	adds	r3, #48	; 0x30
 8010dc6:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_status         = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_status;
 8010dc8:	6979      	ldr	r1, [r7, #20]
 8010dca:	69bb      	ldr	r3, [r7, #24]
 8010dcc:	1c5a      	adds	r2, r3, #1
 8010dce:	4613      	mov	r3, r2
 8010dd0:	00db      	lsls	r3, r3, #3
 8010dd2:	1a9b      	subs	r3, r3, r2
 8010dd4:	00db      	lsls	r3, r3, #3
 8010dd6:	440b      	add	r3, r1
 8010dd8:	3304      	adds	r3, #4
 8010dda:	6819      	ldr	r1, [r3, #0]
 8010ddc:	68f8      	ldr	r0, [r7, #12]
 8010dde:	69bb      	ldr	r3, [r7, #24]
 8010de0:	1c5a      	adds	r2, r3, #1
 8010de2:	4613      	mov	r3, r2
 8010de4:	00db      	lsls	r3, r3, #3
 8010de6:	1a9b      	subs	r3, r3, r2
 8010de8:	00db      	lsls	r3, r3, #3
 8010dea:	4403      	add	r3, r0
 8010dec:	6019      	str	r1, [r3, #0]
            storage -> ux_slave_class_storage_lun[lun_index].ux_slave_class_storage_media_notification   = storage_parameter -> ux_slave_class_storage_parameter_lun[lun_index].ux_slave_class_storage_media_notification;
 8010dee:	6979      	ldr	r1, [r7, #20]
 8010df0:	69bb      	ldr	r3, [r7, #24]
 8010df2:	1c5a      	adds	r2, r3, #1
 8010df4:	4613      	mov	r3, r2
 8010df6:	00db      	lsls	r3, r3, #3
 8010df8:	1a9b      	subs	r3, r3, r2
 8010dfa:	00db      	lsls	r3, r3, #3
 8010dfc:	440b      	add	r3, r1
 8010dfe:	3308      	adds	r3, #8
 8010e00:	6819      	ldr	r1, [r3, #0]
 8010e02:	68f8      	ldr	r0, [r7, #12]
 8010e04:	69bb      	ldr	r3, [r7, #24]
 8010e06:	1c5a      	adds	r2, r3, #1
 8010e08:	4613      	mov	r3, r2
 8010e0a:	00db      	lsls	r3, r3, #3
 8010e0c:	1a9b      	subs	r3, r3, r2
 8010e0e:	00db      	lsls	r3, r3, #3
 8010e10:	4403      	add	r3, r0
 8010e12:	3304      	adds	r3, #4
 8010e14:	6019      	str	r1, [r3, #0]
        for (lun_index = 0; lun_index < storage -> ux_slave_class_storage_number_lun; lun_index++)
 8010e16:	69bb      	ldr	r3, [r7, #24]
 8010e18:	3301      	adds	r3, #1
 8010e1a:	61bb      	str	r3, [r7, #24]
 8010e1c:	68fb      	ldr	r3, [r7, #12]
 8010e1e:	685b      	ldr	r3, [r3, #4]
 8010e20:	69ba      	ldr	r2, [r7, #24]
 8010e22:	429a      	cmp	r2, r3
 8010e24:	f4ff af31 	bcc.w	8010c8a <_ux_device_class_storage_initialize+0xa6>
        }

        /* If it's OK, complete it.  */
        if (status == UX_SUCCESS)
 8010e28:	69fb      	ldr	r3, [r7, #28]
 8010e2a:	2b00      	cmp	r3, #0
 8010e2c:	d13c      	bne.n	8010ea8 <_ux_device_class_storage_initialize+0x2c4>
        {

            /* Store the start and stop signals if needed by the application.  */
            storage -> ux_slave_class_storage_instance_activate = storage_parameter -> ux_slave_class_storage_instance_activate;
 8010e2e:	697b      	ldr	r3, [r7, #20]
 8010e30:	681a      	ldr	r2, [r3, #0]
 8010e32:	68fb      	ldr	r3, [r7, #12]
 8010e34:	655a      	str	r2, [r3, #84]	; 0x54
            storage -> ux_slave_class_storage_instance_deactivate = storage_parameter -> ux_slave_class_storage_instance_deactivate;
 8010e36:	697b      	ldr	r3, [r7, #20]
 8010e38:	685a      	ldr	r2, [r3, #4]
 8010e3a:	68fb      	ldr	r3, [r7, #12]
 8010e3c:	659a      	str	r2, [r3, #88]	; 0x58

            /* Store the vendor id, product id, product revision and product serial.  */
            if (storage_parameter -> ux_slave_class_storage_parameter_vendor_id)
 8010e3e:	697b      	ldr	r3, [r7, #20]
 8010e40:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8010e42:	2b00      	cmp	r3, #0
 8010e44:	d004      	beq.n	8010e50 <_ux_device_class_storage_initialize+0x26c>
                storage -> ux_slave_class_storage_vendor_id = storage_parameter -> ux_slave_class_storage_parameter_vendor_id;
 8010e46:	697b      	ldr	r3, [r7, #20]
 8010e48:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8010e4a:	68fb      	ldr	r3, [r7, #12]
 8010e4c:	65da      	str	r2, [r3, #92]	; 0x5c
 8010e4e:	e002      	b.n	8010e56 <_ux_device_class_storage_initialize+0x272>
            else
                storage -> ux_slave_class_storage_vendor_id = _ux_system_slave_class_storage_vendor_id;
 8010e50:	68fb      	ldr	r3, [r7, #12]
 8010e52:	4a23      	ldr	r2, [pc, #140]	; (8010ee0 <_ux_device_class_storage_initialize+0x2fc>)
 8010e54:	65da      	str	r2, [r3, #92]	; 0x5c

            if (storage_parameter -> ux_slave_class_storage_parameter_product_id)
 8010e56:	697b      	ldr	r3, [r7, #20]
 8010e58:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8010e5a:	2b00      	cmp	r3, #0
 8010e5c:	d004      	beq.n	8010e68 <_ux_device_class_storage_initialize+0x284>
                storage -> ux_slave_class_storage_product_id = storage_parameter -> ux_slave_class_storage_parameter_product_id;
 8010e5e:	697b      	ldr	r3, [r7, #20]
 8010e60:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8010e62:	68fb      	ldr	r3, [r7, #12]
 8010e64:	661a      	str	r2, [r3, #96]	; 0x60
 8010e66:	e002      	b.n	8010e6e <_ux_device_class_storage_initialize+0x28a>
            else
                storage -> ux_slave_class_storage_product_id = _ux_system_slave_class_storage_product_id;
 8010e68:	68fb      	ldr	r3, [r7, #12]
 8010e6a:	4a1e      	ldr	r2, [pc, #120]	; (8010ee4 <_ux_device_class_storage_initialize+0x300>)
 8010e6c:	661a      	str	r2, [r3, #96]	; 0x60

            if (storage_parameter -> ux_slave_class_storage_parameter_product_rev)
 8010e6e:	697b      	ldr	r3, [r7, #20]
 8010e70:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8010e72:	2b00      	cmp	r3, #0
 8010e74:	d004      	beq.n	8010e80 <_ux_device_class_storage_initialize+0x29c>
                storage -> ux_slave_class_storage_product_rev = storage_parameter -> ux_slave_class_storage_parameter_product_rev;
 8010e76:	697b      	ldr	r3, [r7, #20]
 8010e78:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8010e7a:	68fb      	ldr	r3, [r7, #12]
 8010e7c:	665a      	str	r2, [r3, #100]	; 0x64
 8010e7e:	e002      	b.n	8010e86 <_ux_device_class_storage_initialize+0x2a2>
            else
                storage -> ux_slave_class_storage_product_rev = _ux_system_slave_class_storage_product_rev;
 8010e80:	68fb      	ldr	r3, [r7, #12]
 8010e82:	4a19      	ldr	r2, [pc, #100]	; (8010ee8 <_ux_device_class_storage_initialize+0x304>)
 8010e84:	665a      	str	r2, [r3, #100]	; 0x64

            if (storage_parameter -> ux_slave_class_storage_parameter_product_serial)
 8010e86:	697b      	ldr	r3, [r7, #20]
 8010e88:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8010e8a:	2b00      	cmp	r3, #0
 8010e8c:	d004      	beq.n	8010e98 <_ux_device_class_storage_initialize+0x2b4>
                storage -> ux_slave_class_storage_product_serial = storage_parameter -> ux_slave_class_storage_parameter_product_serial;
 8010e8e:	697b      	ldr	r3, [r7, #20]
 8010e90:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8010e92:	68fb      	ldr	r3, [r7, #12]
 8010e94:	669a      	str	r2, [r3, #104]	; 0x68
 8010e96:	e002      	b.n	8010e9e <_ux_device_class_storage_initialize+0x2ba>
            else
                storage -> ux_slave_class_storage_product_serial = _ux_system_slave_class_storage_product_serial;
 8010e98:	68fb      	ldr	r3, [r7, #12]
 8010e9a:	4a14      	ldr	r2, [pc, #80]	; (8010eec <_ux_device_class_storage_initialize+0x308>)
 8010e9c:	669a      	str	r2, [r3, #104]	; 0x68

            /* Save the address of the STORAGE instance inside the STORAGE container.  */
            class_inst -> ux_slave_class_instance = (VOID *) storage;
 8010e9e:	693b      	ldr	r3, [r7, #16]
 8010ea0:	68fa      	ldr	r2, [r7, #12]
 8010ea2:	649a      	str	r2, [r3, #72]	; 0x48

            return(UX_SUCCESS);
 8010ea4:	2300      	movs	r3, #0
 8010ea6:	e013      	b.n	8010ed0 <_ux_device_class_storage_initialize+0x2ec>
        }

        /* Free thread resources.  */
        _ux_device_thread_delete(&class_inst -> ux_slave_class_thread);
 8010ea8:	693b      	ldr	r3, [r7, #16]
 8010eaa:	3350      	adds	r3, #80	; 0x50
 8010eac:	4618      	mov	r0, r3
 8010eae:	f7fe feab 	bl	800fc08 <_ux_utility_thread_delete>
    }

#if !defined(UX_DEVICE_STANDALONE)
    if (class_inst -> ux_slave_class_thread_stack != UX_NULL)
 8010eb2:	693b      	ldr	r3, [r7, #16]
 8010eb4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8010eb8:	2b00      	cmp	r3, #0
 8010eba:	d005      	beq.n	8010ec8 <_ux_device_class_storage_initialize+0x2e4>
        _ux_utility_memory_free(&class_inst -> ux_slave_class_thread_stack);
 8010ebc:	693b      	ldr	r3, [r7, #16]
 8010ebe:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8010ec2:	4618      	mov	r0, r3
 8010ec4:	f7fe fc88 	bl	800f7d8 <_ux_utility_memory_free>
#endif

    /* Free instance.  */
    _ux_utility_memory_free(storage);
 8010ec8:	68f8      	ldr	r0, [r7, #12]
 8010eca:	f7fe fc85 	bl	800f7d8 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(status);
 8010ece:	69fb      	ldr	r3, [r7, #28]
}
 8010ed0:	4618      	mov	r0, r3
 8010ed2:	3720      	adds	r7, #32
 8010ed4:	46bd      	mov	sp, r7
 8010ed6:	bd80      	pop	{r7, pc}
 8010ed8:	080118c5 	.word	0x080118c5
 8010edc:	08013478 	.word	0x08013478
 8010ee0:	200000c0 	.word	0x200000c0
 8010ee4:	200000cc 	.word	0x200000cc
 8010ee8:	200000e0 	.word	0x200000e0
 8010eec:	200000e8 	.word	0x200000e8

08010ef0 <_ux_device_class_storage_inquiry>:
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_inquiry(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
 8010ef0:	b580      	push	{r7, lr}
 8010ef2:	b08a      	sub	sp, #40	; 0x28
 8010ef4:	af00      	add	r7, sp, #0
 8010ef6:	60f8      	str	r0, [r7, #12]
 8010ef8:	60b9      	str	r1, [r7, #8]
 8010efa:	607a      	str	r2, [r7, #4]
 8010efc:	603b      	str	r3, [r7, #0]

UINT                    status = UX_SUCCESS;
 8010efe:	2300      	movs	r3, #0
 8010f00:	627b      	str	r3, [r7, #36]	; 0x24
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_INQUIRY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

#if !defined(UX_DEVICE_STANDALONE)

    /* Check direction.  */
    if (storage -> ux_slave_class_storage_host_length &&
 8010f02:	68fb      	ldr	r3, [r7, #12]
 8010f04:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010f06:	2b00      	cmp	r3, #0
 8010f08:	d00d      	beq.n	8010f26 <_ux_device_class_storage_inquiry+0x36>
        (storage -> ux_slave_class_storage_cbw_flags & 0x80) == 0)
 8010f0a:	68fb      	ldr	r3, [r7, #12]
 8010f0c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8010f10:	b25b      	sxtb	r3, r3
    if (storage -> ux_slave_class_storage_host_length &&
 8010f12:	2b00      	cmp	r3, #0
 8010f14:	db07      	blt.n	8010f26 <_ux_device_class_storage_inquiry+0x36>
    {
        _ux_device_stack_endpoint_stall(endpoint_out);
 8010f16:	6838      	ldr	r0, [r7, #0]
 8010f18:	f7fd fe7c 	bl	800ec14 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
 8010f1c:	68fb      	ldr	r3, [r7, #12]
 8010f1e:	2202      	movs	r2, #2
 8010f20:	651a      	str	r2, [r3, #80]	; 0x50
        return(UX_ERROR);
 8010f22:	23ff      	movs	r3, #255	; 0xff
 8010f24:	e0c7      	b.n	80110b6 <_ux_device_class_storage_inquiry+0x1c6>
    }
#endif

    /* From the SCSI Inquiry payload, get the page code.  */
    inquiry_page_code =  *(cbwcb + UX_SLAVE_CLASS_STORAGE_INQUIRY_PAGE_CODE);
 8010f26:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010f28:	789b      	ldrb	r3, [r3, #2]
 8010f2a:	77fb      	strb	r3, [r7, #31]
    
    /* And the length to be returned. */
    inquiry_length =  storage -> ux_slave_class_storage_host_length;
 8010f2c:	68fb      	ldr	r3, [r7, #12]
 8010f2e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010f30:	623b      	str	r3, [r7, #32]

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
 8010f32:	687b      	ldr	r3, [r7, #4]
 8010f34:	3330      	adds	r3, #48	; 0x30
 8010f36:	61bb      	str	r3, [r7, #24]

    /* Obtain inquiry buffer pointer.  */
    inquiry_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
 8010f38:	69bb      	ldr	r3, [r7, #24]
 8010f3a:	68db      	ldr	r3, [r3, #12]
 8010f3c:	617b      	str	r3, [r7, #20]

    /* Ensure the data buffer is cleaned.  */
    _ux_utility_memory_set(inquiry_buffer, 0, UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH); /* Use case of memset is verified. */
 8010f3e:	2224      	movs	r2, #36	; 0x24
 8010f40:	2100      	movs	r1, #0
 8010f42:	6978      	ldr	r0, [r7, #20]
 8010f44:	f7fe fd26 	bl	800f994 <_ux_utility_memory_set>

    /* Check for the maximum length to be returned. */
    if (inquiry_length > UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH)
 8010f48:	6a3b      	ldr	r3, [r7, #32]
 8010f4a:	2b24      	cmp	r3, #36	; 0x24
 8010f4c:	d901      	bls.n	8010f52 <_ux_device_class_storage_inquiry+0x62>
        inquiry_length = UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH;
 8010f4e:	2324      	movs	r3, #36	; 0x24
 8010f50:	623b      	str	r3, [r7, #32]

    /* Default CSW to passed.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 8010f52:	68fb      	ldr	r3, [r7, #12]
 8010f54:	2200      	movs	r2, #0
 8010f56:	651a      	str	r2, [r3, #80]	; 0x50

    /* Ensure we know about the page code.  */
    switch (inquiry_page_code)
 8010f58:	7ffb      	ldrb	r3, [r7, #31]
 8010f5a:	2b00      	cmp	r3, #0
 8010f5c:	d002      	beq.n	8010f64 <_ux_device_class_storage_inquiry+0x74>
 8010f5e:	2b80      	cmp	r3, #128	; 0x80
 8010f60:	d05d      	beq.n	801101e <_ux_device_class_storage_inquiry+0x12e>
 8010f62:	e078      	b.n	8011056 <_ux_device_class_storage_inquiry+0x166>
    {

    case UX_SLAVE_CLASS_STORAGE_INQUIRY_PAGE_CODE_STANDARD:
            
        /* Store the product type.  */
        inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_PERIPHERAL_TYPE] =  (UCHAR)storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_type;
 8010f64:	68f9      	ldr	r1, [r7, #12]
 8010f66:	68ba      	ldr	r2, [r7, #8]
 8010f68:	4613      	mov	r3, r2
 8010f6a:	00db      	lsls	r3, r3, #3
 8010f6c:	1a9b      	subs	r3, r3, r2
 8010f6e:	00db      	lsls	r3, r3, #3
 8010f70:	440b      	add	r3, r1
 8010f72:	3310      	adds	r3, #16
 8010f74:	681b      	ldr	r3, [r3, #0]
 8010f76:	b2da      	uxtb	r2, r3
 8010f78:	697b      	ldr	r3, [r7, #20]
 8010f7a:	701a      	strb	r2, [r3, #0]

        /* Store the Media Removable bit.  */
        inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_REMOVABLE_MEDIA] =  (UCHAR)storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_removable_flag;
 8010f7c:	68f9      	ldr	r1, [r7, #12]
 8010f7e:	68ba      	ldr	r2, [r7, #8]
 8010f80:	4613      	mov	r3, r2
 8010f82:	00db      	lsls	r3, r3, #3
 8010f84:	1a9b      	subs	r3, r3, r2
 8010f86:	00db      	lsls	r3, r3, #3
 8010f88:	440b      	add	r3, r1
 8010f8a:	3314      	adds	r3, #20
 8010f8c:	681a      	ldr	r2, [r3, #0]
 8010f8e:	697b      	ldr	r3, [r7, #20]
 8010f90:	3301      	adds	r3, #1
 8010f92:	b2d2      	uxtb	r2, r2
 8010f94:	701a      	strb	r2, [r3, #0]

        /* Store the Data Format bit.  */
        if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_type == UX_SLAVE_CLASS_STORAGE_MEDIA_CDROM)
 8010f96:	68f9      	ldr	r1, [r7, #12]
 8010f98:	68ba      	ldr	r2, [r7, #8]
 8010f9a:	4613      	mov	r3, r2
 8010f9c:	00db      	lsls	r3, r3, #3
 8010f9e:	1a9b      	subs	r3, r3, r2
 8010fa0:	00db      	lsls	r3, r3, #3
 8010fa2:	440b      	add	r3, r1
 8010fa4:	3310      	adds	r3, #16
 8010fa6:	681b      	ldr	r3, [r3, #0]
 8010fa8:	2b05      	cmp	r3, #5
 8010faa:	d104      	bne.n	8010fb6 <_ux_device_class_storage_inquiry+0xc6>
            inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_DATA_FORMAT] =  0x32;
 8010fac:	697b      	ldr	r3, [r7, #20]
 8010fae:	3303      	adds	r3, #3
 8010fb0:	2232      	movs	r2, #50	; 0x32
 8010fb2:	701a      	strb	r2, [r3, #0]
 8010fb4:	e003      	b.n	8010fbe <_ux_device_class_storage_inquiry+0xce>
        else
            inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_DATA_FORMAT] =  0x00;
 8010fb6:	697b      	ldr	r3, [r7, #20]
 8010fb8:	3303      	adds	r3, #3
 8010fba:	2200      	movs	r2, #0
 8010fbc:	701a      	strb	r2, [r3, #0]

        /* Store the length of the response.  There is a hack here. For CD-ROM, the data lg is fixed to 0x5B !  */
        if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_type != UX_SLAVE_CLASS_STORAGE_MEDIA_CDROM)
 8010fbe:	68f9      	ldr	r1, [r7, #12]
 8010fc0:	68ba      	ldr	r2, [r7, #8]
 8010fc2:	4613      	mov	r3, r2
 8010fc4:	00db      	lsls	r3, r3, #3
 8010fc6:	1a9b      	subs	r3, r3, r2
 8010fc8:	00db      	lsls	r3, r3, #3
 8010fca:	440b      	add	r3, r1
 8010fcc:	3310      	adds	r3, #16
 8010fce:	681b      	ldr	r3, [r3, #0]
 8010fd0:	2b05      	cmp	r3, #5
 8010fd2:	d004      	beq.n	8010fde <_ux_device_class_storage_inquiry+0xee>
            inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_ADDITIONAL_LENGTH] =  UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH;
 8010fd4:	697b      	ldr	r3, [r7, #20]
 8010fd6:	3304      	adds	r3, #4
 8010fd8:	2224      	movs	r2, #36	; 0x24
 8010fda:	701a      	strb	r2, [r3, #0]
 8010fdc:	e003      	b.n	8010fe6 <_ux_device_class_storage_inquiry+0xf6>
        else            
            inquiry_buffer[UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_ADDITIONAL_LENGTH] =  UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH_CD_ROM;
 8010fde:	697b      	ldr	r3, [r7, #20]
 8010fe0:	3304      	adds	r3, #4
 8010fe2:	225b      	movs	r2, #91	; 0x5b
 8010fe4:	701a      	strb	r2, [r3, #0]

        /* Fill in the storage vendor ID.  */
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_VENDOR_INFORMATION,
 8010fe6:	697b      	ldr	r3, [r7, #20]
 8010fe8:	f103 0008 	add.w	r0, r3, #8
                                                                    storage -> ux_slave_class_storage_vendor_id, 8); /* Use case of memcpy is verified. */
 8010fec:	68fb      	ldr	r3, [r7, #12]
 8010fee:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_VENDOR_INFORMATION,
 8010ff0:	2208      	movs	r2, #8
 8010ff2:	4619      	mov	r1, r3
 8010ff4:	f7fe fbd1 	bl	800f79a <_ux_utility_memory_copy>

        /* Fill in the product vendor ID.  */
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_PRODUCT_ID,
 8010ff8:	697b      	ldr	r3, [r7, #20]
 8010ffa:	f103 0010 	add.w	r0, r3, #16
                                                                    storage -> ux_slave_class_storage_product_id, 16); /* Use case of memcpy is verified. */
 8010ffe:	68fb      	ldr	r3, [r7, #12]
 8011000:	6e1b      	ldr	r3, [r3, #96]	; 0x60
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_PRODUCT_ID,
 8011002:	2210      	movs	r2, #16
 8011004:	4619      	mov	r1, r3
 8011006:	f7fe fbc8 	bl	800f79a <_ux_utility_memory_copy>

        /* Fill in the product revision number.  */
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_PRODUCT_REVISION,
 801100a:	697b      	ldr	r3, [r7, #20]
 801100c:	f103 0020 	add.w	r0, r3, #32
                                                                    storage -> ux_slave_class_storage_product_rev, 4); /* Use case of memcpy is verified. */
 8011010:	68fb      	ldr	r3, [r7, #12]
 8011012:	6e5b      	ldr	r3, [r3, #100]	; 0x64
        _ux_utility_memory_copy(inquiry_buffer + UX_SLAVE_CLASS_STORAGE_INQUIRY_RESPONSE_PRODUCT_REVISION,
 8011014:	2204      	movs	r2, #4
 8011016:	4619      	mov	r1, r3
 8011018:	f7fe fbbf 	bl	800f79a <_ux_utility_memory_copy>

        break;
 801101c:	e02f      	b.n	801107e <_ux_device_class_storage_inquiry+0x18e>

    case UX_SLAVE_CLASS_STORAGE_INQUIRY_PAGE_CODE_SERIAL:

        /* Initialize the page code in response buffer.  */
        _ux_utility_short_put_big_endian(transfer_request -> ux_slave_transfer_request_data_pointer, UX_SLAVE_CLASS_STORAGE_INQUIRY_PAGE_CODE_SERIAL);
 801101e:	69bb      	ldr	r3, [r7, #24]
 8011020:	68db      	ldr	r3, [r3, #12]
 8011022:	2180      	movs	r1, #128	; 0x80
 8011024:	4618      	mov	r0, r3
 8011026:	f7fe fd79 	bl	800fb1c <_ux_utility_short_put_big_endian>

        /* Initialize the length of the serial number in response buffer.  */
        _ux_utility_short_put_big_endian(transfer_request -> ux_slave_transfer_request_data_pointer + 2, 20);
 801102a:	69bb      	ldr	r3, [r7, #24]
 801102c:	68db      	ldr	r3, [r3, #12]
 801102e:	3302      	adds	r3, #2
 8011030:	2114      	movs	r1, #20
 8011032:	4618      	mov	r0, r3
 8011034:	f7fe fd72 	bl	800fb1c <_ux_utility_short_put_big_endian>

        /* Copy the serial number buffer into the transfer request memory.  */
        _ux_utility_memory_copy(transfer_request -> ux_slave_transfer_request_data_pointer + 4, storage -> ux_slave_class_storage_product_serial, 20); /* Use case of memcpy is verified. */
 8011038:	69bb      	ldr	r3, [r7, #24]
 801103a:	68db      	ldr	r3, [r3, #12]
 801103c:	1d18      	adds	r0, r3, #4
 801103e:	68fb      	ldr	r3, [r7, #12]
 8011040:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8011042:	2214      	movs	r2, #20
 8011044:	4619      	mov	r1, r3
 8011046:	f7fe fba8 	bl	800f79a <_ux_utility_memory_copy>

        /* Send a data payload with the inquiry response buffer.  */
        if (inquiry_length > 24)
 801104a:	6a3b      	ldr	r3, [r7, #32]
 801104c:	2b18      	cmp	r3, #24
 801104e:	d915      	bls.n	801107c <_ux_device_class_storage_inquiry+0x18c>
            inquiry_length = 24;
 8011050:	2318      	movs	r3, #24
 8011052:	623b      	str	r3, [r7, #32]
    
        break;
 8011054:	e012      	b.n	801107c <_ux_device_class_storage_inquiry+0x18c>

    default:

#if !defined(UX_DEVICE_STANDALONE)
        /* The page code is not supported.  */
        _ux_device_stack_endpoint_stall(endpoint_in);
 8011056:	6878      	ldr	r0, [r7, #4]
 8011058:	f7fd fddc 	bl	800ec14 <_ux_device_stack_endpoint_stall>
#endif

        /* And update the REQUEST_SENSE codes.  */
        storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
 801105c:	68f9      	ldr	r1, [r7, #12]
 801105e:	68ba      	ldr	r2, [r7, #8]
 8011060:	4613      	mov	r3, r2
 8011062:	00db      	lsls	r3, r3, #3
 8011064:	1a9b      	subs	r3, r3, r2
 8011066:	00db      	lsls	r3, r3, #3
 8011068:	440b      	add	r3, r1
 801106a:	3320      	adds	r3, #32
 801106c:	4a14      	ldr	r2, [pc, #80]	; (80110c0 <_ux_device_class_storage_inquiry+0x1d0>)
 801106e:	601a      	str	r2, [r3, #0]
                                               UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x05,0x26,0x01);

        /* Now we set the CSW with failure.  */
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
 8011070:	68fb      	ldr	r3, [r7, #12]
 8011072:	2201      	movs	r2, #1
 8011074:	651a      	str	r2, [r3, #80]	; 0x50

        /* Return error.  */
        status =  UX_ERROR;
 8011076:	23ff      	movs	r3, #255	; 0xff
 8011078:	627b      	str	r3, [r7, #36]	; 0x24

        break;            
 801107a:	e000      	b.n	801107e <_ux_device_class_storage_inquiry+0x18e>
        break;
 801107c:	bf00      	nop
    }    

    /* Error cases.  */
    if (status != UX_SUCCESS)
 801107e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011080:	2b00      	cmp	r3, #0
 8011082:	d001      	beq.n	8011088 <_ux_device_class_storage_inquiry+0x198>
        return(status);
 8011084:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011086:	e016      	b.n	80110b6 <_ux_device_class_storage_inquiry+0x1c6>
    storage -> ux_device_class_storage_data_count = 0;

#else

    /* Send a data payload with the inquiry response buffer.  */
    if (inquiry_length)
 8011088:	6a3b      	ldr	r3, [r7, #32]
 801108a:	2b00      	cmp	r3, #0
 801108c:	d004      	beq.n	8011098 <_ux_device_class_storage_inquiry+0x1a8>
        _ux_device_stack_transfer_request(transfer_request, inquiry_length, inquiry_length);
 801108e:	6a3a      	ldr	r2, [r7, #32]
 8011090:	6a39      	ldr	r1, [r7, #32]
 8011092:	69b8      	ldr	r0, [r7, #24]
 8011094:	f7fd fff0 	bl	800f078 <_ux_device_stack_transfer_request>

    /* Check length.  */
    if (storage -> ux_slave_class_storage_host_length != inquiry_length)
 8011098:	68fb      	ldr	r3, [r7, #12]
 801109a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801109c:	6a3a      	ldr	r2, [r7, #32]
 801109e:	429a      	cmp	r2, r3
 80110a0:	d008      	beq.n	80110b4 <_ux_device_class_storage_inquiry+0x1c4>
    {
        storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - inquiry_length;
 80110a2:	68fb      	ldr	r3, [r7, #12]
 80110a4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80110a6:	6a3b      	ldr	r3, [r7, #32]
 80110a8:	1ad2      	subs	r2, r2, r3
 80110aa:	68fb      	ldr	r3, [r7, #12]
 80110ac:	64da      	str	r2, [r3, #76]	; 0x4c
        _ux_device_stack_endpoint_stall(endpoint_in);
 80110ae:	6878      	ldr	r0, [r7, #4]
 80110b0:	f7fd fdb0 	bl	800ec14 <_ux_device_stack_endpoint_stall>
    }
#endif

    /* Return completion status.  */
    return(status);
 80110b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 80110b6:	4618      	mov	r0, r3
 80110b8:	3728      	adds	r7, #40	; 0x28
 80110ba:	46bd      	mov	sp, r7
 80110bc:	bd80      	pop	{r7, pc}
 80110be:	bf00      	nop
 80110c0:	00012605 	.word	0x00012605

080110c4 <_ux_device_class_storage_mode_select>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_mode_select(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
 80110c4:	b580      	push	{r7, lr}
 80110c6:	b084      	sub	sp, #16
 80110c8:	af00      	add	r7, sp, #0
 80110ca:	60f8      	str	r0, [r7, #12]
 80110cc:	60b9      	str	r1, [r7, #8]
 80110ce:	607a      	str	r2, [r7, #4]
 80110d0:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_MODE_SELECT, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* This command is not yet supported. So Stall the endpoint.  */
    if (storage -> ux_slave_class_storage_host_length)
 80110d2:	68fb      	ldr	r3, [r7, #12]
 80110d4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80110d6:	2b00      	cmp	r3, #0
 80110d8:	d006      	beq.n	80110e8 <_ux_device_class_storage_mode_select+0x24>
    {

#if !defined(UX_DEVICE_STANDALONE)
        _ux_device_stack_endpoint_stall(endpoint_out);
 80110da:	6838      	ldr	r0, [r7, #0]
 80110dc:	f7fd fd9a 	bl	800ec14 <_ux_device_stack_endpoint_stall>
#else
        UX_PARAMETER_NOT_USED(endpoint_out);
#endif

        storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length;
 80110e0:	68fb      	ldr	r3, [r7, #12]
 80110e2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80110e4:	68fb      	ldr	r3, [r7, #12]
 80110e6:	64da      	str	r2, [r3, #76]	; 0x4c
    }

    /* And update the REQUEST_SENSE codes.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
 80110e8:	68f9      	ldr	r1, [r7, #12]
 80110ea:	68ba      	ldr	r2, [r7, #8]
 80110ec:	4613      	mov	r3, r2
 80110ee:	00db      	lsls	r3, r3, #3
 80110f0:	1a9b      	subs	r3, r3, r2
 80110f2:	00db      	lsls	r3, r3, #3
 80110f4:	440b      	add	r3, r1
 80110f6:	3320      	adds	r3, #32
 80110f8:	4a07      	ldr	r2, [pc, #28]	; (8011118 <_ux_device_class_storage_mode_select+0x54>)
 80110fa:	601a      	str	r2, [r3, #0]
                                            UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x05,0x26,0x01);

    /* Now we set the CSW with failure.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
 80110fc:	68fb      	ldr	r3, [r7, #12]
 80110fe:	2201      	movs	r2, #1
 8011100:	651a      	str	r2, [r3, #80]	; 0x50

    /* Error trap. */
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_FUNCTION_NOT_SUPPORTED);
 8011102:	2254      	movs	r2, #84	; 0x54
 8011104:	2107      	movs	r1, #7
 8011106:	2002      	movs	r0, #2
 8011108:	f7fe f840 	bl	800f18c <_ux_system_error_handler>

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* Return not supported error!  */
    return(UX_FUNCTION_NOT_SUPPORTED);
 801110c:	2354      	movs	r3, #84	; 0x54
}    
 801110e:	4618      	mov	r0, r3
 8011110:	3710      	adds	r7, #16
 8011112:	46bd      	mov	sp, r7
 8011114:	bd80      	pop	{r7, pc}
 8011116:	bf00      	nop
 8011118:	00012605 	.word	0x00012605

0801111c <_ux_device_class_storage_mode_sense>:
UINT  _ux_device_class_storage_mode_sense(UX_SLAVE_CLASS_STORAGE *storage, 
                      ULONG               lun, 
                      UX_SLAVE_ENDPOINT   *endpoint_in,
                      UX_SLAVE_ENDPOINT   *endpoint_out, 
                      UCHAR               *cbwcb)
{
 801111c:	b580      	push	{r7, lr}
 801111e:	b090      	sub	sp, #64	; 0x40
 8011120:	af00      	add	r7, sp, #0
 8011122:	60f8      	str	r0, [r7, #12]
 8011124:	60b9      	str	r1, [r7, #8]
 8011126:	607a      	str	r2, [r7, #4]
 8011128:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_MODE_SENSE, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
 801112a:	687b      	ldr	r3, [r7, #4]
 801112c:	3330      	adds	r3, #48	; 0x30
 801112e:	627b      	str	r3, [r7, #36]	; 0x24

    /* Get the command format : we have 1a and 5a.  */
    mode_sense_command =  (ULONG) *(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_OPERATION);
 8011130:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011132:	781b      	ldrb	r3, [r3, #0]
 8011134:	623b      	str	r3, [r7, #32]
    
    /* Extract the notification from the cbwcb.  */
    page_code =  (ULONG) *(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PC_PAGE_CODE);
 8011136:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011138:	3302      	adds	r3, #2
 801113a:	781b      	ldrb	r3, [r3, #0]
 801113c:	61fb      	str	r3, [r7, #28]

    /* Check the command.  */
    if (mode_sense_command == UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SENSE_SHORT)
 801113e:	6a3b      	ldr	r3, [r7, #32]
 8011140:	2b1a      	cmp	r3, #26
 8011142:	d108      	bne.n	8011156 <_ux_device_class_storage_mode_sense+0x3a>
    {

        /* Extract the length to be returned by the cbwcb.  */
        mode_sense_reply_length =  (ULONG) *(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_ALLOCATION_LENGTH_6);
 8011144:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011146:	3304      	adds	r3, #4
 8011148:	781b      	ldrb	r3, [r3, #0]
 801114a:	63fb      	str	r3, [r7, #60]	; 0x3c
        flags_index = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_FLAGS_6;
 801114c:	2302      	movs	r3, #2
 801114e:	633b      	str	r3, [r7, #48]	; 0x30
        response_header_length = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_HEADER_LENGTH_6;
 8011150:	2304      	movs	r3, #4
 8011152:	637b      	str	r3, [r7, #52]	; 0x34
 8011154:	e009      	b.n	801116a <_ux_device_class_storage_mode_sense+0x4e>

    else
    {

        /* Extract the length to be returned by the cbwcb.  */
        mode_sense_reply_length =  _ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_MODE_SENSE_ALLOCATION_LENGTH_10);
 8011156:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011158:	3307      	adds	r3, #7
 801115a:	4618      	mov	r0, r3
 801115c:	f7fe fcc6 	bl	800faec <_ux_utility_short_get_big_endian>
 8011160:	63f8      	str	r0, [r7, #60]	; 0x3c
        flags_index = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_FLAGS_10;
 8011162:	2303      	movs	r3, #3
 8011164:	633b      	str	r3, [r7, #48]	; 0x30
        response_header_length = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_HEADER_LENGTH_10;
 8011166:	2308      	movs	r3, #8
 8011168:	637b      	str	r3, [r7, #52]	; 0x34
    }

    /* Ensure reply not exceed storage buffer.  */
    if (mode_sense_reply_length > UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE)
 801116a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801116c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8011170:	d902      	bls.n	8011178 <_ux_device_class_storage_mode_sense+0x5c>
        mode_sense_reply_length = UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE;
 8011172:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8011176:	63fb      	str	r3, [r7, #60]	; 0x3c

    /* Ensure memory buffer cleaned.  */
    _ux_utility_memory_set(transfer_request -> ux_slave_transfer_request_data_pointer, 0, mode_sense_reply_length); /* Use case of memset is verified. */
 8011178:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801117a:	68db      	ldr	r3, [r3, #12]
 801117c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801117e:	2100      	movs	r1, #0
 8011180:	4618      	mov	r0, r3
 8011182:	f7fe fc07 	bl	800f994 <_ux_utility_memory_set>

    /* Establish READ ONLY flag.  */
    if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_read_only_flag == UX_TRUE)
 8011186:	68f9      	ldr	r1, [r7, #12]
 8011188:	68ba      	ldr	r2, [r7, #8]
 801118a:	4613      	mov	r3, r2
 801118c:	00db      	lsls	r3, r3, #3
 801118e:	1a9b      	subs	r3, r3, r2
 8011190:	00db      	lsls	r3, r3, #3
 8011192:	440b      	add	r3, r1
 8011194:	3318      	adds	r3, #24
 8011196:	681b      	ldr	r3, [r3, #0]
 8011198:	2b01      	cmp	r3, #1
 801119a:	d103      	bne.n	80111a4 <_ux_device_class_storage_mode_sense+0x88>
    
        /* This device is Read Only.  */
        read_only_flag = UX_SLAVE_CLASS_STORAGE_MODE_SENSE_PARAMETER_FLAG_WP;
 801119c:	2380      	movs	r3, #128	; 0x80
 801119e:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
 80111a2:	e002      	b.n	80111aa <_ux_device_class_storage_mode_sense+0x8e>
    
    else
    
        /* This device can be written to.  */
        read_only_flag = 0;        
 80111a4:	2300      	movs	r3, #0
 80111a6:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b

    /* Build response based on expected page codes.  */

    /* Initialize length and page pointer.  */
    mode_data_length = response_header_length;
 80111aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80111ac:	62fb      	str	r3, [r7, #44]	; 0x2c
    page_pointer = transfer_request -> ux_slave_transfer_request_data_pointer + response_header_length;
 80111ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80111b0:	68da      	ldr	r2, [r3, #12]
 80111b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80111b4:	4413      	add	r3, r2
 80111b6:	62bb      	str	r3, [r7, #40]	; 0x28
        page_pointer += page_length;
    }
#endif

    /* Caching mode page is returned if cache flush callback implemented.  */
    if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_flush != UX_NULL &&
 80111b8:	68f9      	ldr	r1, [r7, #12]
 80111ba:	68ba      	ldr	r2, [r7, #8]
 80111bc:	4613      	mov	r3, r2
 80111be:	00db      	lsls	r3, r3, #3
 80111c0:	1a9b      	subs	r3, r3, r2
 80111c2:	00db      	lsls	r3, r3, #3
 80111c4:	440b      	add	r3, r1
 80111c6:	3334      	adds	r3, #52	; 0x34
 80111c8:	681b      	ldr	r3, [r3, #0]
 80111ca:	2b00      	cmp	r3, #0
 80111cc:	d01f      	beq.n	801120e <_ux_device_class_storage_mode_sense+0xf2>
 80111ce:	69fb      	ldr	r3, [r7, #28]
 80111d0:	2b08      	cmp	r3, #8
 80111d2:	d002      	beq.n	80111da <_ux_device_class_storage_mode_sense+0xbe>
        (page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_CACHE ||
 80111d4:	69fb      	ldr	r3, [r7, #28]
 80111d6:	2b3f      	cmp	r3, #63	; 0x3f
 80111d8:	d119      	bne.n	801120e <_ux_device_class_storage_mode_sense+0xf2>
        page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_ALL))
    {
        page_length = USBX_DEVICE_CLASS_STORAGE_MODE_SENSE_PAGE_CACHE_LENGTH;
 80111da:	2314      	movs	r3, #20
 80111dc:	61bb      	str	r3, [r7, #24]

        /* Store page code.  */
        *(page_pointer) = UX_SLAVE_CLASS_STORAGE_PAGE_CODE_CACHE;
 80111de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80111e0:	2208      	movs	r2, #8
 80111e2:	701a      	strb	r2, [r3, #0]

        /* Store the length of the page data.  */
        *(page_pointer + UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_LENGTH) =
 80111e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80111e6:	3301      	adds	r3, #1
 80111e8:	2212      	movs	r2, #18
 80111ea:	701a      	strb	r2, [r3, #0]
                            UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_PAGE_LENGTH;

        /* Set the Write Cache Enabled (WCE) bit.  */
        *(page_pointer + UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_FLAGS) |=
 80111ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80111ee:	3302      	adds	r3, #2
 80111f0:	781a      	ldrb	r2, [r3, #0]
 80111f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80111f4:	3302      	adds	r3, #2
 80111f6:	f042 0204 	orr.w	r2, r2, #4
 80111fa:	b2d2      	uxtb	r2, r2
 80111fc:	701a      	strb	r2, [r3, #0]
                            UX_SLAVE_CLASS_STORAGE_CACHING_MODE_PAGE_FLAG_WCE;

        mode_data_length += page_length;
 80111fe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011200:	69bb      	ldr	r3, [r7, #24]
 8011202:	4413      	add	r3, r2
 8011204:	62fb      	str	r3, [r7, #44]	; 0x2c
        page_pointer += page_length;
 8011206:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011208:	69bb      	ldr	r3, [r7, #24]
 801120a:	4413      	add	r3, r2
 801120c:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    /* Informational Exceptions Control mode page.  */
    if (page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_IEC ||
 801120e:	69fb      	ldr	r3, [r7, #28]
 8011210:	2b1c      	cmp	r3, #28
 8011212:	d002      	beq.n	801121a <_ux_device_class_storage_mode_sense+0xfe>
 8011214:	69fb      	ldr	r3, [r7, #28]
 8011216:	2b3f      	cmp	r3, #63	; 0x3f
 8011218:	d10c      	bne.n	8011234 <_ux_device_class_storage_mode_sense+0x118>
        page_code == UX_SLAVE_CLASS_STORAGE_PAGE_CODE_ALL)
    {
        page_length = USBX_DEVICE_CLASS_STORAGE_MODE_SENSE_PAGE_IEC_LENGTH;
 801121a:	230c      	movs	r3, #12
 801121c:	61bb      	str	r3, [r7, #24]

        /* Store page code.  */
        *(page_pointer) = UX_SLAVE_CLASS_STORAGE_PAGE_CODE_IEC;
 801121e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011220:	221c      	movs	r2, #28
 8011222:	701a      	strb	r2, [r3, #0]

        /* Store the length of the page data.  */
        *(page_pointer + 1) = UX_SLAVE_CLASS_STORAGE_IEC_MODE_PAGE_PAGE_LENGTH;
 8011224:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011226:	3301      	adds	r3, #1
 8011228:	220a      	movs	r2, #10
 801122a:	701a      	strb	r2, [r3, #0]

        mode_data_length += page_length;
 801122c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801122e:	69bb      	ldr	r3, [r7, #24]
 8011230:	4413      	add	r3, r2
 8011232:	62fb      	str	r3, [r7, #44]	; 0x2c
    }

    /* Put the payload length in the header.  */
    if (mode_sense_command == UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SENSE_SHORT)
 8011234:	6a3b      	ldr	r3, [r7, #32]
 8011236:	2b1a      	cmp	r3, #26
 8011238:	d105      	bne.n	8011246 <_ux_device_class_storage_mode_sense+0x12a>
        * transfer_request -> ux_slave_transfer_request_data_pointer = (UCHAR)(mode_data_length);
 801123a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801123c:	68db      	ldr	r3, [r3, #12]
 801123e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011240:	b2d2      	uxtb	r2, r2
 8011242:	701a      	strb	r2, [r3, #0]
 8011244:	e007      	b.n	8011256 <_ux_device_class_storage_mode_sense+0x13a>
    else
        _ux_utility_short_put_big_endian(transfer_request -> ux_slave_transfer_request_data_pointer, (USHORT)mode_data_length);
 8011246:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011248:	68db      	ldr	r3, [r3, #12]
 801124a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801124c:	b292      	uxth	r2, r2
 801124e:	4611      	mov	r1, r2
 8011250:	4618      	mov	r0, r3
 8011252:	f7fe fc63 	bl	800fb1c <_ux_utility_short_put_big_endian>

    /* Store the write protection flag.  */
    *(transfer_request -> ux_slave_transfer_request_data_pointer + flags_index) = read_only_flag;
 8011256:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011258:	68da      	ldr	r2, [r3, #12]
 801125a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801125c:	4413      	add	r3, r2
 801125e:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 8011262:	701a      	strb	r2, [r3, #0]
    storage -> ux_device_class_storage_data_count = 0;

#else

    /* Send a payload with the response buffer.  */
    _ux_device_stack_transfer_request(transfer_request, mode_sense_reply_length, mode_sense_reply_length); 
 8011264:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011266:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8011268:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801126a:	f7fd ff05 	bl	800f078 <_ux_device_stack_transfer_request>
#endif

    /* Now we set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 801126e:	68fb      	ldr	r3, [r7, #12]
 8011270:	2200      	movs	r2, #0
 8011272:	651a      	str	r2, [r3, #80]	; 0x50
    status = UX_SUCCESS;
 8011274:	2300      	movs	r3, #0
 8011276:	617b      	str	r3, [r7, #20]

    /* Return completion status.  */
    return(status);
 8011278:	697b      	ldr	r3, [r7, #20]
}
 801127a:	4618      	mov	r0, r3
 801127c:	3740      	adds	r7, #64	; 0x40
 801127e:	46bd      	mov	sp, r7
 8011280:	bd80      	pop	{r7, pc}

08011282 <_ux_device_class_storage_prevent_allow_media_removal>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_prevent_allow_media_removal(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
 8011282:	b480      	push	{r7}
 8011284:	b085      	sub	sp, #20
 8011286:	af00      	add	r7, sp, #0
 8011288:	60f8      	str	r0, [r7, #12]
 801128a:	60b9      	str	r1, [r7, #8]
 801128c:	607a      	str	r2, [r7, #4]
 801128e:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_PREVENT_ALLOW_MEDIA_REMOVAL, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* We set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 8011290:	68fb      	ldr	r3, [r7, #12]
 8011292:	2200      	movs	r2, #0
 8011294:	651a      	str	r2, [r3, #80]	; 0x50

    /* Return successful completion.  */
    return(UX_SUCCESS);
 8011296:	2300      	movs	r3, #0
}
 8011298:	4618      	mov	r0, r3
 801129a:	3714      	adds	r7, #20
 801129c:	46bd      	mov	sp, r7
 801129e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80112a2:	4770      	bx	lr

080112a4 <_ux_device_class_storage_read>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_read(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb, UCHAR scsi_command)
{
 80112a4:	b590      	push	{r4, r7, lr}
 80112a6:	b091      	sub	sp, #68	; 0x44
 80112a8:	af02      	add	r7, sp, #8
 80112aa:	60f8      	str	r0, [r7, #12]
 80112ac:	60b9      	str	r1, [r7, #8]
 80112ae:	607a      	str	r2, [r7, #4]
 80112b0:	603b      	str	r3, [r7, #0]


    UX_PARAMETER_NOT_USED(endpoint_out);

    /* Get the LBA from the CBWCB.  */
    lba =  _ux_utility_long_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_READ_LBA);
 80112b2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80112b4:	3302      	adds	r3, #2
 80112b6:	4618      	mov	r0, r3
 80112b8:	f7fe f8cb 	bl	800f452 <_ux_utility_long_get_big_endian>
 80112bc:	6378      	str	r0, [r7, #52]	; 0x34

    /* The type of commands will tell us the width of the field containing the number
       of sectors to read.  */
    if (scsi_command == UX_SLAVE_CLASS_STORAGE_SCSI_READ16)
 80112be:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 80112c2:	2b28      	cmp	r3, #40	; 0x28
 80112c4:	d106      	bne.n	80112d4 <_ux_device_class_storage_read+0x30>

        /* Get the number of blocks from the CBWCB in 16 bits.  */
        total_number_blocks =  _ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_READ_TRANSFER_LENGTH_16);
 80112c6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80112c8:	3307      	adds	r3, #7
 80112ca:	4618      	mov	r0, r3
 80112cc:	f7fe fc0e 	bl	800faec <_ux_utility_short_get_big_endian>
 80112d0:	6338      	str	r0, [r7, #48]	; 0x30
 80112d2:	e005      	b.n	80112e0 <_ux_device_class_storage_read+0x3c>

    else        

        /* Get the number of blocks from the CBWCB in 32 bits.  */
        total_number_blocks =  _ux_utility_long_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_READ_TRANSFER_LENGTH_32);
 80112d4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80112d6:	3306      	adds	r3, #6
 80112d8:	4618      	mov	r0, r3
 80112da:	f7fe f8ba 	bl	800f452 <_ux_utility_long_get_big_endian>
 80112de:	6338      	str	r0, [r7, #48]	; 0x30

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
 80112e0:	687b      	ldr	r3, [r7, #4]
 80112e2:	3330      	adds	r3, #48	; 0x30
 80112e4:	623b      	str	r3, [r7, #32]

    /* Compute the total length to transfer and how much remains.  */
    total_length =  total_number_blocks * storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length;
 80112e6:	68f9      	ldr	r1, [r7, #12]
 80112e8:	68ba      	ldr	r2, [r7, #8]
 80112ea:	4613      	mov	r3, r2
 80112ec:	00db      	lsls	r3, r3, #3
 80112ee:	1a9b      	subs	r3, r3, r2
 80112f0:	00db      	lsls	r3, r3, #3
 80112f2:	440b      	add	r3, r1
 80112f4:	330c      	adds	r3, #12
 80112f6:	681a      	ldr	r2, [r3, #0]
 80112f8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80112fa:	fb02 f303 	mul.w	r3, r2, r3
 80112fe:	62fb      	str	r3, [r7, #44]	; 0x2c

    /* Default CSW to failed.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
 8011300:	68fb      	ldr	r3, [r7, #12]
 8011302:	2201      	movs	r2, #1
 8011304:	651a      	str	r2, [r3, #80]	; 0x50
#else

    /* Check transfer length.  */

    /* Case (7).  Host length < device length.  */
    if (total_length > storage -> ux_slave_class_storage_host_length)
 8011306:	68fb      	ldr	r3, [r7, #12]
 8011308:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801130a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801130c:	429a      	cmp	r2, r3
 801130e:	d907      	bls.n	8011320 <_ux_device_class_storage_read+0x7c>
    {
        _ux_device_stack_endpoint_stall(endpoint_in);
 8011310:	6878      	ldr	r0, [r7, #4]
 8011312:	f7fd fc7f 	bl	800ec14 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
 8011316:	68fb      	ldr	r3, [r7, #12]
 8011318:	2202      	movs	r2, #2
 801131a:	651a      	str	r2, [r3, #80]	; 0x50
        return(UX_ERROR);
 801131c:	23ff      	movs	r3, #255	; 0xff
 801131e:	e0c9      	b.n	80114b4 <_ux_device_class_storage_read+0x210>
    }

    /* Case (8). Hi <> Do.  */
    if ((storage -> ux_slave_class_storage_cbw_flags & 0x80) == 0)
 8011320:	68fb      	ldr	r3, [r7, #12]
 8011322:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8011326:	b25b      	sxtb	r3, r3
 8011328:	2b00      	cmp	r3, #0
 801132a:	db07      	blt.n	801133c <_ux_device_class_storage_read+0x98>
    {
        _ux_device_stack_endpoint_stall(endpoint_out);
 801132c:	6838      	ldr	r0, [r7, #0]
 801132e:	f7fd fc71 	bl	800ec14 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
 8011332:	68fb      	ldr	r3, [r7, #12]
 8011334:	2202      	movs	r2, #2
 8011336:	651a      	str	r2, [r3, #80]	; 0x50
        return(UX_ERROR);
 8011338:	23ff      	movs	r3, #255	; 0xff
 801133a:	e0bb      	b.n	80114b4 <_ux_device_class_storage_read+0x210>
    }

    /* It may take several transfers to send the requested data.  */
    done_length = 0;
 801133c:	2300      	movs	r3, #0
 801133e:	627b      	str	r3, [r7, #36]	; 0x24
    while (total_number_blocks)
 8011340:	e0a2      	b.n	8011488 <_ux_device_class_storage_read+0x1e4>
    {

        /* Obtain the status of the device.  */
        status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, lun, 
 8011342:	68f9      	ldr	r1, [r7, #12]
 8011344:	68bb      	ldr	r3, [r7, #8]
 8011346:	1c5a      	adds	r2, r3, #1
 8011348:	4613      	mov	r3, r2
 801134a:	00db      	lsls	r3, r3, #3
 801134c:	1a9b      	subs	r3, r3, r2
 801134e:	00db      	lsls	r3, r3, #3
 8011350:	440b      	add	r3, r1
 8011352:	681c      	ldr	r4, [r3, #0]
 8011354:	68f9      	ldr	r1, [r7, #12]
 8011356:	68ba      	ldr	r2, [r7, #8]
 8011358:	4613      	mov	r3, r2
 801135a:	00db      	lsls	r3, r3, #3
 801135c:	1a9b      	subs	r3, r3, r2
 801135e:	00db      	lsls	r3, r3, #3
 8011360:	440b      	add	r3, r1
 8011362:	331c      	adds	r3, #28
 8011364:	681a      	ldr	r2, [r3, #0]
 8011366:	f107 0314 	add.w	r3, r7, #20
 801136a:	68b9      	ldr	r1, [r7, #8]
 801136c:	68f8      	ldr	r0, [r7, #12]
 801136e:	47a0      	blx	r4
 8011370:	61f8      	str	r0, [r7, #28]
                                    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);
    
        /* Update the request sense.  */
        storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
 8011372:	6979      	ldr	r1, [r7, #20]
 8011374:	68f8      	ldr	r0, [r7, #12]
 8011376:	68ba      	ldr	r2, [r7, #8]
 8011378:	4613      	mov	r3, r2
 801137a:	00db      	lsls	r3, r3, #3
 801137c:	1a9b      	subs	r3, r3, r2
 801137e:	00db      	lsls	r3, r3, #3
 8011380:	4403      	add	r3, r0
 8011382:	3320      	adds	r3, #32
 8011384:	6019      	str	r1, [r3, #0]
    
        /* If there is a problem, return a failed command.  */
        if (status != UX_SUCCESS)
 8011386:	69fb      	ldr	r3, [r7, #28]
 8011388:	2b00      	cmp	r3, #0
 801138a:	d00a      	beq.n	80113a2 <_ux_device_class_storage_read+0xfe>
        {
    
            /* We have a problem, media status error. Return a bad completion and wait for the
               REQUEST_SENSE command.  */
            _ux_device_stack_endpoint_stall(endpoint_in);
 801138c:	6878      	ldr	r0, [r7, #4]
 801138e:	f7fd fc41 	bl	800ec14 <_ux_device_stack_endpoint_stall>

            /* Update residue.  */
            storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
 8011392:	68fb      	ldr	r3, [r7, #12]
 8011394:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8011396:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011398:	1ad2      	subs	r2, r2, r3
 801139a:	68fb      	ldr	r3, [r7, #12]
 801139c:	64da      	str	r2, [r3, #76]	; 0x4c
    
            /* Return an error.  */
            return(UX_ERROR);
 801139e:	23ff      	movs	r3, #255	; 0xff
 80113a0:	e088      	b.n	80114b4 <_ux_device_class_storage_read+0x210>
        }

        /* How much can we send in this transfer?  */
        if (total_length > UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE)
 80113a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80113a4:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80113a8:	d903      	bls.n	80113b2 <_ux_device_class_storage_read+0x10e>

            /* Compute the transfer length based on the maximum allowed.  */
            transfer_length =  UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE;
 80113aa:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80113ae:	62bb      	str	r3, [r7, #40]	; 0x28
 80113b0:	e001      	b.n	80113b6 <_ux_device_class_storage_read+0x112>
            
        else

            /* Compute the transfer length based on what is left to transfer.  */
            transfer_length =  total_length;
 80113b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80113b4:	62bb      	str	r3, [r7, #40]	; 0x28

        /* Compute the number of blocks to transfer.  */
        number_blocks = transfer_length / storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length;
 80113b6:	68f9      	ldr	r1, [r7, #12]
 80113b8:	68ba      	ldr	r2, [r7, #8]
 80113ba:	4613      	mov	r3, r2
 80113bc:	00db      	lsls	r3, r3, #3
 80113be:	1a9b      	subs	r3, r3, r2
 80113c0:	00db      	lsls	r3, r3, #3
 80113c2:	440b      	add	r3, r1
 80113c4:	330c      	adds	r3, #12
 80113c6:	681b      	ldr	r3, [r3, #0]
 80113c8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80113ca:	fbb2 f3f3 	udiv	r3, r2, r3
 80113ce:	61bb      	str	r3, [r7, #24]
        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_READ, storage, lun, transfer_request -> ux_slave_transfer_request_data_pointer, 
                                number_blocks, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

        /* Execute the read command from the local media.  */
        status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_read(storage, lun, 
 80113d0:	68f9      	ldr	r1, [r7, #12]
 80113d2:	68ba      	ldr	r2, [r7, #8]
 80113d4:	4613      	mov	r3, r2
 80113d6:	00db      	lsls	r3, r3, #3
 80113d8:	1a9b      	subs	r3, r3, r2
 80113da:	00db      	lsls	r3, r3, #3
 80113dc:	440b      	add	r3, r1
 80113de:	332c      	adds	r3, #44	; 0x2c
 80113e0:	681c      	ldr	r4, [r3, #0]
 80113e2:	6a3b      	ldr	r3, [r7, #32]
 80113e4:	68da      	ldr	r2, [r3, #12]
 80113e6:	f107 0314 	add.w	r3, r7, #20
 80113ea:	9301      	str	r3, [sp, #4]
 80113ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80113ee:	9300      	str	r3, [sp, #0]
 80113f0:	69bb      	ldr	r3, [r7, #24]
 80113f2:	68b9      	ldr	r1, [r7, #8]
 80113f4:	68f8      	ldr	r0, [r7, #12]
 80113f6:	47a0      	blx	r4
 80113f8:	61f8      	str	r0, [r7, #28]
                                                    transfer_request -> ux_slave_transfer_request_data_pointer, number_blocks, lba, &media_status); 

        /* If there is a problem, return a failed command.  */
        if (status != UX_SUCCESS)
 80113fa:	69fb      	ldr	r3, [r7, #28]
 80113fc:	2b00      	cmp	r3, #0
 80113fe:	d014      	beq.n	801142a <_ux_device_class_storage_read+0x186>
        {
    
            /* We have a problem, request error. Return a bad completion and wait for the
               REQUEST_SENSE command.  */
            _ux_device_stack_endpoint_stall(endpoint_in);
 8011400:	6878      	ldr	r0, [r7, #4]
 8011402:	f7fd fc07 	bl	800ec14 <_ux_device_stack_endpoint_stall>
    
            /* Update residue.  */
            storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
 8011406:	68fb      	ldr	r3, [r7, #12]
 8011408:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801140a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801140c:	1ad2      	subs	r2, r2, r3
 801140e:	68fb      	ldr	r3, [r7, #12]
 8011410:	64da      	str	r2, [r3, #76]	; 0x4c

            /* And update the REQUEST_SENSE codes.  */
            storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
 8011412:	6979      	ldr	r1, [r7, #20]
 8011414:	68f8      	ldr	r0, [r7, #12]
 8011416:	68ba      	ldr	r2, [r7, #8]
 8011418:	4613      	mov	r3, r2
 801141a:	00db      	lsls	r3, r3, #3
 801141c:	1a9b      	subs	r3, r3, r2
 801141e:	00db      	lsls	r3, r3, #3
 8011420:	4403      	add	r3, r0
 8011422:	3320      	adds	r3, #32
 8011424:	6019      	str	r1, [r3, #0]
    
            /* Return an error.  */
            return(UX_ERROR);
 8011426:	23ff      	movs	r3, #255	; 0xff
 8011428:	e044      	b.n	80114b4 <_ux_device_class_storage_read+0x210>
        }

        /* Sends the data payload back to the caller.  */
        status =  _ux_device_stack_transfer_request(transfer_request, transfer_length, transfer_length);
 801142a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801142c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801142e:	6a38      	ldr	r0, [r7, #32]
 8011430:	f7fd fe22 	bl	800f078 <_ux_device_stack_transfer_request>
 8011434:	61f8      	str	r0, [r7, #28]

        /* Check the status.  */
        if(status != UX_SUCCESS)
 8011436:	69fb      	ldr	r3, [r7, #28]
 8011438:	2b00      	cmp	r3, #0
 801143a:	d015      	beq.n	8011468 <_ux_device_class_storage_read+0x1c4>
        {

            /* We have a problem, request error. Return a bad completion and wait for the
               REQUEST_SENSE command.  */
            _ux_device_stack_endpoint_stall(endpoint_in);
 801143c:	6878      	ldr	r0, [r7, #4]
 801143e:	f7fd fbe9 	bl	800ec14 <_ux_device_stack_endpoint_stall>
    
            /* Update residue.  */
            storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
 8011442:	68fb      	ldr	r3, [r7, #12]
 8011444:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8011446:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011448:	1ad2      	subs	r2, r2, r3
 801144a:	68fb      	ldr	r3, [r7, #12]
 801144c:	64da      	str	r2, [r3, #76]	; 0x4c

            /* Update the REQUEST_SENSE codes.  */
            storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
 801144e:	68f9      	ldr	r1, [r7, #12]
 8011450:	68ba      	ldr	r2, [r7, #8]
 8011452:	4613      	mov	r3, r2
 8011454:	00db      	lsls	r3, r3, #3
 8011456:	1a9b      	subs	r3, r3, r2
 8011458:	00db      	lsls	r3, r3, #3
 801145a:	440b      	add	r3, r1
 801145c:	3320      	adds	r3, #32
 801145e:	f245 4202 	movw	r2, #21506	; 0x5402
 8011462:	601a      	str	r2, [r3, #0]
                                                UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02,0x54,0x00);

            /* Return an error.  */
            return(UX_ERROR);
 8011464:	23ff      	movs	r3, #255	; 0xff
 8011466:	e025      	b.n	80114b4 <_ux_device_class_storage_read+0x210>

        }

        /* Update the LBA address.  */
        lba += number_blocks;
 8011468:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801146a:	69bb      	ldr	r3, [r7, #24]
 801146c:	4413      	add	r3, r2
 801146e:	637b      	str	r3, [r7, #52]	; 0x34
        
        /* Update the length to remain.  */
        total_length -= transfer_length;        
 8011470:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011472:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011474:	1ad3      	subs	r3, r2, r3
 8011476:	62fb      	str	r3, [r7, #44]	; 0x2c
        done_length += transfer_length;
 8011478:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801147a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801147c:	4413      	add	r3, r2
 801147e:	627b      	str	r3, [r7, #36]	; 0x24
        
        /* Update the number of blocks to read.  */
        total_number_blocks -= number_blocks;
 8011480:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011482:	69bb      	ldr	r3, [r7, #24]
 8011484:	1ad3      	subs	r3, r2, r3
 8011486:	633b      	str	r3, [r7, #48]	; 0x30
    while (total_number_blocks)
 8011488:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801148a:	2b00      	cmp	r3, #0
 801148c:	f47f af59 	bne.w	8011342 <_ux_device_class_storage_read+0x9e>
    }

    /* Case (4), (5). Host length too large.  */
    if (storage -> ux_slave_class_storage_host_length > done_length)
 8011490:	68fb      	ldr	r3, [r7, #12]
 8011492:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8011494:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011496:	429a      	cmp	r2, r3
 8011498:	d208      	bcs.n	80114ac <_ux_device_class_storage_read+0x208>
    {

        /* Stall Bulk-In.  */
        _ux_device_stack_endpoint_stall(endpoint_in);
 801149a:	6878      	ldr	r0, [r7, #4]
 801149c:	f7fd fbba 	bl	800ec14 <_ux_device_stack_endpoint_stall>

        /* Update residure.  */
        storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
 80114a0:	68fb      	ldr	r3, [r7, #12]
 80114a2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80114a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80114a6:	1ad2      	subs	r2, r2, r3
 80114a8:	68fb      	ldr	r3, [r7, #12]
 80114aa:	64da      	str	r2, [r3, #76]	; 0x4c
    }

#endif /* else defined(UX_DEVICE_STANDALONE) */

    /* Now we set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 80114ac:	68fb      	ldr	r3, [r7, #12]
 80114ae:	2200      	movs	r2, #0
 80114b0:	651a      	str	r2, [r3, #80]	; 0x50

    /* Return completion status.  */
    return(UX_SUCCESS);
 80114b2:	2300      	movs	r3, #0
}
 80114b4:	4618      	mov	r0, r3
 80114b6:	373c      	adds	r7, #60	; 0x3c
 80114b8:	46bd      	mov	sp, r7
 80114ba:	bd90      	pop	{r4, r7, pc}

080114bc <_ux_device_class_storage_read_capacity>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_read_capacity(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun,
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
 80114bc:	b590      	push	{r4, r7, lr}
 80114be:	b089      	sub	sp, #36	; 0x24
 80114c0:	af00      	add	r7, sp, #0
 80114c2:	60f8      	str	r0, [r7, #12]
 80114c4:	60b9      	str	r1, [r7, #8]
 80114c6:	607a      	str	r2, [r7, #4]
 80114c8:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_READ_CAPACITY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the status of the device.  */
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, lun, 
 80114ca:	68f9      	ldr	r1, [r7, #12]
 80114cc:	68bb      	ldr	r3, [r7, #8]
 80114ce:	1c5a      	adds	r2, r3, #1
 80114d0:	4613      	mov	r3, r2
 80114d2:	00db      	lsls	r3, r3, #3
 80114d4:	1a9b      	subs	r3, r3, r2
 80114d6:	00db      	lsls	r3, r3, #3
 80114d8:	440b      	add	r3, r1
 80114da:	681c      	ldr	r4, [r3, #0]
 80114dc:	68f9      	ldr	r1, [r7, #12]
 80114de:	68ba      	ldr	r2, [r7, #8]
 80114e0:	4613      	mov	r3, r2
 80114e2:	00db      	lsls	r3, r3, #3
 80114e4:	1a9b      	subs	r3, r3, r2
 80114e6:	00db      	lsls	r3, r3, #3
 80114e8:	440b      	add	r3, r1
 80114ea:	331c      	adds	r3, #28
 80114ec:	681a      	ldr	r2, [r3, #0]
 80114ee:	f107 0310 	add.w	r3, r7, #16
 80114f2:	68b9      	ldr	r1, [r7, #8]
 80114f4:	68f8      	ldr	r0, [r7, #12]
 80114f6:	47a0      	blx	r4
 80114f8:	61f8      	str	r0, [r7, #28]
                                storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);

    /* Update the request sense.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
 80114fa:	6939      	ldr	r1, [r7, #16]
 80114fc:	68f8      	ldr	r0, [r7, #12]
 80114fe:	68ba      	ldr	r2, [r7, #8]
 8011500:	4613      	mov	r3, r2
 8011502:	00db      	lsls	r3, r3, #3
 8011504:	1a9b      	subs	r3, r3, r2
 8011506:	00db      	lsls	r3, r3, #3
 8011508:	4403      	add	r3, r0
 801150a:	3320      	adds	r3, #32
 801150c:	6019      	str	r1, [r3, #0]

    /* Check the status for error.  */
    if (status != UX_SUCCESS)
 801150e:	69fb      	ldr	r3, [r7, #28]
 8011510:	2b00      	cmp	r3, #0
 8011512:	d008      	beq.n	8011526 <_ux_device_class_storage_read_capacity+0x6a>
    {

#if !defined(UX_DEVICE_STANDALONE)

        /* We need to STALL the IN endpoint.  The endpoint will be reset by the host.  */
        _ux_device_stack_endpoint_stall(endpoint_in);
 8011514:	6878      	ldr	r0, [r7, #4]
 8011516:	f7fd fb7d 	bl	800ec14 <_ux_device_stack_endpoint_stall>
#endif

        /* Now we set the CSW with Error.  */
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
 801151a:	68fb      	ldr	r3, [r7, #12]
 801151c:	2201      	movs	r2, #1
 801151e:	651a      	str	r2, [r3, #80]	; 0x50
        status = UX_SUCCESS;
 8011520:	2300      	movs	r3, #0
 8011522:	61fb      	str	r3, [r7, #28]
 8011524:	e02f      	b.n	8011586 <_ux_device_class_storage_read_capacity+0xca>
    }
    else
    {
    
        /* Obtain the pointer to the transfer request.  */
        transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
 8011526:	687b      	ldr	r3, [r7, #4]
 8011528:	3330      	adds	r3, #48	; 0x30
 801152a:	61bb      	str	r3, [r7, #24]

        /* Obtain read capacity response buffer.  */
        read_capacity_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
 801152c:	69bb      	ldr	r3, [r7, #24]
 801152e:	68db      	ldr	r3, [r3, #12]
 8011530:	617b      	str	r3, [r7, #20]
    
        /* Ensure it is cleaned.  */
        _ux_utility_memory_set(read_capacity_buffer, 0, UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH); /* Use case of memcpy is verified. */
 8011532:	2208      	movs	r2, #8
 8011534:	2100      	movs	r1, #0
 8011536:	6978      	ldr	r0, [r7, #20]
 8011538:	f7fe fa2c 	bl	800f994 <_ux_utility_memory_set>
    
        /* Insert the last LBA address in the response.  */
        _ux_utility_long_put_big_endian(&read_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LAST_LBA],
 801153c:	68f9      	ldr	r1, [r7, #12]
 801153e:	68ba      	ldr	r2, [r7, #8]
 8011540:	4613      	mov	r3, r2
 8011542:	00db      	lsls	r3, r3, #3
 8011544:	1a9b      	subs	r3, r3, r2
 8011546:	00db      	lsls	r3, r3, #3
 8011548:	440b      	add	r3, r1
 801154a:	3308      	adds	r3, #8
 801154c:	681b      	ldr	r3, [r3, #0]
 801154e:	4619      	mov	r1, r3
 8011550:	6978      	ldr	r0, [r7, #20]
 8011552:	f7fd ffcb 	bl	800f4ec <_ux_utility_long_put_big_endian>
                                        storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_last_lba);
    
        /* Insert the block length in the response.  */
        _ux_utility_long_put_big_endian(&read_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_BLOCK_SIZE],
 8011556:	697b      	ldr	r3, [r7, #20]
 8011558:	1d18      	adds	r0, r3, #4
 801155a:	68f9      	ldr	r1, [r7, #12]
 801155c:	68ba      	ldr	r2, [r7, #8]
 801155e:	4613      	mov	r3, r2
 8011560:	00db      	lsls	r3, r3, #3
 8011562:	1a9b      	subs	r3, r3, r2
 8011564:	00db      	lsls	r3, r3, #3
 8011566:	440b      	add	r3, r1
 8011568:	330c      	adds	r3, #12
 801156a:	681b      	ldr	r3, [r3, #0]
 801156c:	4619      	mov	r1, r3
 801156e:	f7fd ffbd 	bl	800f4ec <_ux_utility_long_put_big_endian>
        UX_SLAVE_TRANSFER_STATE_RESET(storage -> ux_device_class_storage_transfer);

#else

        /* Send a data payload with the read_capacity response buffer.  */
        _ux_device_stack_transfer_request(transfer_request, 
 8011572:	2208      	movs	r2, #8
 8011574:	2108      	movs	r1, #8
 8011576:	69b8      	ldr	r0, [r7, #24]
 8011578:	f7fd fd7e 	bl	800f078 <_ux_device_stack_transfer_request>
                                      UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH,
                                      UX_SLAVE_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH);
#endif

        /* Now we set the CSW with success.  */
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 801157c:	68fb      	ldr	r3, [r7, #12]
 801157e:	2200      	movs	r2, #0
 8011580:	651a      	str	r2, [r3, #80]	; 0x50
        status = UX_SUCCESS;
 8011582:	2300      	movs	r3, #0
 8011584:	61fb      	str	r3, [r7, #28]
    }
        
    /* Return completion status.  */
    return(status);
 8011586:	69fb      	ldr	r3, [r7, #28]
}
 8011588:	4618      	mov	r0, r3
 801158a:	3724      	adds	r7, #36	; 0x24
 801158c:	46bd      	mov	sp, r7
 801158e:	bd90      	pop	{r4, r7, pc}

08011590 <_ux_device_class_storage_read_format_capacity>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_read_format_capacity(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun,
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
 8011590:	b580      	push	{r7, lr}
 8011592:	b088      	sub	sp, #32
 8011594:	af00      	add	r7, sp, #0
 8011596:	60f8      	str	r0, [r7, #12]
 8011598:	60b9      	str	r1, [r7, #8]
 801159a:	607a      	str	r2, [r7, #4]
 801159c:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_READ_FORMAT_CAPACITY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
 801159e:	687b      	ldr	r3, [r7, #4]
 80115a0:	3330      	adds	r3, #48	; 0x30
 80115a2:	61fb      	str	r3, [r7, #28]

    /* Get read format capacity response buffer.  */
    read_format_capacity_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
 80115a4:	69fb      	ldr	r3, [r7, #28]
 80115a6:	68db      	ldr	r3, [r3, #12]
 80115a8:	61bb      	str	r3, [r7, #24]

    /* Ensure it is cleaned.  */
    _ux_utility_memory_set(read_format_capacity_buffer, 0, UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_LENGTH); /* Use case of memset is verified. */
 80115aa:	220c      	movs	r2, #12
 80115ac:	2100      	movs	r1, #0
 80115ae:	69b8      	ldr	r0, [r7, #24]
 80115b0:	f7fe f9f0 	bl	800f994 <_ux_utility_memory_set>

    /* Insert the size of the response block.  */
    _ux_utility_long_put_big_endian(&read_format_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_SIZE], 8);
 80115b4:	2108      	movs	r1, #8
 80115b6:	69b8      	ldr	r0, [r7, #24]
 80115b8:	f7fd ff98 	bl	800f4ec <_ux_utility_long_put_big_endian>

    /* Insert the last LBA address in the response.  */
    _ux_utility_long_put_big_endian(&read_format_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_LAST_LBA],
 80115bc:	69bb      	ldr	r3, [r7, #24]
 80115be:	1d18      	adds	r0, r3, #4
 80115c0:	68f9      	ldr	r1, [r7, #12]
 80115c2:	68ba      	ldr	r2, [r7, #8]
 80115c4:	4613      	mov	r3, r2
 80115c6:	00db      	lsls	r3, r3, #3
 80115c8:	1a9b      	subs	r3, r3, r2
 80115ca:	00db      	lsls	r3, r3, #3
 80115cc:	440b      	add	r3, r1
 80115ce:	3308      	adds	r3, #8
 80115d0:	681b      	ldr	r3, [r3, #0]
 80115d2:	4619      	mov	r1, r3
 80115d4:	f7fd ff8a 	bl	800f4ec <_ux_utility_long_put_big_endian>
                                    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_last_lba);

    /* Insert the block length in the response.  This is in 3 bytes. */
    _ux_utility_long_put_big_endian(&read_format_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_BLOCK_SIZE],
 80115d8:	69bb      	ldr	r3, [r7, #24]
 80115da:	f103 0008 	add.w	r0, r3, #8
 80115de:	68f9      	ldr	r1, [r7, #12]
 80115e0:	68ba      	ldr	r2, [r7, #8]
 80115e2:	4613      	mov	r3, r2
 80115e4:	00db      	lsls	r3, r3, #3
 80115e6:	1a9b      	subs	r3, r3, r2
 80115e8:	00db      	lsls	r3, r3, #3
 80115ea:	440b      	add	r3, r1
 80115ec:	330c      	adds	r3, #12
 80115ee:	681b      	ldr	r3, [r3, #0]
 80115f0:	4619      	mov	r1, r3
 80115f2:	f7fd ff7b 	bl	800f4ec <_ux_utility_long_put_big_endian>
                                    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length);

    /* Insert the response code : always 2.  */
    read_format_capacity_buffer[UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_DESC_CODE] =  2;    
 80115f6:	69bb      	ldr	r3, [r7, #24]
 80115f8:	3308      	adds	r3, #8
 80115fa:	2202      	movs	r2, #2
 80115fc:	701a      	strb	r2, [r3, #0]
    UX_SLAVE_TRANSFER_STATE_RESET(storage -> ux_device_class_storage_transfer);

#else

    /* Send a data payload with the read_capacity response buffer.  */
    _ux_device_stack_transfer_request(transfer_request, 
 80115fe:	220c      	movs	r2, #12
 8011600:	210c      	movs	r1, #12
 8011602:	69f8      	ldr	r0, [r7, #28]
 8011604:	f7fd fd38 	bl	800f078 <_ux_device_stack_transfer_request>
                                  UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_LENGTH,
                                  UX_SLAVE_CLASS_STORAGE_READ_FORMAT_CAPACITY_RESPONSE_LENGTH);
#endif

    /* Now we set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 8011608:	68fb      	ldr	r3, [r7, #12]
 801160a:	2200      	movs	r2, #0
 801160c:	651a      	str	r2, [r3, #80]	; 0x50
    status = UX_SUCCESS;
 801160e:	2300      	movs	r3, #0
 8011610:	617b      	str	r3, [r7, #20]

    /* Return completion status.  */
    return(status);
 8011612:	697b      	ldr	r3, [r7, #20]
}
 8011614:	4618      	mov	r0, r3
 8011616:	3720      	adds	r7, #32
 8011618:	46bd      	mov	sp, r7
 801161a:	bd80      	pop	{r7, pc}

0801161c <_ux_device_class_storage_request_sense>:
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_request_sense(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
 801161c:	b580      	push	{r7, lr}
 801161e:	b08a      	sub	sp, #40	; 0x28
 8011620:	af00      	add	r7, sp, #0
 8011622:	60f8      	str	r0, [r7, #12]
 8011624:	60b9      	str	r1, [r7, #8]
 8011626:	607a      	str	r2, [r7, #4]
 8011628:	603b      	str	r3, [r7, #0]

UINT                    status = UX_SUCCESS;
 801162a:	2300      	movs	r3, #0
 801162c:	623b      	str	r3, [r7, #32]

    UX_PARAMETER_NOT_USED(cbwcb);
    UX_PARAMETER_NOT_USED(endpoint_out);

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_in -> ux_slave_endpoint_transfer_request;
 801162e:	687b      	ldr	r3, [r7, #4]
 8011630:	3330      	adds	r3, #48	; 0x30
 8011632:	61fb      	str	r3, [r7, #28]

    /* Get length.  */
    sense_length = storage -> ux_slave_class_storage_host_length;
 8011634:	68fb      	ldr	r3, [r7, #12]
 8011636:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8011638:	627b      	str	r3, [r7, #36]	; 0x24
    if (sense_length > UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_LENGTH)
 801163a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801163c:	2b12      	cmp	r3, #18
 801163e:	d901      	bls.n	8011644 <_ux_device_class_storage_request_sense+0x28>
        sense_length = UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_LENGTH;
 8011640:	2312      	movs	r3, #18
 8011642:	627b      	str	r3, [r7, #36]	; 0x24

    /* Obtain sense buffer.  */
    sense_buffer = transfer_request -> ux_slave_transfer_request_data_pointer;
 8011644:	69fb      	ldr	r3, [r7, #28]
 8011646:	68db      	ldr	r3, [r3, #12]
 8011648:	61bb      	str	r3, [r7, #24]

    /* Ensure it is cleaned.  */
    _ux_utility_memory_set(sense_buffer, 0, sense_length); /* Use case of memset is verified. */
 801164a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801164c:	2100      	movs	r1, #0
 801164e:	69b8      	ldr	r0, [r7, #24]
 8011650:	f7fe f9a0 	bl	800f994 <_ux_utility_memory_set>
    
    /* Initialize the response buffer with the error code.  */
    sense_buffer[UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_ERROR_CODE] = 
 8011654:	69bb      	ldr	r3, [r7, #24]
 8011656:	2270      	movs	r2, #112	; 0x70
 8011658:	701a      	strb	r2, [r3, #0]
                    UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_ERROR_CODE_VALUE;

    /* Extract sense key, code, qualifier.  */
    key = UX_DEVICE_CLASS_STORAGE_SENSE_KEY(storage -> ux_slave_class_storage_lun[lun].
 801165a:	68f9      	ldr	r1, [r7, #12]
 801165c:	68ba      	ldr	r2, [r7, #8]
 801165e:	4613      	mov	r3, r2
 8011660:	00db      	lsls	r3, r3, #3
 8011662:	1a9b      	subs	r3, r3, r2
 8011664:	00db      	lsls	r3, r3, #3
 8011666:	440b      	add	r3, r1
 8011668:	3320      	adds	r3, #32
 801166a:	681b      	ldr	r3, [r3, #0]
 801166c:	75fb      	strb	r3, [r7, #23]
                                            ux_slave_class_storage_request_sense_status);
    code = UX_DEVICE_CLASS_STORAGE_SENSE_CODE(storage -> ux_slave_class_storage_lun[lun].
 801166e:	68f9      	ldr	r1, [r7, #12]
 8011670:	68ba      	ldr	r2, [r7, #8]
 8011672:	4613      	mov	r3, r2
 8011674:	00db      	lsls	r3, r3, #3
 8011676:	1a9b      	subs	r3, r3, r2
 8011678:	00db      	lsls	r3, r3, #3
 801167a:	440b      	add	r3, r1
 801167c:	3320      	adds	r3, #32
 801167e:	681b      	ldr	r3, [r3, #0]
 8011680:	0a1b      	lsrs	r3, r3, #8
 8011682:	75bb      	strb	r3, [r7, #22]
                                            ux_slave_class_storage_request_sense_status);
    qualifier = UX_DEVICE_CLASS_STORAGE_SENSE_QUALIFIER(storage -> ux_slave_class_storage_lun[lun].
 8011684:	68f9      	ldr	r1, [r7, #12]
 8011686:	68ba      	ldr	r2, [r7, #8]
 8011688:	4613      	mov	r3, r2
 801168a:	00db      	lsls	r3, r3, #3
 801168c:	1a9b      	subs	r3, r3, r2
 801168e:	00db      	lsls	r3, r3, #3
 8011690:	440b      	add	r3, r1
 8011692:	3320      	adds	r3, #32
 8011694:	681b      	ldr	r3, [r3, #0]
 8011696:	0c1b      	lsrs	r3, r3, #16
 8011698:	757b      	strb	r3, [r7, #21]
                                            ux_slave_class_storage_request_sense_status);

    /* Initialize the response buffer with the sense key.  */
    sense_buffer[UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_SENSE_KEY] = key;
 801169a:	69bb      	ldr	r3, [r7, #24]
 801169c:	3302      	adds	r3, #2
 801169e:	7dfa      	ldrb	r2, [r7, #23]
 80116a0:	701a      	strb	r2, [r3, #0]

    /* Initialize the response buffer with the code.  */
    sense_buffer[UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_CODE] = code;
 80116a2:	69bb      	ldr	r3, [r7, #24]
 80116a4:	330c      	adds	r3, #12
 80116a6:	7dba      	ldrb	r2, [r7, #22]
 80116a8:	701a      	strb	r2, [r3, #0]

    /* Initialize the response buffer with the code qualifier.  */
    sense_buffer[UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_CODE_QUALIFIER] = qualifier;
 80116aa:	69bb      	ldr	r3, [r7, #24]
 80116ac:	330d      	adds	r3, #13
 80116ae:	7d7a      	ldrb	r2, [r7, #21]
 80116b0:	701a      	strb	r2, [r3, #0]
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_REQUEST_SENSE, storage, lun, 
                            key, code, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Initialize the response buffer with the additional length.  */
    sense_buffer[UX_SLAVE_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_ADD_LENGTH] =  10;
 80116b2:	69bb      	ldr	r3, [r7, #24]
 80116b4:	3307      	adds	r3, #7
 80116b6:	220a      	movs	r2, #10
 80116b8:	701a      	strb	r2, [r3, #0]
    storage -> ux_device_class_storage_data_count = 0;

#else

    /* Send a data payload with the sense codes.  */
    if (sense_length)
 80116ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80116bc:	2b00      	cmp	r3, #0
 80116be:	d004      	beq.n	80116ca <_ux_device_class_storage_request_sense+0xae>
        _ux_device_stack_transfer_request(transfer_request, sense_length, sense_length);
 80116c0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80116c2:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80116c4:	69f8      	ldr	r0, [r7, #28]
 80116c6:	f7fd fcd7 	bl	800f078 <_ux_device_stack_transfer_request>

    /* Check length.  */
    if (storage -> ux_slave_class_storage_host_length != sense_length)
 80116ca:	68fb      	ldr	r3, [r7, #12]
 80116cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80116ce:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80116d0:	429a      	cmp	r2, r3
 80116d2:	d005      	beq.n	80116e0 <_ux_device_class_storage_request_sense+0xc4>
    {
        _ux_device_stack_endpoint_stall(endpoint_in);
 80116d4:	6878      	ldr	r0, [r7, #4]
 80116d6:	f7fd fa9d 	bl	800ec14 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
 80116da:	68fb      	ldr	r3, [r7, #12]
 80116dc:	2202      	movs	r2, #2
 80116de:	651a      	str	r2, [r3, #80]	; 0x50
    }
#endif

    /* Return completion status.  */    
    return(status);
 80116e0:	6a3b      	ldr	r3, [r7, #32]
}
 80116e2:	4618      	mov	r0, r3
 80116e4:	3728      	adds	r7, #40	; 0x28
 80116e6:	46bd      	mov	sp, r7
 80116e8:	bd80      	pop	{r7, pc}

080116ea <_ux_device_class_storage_start_stop>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_start_stop(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                            UX_SLAVE_ENDPOINT *endpoint_in,
                                            UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
 80116ea:	b480      	push	{r7}
 80116ec:	b085      	sub	sp, #20
 80116ee:	af00      	add	r7, sp, #0
 80116f0:	60f8      	str	r0, [r7, #12]
 80116f2:	60b9      	str	r1, [r7, #8]
 80116f4:	607a      	str	r2, [r7, #4]
 80116f6:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_START_STOP, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* We set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 80116f8:	68fb      	ldr	r3, [r7, #12]
 80116fa:	2200      	movs	r2, #0
 80116fc:	651a      	str	r2, [r3, #80]	; 0x50

    /* Return successful completion.  */
    return(UX_SUCCESS);
 80116fe:	2300      	movs	r3, #0
}
 8011700:	4618      	mov	r0, r3
 8011702:	3714      	adds	r7, #20
 8011704:	46bd      	mov	sp, r7
 8011706:	f85d 7b04 	ldr.w	r7, [sp], #4
 801170a:	4770      	bx	lr

0801170c <_ux_device_class_storage_synchronize_cache>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_synchronize_cache(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                                 UX_SLAVE_ENDPOINT *endpoint_in,
                                                 UX_SLAVE_ENDPOINT *endpoint_out, UCHAR *cbwcb, UCHAR scsi_command)
{
 801170c:	b590      	push	{r4, r7, lr}
 801170e:	b08d      	sub	sp, #52	; 0x34
 8011710:	af02      	add	r7, sp, #8
 8011712:	60f8      	str	r0, [r7, #12]
 8011714:	60b9      	str	r1, [r7, #8]
 8011716:	607a      	str	r2, [r7, #4]
 8011718:	603b      	str	r3, [r7, #0]

    UX_PARAMETER_NOT_USED(endpoint_out);
    UX_PARAMETER_NOT_USED(scsi_command);

    /* By default status is passed.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 801171a:	68fb      	ldr	r3, [r7, #12]
 801171c:	2200      	movs	r2, #0
 801171e:	651a      	str	r2, [r3, #80]	; 0x50

    /* Is there not an implementation?  */
    if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_flush == UX_NULL)
 8011720:	68f9      	ldr	r1, [r7, #12]
 8011722:	68ba      	ldr	r2, [r7, #8]
 8011724:	4613      	mov	r3, r2
 8011726:	00db      	lsls	r3, r3, #3
 8011728:	1a9b      	subs	r3, r3, r2
 801172a:	00db      	lsls	r3, r3, #3
 801172c:	440b      	add	r3, r1
 801172e:	3334      	adds	r3, #52	; 0x34
 8011730:	681b      	ldr	r3, [r3, #0]
 8011732:	2b00      	cmp	r3, #0
 8011734:	d101      	bne.n	801173a <_ux_device_class_storage_synchronize_cache+0x2e>
    {

        /* This means the application is not using a cache.  */

        /* Return success.  */
        return(UX_SUCCESS);
 8011736:	2300      	movs	r3, #0
 8011738:	e07b      	b.n	8011832 <_ux_device_class_storage_synchronize_cache+0x126>
    }

    /* Get the LBA and number of blocks from the CBWCB in 16 bits.  */
    lba           =         _ux_utility_long_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_SYNCHRONIZE_CACHE_LBA);
 801173a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801173c:	3302      	adds	r3, #2
 801173e:	4618      	mov	r0, r3
 8011740:	f7fd fe87 	bl	800f452 <_ux_utility_long_get_big_endian>
 8011744:	6278      	str	r0, [r7, #36]	; 0x24
    number_blocks = (USHORT)_ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_SYNCHRONIZE_CACHE_NUMBER_OF_BLOCKS);
 8011746:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011748:	3307      	adds	r3, #7
 801174a:	4618      	mov	r0, r3
 801174c:	f7fe f9ce 	bl	800faec <_ux_utility_short_get_big_endian>
 8011750:	4603      	mov	r3, r0
 8011752:	847b      	strh	r3, [r7, #34]	; 0x22

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_SYNCHRONIZE_CACHE, storage, lun, lba, number_blocks, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the status of the device.  */
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, 
 8011754:	68f9      	ldr	r1, [r7, #12]
 8011756:	68bb      	ldr	r3, [r7, #8]
 8011758:	1c5a      	adds	r2, r3, #1
 801175a:	4613      	mov	r3, r2
 801175c:	00db      	lsls	r3, r3, #3
 801175e:	1a9b      	subs	r3, r3, r2
 8011760:	00db      	lsls	r3, r3, #3
 8011762:	440b      	add	r3, r1
 8011764:	681c      	ldr	r4, [r3, #0]
 8011766:	68f9      	ldr	r1, [r7, #12]
 8011768:	68ba      	ldr	r2, [r7, #8]
 801176a:	4613      	mov	r3, r2
 801176c:	00db      	lsls	r3, r3, #3
 801176e:	1a9b      	subs	r3, r3, r2
 8011770:	00db      	lsls	r3, r3, #3
 8011772:	440b      	add	r3, r1
 8011774:	331c      	adds	r3, #28
 8011776:	681a      	ldr	r2, [r3, #0]
 8011778:	f107 0314 	add.w	r3, r7, #20
 801177c:	68b9      	ldr	r1, [r7, #8]
 801177e:	68f8      	ldr	r0, [r7, #12]
 8011780:	47a0      	blx	r4
 8011782:	61f8      	str	r0, [r7, #28]
                            lun, storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);

    /* Update the request sense.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
 8011784:	6979      	ldr	r1, [r7, #20]
 8011786:	68f8      	ldr	r0, [r7, #12]
 8011788:	68ba      	ldr	r2, [r7, #8]
 801178a:	4613      	mov	r3, r2
 801178c:	00db      	lsls	r3, r3, #3
 801178e:	1a9b      	subs	r3, r3, r2
 8011790:	00db      	lsls	r3, r3, #3
 8011792:	4403      	add	r3, r0
 8011794:	3320      	adds	r3, #32
 8011796:	6019      	str	r1, [r3, #0]

    /* If there is a problem, return a failed command.  */
    if (status != UX_SUCCESS)
 8011798:	69fb      	ldr	r3, [r7, #28]
 801179a:	2b00      	cmp	r3, #0
 801179c:	d007      	beq.n	80117ae <_ux_device_class_storage_synchronize_cache+0xa2>
    {

        /* We have a problem, media status error. Return a bad completion and wait for the
           REQUEST_SENSE command.  */
#if !defined(UX_DEVICE_STANDALONE)
        _ux_device_stack_endpoint_stall(endpoint_in);
 801179e:	6878      	ldr	r0, [r7, #4]
 80117a0:	f7fd fa38 	bl	800ec14 <_ux_device_stack_endpoint_stall>
#else
        UX_PARAMETER_NOT_USED(endpoint_in);
        storage -> ux_device_class_storage_cmd_state = UX_DEVICE_CLASS_STORAGE_CMD_ERR;
#endif

        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
 80117a4:	68fb      	ldr	r3, [r7, #12]
 80117a6:	2201      	movs	r2, #1
 80117a8:	651a      	str	r2, [r3, #80]	; 0x50

        /* We are done here.  */
        return(UX_ERROR);
 80117aa:	23ff      	movs	r3, #255	; 0xff
 80117ac:	e041      	b.n	8011832 <_ux_device_class_storage_synchronize_cache+0x126>
    storage -> ux_device_class_storage_cmd_n_lb = number_blocks;

#else

    /* Get the flags.  */
    flags =  *(cbwcb + UX_SLAVE_CLASS_STORAGE_SYNCHRONIZE_CACHE_FLAGS);
 80117ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80117b0:	785b      	ldrb	r3, [r3, #1]
 80117b2:	76fb      	strb	r3, [r7, #27]

    /* If the immediate bit is set, we return a CSW before flush.  */
    if ((flags & UX_SLAVE_CLASS_STORAGE_SYNCHRONIZE_CACHE_FLAGS_IMMED) != 0)
 80117b4:	7efb      	ldrb	r3, [r7, #27]
 80117b6:	f003 0302 	and.w	r3, r3, #2
 80117ba:	2b00      	cmp	r3, #0
 80117bc:	d005      	beq.n	80117ca <_ux_device_class_storage_synchronize_cache+0xbe>
        _ux_device_class_storage_csw_send(storage, lun, endpoint_in, UX_SLAVE_CLASS_STORAGE_CSW_PASSED);
 80117be:	2300      	movs	r3, #0
 80117c0:	687a      	ldr	r2, [r7, #4]
 80117c2:	68b9      	ldr	r1, [r7, #8]
 80117c4:	68f8      	ldr	r0, [r7, #12]
 80117c6:	f7ff f92f 	bl	8010a28 <_ux_device_class_storage_csw_send>

    /* Send the flush command to the local media.  */
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_flush(storage, lun, number_blocks, lba, &media_status);
 80117ca:	68f9      	ldr	r1, [r7, #12]
 80117cc:	68ba      	ldr	r2, [r7, #8]
 80117ce:	4613      	mov	r3, r2
 80117d0:	00db      	lsls	r3, r3, #3
 80117d2:	1a9b      	subs	r3, r3, r2
 80117d4:	00db      	lsls	r3, r3, #3
 80117d6:	440b      	add	r3, r1
 80117d8:	3334      	adds	r3, #52	; 0x34
 80117da:	681c      	ldr	r4, [r3, #0]
 80117dc:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 80117de:	f107 0314 	add.w	r3, r7, #20
 80117e2:	9300      	str	r3, [sp, #0]
 80117e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80117e6:	68b9      	ldr	r1, [r7, #8]
 80117e8:	68f8      	ldr	r0, [r7, #12]
 80117ea:	47a0      	blx	r4
 80117ec:	61f8      	str	r0, [r7, #28]

    /* Update the request sense.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
 80117ee:	6979      	ldr	r1, [r7, #20]
 80117f0:	68f8      	ldr	r0, [r7, #12]
 80117f2:	68ba      	ldr	r2, [r7, #8]
 80117f4:	4613      	mov	r3, r2
 80117f6:	00db      	lsls	r3, r3, #3
 80117f8:	1a9b      	subs	r3, r3, r2
 80117fa:	00db      	lsls	r3, r3, #3
 80117fc:	4403      	add	r3, r0
 80117fe:	3320      	adds	r3, #32
 8011800:	6019      	str	r1, [r3, #0]

    /* If the immediate bit is set, we are already done, no matter what local operation status is.  */
    if ((flags & UX_SLAVE_CLASS_STORAGE_SYNCHRONIZE_CACHE_FLAGS_IMMED) != 0)
 8011802:	7efb      	ldrb	r3, [r7, #27]
 8011804:	f003 0302 	and.w	r3, r3, #2
 8011808:	2b00      	cmp	r3, #0
 801180a:	d006      	beq.n	801181a <_ux_device_class_storage_synchronize_cache+0x10e>
    {

        /* CSW skipped since already sent in this function.  */
        UX_DEVICE_CLASS_STORAGE_CSW_SKIP(&storage -> ux_slave_class_storage_csw_status) = UX_TRUE;
 801180c:	68fb      	ldr	r3, [r7, #12]
 801180e:	3350      	adds	r3, #80	; 0x50
 8011810:	3303      	adds	r3, #3
 8011812:	2201      	movs	r2, #1
 8011814:	701a      	strb	r2, [r3, #0]
        return(status);
 8011816:	69fb      	ldr	r3, [r7, #28]
 8011818:	e00b      	b.n	8011832 <_ux_device_class_storage_synchronize_cache+0x126>
    }

    /* If there is a problem, return a failed command.  */
    if (status != UX_SUCCESS)
 801181a:	69fb      	ldr	r3, [r7, #28]
 801181c:	2b00      	cmp	r3, #0
 801181e:	d007      	beq.n	8011830 <_ux_device_class_storage_synchronize_cache+0x124>
    {

        /* We have a problem, request error. Return a bad completion and wait for the
           REQUEST_SENSE command.  */
        _ux_device_stack_endpoint_stall(endpoint_in);
 8011820:	6878      	ldr	r0, [r7, #4]
 8011822:	f7fd f9f7 	bl	800ec14 <_ux_device_stack_endpoint_stall>

        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
 8011826:	68fb      	ldr	r3, [r7, #12]
 8011828:	2201      	movs	r2, #1
 801182a:	651a      	str	r2, [r3, #80]	; 0x50

        /* Return an error.  */
        return(UX_ERROR);
 801182c:	23ff      	movs	r3, #255	; 0xff
 801182e:	e000      	b.n	8011832 <_ux_device_class_storage_synchronize_cache+0x126>
    }
#endif

    /* Return completion status.  */
    return(status);
 8011830:	69fb      	ldr	r3, [r7, #28]
}
 8011832:	4618      	mov	r0, r3
 8011834:	372c      	adds	r7, #44	; 0x2c
 8011836:	46bd      	mov	sp, r7
 8011838:	bd90      	pop	{r4, r7, pc}

0801183a <_ux_device_class_storage_test_ready>:
/*                                            resulting in version 6.1.10 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_test_ready(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, UX_SLAVE_ENDPOINT *endpoint_in,
                                          UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
 801183a:	b590      	push	{r4, r7, lr}
 801183c:	b087      	sub	sp, #28
 801183e:	af00      	add	r7, sp, #0
 8011840:	60f8      	str	r0, [r7, #12]
 8011842:	60b9      	str	r1, [r7, #8]
 8011844:	607a      	str	r2, [r7, #4]
 8011846:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_TEST_READY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the status of the device.  */
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, lun, 
 8011848:	68f9      	ldr	r1, [r7, #12]
 801184a:	68bb      	ldr	r3, [r7, #8]
 801184c:	1c5a      	adds	r2, r3, #1
 801184e:	4613      	mov	r3, r2
 8011850:	00db      	lsls	r3, r3, #3
 8011852:	1a9b      	subs	r3, r3, r2
 8011854:	00db      	lsls	r3, r3, #3
 8011856:	440b      	add	r3, r1
 8011858:	681c      	ldr	r4, [r3, #0]
 801185a:	68f9      	ldr	r1, [r7, #12]
 801185c:	68ba      	ldr	r2, [r7, #8]
 801185e:	4613      	mov	r3, r2
 8011860:	00db      	lsls	r3, r3, #3
 8011862:	1a9b      	subs	r3, r3, r2
 8011864:	00db      	lsls	r3, r3, #3
 8011866:	440b      	add	r3, r1
 8011868:	331c      	adds	r3, #28
 801186a:	681a      	ldr	r2, [r3, #0]
 801186c:	f107 0310 	add.w	r3, r7, #16
 8011870:	68b9      	ldr	r1, [r7, #8]
 8011872:	68f8      	ldr	r0, [r7, #12]
 8011874:	47a0      	blx	r4
 8011876:	6178      	str	r0, [r7, #20]
                                storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);

    /* Set the sense/code/qualifier codes for the REQUEST_SENSE command.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
 8011878:	6939      	ldr	r1, [r7, #16]
 801187a:	68f8      	ldr	r0, [r7, #12]
 801187c:	68ba      	ldr	r2, [r7, #8]
 801187e:	4613      	mov	r3, r2
 8011880:	00db      	lsls	r3, r3, #3
 8011882:	1a9b      	subs	r3, r3, r2
 8011884:	00db      	lsls	r3, r3, #3
 8011886:	4403      	add	r3, r0
 8011888:	3320      	adds	r3, #32
 801188a:	6019      	str	r1, [r3, #0]

    /* Return CSW with success/error.  */
    storage -> ux_slave_class_storage_csw_status = (status == UX_SUCCESS) ?
                            UX_SLAVE_CLASS_STORAGE_CSW_PASSED : UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
 801188c:	697b      	ldr	r3, [r7, #20]
 801188e:	2b00      	cmp	r3, #0
 8011890:	bf14      	ite	ne
 8011892:	2301      	movne	r3, #1
 8011894:	2300      	moveq	r3, #0
 8011896:	b2db      	uxtb	r3, r3
 8011898:	461a      	mov	r2, r3
    storage -> ux_slave_class_storage_csw_status = (status == UX_SUCCESS) ?
 801189a:	68fb      	ldr	r3, [r7, #12]
 801189c:	651a      	str	r2, [r3, #80]	; 0x50
    status = UX_SUCCESS;
 801189e:	2300      	movs	r3, #0
 80118a0:	617b      	str	r3, [r7, #20]

#if !defined(UX_DEVICE_STANDALONE)

    /* Case (9) Ho > Dn.  */
    if (storage -> ux_slave_class_storage_host_length)
 80118a2:	68fb      	ldr	r3, [r7, #12]
 80118a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80118a6:	2b00      	cmp	r3, #0
 80118a8:	d006      	beq.n	80118b8 <_ux_device_class_storage_test_ready+0x7e>
    {
        _ux_device_stack_endpoint_stall(endpoint_out);
 80118aa:	6838      	ldr	r0, [r7, #0]
 80118ac:	f7fd f9b2 	bl	800ec14 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length;
 80118b0:	68fb      	ldr	r3, [r7, #12]
 80118b2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80118b4:	68fb      	ldr	r3, [r7, #12]
 80118b6:	64da      	str	r2, [r3, #76]	; 0x4c
    }
#endif

    /* Return completion status.  */
    return(status);
 80118b8:	697b      	ldr	r3, [r7, #20]
}
 80118ba:	4618      	mov	r0, r3
 80118bc:	371c      	adds	r7, #28
 80118be:	46bd      	mov	sp, r7
 80118c0:	bd90      	pop	{r4, r7, pc}
	...

080118c4 <_ux_device_class_storage_thread>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
VOID  _ux_device_class_storage_thread(ULONG storage_class)
{
 80118c4:	b580      	push	{r7, lr}
 80118c6:	b092      	sub	sp, #72	; 0x48
 80118c8:	af02      	add	r7, sp, #8
 80118ca:	6078      	str	r0, [r7, #4]
    /* This thread runs forever but can be suspended or resumed.  */
    while(1)
    {

        /* Cast properly the storage instance.  */
        UX_THREAD_EXTENSION_PTR_GET(class_ptr, UX_SLAVE_CLASS, storage_class)
 80118cc:	687b      	ldr	r3, [r7, #4]
 80118ce:	633b      	str	r3, [r7, #48]	; 0x30
        
        /* Get the storage instance from this class container.  */
        storage =  (UX_SLAVE_CLASS_STORAGE *) class_ptr -> ux_slave_class_instance;
 80118d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80118d2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80118d4:	62fb      	str	r3, [r7, #44]	; 0x2c
    
        /* Get the pointer to the device.  */
        device =  &_ux_system_slave -> ux_system_slave_device;
 80118d6:	4bb9      	ldr	r3, [pc, #740]	; (8011bbc <_ux_device_class_storage_thread+0x2f8>)
 80118d8:	681b      	ldr	r3, [r3, #0]
 80118da:	3320      	adds	r3, #32
 80118dc:	62bb      	str	r3, [r7, #40]	; 0x28
        
        /* As long as the device is in the CONFIGURED state.  */
        while (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
 80118de:	e238      	b.n	8011d52 <_ux_device_class_storage_thread+0x48e>
        { 

            /* We are activated. We need the interface to the class.  */
            interface_ptr =  storage -> ux_slave_class_storage_interface;
 80118e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80118e2:	681b      	ldr	r3, [r3, #0]
 80118e4:	627b      	str	r3, [r7, #36]	; 0x24

            /* We assume the worst situation.  */
            status =  UX_ERROR;
 80118e6:	23ff      	movs	r3, #255	; 0xff
 80118e8:	637b      	str	r3, [r7, #52]	; 0x34

            /* Locate the endpoints.  */
            endpoint_in =  interface_ptr -> ux_slave_interface_first_endpoint;
 80118ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80118ec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80118ee:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Check the endpoint direction, if IN we have the correct endpoint.  */
            if ((endpoint_in -> ux_slave_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) != UX_ENDPOINT_IN)
 80118f0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80118f2:	695b      	ldr	r3, [r3, #20]
 80118f4:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80118f8:	2b00      	cmp	r3, #0
 80118fa:	d105      	bne.n	8011908 <_ux_device_class_storage_thread+0x44>
            {

                /* Wrong direction, we found the OUT endpoint first.  */
                endpoint_out =  endpoint_in;
 80118fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80118fe:	63bb      	str	r3, [r7, #56]	; 0x38

                /* So the next endpoint has to be the IN endpoint.  */
                endpoint_in =  endpoint_out -> ux_slave_endpoint_next_endpoint;
 8011900:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011902:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011904:	63fb      	str	r3, [r7, #60]	; 0x3c
 8011906:	e002      	b.n	801190e <_ux_device_class_storage_thread+0x4a>
            }
            else
            {

                /* We found the endpoint IN first, so next endpoint is OUT.  */
                endpoint_out =  endpoint_in -> ux_slave_endpoint_next_endpoint;
 8011908:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801190a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801190c:	63bb      	str	r3, [r7, #56]	; 0x38
            }

            /* All SCSI commands are on the endpoint OUT, from the host.  */
            transfer_request =  &endpoint_out -> ux_slave_endpoint_transfer_request;
 801190e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011910:	3330      	adds	r3, #48	; 0x30
 8011912:	623b      	str	r3, [r7, #32]

            /* Check state, they must be both RESET.  */
            if (endpoint_out -> ux_slave_endpoint_state == UX_ENDPOINT_RESET &&
 8011914:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011916:	685b      	ldr	r3, [r3, #4]
 8011918:	2b00      	cmp	r3, #0
 801191a:	d10a      	bne.n	8011932 <_ux_device_class_storage_thread+0x6e>
                (UCHAR)storage -> ux_slave_class_storage_csw_status != UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR)
 801191c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801191e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8011920:	b2db      	uxtb	r3, r3
            if (endpoint_out -> ux_slave_endpoint_state == UX_ENDPOINT_RESET &&
 8011922:	2b02      	cmp	r3, #2
 8011924:	d005      	beq.n	8011932 <_ux_device_class_storage_thread+0x6e>
            {

                /* Send the request to the device controller.  */
                status =  _ux_device_stack_transfer_request(transfer_request, 64, 64);
 8011926:	2240      	movs	r2, #64	; 0x40
 8011928:	2140      	movs	r1, #64	; 0x40
 801192a:	6a38      	ldr	r0, [r7, #32]
 801192c:	f7fd fba4 	bl	800f078 <_ux_device_stack_transfer_request>
 8011930:	6378      	str	r0, [r7, #52]	; 0x34

            }                
    
            /* Check the status. Our status is UX_ERROR if one of the endpoint was STALLED. We must wait for the host
               to clear the mess.   */    
            if (status == UX_SUCCESS)
 8011932:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011934:	2b00      	cmp	r3, #0
 8011936:	f040 81fe 	bne.w	8011d36 <_ux_device_class_storage_thread+0x472>
            {

                /* Obtain the length of the transaction.  */
                length =  transfer_request -> ux_slave_transfer_request_actual_length;
 801193a:	6a3b      	ldr	r3, [r7, #32]
 801193c:	699b      	ldr	r3, [r3, #24]
 801193e:	61fb      	str	r3, [r7, #28]
                
                /* Obtain the buffer address containing the SCSI command.  */
                scsi_command =  transfer_request -> ux_slave_transfer_request_data_pointer;
 8011940:	6a3b      	ldr	r3, [r7, #32]
 8011942:	68db      	ldr	r3, [r3, #12]
 8011944:	61bb      	str	r3, [r7, #24]
                
                /* Obtain the lun from the CBW.  */
                lun =  (ULONG) *(scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_LUN);
 8011946:	69bb      	ldr	r3, [r7, #24]
 8011948:	330d      	adds	r3, #13
 801194a:	781b      	ldrb	r3, [r3, #0]
 801194c:	617b      	str	r3, [r7, #20]
                storage -> ux_slave_class_storage_cbw_lun = (UCHAR)lun;
 801194e:	697b      	ldr	r3, [r7, #20]
 8011950:	b2da      	uxtb	r2, r3
 8011952:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011954:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
                
                /* We have to memorize the SCSI command tag for the CSW phase.  */
                storage -> ux_slave_class_storage_scsi_tag =  _ux_utility_long_get(scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_TAG);
 8011958:	69bb      	ldr	r3, [r7, #24]
 801195a:	3304      	adds	r3, #4
 801195c:	4618      	mov	r0, r3
 801195e:	f7fd fd52 	bl	800f406 <_ux_utility_long_get>
 8011962:	4602      	mov	r2, r0
 8011964:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011966:	649a      	str	r2, [r3, #72]	; 0x48

                /* Get dCBWDataTransferLength: number of bytes to transfer.  */
                storage -> ux_slave_class_storage_host_length = _ux_utility_long_get(scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_DATA_LENGTH);
 8011968:	69bb      	ldr	r3, [r7, #24]
 801196a:	3308      	adds	r3, #8
 801196c:	4618      	mov	r0, r3
 801196e:	f7fd fd4a 	bl	800f406 <_ux_utility_long_get>
 8011972:	4602      	mov	r2, r0
 8011974:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011976:	641a      	str	r2, [r3, #64]	; 0x40

                /* Save bmCBWFlags.  */
                storage -> ux_slave_class_storage_cbw_flags = *(scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_FLAGS);
 8011978:	69bb      	ldr	r3, [r7, #24]
 801197a:	7b1a      	ldrb	r2, [r3, #12]
 801197c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801197e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

                /* Reset CSW status.  */
                storage -> ux_slave_class_storage_csw_residue = 0;
 8011982:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011984:	2200      	movs	r2, #0
 8011986:	64da      	str	r2, [r3, #76]	; 0x4c
                storage -> ux_slave_class_storage_csw_status = 0;
 8011988:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801198a:	2200      	movs	r2, #0
 801198c:	651a      	str	r2, [r3, #80]	; 0x50

                /* Ensure the LUN number is within our declared values and check the command 
                   content and format. First we make sure we have a complete CBW.  */
                if ((lun < storage -> ux_slave_class_storage_number_lun) && (length == UX_SLAVE_CLASS_STORAGE_CBW_LENGTH))
 801198e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011990:	685b      	ldr	r3, [r3, #4]
 8011992:	697a      	ldr	r2, [r7, #20]
 8011994:	429a      	cmp	r2, r3
 8011996:	f080 81c8 	bcs.w	8011d2a <_ux_device_class_storage_thread+0x466>
 801199a:	69fb      	ldr	r3, [r7, #28]
 801199c:	2b1f      	cmp	r3, #31
 801199e:	f040 81c4 	bne.w	8011d2a <_ux_device_class_storage_thread+0x466>
                {

                    /* The length of the CBW is correct, analyze the header.  */
                    if (_ux_utility_long_get(scsi_command) == UX_SLAVE_CLASS_STORAGE_CBW_SIGNATURE_MASK)
 80119a2:	69b8      	ldr	r0, [r7, #24]
 80119a4:	f7fd fd2f 	bl	800f406 <_ux_utility_long_get>
 80119a8:	4603      	mov	r3, r0
 80119aa:	4a85      	ldr	r2, [pc, #532]	; (8011bc0 <_ux_device_class_storage_thread+0x2fc>)
 80119ac:	4293      	cmp	r3, r2
 80119ae:	f040 81b8 	bne.w	8011d22 <_ux_device_class_storage_thread+0x45e>
                    {

                        /* Get the length of the CBWCB.  */
                        cbwcb_length =  (ULONG) *(scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_CB_LENGTH);
 80119b2:	69bb      	ldr	r3, [r7, #24]
 80119b4:	330e      	adds	r3, #14
 80119b6:	781b      	ldrb	r3, [r3, #0]
 80119b8:	613b      	str	r3, [r7, #16]
    
                        /* Check the length of the CBWCB to ensure there is at least a command.  */
                        if (cbwcb_length != 0)
 80119ba:	693b      	ldr	r3, [r7, #16]
 80119bc:	2b00      	cmp	r3, #0
 80119be:	f000 81ac 	beq.w	8011d1a <_ux_device_class_storage_thread+0x456>
                        {

                            /* Analyze the command stored in the CBWCB.  */
                            cbw_cb = scsi_command + UX_SLAVE_CLASS_STORAGE_CBW_CB;
 80119c2:	69bb      	ldr	r3, [r7, #24]
 80119c4:	330f      	adds	r3, #15
 80119c6:	60fb      	str	r3, [r7, #12]
                            switch (*(cbw_cb))
 80119c8:	68fb      	ldr	r3, [r7, #12]
 80119ca:	781b      	ldrb	r3, [r3, #0]
 80119cc:	2baa      	cmp	r3, #170	; 0xaa
 80119ce:	f000 8145 	beq.w	8011c5c <_ux_device_class_storage_thread+0x398>
 80119d2:	2baa      	cmp	r3, #170	; 0xaa
 80119d4:	f300 8164 	bgt.w	8011ca0 <_ux_device_class_storage_thread+0x3dc>
 80119d8:	2b5a      	cmp	r3, #90	; 0x5a
 80119da:	f300 80bf 	bgt.w	8011b5c <_ux_device_class_storage_thread+0x298>
 80119de:	2b00      	cmp	r3, #0
 80119e0:	f2c0 815e 	blt.w	8011ca0 <_ux_device_class_storage_thread+0x3dc>
 80119e4:	2b5a      	cmp	r3, #90	; 0x5a
 80119e6:	f200 815b 	bhi.w	8011ca0 <_ux_device_class_storage_thread+0x3dc>
 80119ea:	a201      	add	r2, pc, #4	; (adr r2, 80119f0 <_ux_device_class_storage_thread+0x12c>)
 80119ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80119f0:	08011b63 	.word	0x08011b63
 80119f4:	08011ca1 	.word	0x08011ca1
 80119f8:	08011ca1 	.word	0x08011ca1
 80119fc:	08011b75 	.word	0x08011b75
 8011a00:	08011b87 	.word	0x08011b87
 8011a04:	08011ca1 	.word	0x08011ca1
 8011a08:	08011ca1 	.word	0x08011ca1
 8011a0c:	08011ca1 	.word	0x08011ca1
 8011a10:	08011ca1 	.word	0x08011ca1
 8011a14:	08011ca1 	.word	0x08011ca1
 8011a18:	08011ca1 	.word	0x08011ca1
 8011a1c:	08011ca1 	.word	0x08011ca1
 8011a20:	08011ca1 	.word	0x08011ca1
 8011a24:	08011ca1 	.word	0x08011ca1
 8011a28:	08011ca1 	.word	0x08011ca1
 8011a2c:	08011ca1 	.word	0x08011ca1
 8011a30:	08011ca1 	.word	0x08011ca1
 8011a34:	08011ca1 	.word	0x08011ca1
 8011a38:	08011b99 	.word	0x08011b99
 8011a3c:	08011ca1 	.word	0x08011ca1
 8011a40:	08011ca1 	.word	0x08011ca1
 8011a44:	08011ca1 	.word	0x08011ca1
 8011a48:	08011ca1 	.word	0x08011ca1
 8011a4c:	08011ca1 	.word	0x08011ca1
 8011a50:	08011ca1 	.word	0x08011ca1
 8011a54:	08011ca1 	.word	0x08011ca1
 8011a58:	08011c1f 	.word	0x08011c1f
 8011a5c:	08011bab 	.word	0x08011bab
 8011a60:	08011ca1 	.word	0x08011ca1
 8011a64:	08011ca1 	.word	0x08011ca1
 8011a68:	08011bc5 	.word	0x08011bc5
 8011a6c:	08011ca1 	.word	0x08011ca1
 8011a70:	08011ca1 	.word	0x08011ca1
 8011a74:	08011ca1 	.word	0x08011ca1
 8011a78:	08011ca1 	.word	0x08011ca1
 8011a7c:	08011bd7 	.word	0x08011bd7
 8011a80:	08011ca1 	.word	0x08011ca1
 8011a84:	08011be9 	.word	0x08011be9
 8011a88:	08011ca1 	.word	0x08011ca1
 8011a8c:	08011ca1 	.word	0x08011ca1
 8011a90:	08011c47 	.word	0x08011c47
 8011a94:	08011ca1 	.word	0x08011ca1
 8011a98:	08011c73 	.word	0x08011c73
 8011a9c:	08011ca1 	.word	0x08011ca1
 8011aa0:	08011ca1 	.word	0x08011ca1
 8011aa4:	08011ca1 	.word	0x08011ca1
 8011aa8:	08011ca1 	.word	0x08011ca1
 8011aac:	08011bfb 	.word	0x08011bfb
 8011ab0:	08011ca1 	.word	0x08011ca1
 8011ab4:	08011ca1 	.word	0x08011ca1
 8011ab8:	08011ca1 	.word	0x08011ca1
 8011abc:	08011ca1 	.word	0x08011ca1
 8011ac0:	08011ca1 	.word	0x08011ca1
 8011ac4:	08011c89 	.word	0x08011c89
 8011ac8:	08011ca1 	.word	0x08011ca1
 8011acc:	08011ca1 	.word	0x08011ca1
 8011ad0:	08011ca1 	.word	0x08011ca1
 8011ad4:	08011ca1 	.word	0x08011ca1
 8011ad8:	08011ca1 	.word	0x08011ca1
 8011adc:	08011ca1 	.word	0x08011ca1
 8011ae0:	08011ca1 	.word	0x08011ca1
 8011ae4:	08011ca1 	.word	0x08011ca1
 8011ae8:	08011ca1 	.word	0x08011ca1
 8011aec:	08011ca1 	.word	0x08011ca1
 8011af0:	08011ca1 	.word	0x08011ca1
 8011af4:	08011ca1 	.word	0x08011ca1
 8011af8:	08011ca1 	.word	0x08011ca1
 8011afc:	08011ca1 	.word	0x08011ca1
 8011b00:	08011ca1 	.word	0x08011ca1
 8011b04:	08011ca1 	.word	0x08011ca1
 8011b08:	08011ca1 	.word	0x08011ca1
 8011b0c:	08011ca1 	.word	0x08011ca1
 8011b10:	08011ca1 	.word	0x08011ca1
 8011b14:	08011ca1 	.word	0x08011ca1
 8011b18:	08011ca1 	.word	0x08011ca1
 8011b1c:	08011ca1 	.word	0x08011ca1
 8011b20:	08011ca1 	.word	0x08011ca1
 8011b24:	08011ca1 	.word	0x08011ca1
 8011b28:	08011ca1 	.word	0x08011ca1
 8011b2c:	08011ca1 	.word	0x08011ca1
 8011b30:	08011ca1 	.word	0x08011ca1
 8011b34:	08011ca1 	.word	0x08011ca1
 8011b38:	08011ca1 	.word	0x08011ca1
 8011b3c:	08011ca1 	.word	0x08011ca1
 8011b40:	08011ca1 	.word	0x08011ca1
 8011b44:	08011c0d 	.word	0x08011c0d
 8011b48:	08011ca1 	.word	0x08011ca1
 8011b4c:	08011ca1 	.word	0x08011ca1
 8011b50:	08011ca1 	.word	0x08011ca1
 8011b54:	08011ca1 	.word	0x08011ca1
 8011b58:	08011c1f 	.word	0x08011c1f
 8011b5c:	2ba8      	cmp	r3, #168	; 0xa8
 8011b5e:	d067      	beq.n	8011c30 <_ux_device_class_storage_thread+0x36c>
 8011b60:	e09e      	b.n	8011ca0 <_ux_device_class_storage_thread+0x3dc>
                            {

                            case UX_SLAVE_CLASS_STORAGE_SCSI_TEST_READY:

                                _ux_device_class_storage_test_ready(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011b62:	68fb      	ldr	r3, [r7, #12]
 8011b64:	9300      	str	r3, [sp, #0]
 8011b66:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011b68:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011b6a:	6979      	ldr	r1, [r7, #20]
 8011b6c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011b6e:	f7ff fe64 	bl	801183a <_ux_device_class_storage_test_ready>
                                break;
 8011b72:	e0c2      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
                                    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_REQUEST_SENSE:

                                _ux_device_class_storage_request_sense(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011b74:	68fb      	ldr	r3, [r7, #12]
 8011b76:	9300      	str	r3, [sp, #0]
 8011b78:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011b7a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011b7c:	6979      	ldr	r1, [r7, #20]
 8011b7e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011b80:	f7ff fd4c 	bl	801161c <_ux_device_class_storage_request_sense>
                                break;
 8011b84:	e0b9      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_FORMAT:

                                _ux_device_class_storage_format(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011b86:	68fb      	ldr	r3, [r7, #12]
 8011b88:	9300      	str	r3, [sp, #0]
 8011b8a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011b8c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011b8e:	6979      	ldr	r1, [r7, #20]
 8011b90:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011b92:	f7ff f809 	bl	8010ba8 <_ux_device_class_storage_format>
                                break;
 8011b96:	e0b0      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_INQUIRY:

                                _ux_device_class_storage_inquiry(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011b98:	68fb      	ldr	r3, [r7, #12]
 8011b9a:	9300      	str	r3, [sp, #0]
 8011b9c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011b9e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011ba0:	6979      	ldr	r1, [r7, #20]
 8011ba2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011ba4:	f7ff f9a4 	bl	8010ef0 <_ux_device_class_storage_inquiry>
                                break;
 8011ba8:	e0a7      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_START_STOP:

                                _ux_device_class_storage_start_stop(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011baa:	68fb      	ldr	r3, [r7, #12]
 8011bac:	9300      	str	r3, [sp, #0]
 8011bae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011bb0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011bb2:	6979      	ldr	r1, [r7, #20]
 8011bb4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011bb6:	f7ff fd98 	bl	80116ea <_ux_device_class_storage_start_stop>
                                break;
 8011bba:	e09e      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
 8011bbc:	2000730c 	.word	0x2000730c
 8011bc0:	43425355 	.word	0x43425355
                                    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_PREVENT_ALLOW_MEDIA_REMOVAL:

                                _ux_device_class_storage_prevent_allow_media_removal(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011bc4:	68fb      	ldr	r3, [r7, #12]
 8011bc6:	9300      	str	r3, [sp, #0]
 8011bc8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011bca:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011bcc:	6979      	ldr	r1, [r7, #20]
 8011bce:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011bd0:	f7ff fb57 	bl	8011282 <_ux_device_class_storage_prevent_allow_media_removal>
                                break;
 8011bd4:	e091      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_READ_FORMAT_CAPACITY:

                                _ux_device_class_storage_read_format_capacity(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011bd6:	68fb      	ldr	r3, [r7, #12]
 8011bd8:	9300      	str	r3, [sp, #0]
 8011bda:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011bdc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011bde:	6979      	ldr	r1, [r7, #20]
 8011be0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011be2:	f7ff fcd5 	bl	8011590 <_ux_device_class_storage_read_format_capacity>
                                break;
 8011be6:	e088      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_READ_CAPACITY:

                                _ux_device_class_storage_read_capacity(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011be8:	68fb      	ldr	r3, [r7, #12]
 8011bea:	9300      	str	r3, [sp, #0]
 8011bec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011bee:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011bf0:	6979      	ldr	r1, [r7, #20]
 8011bf2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011bf4:	f7ff fc62 	bl	80114bc <_ux_device_class_storage_read_capacity>
                                break;
 8011bf8:	e07f      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_VERIFY:

                                _ux_device_class_storage_verify(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011bfa:	68fb      	ldr	r3, [r7, #12]
 8011bfc:	9300      	str	r3, [sp, #0]
 8011bfe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011c00:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011c02:	6979      	ldr	r1, [r7, #20]
 8011c04:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011c06:	f000 f8cf 	bl	8011da8 <_ux_device_class_storage_verify>
                                break;
 8011c0a:	e076      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SELECT:

                                _ux_device_class_storage_mode_select(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011c0c:	68fb      	ldr	r3, [r7, #12]
 8011c0e:	9300      	str	r3, [sp, #0]
 8011c10:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011c12:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011c14:	6979      	ldr	r1, [r7, #20]
 8011c16:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011c18:	f7ff fa54 	bl	80110c4 <_ux_device_class_storage_mode_select>
                                break;
 8011c1c:	e06d      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SENSE_SHORT:
                            case UX_SLAVE_CLASS_STORAGE_SCSI_MODE_SENSE:

                                _ux_device_class_storage_mode_sense(storage, lun, endpoint_in, endpoint_out, cbw_cb);
 8011c1e:	68fb      	ldr	r3, [r7, #12]
 8011c20:	9300      	str	r3, [sp, #0]
 8011c22:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011c24:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011c26:	6979      	ldr	r1, [r7, #20]
 8011c28:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011c2a:	f7ff fa77 	bl	801111c <_ux_device_class_storage_mode_sense>
                                break;
 8011c2e:	e064      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_READ32:

                                _ux_device_class_storage_read(storage, lun, endpoint_in, endpoint_out, cbw_cb, 
 8011c30:	23a8      	movs	r3, #168	; 0xa8
 8011c32:	9301      	str	r3, [sp, #4]
 8011c34:	68fb      	ldr	r3, [r7, #12]
 8011c36:	9300      	str	r3, [sp, #0]
 8011c38:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011c3a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011c3c:	6979      	ldr	r1, [r7, #20]
 8011c3e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011c40:	f7ff fb30 	bl	80112a4 <_ux_device_class_storage_read>
                                                                UX_SLAVE_CLASS_STORAGE_SCSI_READ32);
                                break;
 8011c44:	e059      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_READ16:

                                _ux_device_class_storage_read(storage, lun, endpoint_in, endpoint_out, cbw_cb, 
 8011c46:	2328      	movs	r3, #40	; 0x28
 8011c48:	9301      	str	r3, [sp, #4]
 8011c4a:	68fb      	ldr	r3, [r7, #12]
 8011c4c:	9300      	str	r3, [sp, #0]
 8011c4e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011c50:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011c52:	6979      	ldr	r1, [r7, #20]
 8011c54:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011c56:	f7ff fb25 	bl	80112a4 <_ux_device_class_storage_read>
                                                                UX_SLAVE_CLASS_STORAGE_SCSI_READ16);
                                break;
 8011c5a:	e04e      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_WRITE32:

                                _ux_device_class_storage_write(storage, lun, endpoint_in, endpoint_out, cbw_cb,
 8011c5c:	23aa      	movs	r3, #170	; 0xaa
 8011c5e:	9301      	str	r3, [sp, #4]
 8011c60:	68fb      	ldr	r3, [r7, #12]
 8011c62:	9300      	str	r3, [sp, #0]
 8011c64:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011c66:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011c68:	6979      	ldr	r1, [r7, #20]
 8011c6a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011c6c:	f000 f8ad 	bl	8011dca <_ux_device_class_storage_write>
                                                                UX_SLAVE_CLASS_STORAGE_SCSI_WRITE32);
                                break;
 8011c70:	e043      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
    
                            case UX_SLAVE_CLASS_STORAGE_SCSI_WRITE16:

                                _ux_device_class_storage_write(storage, lun, endpoint_in, endpoint_out, cbw_cb, 
 8011c72:	232a      	movs	r3, #42	; 0x2a
 8011c74:	9301      	str	r3, [sp, #4]
 8011c76:	68fb      	ldr	r3, [r7, #12]
 8011c78:	9300      	str	r3, [sp, #0]
 8011c7a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011c7c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011c7e:	6979      	ldr	r1, [r7, #20]
 8011c80:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011c82:	f000 f8a2 	bl	8011dca <_ux_device_class_storage_write>
                                                                UX_SLAVE_CLASS_STORAGE_SCSI_WRITE16);
                                break;
 8011c86:	e038      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>

                            case UX_SLAVE_CLASS_STORAGE_SCSI_SYNCHRONIZE_CACHE:

                                _ux_device_class_storage_synchronize_cache(storage, lun, endpoint_in, endpoint_out, cbw_cb, *(cbw_cb));
 8011c88:	68fb      	ldr	r3, [r7, #12]
 8011c8a:	781b      	ldrb	r3, [r3, #0]
 8011c8c:	9301      	str	r3, [sp, #4]
 8011c8e:	68fb      	ldr	r3, [r7, #12]
 8011c90:	9300      	str	r3, [sp, #0]
 8011c92:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011c94:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011c96:	6979      	ldr	r1, [r7, #20]
 8011c98:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011c9a:	f7ff fd37 	bl	801170c <_ux_device_class_storage_synchronize_cache>
                                break;
 8011c9e:	e02c      	b.n	8011cfa <_ux_device_class_storage_thread+0x436>
                            /* fall through */
                            default:
    
                                /* The command is unknown or unsupported, so we stall the endpoint.  */

                                if (storage -> ux_slave_class_storage_host_length > 0 &&
 8011ca0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011ca2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8011ca4:	2b00      	cmp	r3, #0
 8011ca6:	d009      	beq.n	8011cbc <_ux_device_class_storage_thread+0x3f8>
                                    ((storage -> ux_slave_class_storage_cbw_flags & 0x80) == 0))
 8011ca8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011caa:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8011cae:	b25b      	sxtb	r3, r3
                                if (storage -> ux_slave_class_storage_host_length > 0 &&
 8011cb0:	2b00      	cmp	r3, #0
 8011cb2:	db03      	blt.n	8011cbc <_ux_device_class_storage_thread+0x3f8>

                                    /* Data-Out from host to device, stall OUT.  */
                                    _ux_device_stack_endpoint_stall(endpoint_out);
 8011cb4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8011cb6:	f7fc ffad 	bl	800ec14 <_ux_device_stack_endpoint_stall>
 8011cba:	e002      	b.n	8011cc2 <_ux_device_class_storage_thread+0x3fe>
                                else

                                    /* Data-In from device to host, stall IN.  */
                                    _ux_device_stack_endpoint_stall(endpoint_in);
 8011cbc:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8011cbe:	f7fc ffa9 	bl	800ec14 <_ux_device_stack_endpoint_stall>
                                
                                /* Initialize the request sense keys.  */
                                storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
 8011cc2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8011cc4:	697a      	ldr	r2, [r7, #20]
 8011cc6:	4613      	mov	r3, r2
 8011cc8:	00db      	lsls	r3, r3, #3
 8011cca:	1a9b      	subs	r3, r3, r2
 8011ccc:	00db      	lsls	r3, r3, #3
 8011cce:	440b      	add	r3, r1
 8011cd0:	3320      	adds	r3, #32
 8011cd2:	f242 0205 	movw	r2, #8197	; 0x2005
 8011cd6:	601a      	str	r2, [r3, #0]
                                    UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(UX_SLAVE_CLASS_STORAGE_SENSE_KEY_ILLEGAL_REQUEST,
                                                                         UX_SLAVE_CLASS_STORAGE_ASC_KEY_INVALID_COMMAND,0);

                                /* This is the tricky part of the SCSI state machine. We must send the CSW BUT need to wait
                                   for the endpoint_in to be reset by the host.  */
                                while (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
 8011cd8:	e00a      	b.n	8011cf0 <_ux_device_class_storage_thread+0x42c>
                                { 

                                    /* Check the endpoint state.  */
                                    if (endpoint_in -> ux_slave_endpoint_state == UX_ENDPOINT_RESET)
 8011cda:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011cdc:	685b      	ldr	r3, [r3, #4]
 8011cde:	2b00      	cmp	r3, #0
 8011ce0:	d104      	bne.n	8011cec <_ux_device_class_storage_thread+0x428>
                                    {

                                        /* Now we set the CSW with failure.  */
                                        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
 8011ce2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011ce4:	2201      	movs	r2, #1
 8011ce6:	651a      	str	r2, [r3, #80]	; 0x50
                                        break;
 8011ce8:	bf00      	nop
                                    else

                                        /* We must therefore wait a while.  */
                                        _ux_device_thread_relinquish();
                                }
                                break;
 8011cea:	e005      	b.n	8011cf8 <_ux_device_class_storage_thread+0x434>
                                        _ux_device_thread_relinquish();
 8011cec:	f7fd ff9c 	bl	800fc28 <_ux_utility_thread_relinquish>
                                while (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
 8011cf0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011cf2:	681b      	ldr	r3, [r3, #0]
 8011cf4:	2b03      	cmp	r3, #3
 8011cf6:	d0f0      	beq.n	8011cda <_ux_device_class_storage_thread+0x416>
                                break;
 8011cf8:	bf00      	nop
                            }

                            /* Send CSW if not SYNC_CACHE.  */
                            status = _ux_device_class_storage_csw_send(storage, lun, endpoint_in, 0 /* Don't care */);
 8011cfa:	2300      	movs	r3, #0
 8011cfc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011cfe:	6979      	ldr	r1, [r7, #20]
 8011d00:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8011d02:	f7fe fe91 	bl	8010a28 <_ux_device_class_storage_csw_send>
 8011d06:	6378      	str	r0, [r7, #52]	; 0x34

                            /* Check error code. */
                            if (status != UX_SUCCESS)
 8011d08:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011d0a:	2b00      	cmp	r3, #0
 8011d0c:	d011      	beq.n	8011d32 <_ux_device_class_storage_thread+0x46e>

                                /* Error trap. */
                                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, status);
 8011d0e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011d10:	2107      	movs	r1, #7
 8011d12:	2002      	movs	r0, #2
 8011d14:	f7fd fa3a 	bl	800f18c <_ux_system_error_handler>
                    if (_ux_utility_long_get(scsi_command) == UX_SLAVE_CLASS_STORAGE_CBW_SIGNATURE_MASK)
 8011d18:	e00b      	b.n	8011d32 <_ux_device_class_storage_thread+0x46e>
                        }
                        else

                            /* Phase error!  */
                            storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
 8011d1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011d1c:	2202      	movs	r2, #2
 8011d1e:	651a      	str	r2, [r3, #80]	; 0x50
                    if (_ux_utility_long_get(scsi_command) == UX_SLAVE_CLASS_STORAGE_CBW_SIGNATURE_MASK)
 8011d20:	e007      	b.n	8011d32 <_ux_device_class_storage_thread+0x46e>
                    }
                    
                    else

                        /* Phase error!  */
                        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
 8011d22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011d24:	2202      	movs	r2, #2
 8011d26:	651a      	str	r2, [r3, #80]	; 0x50
                    if (_ux_utility_long_get(scsi_command) == UX_SLAVE_CLASS_STORAGE_CBW_SIGNATURE_MASK)
 8011d28:	e003      	b.n	8011d32 <_ux_device_class_storage_thread+0x46e>
                }
                else

                    /* Phase error!  */
                    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
 8011d2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011d2c:	2202      	movs	r2, #2
 8011d2e:	651a      	str	r2, [r3, #80]	; 0x50
 8011d30:	e00f      	b.n	8011d52 <_ux_device_class_storage_thread+0x48e>
                    if (_ux_utility_long_get(scsi_command) == UX_SLAVE_CLASS_STORAGE_CBW_SIGNATURE_MASK)
 8011d32:	bf00      	nop
 8011d34:	e00d      	b.n	8011d52 <_ux_device_class_storage_thread+0x48e>
            }
            else
            {

                if ((UCHAR)storage -> ux_slave_class_storage_csw_status == UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR)
 8011d36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011d38:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8011d3a:	b2db      	uxtb	r3, r3
 8011d3c:	2b02      	cmp	r3, #2
 8011d3e:	d105      	bne.n	8011d4c <_ux_device_class_storage_thread+0x488>
                {

                    /* We should keep the endpoints stalled.  */
                    _ux_device_stack_endpoint_stall(endpoint_out);
 8011d40:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8011d42:	f7fc ff67 	bl	800ec14 <_ux_device_stack_endpoint_stall>
                    _ux_device_stack_endpoint_stall(endpoint_in);
 8011d46:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8011d48:	f7fc ff64 	bl	800ec14 <_ux_device_stack_endpoint_stall>
                }

                /* We must therefore wait a while.  */
                _ux_utility_delay_ms(2);
 8011d4c:	2002      	movs	r0, #2
 8011d4e:	f7fd faf1 	bl	800f334 <_ux_utility_delay_ms>
        while (device -> ux_slave_device_state == UX_DEVICE_CONFIGURED)
 8011d52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d54:	681b      	ldr	r3, [r3, #0]
 8011d56:	2b03      	cmp	r3, #3
 8011d58:	f43f adc2 	beq.w	80118e0 <_ux_device_class_storage_thread+0x1c>
            }
        }

        /* We need to suspend ourselves. We will be resumed by the 
           device enumeration module.  */
        _ux_device_thread_suspend(&class_ptr -> ux_slave_class_thread);
 8011d5c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011d5e:	3350      	adds	r3, #80	; 0x50
 8011d60:	4618      	mov	r0, r3
 8011d62:	f7fd ff74 	bl	800fc4e <_ux_utility_thread_suspend>
        UX_THREAD_EXTENSION_PTR_GET(class_ptr, UX_SLAVE_CLASS, storage_class)
 8011d66:	e5b1      	b.n	80118cc <_ux_device_class_storage_thread+0x8>

08011d68 <_ux_device_class_storage_uninitialize>:
/*                                            names conflict C++ keyword, */
/*                                            resulting in version 6.1.12 */
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_uninitialize(UX_SLAVE_CLASS_COMMAND *command)
{
 8011d68:	b580      	push	{r7, lr}
 8011d6a:	b084      	sub	sp, #16
 8011d6c:	af00      	add	r7, sp, #0
 8011d6e:	6078      	str	r0, [r7, #4]
                                          
UX_SLAVE_CLASS_STORAGE                  *storage;
UX_SLAVE_CLASS                          *class_ptr;

    /* Get the class container.  */
    class_ptr =  command -> ux_slave_class_command_class_ptr;
 8011d70:	687b      	ldr	r3, [r7, #4]
 8011d72:	6a1b      	ldr	r3, [r3, #32]
 8011d74:	60fb      	str	r3, [r7, #12]

    /* Get the class instance in the container.  */
    storage = (UX_SLAVE_CLASS_STORAGE *) class_ptr -> ux_slave_class_instance;
 8011d76:	68fb      	ldr	r3, [r7, #12]
 8011d78:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8011d7a:	60bb      	str	r3, [r7, #8]
    
    /* Sanity check.  */
    if (storage != UX_NULL)
 8011d7c:	68bb      	ldr	r3, [r7, #8]
 8011d7e:	2b00      	cmp	r3, #0
 8011d80:	d00d      	beq.n	8011d9e <_ux_device_class_storage_uninitialize+0x36>
    {

        /* Remove STORAGE thread.  */
        _ux_device_thread_delete(&class_ptr -> ux_slave_class_thread);
 8011d82:	68fb      	ldr	r3, [r7, #12]
 8011d84:	3350      	adds	r3, #80	; 0x50
 8011d86:	4618      	mov	r0, r3
 8011d88:	f7fd ff3e 	bl	800fc08 <_ux_utility_thread_delete>

#if !(defined(UX_DEVICE_STANDALONE) || defined(UX_STANDALONE))    
        /* Remove the thread used by STORAGE.  */
        _ux_utility_memory_free(class_ptr -> ux_slave_class_thread_stack);
 8011d8c:	68fb      	ldr	r3, [r7, #12]
 8011d8e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
 8011d92:	4618      	mov	r0, r3
 8011d94:	f7fd fd20 	bl	800f7d8 <_ux_utility_memory_free>
#endif

        /* Free the resources.  */
        _ux_utility_memory_free(storage);
 8011d98:	68b8      	ldr	r0, [r7, #8]
 8011d9a:	f7fd fd1d 	bl	800f7d8 <_ux_utility_memory_free>
    }
    
    /* Return completion status.  */
    return(UX_SUCCESS);
 8011d9e:	2300      	movs	r3, #0
}
 8011da0:	4618      	mov	r0, r3
 8011da2:	3710      	adds	r7, #16
 8011da4:	46bd      	mov	sp, r7
 8011da6:	bd80      	pop	{r7, pc}

08011da8 <_ux_device_class_storage_verify>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_verify(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                      UX_SLAVE_ENDPOINT *endpoint_in,
                                      UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb)
{
 8011da8:	b480      	push	{r7}
 8011daa:	b085      	sub	sp, #20
 8011dac:	af00      	add	r7, sp, #0
 8011dae:	60f8      	str	r0, [r7, #12]
 8011db0:	60b9      	str	r1, [r7, #8]
 8011db2:	607a      	str	r2, [r7, #4]
 8011db4:	603b      	str	r3, [r7, #0]

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_VERIFY, storage, lun, 0, 0, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* We set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 8011db6:	68fb      	ldr	r3, [r7, #12]
 8011db8:	2200      	movs	r2, #0
 8011dba:	651a      	str	r2, [r3, #80]	; 0x50

    /* Return success!  */
    return(UX_SUCCESS);
 8011dbc:	2300      	movs	r3, #0
}
 8011dbe:	4618      	mov	r0, r3
 8011dc0:	3714      	adds	r7, #20
 8011dc2:	46bd      	mov	sp, r7
 8011dc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011dc8:	4770      	bx	lr

08011dca <_ux_device_class_storage_write>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_device_class_storage_write(UX_SLAVE_CLASS_STORAGE *storage, ULONG lun, 
                                    UX_SLAVE_ENDPOINT *endpoint_in,
                                    UX_SLAVE_ENDPOINT *endpoint_out, UCHAR * cbwcb, UCHAR scsi_command)
{
 8011dca:	b590      	push	{r4, r7, lr}
 8011dcc:	b091      	sub	sp, #68	; 0x44
 8011dce:	af02      	add	r7, sp, #8
 8011dd0:	60f8      	str	r0, [r7, #12]
 8011dd2:	60b9      	str	r1, [r7, #8]
 8011dd4:	607a      	str	r2, [r7, #4]
 8011dd6:	603b      	str	r3, [r7, #0]


    UX_PARAMETER_NOT_USED(endpoint_in);

    /* Get the LBA from the CBWCB.  */
    lba =  _ux_utility_long_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_WRITE_LBA);
 8011dd8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011dda:	3302      	adds	r3, #2
 8011ddc:	4618      	mov	r0, r3
 8011dde:	f7fd fb38 	bl	800f452 <_ux_utility_long_get_big_endian>
 8011de2:	6338      	str	r0, [r7, #48]	; 0x30
    
    /* The type of commands will tell us the width of the field containing the number
       of sectors to read.   */
    if (scsi_command == UX_SLAVE_CLASS_STORAGE_SCSI_WRITE16)
 8011de4:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 8011de8:	2b2a      	cmp	r3, #42	; 0x2a
 8011dea:	d106      	bne.n	8011dfa <_ux_device_class_storage_write+0x30>

        /* Get the number of blocks from the CBWCB in 16 bits.  */
        total_number_blocks =  _ux_utility_short_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_WRITE_TRANSFER_LENGTH_16);
 8011dec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011dee:	3307      	adds	r3, #7
 8011df0:	4618      	mov	r0, r3
 8011df2:	f7fd fe7b 	bl	800faec <_ux_utility_short_get_big_endian>
 8011df6:	62f8      	str	r0, [r7, #44]	; 0x2c
 8011df8:	e005      	b.n	8011e06 <_ux_device_class_storage_write+0x3c>

    else        

        /* Get the number of blocks from the CBWCB in 32 bits.  */
        total_number_blocks =  _ux_utility_long_get_big_endian(cbwcb + UX_SLAVE_CLASS_STORAGE_WRITE_TRANSFER_LENGTH_32);
 8011dfa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8011dfc:	3306      	adds	r3, #6
 8011dfe:	4618      	mov	r0, r3
 8011e00:	f7fd fb27 	bl	800f452 <_ux_utility_long_get_big_endian>
 8011e04:	62f8      	str	r0, [r7, #44]	; 0x2c

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_DEVICE_CLASS_STORAGE_WRITE, storage, lun, lba, total_number_blocks, UX_TRACE_DEVICE_CLASS_EVENTS, 0, 0)

    /* Obtain the pointer to the transfer request.  */
    transfer_request =  &endpoint_out -> ux_slave_endpoint_transfer_request;
 8011e06:	683b      	ldr	r3, [r7, #0]
 8011e08:	3330      	adds	r3, #48	; 0x30
 8011e0a:	61fb      	str	r3, [r7, #28]

    /* Obtain the status of the device.  */
    status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_status(storage, 
 8011e0c:	68f9      	ldr	r1, [r7, #12]
 8011e0e:	68bb      	ldr	r3, [r7, #8]
 8011e10:	1c5a      	adds	r2, r3, #1
 8011e12:	4613      	mov	r3, r2
 8011e14:	00db      	lsls	r3, r3, #3
 8011e16:	1a9b      	subs	r3, r3, r2
 8011e18:	00db      	lsls	r3, r3, #3
 8011e1a:	440b      	add	r3, r1
 8011e1c:	681c      	ldr	r4, [r3, #0]
 8011e1e:	68f9      	ldr	r1, [r7, #12]
 8011e20:	68ba      	ldr	r2, [r7, #8]
 8011e22:	4613      	mov	r3, r2
 8011e24:	00db      	lsls	r3, r3, #3
 8011e26:	1a9b      	subs	r3, r3, r2
 8011e28:	00db      	lsls	r3, r3, #3
 8011e2a:	440b      	add	r3, r1
 8011e2c:	331c      	adds	r3, #28
 8011e2e:	681a      	ldr	r2, [r3, #0]
 8011e30:	f107 0314 	add.w	r3, r7, #20
 8011e34:	68b9      	ldr	r1, [r7, #8]
 8011e36:	68f8      	ldr	r0, [r7, #12]
 8011e38:	47a0      	blx	r4
 8011e3a:	6378      	str	r0, [r7, #52]	; 0x34
                            lun, storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_id, &media_status);
    
    /* Update the request sense.  */
    storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
 8011e3c:	6979      	ldr	r1, [r7, #20]
 8011e3e:	68f8      	ldr	r0, [r7, #12]
 8011e40:	68ba      	ldr	r2, [r7, #8]
 8011e42:	4613      	mov	r3, r2
 8011e44:	00db      	lsls	r3, r3, #3
 8011e46:	1a9b      	subs	r3, r3, r2
 8011e48:	00db      	lsls	r3, r3, #3
 8011e4a:	4403      	add	r3, r0
 8011e4c:	3320      	adds	r3, #32
 8011e4e:	6019      	str	r1, [r3, #0]

    /* Default CSW to failed.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_FAILED;
 8011e50:	68fb      	ldr	r3, [r7, #12]
 8011e52:	2201      	movs	r2, #1
 8011e54:	651a      	str	r2, [r3, #80]	; 0x50

    /* If there is a problem, return a failed command.  */
    if (status != UX_SUCCESS)
 8011e56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011e58:	2b00      	cmp	r3, #0
 8011e5a:	d004      	beq.n	8011e66 <_ux_device_class_storage_write+0x9c>
    {

        /* We have a problem, media status error. Return a bad completion and wait for the
           REQUEST_SENSE command.  */
#if !defined(UX_DEVICE_STANDALONE)
        _ux_device_stack_endpoint_stall(endpoint_out);
 8011e5c:	6838      	ldr	r0, [r7, #0]
 8011e5e:	f7fc fed9 	bl	800ec14 <_ux_device_stack_endpoint_stall>
#endif

        /* We are done here.  */
        return(UX_ERROR);
 8011e62:	23ff      	movs	r3, #255	; 0xff
 8011e64:	e0ca      	b.n	8011ffc <_ux_device_class_storage_write+0x232>
    }

    /* Check Read Only flag.  */
    if (storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_read_only_flag == UX_TRUE)
 8011e66:	68f9      	ldr	r1, [r7, #12]
 8011e68:	68ba      	ldr	r2, [r7, #8]
 8011e6a:	4613      	mov	r3, r2
 8011e6c:	00db      	lsls	r3, r3, #3
 8011e6e:	1a9b      	subs	r3, r3, r2
 8011e70:	00db      	lsls	r3, r3, #3
 8011e72:	440b      	add	r3, r1
 8011e74:	3318      	adds	r3, #24
 8011e76:	681b      	ldr	r3, [r3, #0]
 8011e78:	2b01      	cmp	r3, #1
 8011e7a:	d10f      	bne.n	8011e9c <_ux_device_class_storage_write+0xd2>
    {

        /* Update the request sense.  */
        storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
 8011e7c:	68f9      	ldr	r1, [r7, #12]
 8011e7e:	68ba      	ldr	r2, [r7, #8]
 8011e80:	4613      	mov	r3, r2
 8011e82:	00db      	lsls	r3, r3, #3
 8011e84:	1a9b      	subs	r3, r3, r2
 8011e86:	00db      	lsls	r3, r3, #3
 8011e88:	440b      	add	r3, r1
 8011e8a:	3320      	adds	r3, #32
 8011e8c:	f242 7207 	movw	r2, #9991	; 0x2707
 8011e90:	601a      	str	r2, [r3, #0]
                                            UX_SLAVE_CLASS_STORAGE_REQUEST_CODE_MEDIA_PROTECTED,0);

        /* We have a problem, cannot write to RO drive. Return a bad completion and wait for the
           REQUEST_SENSE command.  */
#if !defined(UX_DEVICE_STANDALONE)
        _ux_device_stack_endpoint_stall(endpoint_out);
 8011e92:	6838      	ldr	r0, [r7, #0]
 8011e94:	f7fc febe 	bl	800ec14 <_ux_device_stack_endpoint_stall>
#endif

        /* We are done here.  */
        return(UX_ERROR);
 8011e98:	23ff      	movs	r3, #255	; 0xff
 8011e9a:	e0af      	b.n	8011ffc <_ux_device_class_storage_write+0x232>
    }

    /* Compute the total length to transfer and how much remains.  */
    total_length =  total_number_blocks * storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length;
 8011e9c:	68f9      	ldr	r1, [r7, #12]
 8011e9e:	68ba      	ldr	r2, [r7, #8]
 8011ea0:	4613      	mov	r3, r2
 8011ea2:	00db      	lsls	r3, r3, #3
 8011ea4:	1a9b      	subs	r3, r3, r2
 8011ea6:	00db      	lsls	r3, r3, #3
 8011ea8:	440b      	add	r3, r1
 8011eaa:	330c      	adds	r3, #12
 8011eac:	681a      	ldr	r2, [r3, #0]
 8011eae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011eb0:	fb02 f303 	mul.w	r3, r2, r3
 8011eb4:	62bb      	str	r3, [r7, #40]	; 0x28
#else

    /* Check transfer length.  */

    /* Case (3) Hn < Do.  */
    if (total_length > storage -> ux_slave_class_storage_host_length)
 8011eb6:	68fb      	ldr	r3, [r7, #12]
 8011eb8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8011eba:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011ebc:	429a      	cmp	r2, r3
 8011ebe:	d907      	bls.n	8011ed0 <_ux_device_class_storage_write+0x106>
    {
        _ux_device_stack_endpoint_stall(endpoint_out);
 8011ec0:	6838      	ldr	r0, [r7, #0]
 8011ec2:	f7fc fea7 	bl	800ec14 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
 8011ec6:	68fb      	ldr	r3, [r7, #12]
 8011ec8:	2202      	movs	r2, #2
 8011eca:	651a      	str	r2, [r3, #80]	; 0x50
        return(UX_ERROR);
 8011ecc:	23ff      	movs	r3, #255	; 0xff
 8011ece:	e095      	b.n	8011ffc <_ux_device_class_storage_write+0x232>
    }

    /* Case (8). Hi <> Do.  */
    if ((storage -> ux_slave_class_storage_cbw_flags & 0x80) != 0)
 8011ed0:	68fb      	ldr	r3, [r7, #12]
 8011ed2:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8011ed6:	b25b      	sxtb	r3, r3
 8011ed8:	2b00      	cmp	r3, #0
 8011eda:	da07      	bge.n	8011eec <_ux_device_class_storage_write+0x122>
    {
        _ux_device_stack_endpoint_stall(endpoint_in);
 8011edc:	6878      	ldr	r0, [r7, #4]
 8011ede:	f7fc fe99 	bl	800ec14 <_ux_device_stack_endpoint_stall>
        storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PHASE_ERROR;
 8011ee2:	68fb      	ldr	r3, [r7, #12]
 8011ee4:	2202      	movs	r2, #2
 8011ee6:	651a      	str	r2, [r3, #80]	; 0x50
        return(UX_ERROR);
 8011ee8:	23ff      	movs	r3, #255	; 0xff
 8011eea:	e087      	b.n	8011ffc <_ux_device_class_storage_write+0x232>
    }

    /* Default status to success.  */
    status =  UX_SUCCESS;
 8011eec:	2300      	movs	r3, #0
 8011eee:	637b      	str	r3, [r7, #52]	; 0x34

    /* It may take several transfers to send the requested data.  */
    done_length = 0;
 8011ef0:	2300      	movs	r3, #0
 8011ef2:	623b      	str	r3, [r7, #32]
    while (total_length)
 8011ef4:	e06e      	b.n	8011fd4 <_ux_device_class_storage_write+0x20a>
    {

        /* How much can we receive in this transfer?  */
        if (total_length > UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE)
 8011ef6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011ef8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8011efc:	d903      	bls.n	8011f06 <_ux_device_class_storage_write+0x13c>
            transfer_length =  UX_SLAVE_CLASS_STORAGE_BUFFER_SIZE;
 8011efe:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8011f02:	627b      	str	r3, [r7, #36]	; 0x24
 8011f04:	e001      	b.n	8011f0a <_ux_device_class_storage_write+0x140>
        else
            transfer_length =  total_length;
 8011f06:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011f08:	627b      	str	r3, [r7, #36]	; 0x24
        
        /* Get the data payload from the host.  */
        status =  _ux_device_stack_transfer_request(transfer_request, transfer_length, transfer_length);
 8011f0a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011f0c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8011f0e:	69f8      	ldr	r0, [r7, #28]
 8011f10:	f7fd f8b2 	bl	800f078 <_ux_device_stack_transfer_request>
 8011f14:	6378      	str	r0, [r7, #52]	; 0x34
        
        /* Check the status.  */
        if (status != UX_SUCCESS)
 8011f16:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011f18:	2b00      	cmp	r3, #0
 8011f1a:	d015      	beq.n	8011f48 <_ux_device_class_storage_write+0x17e>
        {

            /* We have a problem, request error. Return a bad completion and wait for the
               REQUEST_SENSE command.  */
            _ux_device_stack_endpoint_stall(endpoint_out);
 8011f1c:	6838      	ldr	r0, [r7, #0]
 8011f1e:	f7fc fe79 	bl	800ec14 <_ux_device_stack_endpoint_stall>

            /* Update residue.  */
            storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
 8011f22:	68fb      	ldr	r3, [r7, #12]
 8011f24:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8011f26:	6a3b      	ldr	r3, [r7, #32]
 8011f28:	1ad2      	subs	r2, r2, r3
 8011f2a:	68fb      	ldr	r3, [r7, #12]
 8011f2c:	64da      	str	r2, [r3, #76]	; 0x4c

            /* And update the REQUEST_SENSE codes.  */
            storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status =
 8011f2e:	68f9      	ldr	r1, [r7, #12]
 8011f30:	68ba      	ldr	r2, [r7, #8]
 8011f32:	4613      	mov	r3, r2
 8011f34:	00db      	lsls	r3, r3, #3
 8011f36:	1a9b      	subs	r3, r3, r2
 8011f38:	00db      	lsls	r3, r3, #3
 8011f3a:	440b      	add	r3, r1
 8011f3c:	3320      	adds	r3, #32
 8011f3e:	f245 4202 	movw	r2, #21506	; 0x5402
 8011f42:	601a      	str	r2, [r3, #0]
                                                UX_DEVICE_CLASS_STORAGE_SENSE_STATUS(0x02,0x54,0x00);
    
            /* Return an error.  */
            return(UX_ERROR);
 8011f44:	23ff      	movs	r3, #255	; 0xff
 8011f46:	e059      	b.n	8011ffc <_ux_device_class_storage_write+0x232>
        }

        /* Compute the number of blocks to transfer.  */
        number_blocks = transfer_length / storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_block_length;
 8011f48:	68f9      	ldr	r1, [r7, #12]
 8011f4a:	68ba      	ldr	r2, [r7, #8]
 8011f4c:	4613      	mov	r3, r2
 8011f4e:	00db      	lsls	r3, r3, #3
 8011f50:	1a9b      	subs	r3, r3, r2
 8011f52:	00db      	lsls	r3, r3, #3
 8011f54:	440b      	add	r3, r1
 8011f56:	330c      	adds	r3, #12
 8011f58:	681b      	ldr	r3, [r3, #0]
 8011f5a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8011f5c:	fbb2 f3f3 	udiv	r3, r2, r3
 8011f60:	61bb      	str	r3, [r7, #24]
        
        /* Execute the write command to the local media.  */
        status =  storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_media_write(storage, lun, transfer_request -> ux_slave_transfer_request_data_pointer, number_blocks, lba, &media_status);
 8011f62:	68f9      	ldr	r1, [r7, #12]
 8011f64:	68ba      	ldr	r2, [r7, #8]
 8011f66:	4613      	mov	r3, r2
 8011f68:	00db      	lsls	r3, r3, #3
 8011f6a:	1a9b      	subs	r3, r3, r2
 8011f6c:	00db      	lsls	r3, r3, #3
 8011f6e:	440b      	add	r3, r1
 8011f70:	3330      	adds	r3, #48	; 0x30
 8011f72:	681c      	ldr	r4, [r3, #0]
 8011f74:	69fb      	ldr	r3, [r7, #28]
 8011f76:	68da      	ldr	r2, [r3, #12]
 8011f78:	f107 0314 	add.w	r3, r7, #20
 8011f7c:	9301      	str	r3, [sp, #4]
 8011f7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011f80:	9300      	str	r3, [sp, #0]
 8011f82:	69bb      	ldr	r3, [r7, #24]
 8011f84:	68b9      	ldr	r1, [r7, #8]
 8011f86:	68f8      	ldr	r0, [r7, #12]
 8011f88:	47a0      	blx	r4
 8011f8a:	6378      	str	r0, [r7, #52]	; 0x34
    
        /* If there is a problem, return a failed command.  */
        if (status != UX_SUCCESS)
 8011f8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011f8e:	2b00      	cmp	r3, #0
 8011f90:	d014      	beq.n	8011fbc <_ux_device_class_storage_write+0x1f2>
        {
    
            /* We have a problem, request error. Return a bad completion and wait for the
               REQUEST_SENSE command.  */
            _ux_device_stack_endpoint_stall(endpoint_out);
 8011f92:	6838      	ldr	r0, [r7, #0]
 8011f94:	f7fc fe3e 	bl	800ec14 <_ux_device_stack_endpoint_stall>
    
            /* Update residue.  */
            storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
 8011f98:	68fb      	ldr	r3, [r7, #12]
 8011f9a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8011f9c:	6a3b      	ldr	r3, [r7, #32]
 8011f9e:	1ad2      	subs	r2, r2, r3
 8011fa0:	68fb      	ldr	r3, [r7, #12]
 8011fa2:	64da      	str	r2, [r3, #76]	; 0x4c

            /* And update the REQUEST_SENSE codes.  */
            storage -> ux_slave_class_storage_lun[lun].ux_slave_class_storage_request_sense_status = media_status;
 8011fa4:	6979      	ldr	r1, [r7, #20]
 8011fa6:	68f8      	ldr	r0, [r7, #12]
 8011fa8:	68ba      	ldr	r2, [r7, #8]
 8011faa:	4613      	mov	r3, r2
 8011fac:	00db      	lsls	r3, r3, #3
 8011fae:	1a9b      	subs	r3, r3, r2
 8011fb0:	00db      	lsls	r3, r3, #3
 8011fb2:	4403      	add	r3, r0
 8011fb4:	3320      	adds	r3, #32
 8011fb6:	6019      	str	r1, [r3, #0]
    
            /* Return an error.  */
            return(UX_ERROR);
 8011fb8:	23ff      	movs	r3, #255	; 0xff
 8011fba:	e01f      	b.n	8011ffc <_ux_device_class_storage_write+0x232>
        }

        /* Update the lba.  */
        lba += number_blocks;
 8011fbc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011fbe:	69bb      	ldr	r3, [r7, #24]
 8011fc0:	4413      	add	r3, r2
 8011fc2:	633b      	str	r3, [r7, #48]	; 0x30
        
        /* Update the length to remain.  */
        total_length -= transfer_length;
 8011fc4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011fc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011fc8:	1ad3      	subs	r3, r2, r3
 8011fca:	62bb      	str	r3, [r7, #40]	; 0x28
        done_length += transfer_length;
 8011fcc:	6a3a      	ldr	r2, [r7, #32]
 8011fce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011fd0:	4413      	add	r3, r2
 8011fd2:	623b      	str	r3, [r7, #32]
    while (total_length)
 8011fd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011fd6:	2b00      	cmp	r3, #0
 8011fd8:	d18d      	bne.n	8011ef6 <_ux_device_class_storage_write+0x12c>
    }

    /* Update residue.  */
    storage -> ux_slave_class_storage_csw_residue = storage -> ux_slave_class_storage_host_length - done_length;
 8011fda:	68fb      	ldr	r3, [r7, #12]
 8011fdc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8011fde:	6a3b      	ldr	r3, [r7, #32]
 8011fe0:	1ad2      	subs	r2, r2, r3
 8011fe2:	68fb      	ldr	r3, [r7, #12]
 8011fe4:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Case (9), (11). If host expects more transfer, stall it.  */
    if (storage -> ux_slave_class_storage_csw_residue)
 8011fe6:	68fb      	ldr	r3, [r7, #12]
 8011fe8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8011fea:	2b00      	cmp	r3, #0
 8011fec:	d002      	beq.n	8011ff4 <_ux_device_class_storage_write+0x22a>
        _ux_device_stack_endpoint_stall(endpoint_out);
 8011fee:	6838      	ldr	r0, [r7, #0]
 8011ff0:	f7fc fe10 	bl	800ec14 <_ux_device_stack_endpoint_stall>

#endif /* else defined(UX_DEVICE_STANDALONE) */

    /* Now we set the CSW with success.  */
    storage -> ux_slave_class_storage_csw_status = UX_SLAVE_CLASS_STORAGE_CSW_PASSED;
 8011ff4:	68fb      	ldr	r3, [r7, #12]
 8011ff6:	2200      	movs	r2, #0
 8011ff8:	651a      	str	r2, [r3, #80]	; 0x50

    /* Return completion status.  */
    return(status);
 8011ffa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 8011ffc:	4618      	mov	r0, r3
 8011ffe:	373c      	adds	r7, #60	; 0x3c
 8012000:	46bd      	mov	sp, r7
 8012002:	bd90      	pop	{r4, r7, pc}

08012004 <MX_NetXDuo_Init>:
  * @brief  Application NetXDuo Initialization.
  * @param memory_ptr: memory pointer
  * @retval int
  */
UINT MX_NetXDuo_Init(VOID *memory_ptr)
{
 8012004:	b480      	push	{r7}
 8012006:	b085      	sub	sp, #20
 8012008:	af00      	add	r7, sp, #0
 801200a:	6078      	str	r0, [r7, #4]
  UINT ret = NX_SUCCESS;
 801200c:	2300      	movs	r3, #0
 801200e:	60fb      	str	r3, [r7, #12]
  TX_BYTE_POOL *byte_pool = (TX_BYTE_POOL*)memory_ptr;
 8012010:	687b      	ldr	r3, [r7, #4]
 8012012:	60bb      	str	r3, [r7, #8]

  /* USER CODE BEGIN MX_NetXDuo_Init */

  /* USER CODE END MX_NetXDuo_Init */

  return ret;
 8012014:	68fb      	ldr	r3, [r7, #12]
}
 8012016:	4618      	mov	r0, r3
 8012018:	3714      	adds	r7, #20
 801201a:	46bd      	mov	sp, r7
 801201c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012020:	4770      	bx	lr
	...

08012024 <MX_USBX_Device_Init>:
  * @brief  Application USBX Device Initialization.
  * @param  memory_ptr: memory pointer
  * @retval status
  */
UINT MX_USBX_Device_Init(VOID *memory_ptr)
{
 8012024:	b590      	push	{r4, r7, lr}
 8012026:	b095      	sub	sp, #84	; 0x54
 8012028:	af06      	add	r7, sp, #24
 801202a:	6078      	str	r0, [r7, #4]
  UINT ret = UX_SUCCESS;
 801202c:	2300      	movs	r3, #0
 801202e:	637b      	str	r3, [r7, #52]	; 0x34
  ULONG string_framework_length;
  ULONG language_id_framework_length;
  UCHAR *string_framework;
  UCHAR *language_id_framework;
  UCHAR *pointer;
  TX_BYTE_POOL *byte_pool = (TX_BYTE_POOL*)memory_ptr;
 8012030:	687b      	ldr	r3, [r7, #4]
 8012032:	633b      	str	r3, [r7, #48]	; 0x30
  /* USER CODE BEGIN MX_USBX_Device_Init0 */

  /* USER CODE END MX_USBX_Device_Init0 */

  /* Allocate the stack for USBX Memory */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer,
 8012034:	f107 010c 	add.w	r1, r7, #12
 8012038:	2300      	movs	r3, #0
 801203a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801203e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8012040:	f7f9 f97a 	bl	800b338 <_tx_byte_allocate>
 8012044:	4603      	mov	r3, r0
 8012046:	2b00      	cmp	r3, #0
 8012048:	d001      	beq.n	801204e <MX_USBX_Device_Init+0x2a>
                       USBX_DEVICE_MEMORY_STACK_SIZE, TX_NO_WAIT) != TX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_ALLOCATE_STACK_ERORR */
    return TX_POOL_ERROR;
 801204a:	2302      	movs	r3, #2
 801204c:	e0f6      	b.n	801223c <MX_USBX_Device_Init+0x218>
    /* USER CODE END USBX_ALLOCATE_STACK_ERORR */
  }

  /* Initialize USBX Memory */
  if (ux_system_initialize(pointer, USBX_DEVICE_MEMORY_STACK_SIZE, UX_NULL, 0) != UX_SUCCESS)
 801204e:	68f8      	ldr	r0, [r7, #12]
 8012050:	2300      	movs	r3, #0
 8012052:	2200      	movs	r2, #0
 8012054:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8012058:	f7fd f8ba 	bl	800f1d0 <_ux_system_initialize>
 801205c:	4603      	mov	r3, r0
 801205e:	2b00      	cmp	r3, #0
 8012060:	d001      	beq.n	8012066 <MX_USBX_Device_Init+0x42>
  {
    /* USER CODE BEGIN USBX_SYSTEM_INITIALIZE_ERORR */
    return UX_ERROR;
 8012062:	23ff      	movs	r3, #255	; 0xff
 8012064:	e0ea      	b.n	801223c <MX_USBX_Device_Init+0x218>
    /* USER CODE END USBX_SYSTEM_INITIALIZE_ERORR */
  }

  /* Get Device Framework High Speed and get the length */
  device_framework_high_speed = USBD_Get_Device_Framework_Speed(USBD_HIGH_SPEED,
 8012066:	f107 031c 	add.w	r3, r7, #28
 801206a:	4619      	mov	r1, r3
 801206c:	2001      	movs	r0, #1
 801206e:	f000 f979 	bl	8012364 <USBD_Get_Device_Framework_Speed>
 8012072:	62f8      	str	r0, [r7, #44]	; 0x2c
                                                                &device_framework_hs_length);

  /* Get Device Framework Full Speed and get the length */
  device_framework_full_speed = USBD_Get_Device_Framework_Speed(USBD_FULL_SPEED,
 8012074:	f107 0318 	add.w	r3, r7, #24
 8012078:	4619      	mov	r1, r3
 801207a:	2000      	movs	r0, #0
 801207c:	f000 f972 	bl	8012364 <USBD_Get_Device_Framework_Speed>
 8012080:	62b8      	str	r0, [r7, #40]	; 0x28
                                                                &device_framework_fs_length);

  /* Get String Framework and get the length */
  string_framework = USBD_Get_String_Framework(&string_framework_length);
 8012082:	f107 0314 	add.w	r3, r7, #20
 8012086:	4618      	mov	r0, r3
 8012088:	f000 f9ae 	bl	80123e8 <USBD_Get_String_Framework>
 801208c:	6278      	str	r0, [r7, #36]	; 0x24

  /* Get Language Id Framework and get the length */
  language_id_framework = USBD_Get_Language_Id_Framework(&language_id_framework_length);
 801208e:	f107 0310 	add.w	r3, r7, #16
 8012092:	4618      	mov	r0, r3
 8012094:	f000 fa2c 	bl	80124f0 <USBD_Get_Language_Id_Framework>
 8012098:	6238      	str	r0, [r7, #32]

  /* Install the device portion of USBX */
  if (ux_device_stack_initialize(device_framework_high_speed,
 801209a:	69f9      	ldr	r1, [r7, #28]
 801209c:	69b8      	ldr	r0, [r7, #24]
 801209e:	697b      	ldr	r3, [r7, #20]
 80120a0:	693a      	ldr	r2, [r7, #16]
 80120a2:	2400      	movs	r4, #0
 80120a4:	9404      	str	r4, [sp, #16]
 80120a6:	9203      	str	r2, [sp, #12]
 80120a8:	6a3a      	ldr	r2, [r7, #32]
 80120aa:	9202      	str	r2, [sp, #8]
 80120ac:	9301      	str	r3, [sp, #4]
 80120ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80120b0:	9300      	str	r3, [sp, #0]
 80120b2:	4603      	mov	r3, r0
 80120b4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80120b6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80120b8:	f7fc fde4 	bl	800ec84 <_ux_device_stack_initialize>
 80120bc:	4603      	mov	r3, r0
 80120be:	2b00      	cmp	r3, #0
 80120c0:	d001      	beq.n	80120c6 <MX_USBX_Device_Init+0xa2>
                                 language_id_framework,
                                 language_id_framework_length,
                                 UX_NULL) != UX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_DEVICE_INITIALIZE_ERORR */
    return UX_ERROR;
 80120c2:	23ff      	movs	r3, #255	; 0xff
 80120c4:	e0ba      	b.n	801223c <MX_USBX_Device_Init+0x218>
    /* USER CODE END USBX_DEVICE_INITIALIZE_ERORR */
  }

  /* Initialize the hid custom class parameters for the device */
  custom_hid_parameter.ux_slave_class_hid_instance_activate         = USBD_Custom_HID_Activate;
 80120c6:	4b5f      	ldr	r3, [pc, #380]	; (8012244 <MX_USBX_Device_Init+0x220>)
 80120c8:	4a5f      	ldr	r2, [pc, #380]	; (8012248 <MX_USBX_Device_Init+0x224>)
 80120ca:	601a      	str	r2, [r3, #0]
  custom_hid_parameter.ux_slave_class_hid_instance_deactivate       = USBD_Custom_HID_Deactivate;
 80120cc:	4b5d      	ldr	r3, [pc, #372]	; (8012244 <MX_USBX_Device_Init+0x220>)
 80120ce:	4a5f      	ldr	r2, [pc, #380]	; (801224c <MX_USBX_Device_Init+0x228>)
 80120d0:	605a      	str	r2, [r3, #4]
  custom_hid_parameter.ux_device_class_hid_parameter_report_address = USBD_HID_ReportDesc(INTERFACE_HID_CUSTOM);
 80120d2:	2000      	movs	r0, #0
 80120d4:	f000 fa7e 	bl	80125d4 <USBD_HID_ReportDesc>
 80120d8:	4603      	mov	r3, r0
 80120da:	4a5a      	ldr	r2, [pc, #360]	; (8012244 <MX_USBX_Device_Init+0x220>)
 80120dc:	6093      	str	r3, [r2, #8]
  custom_hid_parameter.ux_device_class_hid_parameter_report_length  = USBD_HID_ReportDesc_length(INTERFACE_HID_CUSTOM);
 80120de:	2000      	movs	r0, #0
 80120e0:	f000 fa90 	bl	8012604 <USBD_HID_ReportDesc_length>
 80120e4:	4603      	mov	r3, r0
 80120e6:	461a      	mov	r2, r3
 80120e8:	4b56      	ldr	r3, [pc, #344]	; (8012244 <MX_USBX_Device_Init+0x220>)
 80120ea:	611a      	str	r2, [r3, #16]
  custom_hid_parameter.ux_device_class_hid_parameter_report_id      = UX_TRUE;
 80120ec:	4b55      	ldr	r3, [pc, #340]	; (8012244 <MX_USBX_Device_Init+0x220>)
 80120ee:	2201      	movs	r2, #1
 80120f0:	60da      	str	r2, [r3, #12]
  custom_hid_parameter.ux_device_class_hid_parameter_callback       = USBD_Custom_HID_SetFeature;
 80120f2:	4b54      	ldr	r3, [pc, #336]	; (8012244 <MX_USBX_Device_Init+0x220>)
 80120f4:	4a56      	ldr	r2, [pc, #344]	; (8012250 <MX_USBX_Device_Init+0x22c>)
 80120f6:	615a      	str	r2, [r3, #20]
  custom_hid_parameter.ux_device_class_hid_parameter_get_callback   = USBD_Custom_HID_GetReport;
 80120f8:	4b52      	ldr	r3, [pc, #328]	; (8012244 <MX_USBX_Device_Init+0x220>)
 80120fa:	4a56      	ldr	r2, [pc, #344]	; (8012254 <MX_USBX_Device_Init+0x230>)
 80120fc:	619a      	str	r2, [r3, #24]
#ifdef UX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT
  custom_hid_parameter.ux_device_class_hid_parameter_receiver_initialize       = ux_device_class_hid_receiver_initialize;
 80120fe:	4b51      	ldr	r3, [pc, #324]	; (8012244 <MX_USBX_Device_Init+0x220>)
 8012100:	4a55      	ldr	r2, [pc, #340]	; (8012258 <MX_USBX_Device_Init+0x234>)
 8012102:	61da      	str	r2, [r3, #28]
  custom_hid_parameter.ux_device_class_hid_parameter_receiver_event_max_number = USBD_Custom_HID_EventMaxNumber();
 8012104:	f000 f916 	bl	8012334 <USBD_Custom_HID_EventMaxNumber>
 8012108:	4603      	mov	r3, r0
 801210a:	4a4e      	ldr	r2, [pc, #312]	; (8012244 <MX_USBX_Device_Init+0x220>)
 801210c:	6213      	str	r3, [r2, #32]
  custom_hid_parameter.ux_device_class_hid_parameter_receiver_event_max_length = USBD_Custom_HID_EventMaxLength();
 801210e:	f000 f91d 	bl	801234c <USBD_Custom_HID_EventMaxLength>
 8012112:	4603      	mov	r3, r0
 8012114:	4a4b      	ldr	r2, [pc, #300]	; (8012244 <MX_USBX_Device_Init+0x220>)
 8012116:	6253      	str	r3, [r2, #36]	; 0x24
  custom_hid_parameter.ux_device_class_hid_parameter_receiver_event_callback   = USBD_Custom_HID_SetReport;
 8012118:	4b4a      	ldr	r3, [pc, #296]	; (8012244 <MX_USBX_Device_Init+0x220>)
 801211a:	4a50      	ldr	r2, [pc, #320]	; (801225c <MX_USBX_Device_Init+0x238>)
 801211c:	629a      	str	r2, [r3, #40]	; 0x28
  /* USER CODE BEGIN CUSTOM_HID_PARAMETER */

  /* USER CODE END CUSTOM_HID_PARAMETER */

  /* Get Custom hid configuration number */
  hid_custom_configuration_number = USBD_Get_Configuration_Number(CLASS_TYPE_HID, INTERFACE_HID_CUSTOM);
 801211e:	2100      	movs	r1, #0
 8012120:	2001      	movs	r0, #1
 8012122:	f000 fa45 	bl	80125b0 <USBD_Get_Configuration_Number>
 8012126:	4603      	mov	r3, r0
 8012128:	461a      	mov	r2, r3
 801212a:	4b4d      	ldr	r3, [pc, #308]	; (8012260 <MX_USBX_Device_Init+0x23c>)
 801212c:	601a      	str	r2, [r3, #0]

  /* Find Custom hid interface number */
  hid_custom_interface_number = USBD_Get_Interface_Number(CLASS_TYPE_HID, INTERFACE_HID_CUSTOM);
 801212e:	2100      	movs	r1, #0
 8012130:	2001      	movs	r0, #1
 8012132:	f000 f9ff 	bl	8012534 <USBD_Get_Interface_Number>
 8012136:	4603      	mov	r3, r0
 8012138:	461a      	mov	r2, r3
 801213a:	4b4a      	ldr	r3, [pc, #296]	; (8012264 <MX_USBX_Device_Init+0x240>)
 801213c:	601a      	str	r2, [r3, #0]

  /* Initialize the device hid custom class */
  if (ux_device_stack_class_register(_ux_system_slave_class_hid_name,
 801213e:	4b48      	ldr	r3, [pc, #288]	; (8012260 <MX_USBX_Device_Init+0x23c>)
 8012140:	681a      	ldr	r2, [r3, #0]
 8012142:	4b48      	ldr	r3, [pc, #288]	; (8012264 <MX_USBX_Device_Init+0x240>)
 8012144:	681b      	ldr	r3, [r3, #0]
 8012146:	493f      	ldr	r1, [pc, #252]	; (8012244 <MX_USBX_Device_Init+0x220>)
 8012148:	9100      	str	r1, [sp, #0]
 801214a:	4947      	ldr	r1, [pc, #284]	; (8012268 <MX_USBX_Device_Init+0x244>)
 801214c:	4847      	ldr	r0, [pc, #284]	; (801226c <MX_USBX_Device_Init+0x248>)
 801214e:	f7fc fd0f 	bl	800eb70 <_ux_device_stack_class_register>
 8012152:	4603      	mov	r3, r0
 8012154:	2b00      	cmp	r3, #0
 8012156:	d001      	beq.n	801215c <MX_USBX_Device_Init+0x138>
                                     hid_custom_configuration_number,
                                     hid_custom_interface_number,
                                     &custom_hid_parameter) != UX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_DEVICE_HID_CUSTOM_REGISTER_ERORR */
    return UX_ERROR;
 8012158:	23ff      	movs	r3, #255	; 0xff
 801215a:	e06f      	b.n	801223c <MX_USBX_Device_Init+0x218>
    /* USER CODE END USBX_DEVICE_HID_CUSTOM_REGISTER_ERORR */
  }

  /* Initialize the storage class parameters for the device */
  storage_parameter.ux_slave_class_storage_instance_activate   = USBD_STORAGE_Activate;
 801215c:	4b44      	ldr	r3, [pc, #272]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 801215e:	4a45      	ldr	r2, [pc, #276]	; (8012274 <MX_USBX_Device_Init+0x250>)
 8012160:	601a      	str	r2, [r3, #0]
  storage_parameter.ux_slave_class_storage_instance_deactivate = USBD_STORAGE_Deactivate;
 8012162:	4b43      	ldr	r3, [pc, #268]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 8012164:	4a44      	ldr	r2, [pc, #272]	; (8012278 <MX_USBX_Device_Init+0x254>)
 8012166:	605a      	str	r2, [r3, #4]

  /* Store the number of LUN in this device storage instance */
  storage_parameter.ux_slave_class_storage_parameter_number_lun = STORAGE_NUMBER_LUN;
 8012168:	4b41      	ldr	r3, [pc, #260]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 801216a:	2201      	movs	r2, #1
 801216c:	609a      	str	r2, [r3, #8]

  /* Initialize the storage class parameters for reading/writing to the Flash Disk */
  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_last_lba = USBD_STORAGE_GetMediaLastLba();
 801216e:	f001 f863 	bl	8013238 <USBD_STORAGE_GetMediaLastLba>
 8012172:	4603      	mov	r3, r0
 8012174:	4a3e      	ldr	r2, [pc, #248]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 8012176:	60d3      	str	r3, [r2, #12]

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_block_length = USBD_STORAGE_GetMediaBlocklength();
 8012178:	f001 f86a 	bl	8013250 <USBD_STORAGE_GetMediaBlocklength>
 801217c:	4603      	mov	r3, r0
 801217e:	4a3c      	ldr	r2, [pc, #240]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 8012180:	6113      	str	r3, [r2, #16]

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_type = 0;
 8012182:	4b3b      	ldr	r3, [pc, #236]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 8012184:	2200      	movs	r2, #0
 8012186:	615a      	str	r2, [r3, #20]

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_removable_flag = STORAGE_REMOVABLE_FLAG;
 8012188:	4b39      	ldr	r3, [pc, #228]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 801218a:	2280      	movs	r2, #128	; 0x80
 801218c:	619a      	str	r2, [r3, #24]

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_read_only_flag = STORAGE_READ_ONLY;
 801218e:	4b38      	ldr	r3, [pc, #224]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 8012190:	2200      	movs	r2, #0
 8012192:	61da      	str	r2, [r3, #28]

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_read = USBD_STORAGE_Read;
 8012194:	4b36      	ldr	r3, [pc, #216]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 8012196:	4a39      	ldr	r2, [pc, #228]	; (801227c <MX_USBX_Device_Init+0x258>)
 8012198:	631a      	str	r2, [r3, #48]	; 0x30

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_write = USBD_STORAGE_Write;
 801219a:	4b35      	ldr	r3, [pc, #212]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 801219c:	4a38      	ldr	r2, [pc, #224]	; (8012280 <MX_USBX_Device_Init+0x25c>)
 801219e:	635a      	str	r2, [r3, #52]	; 0x34

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_flush = USBD_STORAGE_Flush;
 80121a0:	4b33      	ldr	r3, [pc, #204]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 80121a2:	4a38      	ldr	r2, [pc, #224]	; (8012284 <MX_USBX_Device_Init+0x260>)
 80121a4:	639a      	str	r2, [r3, #56]	; 0x38

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_status = USBD_STORAGE_Status;
 80121a6:	4b32      	ldr	r3, [pc, #200]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 80121a8:	4a37      	ldr	r2, [pc, #220]	; (8012288 <MX_USBX_Device_Init+0x264>)
 80121aa:	63da      	str	r2, [r3, #60]	; 0x3c

  storage_parameter.ux_slave_class_storage_parameter_lun[0].
    ux_slave_class_storage_media_notification = USBD_STORAGE_Notification;
 80121ac:	4b30      	ldr	r3, [pc, #192]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 80121ae:	4a37      	ldr	r2, [pc, #220]	; (801228c <MX_USBX_Device_Init+0x268>)
 80121b0:	641a      	str	r2, [r3, #64]	; 0x40
  /* USER CODE BEGIN STORAGE_PARAMETER */

  /* USER CODE END STORAGE_PARAMETER */

  /* Get storage configuration number */
  storage_configuration_number = USBD_Get_Configuration_Number(CLASS_TYPE_MSC, 0);
 80121b2:	2100      	movs	r1, #0
 80121b4:	2003      	movs	r0, #3
 80121b6:	f000 f9fb 	bl	80125b0 <USBD_Get_Configuration_Number>
 80121ba:	4603      	mov	r3, r0
 80121bc:	461a      	mov	r2, r3
 80121be:	4b34      	ldr	r3, [pc, #208]	; (8012290 <MX_USBX_Device_Init+0x26c>)
 80121c0:	601a      	str	r2, [r3, #0]

  /* Find storage interface number */
  storage_interface_number = USBD_Get_Interface_Number(CLASS_TYPE_MSC, 0);
 80121c2:	2100      	movs	r1, #0
 80121c4:	2003      	movs	r0, #3
 80121c6:	f000 f9b5 	bl	8012534 <USBD_Get_Interface_Number>
 80121ca:	4603      	mov	r3, r0
 80121cc:	461a      	mov	r2, r3
 80121ce:	4b31      	ldr	r3, [pc, #196]	; (8012294 <MX_USBX_Device_Init+0x270>)
 80121d0:	601a      	str	r2, [r3, #0]

  /* Initialize the device storage class */
  if (ux_device_stack_class_register(_ux_system_slave_class_storage_name,
 80121d2:	4b2f      	ldr	r3, [pc, #188]	; (8012290 <MX_USBX_Device_Init+0x26c>)
 80121d4:	681a      	ldr	r2, [r3, #0]
 80121d6:	4b2f      	ldr	r3, [pc, #188]	; (8012294 <MX_USBX_Device_Init+0x270>)
 80121d8:	681b      	ldr	r3, [r3, #0]
 80121da:	4925      	ldr	r1, [pc, #148]	; (8012270 <MX_USBX_Device_Init+0x24c>)
 80121dc:	9100      	str	r1, [sp, #0]
 80121de:	492e      	ldr	r1, [pc, #184]	; (8012298 <MX_USBX_Device_Init+0x274>)
 80121e0:	482e      	ldr	r0, [pc, #184]	; (801229c <MX_USBX_Device_Init+0x278>)
 80121e2:	f7fc fcc5 	bl	800eb70 <_ux_device_stack_class_register>
 80121e6:	4603      	mov	r3, r0
 80121e8:	2b00      	cmp	r3, #0
 80121ea:	d001      	beq.n	80121f0 <MX_USBX_Device_Init+0x1cc>
                                     storage_configuration_number,
                                     storage_interface_number,
                                     &storage_parameter) != UX_SUCCESS)
  {
    /* USER CODE BEGIN USBX_DEVICE_STORAGE_REGISTER_ERORR */
    return UX_ERROR;
 80121ec:	23ff      	movs	r3, #255	; 0xff
 80121ee:	e025      	b.n	801223c <MX_USBX_Device_Init+0x218>
    /* USER CODE END USBX_DEVICE_STORAGE_REGISTER_ERORR */
  }

  /* Allocate the stack for device application main thread */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer, UX_DEVICE_APP_THREAD_STACK_SIZE,
 80121f0:	f107 010c 	add.w	r1, r7, #12
 80121f4:	2300      	movs	r3, #0
 80121f6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80121fa:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80121fc:	f7f9 f89c 	bl	800b338 <_tx_byte_allocate>
 8012200:	4603      	mov	r3, r0
 8012202:	2b00      	cmp	r3, #0
 8012204:	d001      	beq.n	801220a <MX_USBX_Device_Init+0x1e6>
                       TX_NO_WAIT) != TX_SUCCESS)
  {
    /* USER CODE BEGIN MAIN_THREAD_ALLOCATE_STACK_ERORR */
    return TX_POOL_ERROR;
 8012206:	2302      	movs	r3, #2
 8012208:	e018      	b.n	801223c <MX_USBX_Device_Init+0x218>
    /* USER CODE END MAIN_THREAD_ALLOCATE_STACK_ERORR */
  }

  /* Create the device application main thread */
  if (tx_thread_create(&ux_device_app_thread, UX_DEVICE_APP_THREAD_NAME, app_ux_device_thread_entry,
 801220a:	68fb      	ldr	r3, [r7, #12]
 801220c:	2201      	movs	r2, #1
 801220e:	9205      	str	r2, [sp, #20]
 8012210:	2200      	movs	r2, #0
 8012212:	9204      	str	r2, [sp, #16]
 8012214:	220a      	movs	r2, #10
 8012216:	9203      	str	r2, [sp, #12]
 8012218:	220a      	movs	r2, #10
 801221a:	9202      	str	r2, [sp, #8]
 801221c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8012220:	9201      	str	r2, [sp, #4]
 8012222:	9300      	str	r3, [sp, #0]
 8012224:	2300      	movs	r3, #0
 8012226:	4a1e      	ldr	r2, [pc, #120]	; (80122a0 <MX_USBX_Device_Init+0x27c>)
 8012228:	491e      	ldr	r1, [pc, #120]	; (80122a4 <MX_USBX_Device_Init+0x280>)
 801222a:	481f      	ldr	r0, [pc, #124]	; (80122a8 <MX_USBX_Device_Init+0x284>)
 801222c:	f7fb f80a 	bl	800d244 <_tx_thread_create>
 8012230:	4603      	mov	r3, r0
 8012232:	2b00      	cmp	r3, #0
 8012234:	d001      	beq.n	801223a <MX_USBX_Device_Init+0x216>
                       0, pointer, UX_DEVICE_APP_THREAD_STACK_SIZE, UX_DEVICE_APP_THREAD_PRIO,
                       UX_DEVICE_APP_THREAD_PREEMPTION_THRESHOLD, UX_DEVICE_APP_THREAD_TIME_SLICE,
                       UX_DEVICE_APP_THREAD_START_OPTION) != TX_SUCCESS)
  {
    /* USER CODE BEGIN MAIN_THREAD_CREATE_ERORR */
    return TX_THREAD_ERROR;
 8012236:	230e      	movs	r3, #14
 8012238:	e000      	b.n	801223c <MX_USBX_Device_Init+0x218>

  /* USER CODE BEGIN MX_USBX_Device_Init1 */

  /* USER CODE END MX_USBX_Device_Init1 */

  return ret;
 801223a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 801223c:	4618      	mov	r0, r3
 801223e:	373c      	adds	r7, #60	; 0x3c
 8012240:	46bd      	mov	sp, r7
 8012242:	bd90      	pop	{r4, r7, pc}
 8012244:	20007324 	.word	0x20007324
 8012248:	080122c1 	.word	0x080122c1
 801224c:	080122d5 	.word	0x080122d5
 8012250:	080122e9 	.word	0x080122e9
 8012254:	08012305 	.word	0x08012305
 8012258:	080104ad 	.word	0x080104ad
 801225c:	08012321 	.word	0x08012321
 8012260:	20007318 	.word	0x20007318
 8012264:	20007314 	.word	0x20007314
 8012268:	080100ad 	.word	0x080100ad
 801226c:	200000ac 	.word	0x200000ac
 8012270:	20007350 	.word	0x20007350
 8012274:	08013171 	.word	0x08013171
 8012278:	08013185 	.word	0x08013185
 801227c:	08013199 	.word	0x08013199
 8012280:	080131b9 	.word	0x080131b9
 8012284:	080131d9 	.word	0x080131d9
 8012288:	080131f9 	.word	0x080131f9
 801228c:	08013219 	.word	0x08013219
 8012290:	20007320 	.word	0x20007320
 8012294:	2000731c 	.word	0x2000731c
 8012298:	08010b15 	.word	0x08010b15
 801229c:	20000094 	.word	0x20000094
 80122a0:	080122ad 	.word	0x080122ad
 80122a4:	08013490 	.word	0x08013490
 80122a8:	200073a4 	.word	0x200073a4

080122ac <app_ux_device_thread_entry>:
  * @brief  Function implementing app_ux_device_thread_entry.
  * @param  thread_input: User thread input parameter.
  * @retval none
  */
static VOID app_ux_device_thread_entry(ULONG thread_input)
{
 80122ac:	b480      	push	{r7}
 80122ae:	b083      	sub	sp, #12
 80122b0:	af00      	add	r7, sp, #0
 80122b2:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN app_ux_device_thread_entry */
  TX_PARAMETER_NOT_USED(thread_input);
  /* USER CODE END app_ux_device_thread_entry */
}
 80122b4:	bf00      	nop
 80122b6:	370c      	adds	r7, #12
 80122b8:	46bd      	mov	sp, r7
 80122ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80122be:	4770      	bx	lr

080122c0 <USBD_Custom_HID_Activate>:
  *         This function is called when insertion of a Custom HID device.
  * @param  hid_instance: Pointer to the hid class instance.
  * @retval none
  */
VOID USBD_Custom_HID_Activate(VOID *hid_instance)
{
 80122c0:	b480      	push	{r7}
 80122c2:	b083      	sub	sp, #12
 80122c4:	af00      	add	r7, sp, #0
 80122c6:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN USBD_Custom_HID_Activate */
  UX_PARAMETER_NOT_USED(hid_instance);
  /* USER CODE END USBD_Custom_HID_Activate */

  return;
 80122c8:	bf00      	nop
}
 80122ca:	370c      	adds	r7, #12
 80122cc:	46bd      	mov	sp, r7
 80122ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80122d2:	4770      	bx	lr

080122d4 <USBD_Custom_HID_Deactivate>:
  *         This function is called when extraction of a Custom HID device.
  * @param  hid_instance: Pointer to the hid class instance.
  * @retval none
  */
VOID USBD_Custom_HID_Deactivate(VOID *hid_instance)
{
 80122d4:	b480      	push	{r7}
 80122d6:	b083      	sub	sp, #12
 80122d8:	af00      	add	r7, sp, #0
 80122da:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN USBD_Custom_HID_Deactivate */
  UX_PARAMETER_NOT_USED(hid_instance);
  /* USER CODE END USBD_Custom_HID_Deactivate */

  return;
 80122dc:	bf00      	nop
}
 80122de:	370c      	adds	r7, #12
 80122e0:	46bd      	mov	sp, r7
 80122e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80122e6:	4770      	bx	lr

080122e8 <USBD_Custom_HID_SetFeature>:
  * @param  hid_event: Pointer to structure of the hid event.
  * @retval status
  */
UINT USBD_Custom_HID_SetFeature(UX_SLAVE_CLASS_HID *hid_instance,
                                UX_SLAVE_CLASS_HID_EVENT *hid_event)
{
 80122e8:	b480      	push	{r7}
 80122ea:	b085      	sub	sp, #20
 80122ec:	af00      	add	r7, sp, #0
 80122ee:	6078      	str	r0, [r7, #4]
 80122f0:	6039      	str	r1, [r7, #0]
  UINT status = UX_SUCCESS;
 80122f2:	2300      	movs	r3, #0
 80122f4:	60fb      	str	r3, [r7, #12]
  /* USER CODE BEGIN USBD_Custom_HID_SetFeature */
  UX_PARAMETER_NOT_USED(hid_instance);
  UX_PARAMETER_NOT_USED(hid_event);
  /* USER CODE END USBD_Custom_HID_SetFeature */

  return status;
 80122f6:	68fb      	ldr	r3, [r7, #12]
}
 80122f8:	4618      	mov	r0, r3
 80122fa:	3714      	adds	r7, #20
 80122fc:	46bd      	mov	sp, r7
 80122fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012302:	4770      	bx	lr

08012304 <USBD_Custom_HID_GetReport>:
  * @param  hid_event: Pointer to structure of the hid event.
  * @retval status
  */
UINT USBD_Custom_HID_GetReport(UX_SLAVE_CLASS_HID *hid_instance,
                               UX_SLAVE_CLASS_HID_EVENT *hid_event)
{
 8012304:	b480      	push	{r7}
 8012306:	b085      	sub	sp, #20
 8012308:	af00      	add	r7, sp, #0
 801230a:	6078      	str	r0, [r7, #4]
 801230c:	6039      	str	r1, [r7, #0]
  UINT status = UX_SUCCESS;
 801230e:	2300      	movs	r3, #0
 8012310:	60fb      	str	r3, [r7, #12]
  /* USER CODE BEGIN USBD_Custom_HID_GetReport */
  UX_PARAMETER_NOT_USED(hid_instance);
  UX_PARAMETER_NOT_USED(hid_event);
  /* USER CODE END USBD_Custom_HID_GetReport */

  return status;
 8012312:	68fb      	ldr	r3, [r7, #12]
}
 8012314:	4618      	mov	r0, r3
 8012316:	3714      	adds	r7, #20
 8012318:	46bd      	mov	sp, r7
 801231a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801231e:	4770      	bx	lr

08012320 <USBD_Custom_HID_SetReport>:
  *         to the application over Endpoint OUT (Set Report).
  * @param  hid_instance: Pointer to the hid class instance.
  * @retval none
  */
VOID USBD_Custom_HID_SetReport(struct UX_SLAVE_CLASS_HID_STRUCT *hid_instance)
{
 8012320:	b480      	push	{r7}
 8012322:	b083      	sub	sp, #12
 8012324:	af00      	add	r7, sp, #0
 8012326:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN USBD_Custom_HID_SetReport */
  UX_PARAMETER_NOT_USED(hid_instance);
  /* USER CODE END USBD_Custom_HID_SetReport */

  return;
 8012328:	bf00      	nop
}
 801232a:	370c      	adds	r7, #12
 801232c:	46bd      	mov	sp, r7
 801232e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012332:	4770      	bx	lr

08012334 <USBD_Custom_HID_EventMaxNumber>:
  *         This function to set receiver event max number parameter.
  * @param  none
  * @retval receiver event max number
  */
ULONG USBD_Custom_HID_EventMaxNumber(VOID)
{
 8012334:	b480      	push	{r7}
 8012336:	b083      	sub	sp, #12
 8012338:	af00      	add	r7, sp, #0
  ULONG max_number = 0U;
 801233a:	2300      	movs	r3, #0
 801233c:	607b      	str	r3, [r7, #4]

  /* USER CODE BEGIN USBD_Custom_HID_EventMaxNumber */

  /* USER CODE END USBD_Custom_HID_EventMaxNumber */

  return max_number;
 801233e:	687b      	ldr	r3, [r7, #4]
}
 8012340:	4618      	mov	r0, r3
 8012342:	370c      	adds	r7, #12
 8012344:	46bd      	mov	sp, r7
 8012346:	f85d 7b04 	ldr.w	r7, [sp], #4
 801234a:	4770      	bx	lr

0801234c <USBD_Custom_HID_EventMaxLength>:
  *         This function to set receiver event max length parameter.
  * @param  none
  * @retval receiver event max length
  */
ULONG USBD_Custom_HID_EventMaxLength(VOID)
{
 801234c:	b480      	push	{r7}
 801234e:	b083      	sub	sp, #12
 8012350:	af00      	add	r7, sp, #0
  ULONG max_length = 0U;
 8012352:	2300      	movs	r3, #0
 8012354:	607b      	str	r3, [r7, #4]

  /* USER CODE BEGIN USBD_Custom_HID_EventMaxLength */

  /* USER CODE END USBD_Custom_HID_EventMaxLength */

  return max_length;
 8012356:	687b      	ldr	r3, [r7, #4]
}
 8012358:	4618      	mov	r0, r3
 801235a:	370c      	adds	r7, #12
 801235c:	46bd      	mov	sp, r7
 801235e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012362:	4770      	bx	lr

08012364 <USBD_Get_Device_Framework_Speed>:
  * @param  Speed : HIGH or FULL SPEED flag
  * @param  length : length of HIGH or FULL SPEED array
  * @retval Pointer to descriptor buffer
  */
uint8_t *USBD_Get_Device_Framework_Speed(uint8_t Speed, ULONG *Length)
{
 8012364:	b580      	push	{r7, lr}
 8012366:	b084      	sub	sp, #16
 8012368:	af00      	add	r7, sp, #0
 801236a:	4603      	mov	r3, r0
 801236c:	6039      	str	r1, [r7, #0]
 801236e:	71fb      	strb	r3, [r7, #7]
  uint8_t *pFrameWork = NULL;
 8012370:	2300      	movs	r3, #0
 8012372:	60fb      	str	r3, [r7, #12]
  /* USER CODE BEGIN Device_Framework0 */

  /* USER TAG BEGIN Device_Framework0 */

  if (USBD_FULL_SPEED == Speed)
 8012374:	79fb      	ldrb	r3, [r7, #7]
 8012376:	2b00      	cmp	r3, #0
 8012378:	d113      	bne.n	80123a2 <USBD_Get_Device_Framework_Speed+0x3e>
  {
    USBD_Device_Framework_Builder(&USBD_Device_FS, pDevFrameWorkDesc_FS,
 801237a:	4b16      	ldr	r3, [pc, #88]	; (80123d4 <USBD_Get_Device_Framework_Speed+0x70>)
 801237c:	6819      	ldr	r1, [r3, #0]
 801237e:	79fb      	ldrb	r3, [r7, #7]
 8012380:	4a15      	ldr	r2, [pc, #84]	; (80123d8 <USBD_Get_Device_Framework_Speed+0x74>)
 8012382:	4816      	ldr	r0, [pc, #88]	; (80123dc <USBD_Get_Device_Framework_Speed+0x78>)
 8012384:	f000 f9a0 	bl	80126c8 <USBD_Device_Framework_Builder>
                                  UserClassInstance, Speed);

    /* Get the length of USBD_device_framework_full_speed */
    *Length = (ULONG)(USBD_Device_FS.CurrDevDescSz + USBD_Device_FS.CurrConfDescSz);
 8012388:	4b14      	ldr	r3, [pc, #80]	; (80123dc <USBD_Get_Device_Framework_Speed+0x78>)
 801238a:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
 801238e:	4b13      	ldr	r3, [pc, #76]	; (80123dc <USBD_Get_Device_Framework_Speed+0x78>)
 8012390:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 8012394:	441a      	add	r2, r3
 8012396:	683b      	ldr	r3, [r7, #0]
 8012398:	601a      	str	r2, [r3, #0]

    pFrameWork = pDevFrameWorkDesc_FS;
 801239a:	4b0e      	ldr	r3, [pc, #56]	; (80123d4 <USBD_Get_Device_Framework_Speed+0x70>)
 801239c:	681b      	ldr	r3, [r3, #0]
 801239e:	60fb      	str	r3, [r7, #12]
 80123a0:	e012      	b.n	80123c8 <USBD_Get_Device_Framework_Speed+0x64>
  }
  else
  {
    USBD_Device_Framework_Builder(&USBD_Device_HS, pDevFrameWorkDesc_HS,
 80123a2:	4b0f      	ldr	r3, [pc, #60]	; (80123e0 <USBD_Get_Device_Framework_Speed+0x7c>)
 80123a4:	6819      	ldr	r1, [r3, #0]
 80123a6:	79fb      	ldrb	r3, [r7, #7]
 80123a8:	4a0b      	ldr	r2, [pc, #44]	; (80123d8 <USBD_Get_Device_Framework_Speed+0x74>)
 80123aa:	480e      	ldr	r0, [pc, #56]	; (80123e4 <USBD_Get_Device_Framework_Speed+0x80>)
 80123ac:	f000 f98c 	bl	80126c8 <USBD_Device_Framework_Builder>
                                  UserClassInstance, Speed);

    /* Get the length of USBD_device_framework_high_speed */
    *Length = (ULONG)(USBD_Device_HS.CurrDevDescSz + USBD_Device_HS.CurrConfDescSz);
 80123b0:	4b0c      	ldr	r3, [pc, #48]	; (80123e4 <USBD_Get_Device_Framework_Speed+0x80>)
 80123b2:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
 80123b6:	4b0b      	ldr	r3, [pc, #44]	; (80123e4 <USBD_Get_Device_Framework_Speed+0x80>)
 80123b8:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 80123bc:	441a      	add	r2, r3
 80123be:	683b      	ldr	r3, [r7, #0]
 80123c0:	601a      	str	r2, [r3, #0]

    pFrameWork = pDevFrameWorkDesc_HS;
 80123c2:	4b07      	ldr	r3, [pc, #28]	; (80123e0 <USBD_Get_Device_Framework_Speed+0x7c>)
 80123c4:	681b      	ldr	r3, [r3, #0]
 80123c6:	60fb      	str	r3, [r7, #12]
  }
  /* USER CODE Device_Framework1 */

  /* USER CODE Device_Framework1 */
  return pFrameWork;
 80123c8:	68fb      	ldr	r3, [r7, #12]
}
 80123ca:	4618      	mov	r0, r3
 80123cc:	3710      	adds	r7, #16
 80123ce:	46bd      	mov	sp, r7
 80123d0:	bd80      	pop	{r7, pc}
 80123d2:	bf00      	nop
 80123d4:	2000010c 	.word	0x2000010c
 80123d8:	20000100 	.word	0x20000100
 80123dc:	20007454 	.word	0x20007454
 80123e0:	20000110 	.word	0x20000110
 80123e4:	2000757c 	.word	0x2000757c

080123e8 <USBD_Get_String_Framework>:
  *         Return the language_id_framework
  * @param  Length : Length of String_Framework
  * @retval Pointer to language_id_framework buffer
  */
uint8_t *USBD_Get_String_Framework(ULONG *Length)
{
 80123e8:	b580      	push	{r7, lr}
 80123ea:	b084      	sub	sp, #16
 80123ec:	af00      	add	r7, sp, #0
 80123ee:	6078      	str	r0, [r7, #4]
  uint16_t len = 0U;
 80123f0:	2300      	movs	r3, #0
 80123f2:	81bb      	strh	r3, [r7, #12]
  uint8_t count = 0U;
 80123f4:	2300      	movs	r3, #0
 80123f6:	73fb      	strb	r3, [r7, #15]
  /* USER CODE String_Framework0 */

  /* USER CODE String_Framework0 */

  /* Set the Manufacturer language Id and index in USBD_string_framework */
  USBD_string_framework[count++] = USBD_LANGID_STRING & 0xFF;
 80123f8:	7bfb      	ldrb	r3, [r7, #15]
 80123fa:	1c5a      	adds	r2, r3, #1
 80123fc:	73fa      	strb	r2, [r7, #15]
 80123fe:	461a      	mov	r2, r3
 8012400:	4b37      	ldr	r3, [pc, #220]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 8012402:	2109      	movs	r1, #9
 8012404:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_LANGID_STRING >> 8;
 8012406:	7bfb      	ldrb	r3, [r7, #15]
 8012408:	1c5a      	adds	r2, r3, #1
 801240a:	73fa      	strb	r2, [r7, #15]
 801240c:	461a      	mov	r2, r3
 801240e:	4b34      	ldr	r3, [pc, #208]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 8012410:	2104      	movs	r1, #4
 8012412:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_IDX_MFC_STR;
 8012414:	7bfb      	ldrb	r3, [r7, #15]
 8012416:	1c5a      	adds	r2, r3, #1
 8012418:	73fa      	strb	r2, [r7, #15]
 801241a:	461a      	mov	r2, r3
 801241c:	4b30      	ldr	r3, [pc, #192]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 801241e:	2101      	movs	r1, #1
 8012420:	5499      	strb	r1, [r3, r2]

  /* Set the Manufacturer string in string_framework */
  USBD_Desc_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_string_framework + count, &len);
 8012422:	7bfb      	ldrb	r3, [r7, #15]
 8012424:	4a2e      	ldr	r2, [pc, #184]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 8012426:	4413      	add	r3, r2
 8012428:	f107 020c 	add.w	r2, r7, #12
 801242c:	4619      	mov	r1, r3
 801242e:	482d      	ldr	r0, [pc, #180]	; (80124e4 <USBD_Get_String_Framework+0xfc>)
 8012430:	f000 f8fd 	bl	801262e <USBD_Desc_GetString>

  /* Set the Product language Id and index in USBD_string_framework */
  count += len + 1;
 8012434:	89bb      	ldrh	r3, [r7, #12]
 8012436:	b2da      	uxtb	r2, r3
 8012438:	7bfb      	ldrb	r3, [r7, #15]
 801243a:	4413      	add	r3, r2
 801243c:	b2db      	uxtb	r3, r3
 801243e:	3301      	adds	r3, #1
 8012440:	73fb      	strb	r3, [r7, #15]
  USBD_string_framework[count++] = USBD_LANGID_STRING & 0xFF;
 8012442:	7bfb      	ldrb	r3, [r7, #15]
 8012444:	1c5a      	adds	r2, r3, #1
 8012446:	73fa      	strb	r2, [r7, #15]
 8012448:	461a      	mov	r2, r3
 801244a:	4b25      	ldr	r3, [pc, #148]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 801244c:	2109      	movs	r1, #9
 801244e:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_LANGID_STRING >> 8;
 8012450:	7bfb      	ldrb	r3, [r7, #15]
 8012452:	1c5a      	adds	r2, r3, #1
 8012454:	73fa      	strb	r2, [r7, #15]
 8012456:	461a      	mov	r2, r3
 8012458:	4b21      	ldr	r3, [pc, #132]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 801245a:	2104      	movs	r1, #4
 801245c:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_IDX_PRODUCT_STR;
 801245e:	7bfb      	ldrb	r3, [r7, #15]
 8012460:	1c5a      	adds	r2, r3, #1
 8012462:	73fa      	strb	r2, [r7, #15]
 8012464:	461a      	mov	r2, r3
 8012466:	4b1e      	ldr	r3, [pc, #120]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 8012468:	2102      	movs	r1, #2
 801246a:	5499      	strb	r1, [r3, r2]

  /* Set the Product string in USBD_string_framework */
  USBD_Desc_GetString((uint8_t *)USBD_PRODUCT_STRING, USBD_string_framework + count, &len);
 801246c:	7bfb      	ldrb	r3, [r7, #15]
 801246e:	4a1c      	ldr	r2, [pc, #112]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 8012470:	4413      	add	r3, r2
 8012472:	f107 020c 	add.w	r2, r7, #12
 8012476:	4619      	mov	r1, r3
 8012478:	481b      	ldr	r0, [pc, #108]	; (80124e8 <USBD_Get_String_Framework+0x100>)
 801247a:	f000 f8d8 	bl	801262e <USBD_Desc_GetString>

  /* Set Serial language Id and index in string_framework */
  count += len + 1;
 801247e:	89bb      	ldrh	r3, [r7, #12]
 8012480:	b2da      	uxtb	r2, r3
 8012482:	7bfb      	ldrb	r3, [r7, #15]
 8012484:	4413      	add	r3, r2
 8012486:	b2db      	uxtb	r3, r3
 8012488:	3301      	adds	r3, #1
 801248a:	73fb      	strb	r3, [r7, #15]
  USBD_string_framework[count++] = USBD_LANGID_STRING & 0xFF;
 801248c:	7bfb      	ldrb	r3, [r7, #15]
 801248e:	1c5a      	adds	r2, r3, #1
 8012490:	73fa      	strb	r2, [r7, #15]
 8012492:	461a      	mov	r2, r3
 8012494:	4b12      	ldr	r3, [pc, #72]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 8012496:	2109      	movs	r1, #9
 8012498:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_LANGID_STRING >> 8;
 801249a:	7bfb      	ldrb	r3, [r7, #15]
 801249c:	1c5a      	adds	r2, r3, #1
 801249e:	73fa      	strb	r2, [r7, #15]
 80124a0:	461a      	mov	r2, r3
 80124a2:	4b0f      	ldr	r3, [pc, #60]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 80124a4:	2104      	movs	r1, #4
 80124a6:	5499      	strb	r1, [r3, r2]
  USBD_string_framework[count++] = USBD_IDX_SERIAL_STR;
 80124a8:	7bfb      	ldrb	r3, [r7, #15]
 80124aa:	1c5a      	adds	r2, r3, #1
 80124ac:	73fa      	strb	r2, [r7, #15]
 80124ae:	461a      	mov	r2, r3
 80124b0:	4b0b      	ldr	r3, [pc, #44]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 80124b2:	2103      	movs	r1, #3
 80124b4:	5499      	strb	r1, [r3, r2]

  /* Set the Serial number in USBD_string_framework */
  USBD_Desc_GetString((uint8_t *)USBD_SERIAL_NUMBER, USBD_string_framework + count, &len);
 80124b6:	7bfb      	ldrb	r3, [r7, #15]
 80124b8:	4a09      	ldr	r2, [pc, #36]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 80124ba:	4413      	add	r3, r2
 80124bc:	f107 020c 	add.w	r2, r7, #12
 80124c0:	4619      	mov	r1, r3
 80124c2:	480a      	ldr	r0, [pc, #40]	; (80124ec <USBD_Get_String_Framework+0x104>)
 80124c4:	f000 f8b3 	bl	801262e <USBD_Desc_GetString>
  /* USER CODE String_Framework1 */

  /* USER CODE String_Framework1 */

  /* Get the length of USBD_string_framework */
  *Length = strlen((const char *)USBD_string_framework);
 80124c8:	4805      	ldr	r0, [pc, #20]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
 80124ca:	f7ed ff75 	bl	80003b8 <strlen>
 80124ce:	4602      	mov	r2, r0
 80124d0:	687b      	ldr	r3, [r7, #4]
 80124d2:	601a      	str	r2, [r3, #0]

  return USBD_string_framework;
 80124d4:	4b02      	ldr	r3, [pc, #8]	; (80124e0 <USBD_Get_String_Framework+0xf8>)
}
 80124d6:	4618      	mov	r0, r3
 80124d8:	3710      	adds	r7, #16
 80124da:	46bd      	mov	sp, r7
 80124dc:	bd80      	pop	{r7, pc}
 80124de:	bf00      	nop
 80124e0:	20007838 	.word	0x20007838
 80124e4:	080134ac 	.word	0x080134ac
 80124e8:	080134c0 	.word	0x080134c0
 80124ec:	080134d4 	.word	0x080134d4

080124f0 <USBD_Get_Language_Id_Framework>:
  *         Return the language_id_framework
  * @param  Length : Length of Language_Id_Framework
  * @retval Pointer to language_id_framework buffer
  */
uint8_t *USBD_Get_Language_Id_Framework(ULONG *Length)
{
 80124f0:	b580      	push	{r7, lr}
 80124f2:	b084      	sub	sp, #16
 80124f4:	af00      	add	r7, sp, #0
 80124f6:	6078      	str	r0, [r7, #4]
  uint8_t count = 0U;
 80124f8:	2300      	movs	r3, #0
 80124fa:	73fb      	strb	r3, [r7, #15]

  /* Set the language Id in USBD_language_id_framework */
  USBD_language_id_framework[count++] = USBD_LANGID_STRING & 0xFF;
 80124fc:	7bfb      	ldrb	r3, [r7, #15]
 80124fe:	1c5a      	adds	r2, r3, #1
 8012500:	73fa      	strb	r2, [r7, #15]
 8012502:	461a      	mov	r2, r3
 8012504:	4b0a      	ldr	r3, [pc, #40]	; (8012530 <USBD_Get_Language_Id_Framework+0x40>)
 8012506:	2109      	movs	r1, #9
 8012508:	5499      	strb	r1, [r3, r2]
  USBD_language_id_framework[count++] = USBD_LANGID_STRING >> 8;
 801250a:	7bfb      	ldrb	r3, [r7, #15]
 801250c:	1c5a      	adds	r2, r3, #1
 801250e:	73fa      	strb	r2, [r7, #15]
 8012510:	461a      	mov	r2, r3
 8012512:	4b07      	ldr	r3, [pc, #28]	; (8012530 <USBD_Get_Language_Id_Framework+0x40>)
 8012514:	2104      	movs	r1, #4
 8012516:	5499      	strb	r1, [r3, r2]

  /* Get the length of USBD_language_id_framework */
  *Length = strlen((const char *)USBD_language_id_framework);
 8012518:	4805      	ldr	r0, [pc, #20]	; (8012530 <USBD_Get_Language_Id_Framework+0x40>)
 801251a:	f7ed ff4d 	bl	80003b8 <strlen>
 801251e:	4602      	mov	r2, r0
 8012520:	687b      	ldr	r3, [r7, #4]
 8012522:	601a      	str	r2, [r3, #0]

  return USBD_language_id_framework;
 8012524:	4b02      	ldr	r3, [pc, #8]	; (8012530 <USBD_Get_Language_Id_Framework+0x40>)
}
 8012526:	4618      	mov	r0, r3
 8012528:	3710      	adds	r7, #16
 801252a:	46bd      	mov	sp, r7
 801252c:	bd80      	pop	{r7, pc}
 801252e:	bf00      	nop
 8012530:	20007938 	.word	0x20007938

08012534 <USBD_Get_Interface_Number>:
  * @param  class_type : Device class type
  * @param  interface_type : Device interface type
  * @retval interface number
  */
uint16_t USBD_Get_Interface_Number(uint8_t class_type, uint8_t interface_type)
{
 8012534:	b480      	push	{r7}
 8012536:	b085      	sub	sp, #20
 8012538:	af00      	add	r7, sp, #0
 801253a:	4603      	mov	r3, r0
 801253c:	460a      	mov	r2, r1
 801253e:	71fb      	strb	r3, [r7, #7]
 8012540:	4613      	mov	r3, r2
 8012542:	71bb      	strb	r3, [r7, #6]
  uint8_t itf_num = 0U;
 8012544:	2300      	movs	r3, #0
 8012546:	73fb      	strb	r3, [r7, #15]
  uint8_t idx = 0U;
 8012548:	2300      	movs	r3, #0
 801254a:	73bb      	strb	r3, [r7, #14]

  /* USER CODE BEGIN USBD_Get_Interface_Number0 */

  /* USER CODE BEGIN USBD_Get_Interface_Number0 */

  for(idx = 0; idx < USBD_MAX_SUPPORTED_CLASS; idx++)
 801254c:	2300      	movs	r3, #0
 801254e:	73bb      	strb	r3, [r7, #14]
 8012550:	e021      	b.n	8012596 <USBD_Get_Interface_Number+0x62>
  {
    if ((USBD_Device_FS.tclasslist[idx].ClassType == class_type) &&
 8012552:	7bbb      	ldrb	r3, [r7, #14]
 8012554:	4a15      	ldr	r2, [pc, #84]	; (80125ac <USBD_Get_Interface_Number+0x78>)
 8012556:	215c      	movs	r1, #92	; 0x5c
 8012558:	fb01 f303 	mul.w	r3, r1, r3
 801255c:	4413      	add	r3, r2
 801255e:	330c      	adds	r3, #12
 8012560:	781b      	ldrb	r3, [r3, #0]
 8012562:	79fa      	ldrb	r2, [r7, #7]
 8012564:	429a      	cmp	r2, r3
 8012566:	d113      	bne.n	8012590 <USBD_Get_Interface_Number+0x5c>
        (USBD_Device_FS.tclasslist[idx].InterfaceType == interface_type))
 8012568:	7bbb      	ldrb	r3, [r7, #14]
 801256a:	4a10      	ldr	r2, [pc, #64]	; (80125ac <USBD_Get_Interface_Number+0x78>)
 801256c:	215c      	movs	r1, #92	; 0x5c
 801256e:	fb01 f303 	mul.w	r3, r1, r3
 8012572:	4413      	add	r3, r2
 8012574:	3314      	adds	r3, #20
 8012576:	781b      	ldrb	r3, [r3, #0]
    if ((USBD_Device_FS.tclasslist[idx].ClassType == class_type) &&
 8012578:	79ba      	ldrb	r2, [r7, #6]
 801257a:	429a      	cmp	r2, r3
 801257c:	d108      	bne.n	8012590 <USBD_Get_Interface_Number+0x5c>
    {
      itf_num = USBD_Device_FS.tclasslist[idx].Ifs[0];
 801257e:	7bbb      	ldrb	r3, [r7, #14]
 8012580:	4a0a      	ldr	r2, [pc, #40]	; (80125ac <USBD_Get_Interface_Number+0x78>)
 8012582:	215c      	movs	r1, #92	; 0x5c
 8012584:	fb01 f303 	mul.w	r3, r1, r3
 8012588:	4413      	add	r3, r2
 801258a:	335a      	adds	r3, #90	; 0x5a
 801258c:	781b      	ldrb	r3, [r3, #0]
 801258e:	73fb      	strb	r3, [r7, #15]
  for(idx = 0; idx < USBD_MAX_SUPPORTED_CLASS; idx++)
 8012590:	7bbb      	ldrb	r3, [r7, #14]
 8012592:	3301      	adds	r3, #1
 8012594:	73bb      	strb	r3, [r7, #14]
 8012596:	7bbb      	ldrb	r3, [r7, #14]
 8012598:	2b02      	cmp	r3, #2
 801259a:	d9da      	bls.n	8012552 <USBD_Get_Interface_Number+0x1e>

  /* USER CODE BEGIN USBD_Get_Interface_Number1 */

  /* USER CODE BEGIN USBD_Get_Interface_Number1 */

  return itf_num;
 801259c:	7bfb      	ldrb	r3, [r7, #15]
 801259e:	b29b      	uxth	r3, r3
}
 80125a0:	4618      	mov	r0, r3
 80125a2:	3714      	adds	r7, #20
 80125a4:	46bd      	mov	sp, r7
 80125a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125aa:	4770      	bx	lr
 80125ac:	20007454 	.word	0x20007454

080125b0 <USBD_Get_Configuration_Number>:
  * @param  class_type : Device class type
  * @param  interface_type : Device interface type
  * @retval configuration number
  */
uint16_t USBD_Get_Configuration_Number(uint8_t class_type, uint8_t interface_type)
{
 80125b0:	b480      	push	{r7}
 80125b2:	b085      	sub	sp, #20
 80125b4:	af00      	add	r7, sp, #0
 80125b6:	4603      	mov	r3, r0
 80125b8:	460a      	mov	r2, r1
 80125ba:	71fb      	strb	r3, [r7, #7]
 80125bc:	4613      	mov	r3, r2
 80125be:	71bb      	strb	r3, [r7, #6]
  uint8_t cfg_num = 1U;
 80125c0:	2301      	movs	r3, #1
 80125c2:	73fb      	strb	r3, [r7, #15]

  /* USER CODE BEGIN USBD_Get_CONFIGURATION_Number1 */

  /* USER CODE BEGIN USBD_Get_CONFIGURATION_Number1 */

  return cfg_num;
 80125c4:	7bfb      	ldrb	r3, [r7, #15]
 80125c6:	b29b      	uxth	r3, r3
}
 80125c8:	4618      	mov	r0, r3
 80125ca:	3714      	adds	r7, #20
 80125cc:	46bd      	mov	sp, r7
 80125ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125d2:	4770      	bx	lr

080125d4 <USBD_HID_ReportDesc>:
  *         Return the device HID Report Descriptor
  * @param  hid_type : HID Device type
  * @retval Pointer to HID Report Descriptor buffer
  */
uint8_t *USBD_HID_ReportDesc(uint8_t hid_type)
{
 80125d4:	b480      	push	{r7}
 80125d6:	b085      	sub	sp, #20
 80125d8:	af00      	add	r7, sp, #0
 80125da:	4603      	mov	r3, r0
 80125dc:	71fb      	strb	r3, [r7, #7]
  uint8_t *pHidReportDesc = NULL;
 80125de:	2300      	movs	r3, #0
 80125e0:	60fb      	str	r3, [r7, #12]

  /* USER CODE HidReportDesc0 */

  /* USER CODE HidReportDesc0 */

  switch(hid_type)
 80125e2:	79fb      	ldrb	r3, [r7, #7]
 80125e4:	2b00      	cmp	r3, #0
 80125e6:	d102      	bne.n	80125ee <USBD_HID_ReportDesc+0x1a>
  {
    case INTERFACE_HID_CUSTOM:
      pHidReportDesc = USBD_CustomHID_ReportDesc;
 80125e8:	4b05      	ldr	r3, [pc, #20]	; (8012600 <USBD_HID_ReportDesc+0x2c>)
 80125ea:	60fb      	str	r3, [r7, #12]
      break;
 80125ec:	e000      	b.n	80125f0 <USBD_HID_ReportDesc+0x1c>

    default:
      break;
 80125ee:	bf00      	nop

  /* USER CODE HidReportDesc1 */

  /* USER CODE HidReportDesc1 */

  return pHidReportDesc;
 80125f0:	68fb      	ldr	r3, [r7, #12]
}
 80125f2:	4618      	mov	r0, r3
 80125f4:	3714      	adds	r7, #20
 80125f6:	46bd      	mov	sp, r7
 80125f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125fc:	4770      	bx	lr
 80125fe:	bf00      	nop
 8012600:	20000114 	.word	0x20000114

08012604 <USBD_HID_ReportDesc_length>:
  *         Return the device HID Report Descriptor
  * @param  hid_type : HID Device type
  * @retval Size of HID Report Descriptor buffer
  */
uint16_t USBD_HID_ReportDesc_length(uint8_t hid_type)
{
 8012604:	b480      	push	{r7}
 8012606:	b085      	sub	sp, #20
 8012608:	af00      	add	r7, sp, #0
 801260a:	4603      	mov	r3, r0
 801260c:	71fb      	strb	r3, [r7, #7]
  uint16_t ReportDesc_Size = 0;
 801260e:	2300      	movs	r3, #0
 8012610:	81fb      	strh	r3, [r7, #14]

  /* USER CODE ReportDesc_Size0 */

  /* USER CODE ReportDesc_Size0 */

  switch(hid_type)
 8012612:	79fb      	ldrb	r3, [r7, #7]
 8012614:	2b00      	cmp	r3, #0
 8012616:	d102      	bne.n	801261e <USBD_HID_ReportDesc_length+0x1a>
  {
    case INTERFACE_HID_CUSTOM:
      ReportDesc_Size = sizeof(USBD_CustomHID_ReportDesc);
 8012618:	2301      	movs	r3, #1
 801261a:	81fb      	strh	r3, [r7, #14]
      break;
 801261c:	e000      	b.n	8012620 <USBD_HID_ReportDesc_length+0x1c>

    default:
      break;
 801261e:	bf00      	nop

  /* USER CODE ReportDesc_Size1 */

  /* USER CODE ReportDesc_Size1 */

  return ReportDesc_Size;
 8012620:	89fb      	ldrh	r3, [r7, #14]
}
 8012622:	4618      	mov	r0, r3
 8012624:	3714      	adds	r7, #20
 8012626:	46bd      	mov	sp, r7
 8012628:	f85d 7b04 	ldr.w	r7, [sp], #4
 801262c:	4770      	bx	lr

0801262e <USBD_Desc_GetString>:
  * @param  Unicode : Formatted string buffer (Unicode)
  * @param  len : descriptor length
  * @retval None
  */
static void USBD_Desc_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 801262e:	b580      	push	{r7, lr}
 8012630:	b086      	sub	sp, #24
 8012632:	af00      	add	r7, sp, #0
 8012634:	60f8      	str	r0, [r7, #12]
 8012636:	60b9      	str	r1, [r7, #8]
 8012638:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 801263a:	2300      	movs	r3, #0
 801263c:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 801263e:	68fb      	ldr	r3, [r7, #12]
 8012640:	2b00      	cmp	r3, #0
 8012642:	d023      	beq.n	801268c <USBD_Desc_GetString+0x5e>
  {
    return;
  }

  pdesc = desc;
 8012644:	68fb      	ldr	r3, [r7, #12]
 8012646:	613b      	str	r3, [r7, #16]
  *len = (uint16_t)USBD_Desc_GetLen(pdesc);
 8012648:	6938      	ldr	r0, [r7, #16]
 801264a:	f000 f823 	bl	8012694 <USBD_Desc_GetLen>
 801264e:	4603      	mov	r3, r0
 8012650:	b29a      	uxth	r2, r3
 8012652:	687b      	ldr	r3, [r7, #4]
 8012654:	801a      	strh	r2, [r3, #0]

  unicode[idx++] = *(uint8_t *)len;
 8012656:	7dfb      	ldrb	r3, [r7, #23]
 8012658:	1c5a      	adds	r2, r3, #1
 801265a:	75fa      	strb	r2, [r7, #23]
 801265c:	461a      	mov	r2, r3
 801265e:	68bb      	ldr	r3, [r7, #8]
 8012660:	4413      	add	r3, r2
 8012662:	687a      	ldr	r2, [r7, #4]
 8012664:	7812      	ldrb	r2, [r2, #0]
 8012666:	701a      	strb	r2, [r3, #0]

  while (*pdesc != (uint8_t)'\0')
 8012668:	e00b      	b.n	8012682 <USBD_Desc_GetString+0x54>
  {
    unicode[idx++] = *pdesc;
 801266a:	7dfb      	ldrb	r3, [r7, #23]
 801266c:	1c5a      	adds	r2, r3, #1
 801266e:	75fa      	strb	r2, [r7, #23]
 8012670:	461a      	mov	r2, r3
 8012672:	68bb      	ldr	r3, [r7, #8]
 8012674:	4413      	add	r3, r2
 8012676:	693a      	ldr	r2, [r7, #16]
 8012678:	7812      	ldrb	r2, [r2, #0]
 801267a:	701a      	strb	r2, [r3, #0]
    pdesc++;
 801267c:	693b      	ldr	r3, [r7, #16]
 801267e:	3301      	adds	r3, #1
 8012680:	613b      	str	r3, [r7, #16]
  while (*pdesc != (uint8_t)'\0')
 8012682:	693b      	ldr	r3, [r7, #16]
 8012684:	781b      	ldrb	r3, [r3, #0]
 8012686:	2b00      	cmp	r3, #0
 8012688:	d1ef      	bne.n	801266a <USBD_Desc_GetString+0x3c>
 801268a:	e000      	b.n	801268e <USBD_Desc_GetString+0x60>
    return;
 801268c:	bf00      	nop
  }
}
 801268e:	3718      	adds	r7, #24
 8012690:	46bd      	mov	sp, r7
 8012692:	bd80      	pop	{r7, pc}

08012694 <USBD_Desc_GetLen>:
  *         return the string length
  * @param  buf : pointer to the ASCII string buffer
  * @retval string length
  */
static uint8_t USBD_Desc_GetLen(uint8_t *buf)
{
 8012694:	b480      	push	{r7}
 8012696:	b085      	sub	sp, #20
 8012698:	af00      	add	r7, sp, #0
 801269a:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 801269c:	2300      	movs	r3, #0
 801269e:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 80126a0:	687b      	ldr	r3, [r7, #4]
 80126a2:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 80126a4:	e005      	b.n	80126b2 <USBD_Desc_GetLen+0x1e>
  {
    len++;
 80126a6:	7bfb      	ldrb	r3, [r7, #15]
 80126a8:	3301      	adds	r3, #1
 80126aa:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 80126ac:	68bb      	ldr	r3, [r7, #8]
 80126ae:	3301      	adds	r3, #1
 80126b0:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 80126b2:	68bb      	ldr	r3, [r7, #8]
 80126b4:	781b      	ldrb	r3, [r3, #0]
 80126b6:	2b00      	cmp	r3, #0
 80126b8:	d1f5      	bne.n	80126a6 <USBD_Desc_GetLen+0x12>
  }

  return len;
 80126ba:	7bfb      	ldrb	r3, [r7, #15]
}
 80126bc:	4618      	mov	r0, r3
 80126be:	3714      	adds	r7, #20
 80126c0:	46bd      	mov	sp, r7
 80126c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126c6:	4770      	bx	lr

080126c8 <USBD_Device_Framework_Builder>:
  */
static uint8_t *USBD_Device_Framework_Builder(USBD_DevClassHandleTypeDef *pdev,
                                              uint8_t *pDevFrameWorkDesc,
                                              uint8_t *UserClassInstance,
                                              uint8_t Speed)
{
 80126c8:	b580      	push	{r7, lr}
 80126ca:	b088      	sub	sp, #32
 80126cc:	af02      	add	r7, sp, #8
 80126ce:	60f8      	str	r0, [r7, #12]
 80126d0:	60b9      	str	r1, [r7, #8]
 80126d2:	607a      	str	r2, [r7, #4]
 80126d4:	70fb      	strb	r3, [r7, #3]
  static USBD_DeviceDescTypedef   *pDevDesc;
  static USBD_DevQualiDescTypedef *pDevQualDesc;
  uint8_t Idx_Instance = 0U;
 80126d6:	2300      	movs	r3, #0
 80126d8:	75fb      	strb	r3, [r7, #23]

  /* Set Dev and conf descriptors size to 0 */
  pdev->CurrConfDescSz = 0U;
 80126da:	68fb      	ldr	r3, [r7, #12]
 80126dc:	2200      	movs	r2, #0
 80126de:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
  pdev->CurrDevDescSz = 0U;
 80126e2:	68fb      	ldr	r3, [r7, #12]
 80126e4:	2200      	movs	r2, #0
 80126e6:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

  /* Set the pointer to the device descriptor area*/
  pDevDesc = (USBD_DeviceDescTypedef *)pDevFrameWorkDesc;
 80126ea:	4a73      	ldr	r2, [pc, #460]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 80126ec:	68bb      	ldr	r3, [r7, #8]
 80126ee:	6013      	str	r3, [r2, #0]

  /* Start building the generic device descriptor common part */
  pDevDesc->bLength = (uint8_t)sizeof(USBD_DeviceDescTypedef);
 80126f0:	4b71      	ldr	r3, [pc, #452]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 80126f2:	681b      	ldr	r3, [r3, #0]
 80126f4:	2212      	movs	r2, #18
 80126f6:	701a      	strb	r2, [r3, #0]
  pDevDesc->bDescriptorType = UX_DEVICE_DESCRIPTOR_ITEM;
 80126f8:	4b6f      	ldr	r3, [pc, #444]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 80126fa:	681b      	ldr	r3, [r3, #0]
 80126fc:	2201      	movs	r2, #1
 80126fe:	705a      	strb	r2, [r3, #1]
  pDevDesc->bcdUSB = USB_BCDUSB;
 8012700:	4b6d      	ldr	r3, [pc, #436]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 8012702:	681b      	ldr	r3, [r3, #0]
 8012704:	2200      	movs	r2, #0
 8012706:	709a      	strb	r2, [r3, #2]
 8012708:	2200      	movs	r2, #0
 801270a:	f042 0202 	orr.w	r2, r2, #2
 801270e:	70da      	strb	r2, [r3, #3]
  pDevDesc->bDeviceClass = 0x00;
 8012710:	4b69      	ldr	r3, [pc, #420]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 8012712:	681b      	ldr	r3, [r3, #0]
 8012714:	2200      	movs	r2, #0
 8012716:	711a      	strb	r2, [r3, #4]
  pDevDesc->bDeviceSubClass = 0x00;
 8012718:	4b67      	ldr	r3, [pc, #412]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 801271a:	681b      	ldr	r3, [r3, #0]
 801271c:	2200      	movs	r2, #0
 801271e:	715a      	strb	r2, [r3, #5]
  pDevDesc->bDeviceProtocol = 0x00;
 8012720:	4b65      	ldr	r3, [pc, #404]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 8012722:	681b      	ldr	r3, [r3, #0]
 8012724:	2200      	movs	r2, #0
 8012726:	719a      	strb	r2, [r3, #6]
  pDevDesc->bMaxPacketSize = USBD_MAX_EP0_SIZE;
 8012728:	4b63      	ldr	r3, [pc, #396]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 801272a:	681b      	ldr	r3, [r3, #0]
 801272c:	2240      	movs	r2, #64	; 0x40
 801272e:	71da      	strb	r2, [r3, #7]
  pDevDesc->idVendor = USBD_VID;
 8012730:	4b61      	ldr	r3, [pc, #388]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 8012732:	681b      	ldr	r3, [r3, #0]
 8012734:	2200      	movs	r2, #0
 8012736:	f062 027c 	orn	r2, r2, #124	; 0x7c
 801273a:	721a      	strb	r2, [r3, #8]
 801273c:	2200      	movs	r2, #0
 801273e:	f042 0204 	orr.w	r2, r2, #4
 8012742:	725a      	strb	r2, [r3, #9]
  pDevDesc->idProduct = USBD_PID;
 8012744:	4b5c      	ldr	r3, [pc, #368]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 8012746:	681b      	ldr	r3, [r3, #0]
 8012748:	2200      	movs	r2, #0
 801274a:	f042 0210 	orr.w	r2, r2, #16
 801274e:	729a      	strb	r2, [r3, #10]
 8012750:	2200      	movs	r2, #0
 8012752:	f042 0257 	orr.w	r2, r2, #87	; 0x57
 8012756:	72da      	strb	r2, [r3, #11]
  pDevDesc->bcdDevice = 0x0200;
 8012758:	4b57      	ldr	r3, [pc, #348]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 801275a:	681b      	ldr	r3, [r3, #0]
 801275c:	2200      	movs	r2, #0
 801275e:	731a      	strb	r2, [r3, #12]
 8012760:	2200      	movs	r2, #0
 8012762:	f042 0202 	orr.w	r2, r2, #2
 8012766:	735a      	strb	r2, [r3, #13]
  pDevDesc->iManufacturer = USBD_IDX_MFC_STR;
 8012768:	4b53      	ldr	r3, [pc, #332]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 801276a:	681b      	ldr	r3, [r3, #0]
 801276c:	2201      	movs	r2, #1
 801276e:	739a      	strb	r2, [r3, #14]
  pDevDesc->iProduct = USBD_IDX_PRODUCT_STR;
 8012770:	4b51      	ldr	r3, [pc, #324]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 8012772:	681b      	ldr	r3, [r3, #0]
 8012774:	2202      	movs	r2, #2
 8012776:	73da      	strb	r2, [r3, #15]
  pDevDesc->iSerialNumber = USBD_IDX_SERIAL_STR;
 8012778:	4b4f      	ldr	r3, [pc, #316]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 801277a:	681b      	ldr	r3, [r3, #0]
 801277c:	2203      	movs	r2, #3
 801277e:	741a      	strb	r2, [r3, #16]
  pDevDesc->bNumConfigurations = USBD_MAX_NUM_CONFIGURATION;
 8012780:	4b4d      	ldr	r3, [pc, #308]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 8012782:	681b      	ldr	r3, [r3, #0]
 8012784:	2201      	movs	r2, #1
 8012786:	745a      	strb	r2, [r3, #17]
  pdev->CurrDevDescSz += (uint32_t)sizeof(USBD_DeviceDescTypedef);
 8012788:	68fb      	ldr	r3, [r7, #12]
 801278a:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 801278e:	f103 0212 	add.w	r2, r3, #18
 8012792:	68fb      	ldr	r3, [r7, #12]
 8012794:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

  /* Check if USBx is in high speed mode to add qualifier descriptor */
  if (Speed == USBD_HIGH_SPEED)
 8012798:	78fb      	ldrb	r3, [r7, #3]
 801279a:	2b01      	cmp	r3, #1
 801279c:	d162      	bne.n	8012864 <USBD_Device_Framework_Builder+0x19c>
  {
    pDevQualDesc = (USBD_DevQualiDescTypedef *)(pDevFrameWorkDesc + pdev->CurrDevDescSz);
 801279e:	68fb      	ldr	r3, [r7, #12]
 80127a0:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 80127a4:	68ba      	ldr	r2, [r7, #8]
 80127a6:	4413      	add	r3, r2
 80127a8:	4a44      	ldr	r2, [pc, #272]	; (80128bc <USBD_Device_Framework_Builder+0x1f4>)
 80127aa:	6013      	str	r3, [r2, #0]
    pDevQualDesc->bLength = (uint8_t)sizeof(USBD_DevQualiDescTypedef);
 80127ac:	4b43      	ldr	r3, [pc, #268]	; (80128bc <USBD_Device_Framework_Builder+0x1f4>)
 80127ae:	681b      	ldr	r3, [r3, #0]
 80127b0:	220a      	movs	r2, #10
 80127b2:	701a      	strb	r2, [r3, #0]
    pDevQualDesc->bDescriptorType = UX_DEVICE_QUALIFIER_DESCRIPTOR_ITEM;
 80127b4:	4b41      	ldr	r3, [pc, #260]	; (80128bc <USBD_Device_Framework_Builder+0x1f4>)
 80127b6:	681b      	ldr	r3, [r3, #0]
 80127b8:	2206      	movs	r2, #6
 80127ba:	705a      	strb	r2, [r3, #1]
    pDevQualDesc->bcdDevice = 0x0200;
 80127bc:	4b3f      	ldr	r3, [pc, #252]	; (80128bc <USBD_Device_Framework_Builder+0x1f4>)
 80127be:	681b      	ldr	r3, [r3, #0]
 80127c0:	2200      	movs	r2, #0
 80127c2:	709a      	strb	r2, [r3, #2]
 80127c4:	2200      	movs	r2, #0
 80127c6:	f042 0202 	orr.w	r2, r2, #2
 80127ca:	70da      	strb	r2, [r3, #3]
    pDevQualDesc->Class = 0x00;
 80127cc:	4b3b      	ldr	r3, [pc, #236]	; (80128bc <USBD_Device_Framework_Builder+0x1f4>)
 80127ce:	681b      	ldr	r3, [r3, #0]
 80127d0:	2200      	movs	r2, #0
 80127d2:	711a      	strb	r2, [r3, #4]
    pDevQualDesc->SubClass = 0x00;
 80127d4:	4b39      	ldr	r3, [pc, #228]	; (80128bc <USBD_Device_Framework_Builder+0x1f4>)
 80127d6:	681b      	ldr	r3, [r3, #0]
 80127d8:	2200      	movs	r2, #0
 80127da:	715a      	strb	r2, [r3, #5]
    pDevQualDesc->Protocol = 0x00;
 80127dc:	4b37      	ldr	r3, [pc, #220]	; (80128bc <USBD_Device_Framework_Builder+0x1f4>)
 80127de:	681b      	ldr	r3, [r3, #0]
 80127e0:	2200      	movs	r2, #0
 80127e2:	719a      	strb	r2, [r3, #6]
    pDevQualDesc->bMaxPacketSize = 0x40;
 80127e4:	4b35      	ldr	r3, [pc, #212]	; (80128bc <USBD_Device_Framework_Builder+0x1f4>)
 80127e6:	681b      	ldr	r3, [r3, #0]
 80127e8:	2240      	movs	r2, #64	; 0x40
 80127ea:	71da      	strb	r2, [r3, #7]
    pDevQualDesc->bNumConfigurations = 0x01;
 80127ec:	4b33      	ldr	r3, [pc, #204]	; (80128bc <USBD_Device_Framework_Builder+0x1f4>)
 80127ee:	681b      	ldr	r3, [r3, #0]
 80127f0:	2201      	movs	r2, #1
 80127f2:	721a      	strb	r2, [r3, #8]
    pDevQualDesc->bReserved = 0x00;
 80127f4:	4b31      	ldr	r3, [pc, #196]	; (80128bc <USBD_Device_Framework_Builder+0x1f4>)
 80127f6:	681b      	ldr	r3, [r3, #0]
 80127f8:	2200      	movs	r2, #0
 80127fa:	725a      	strb	r2, [r3, #9]
    pdev->CurrDevDescSz += (uint32_t)sizeof(USBD_DevQualiDescTypedef);
 80127fc:	68fb      	ldr	r3, [r7, #12]
 80127fe:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 8012802:	f103 020a 	add.w	r2, r3, #10
 8012806:	68fb      	ldr	r3, [r7, #12]
 8012808:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
  }

  /* Build the device framework */
  while (Idx_Instance < USBD_MAX_SUPPORTED_CLASS)
 801280c:	e02a      	b.n	8012864 <USBD_Device_Framework_Builder+0x19c>
  {
    if ((pdev->classId < USBD_MAX_SUPPORTED_CLASS) &&
 801280e:	68fb      	ldr	r3, [r7, #12]
 8012810:	685b      	ldr	r3, [r3, #4]
 8012812:	2b02      	cmp	r3, #2
 8012814:	d823      	bhi.n	801285e <USBD_Device_Framework_Builder+0x196>
        (pdev->NumClasses < USBD_MAX_SUPPORTED_CLASS) &&
 8012816:	68fb      	ldr	r3, [r7, #12]
 8012818:	689b      	ldr	r3, [r3, #8]
    if ((pdev->classId < USBD_MAX_SUPPORTED_CLASS) &&
 801281a:	2b02      	cmp	r3, #2
 801281c:	d81f      	bhi.n	801285e <USBD_Device_Framework_Builder+0x196>
        (UserClassInstance[Idx_Instance] != CLASS_TYPE_NONE))
 801281e:	7dfb      	ldrb	r3, [r7, #23]
 8012820:	687a      	ldr	r2, [r7, #4]
 8012822:	4413      	add	r3, r2
 8012824:	781b      	ldrb	r3, [r3, #0]
        (pdev->NumClasses < USBD_MAX_SUPPORTED_CLASS) &&
 8012826:	2b00      	cmp	r3, #0
 8012828:	d019      	beq.n	801285e <USBD_Device_Framework_Builder+0x196>
    {
      /* Call the composite class builder */
      (void)USBD_FrameWork_AddClass(pdev,
                                    (USBD_CompositeClassTypeDef)UserClassInstance[Idx_Instance],
 801282a:	7dfb      	ldrb	r3, [r7, #23]
 801282c:	687a      	ldr	r2, [r7, #4]
 801282e:	4413      	add	r3, r2
      (void)USBD_FrameWork_AddClass(pdev,
 8012830:	7819      	ldrb	r1, [r3, #0]
                                    0, Speed,
                                    (pDevFrameWorkDesc + pdev->CurrDevDescSz));
 8012832:	68fb      	ldr	r3, [r7, #12]
 8012834:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
      (void)USBD_FrameWork_AddClass(pdev,
 8012838:	68ba      	ldr	r2, [r7, #8]
 801283a:	4413      	add	r3, r2
 801283c:	78fa      	ldrb	r2, [r7, #3]
 801283e:	9300      	str	r3, [sp, #0]
 8012840:	4613      	mov	r3, r2
 8012842:	2200      	movs	r2, #0
 8012844:	68f8      	ldr	r0, [r7, #12]
 8012846:	f000 f83b 	bl	80128c0 <USBD_FrameWork_AddClass>

      /* Increment the ClassId for the next occurrence */
      pdev->classId ++;
 801284a:	68fb      	ldr	r3, [r7, #12]
 801284c:	685b      	ldr	r3, [r3, #4]
 801284e:	1c5a      	adds	r2, r3, #1
 8012850:	68fb      	ldr	r3, [r7, #12]
 8012852:	605a      	str	r2, [r3, #4]
      pdev->NumClasses ++;
 8012854:	68fb      	ldr	r3, [r7, #12]
 8012856:	689b      	ldr	r3, [r3, #8]
 8012858:	1c5a      	adds	r2, r3, #1
 801285a:	68fb      	ldr	r3, [r7, #12]
 801285c:	609a      	str	r2, [r3, #8]
    }

    Idx_Instance++;
 801285e:	7dfb      	ldrb	r3, [r7, #23]
 8012860:	3301      	adds	r3, #1
 8012862:	75fb      	strb	r3, [r7, #23]
  while (Idx_Instance < USBD_MAX_SUPPORTED_CLASS)
 8012864:	7dfb      	ldrb	r3, [r7, #23]
 8012866:	2b02      	cmp	r3, #2
 8012868:	d9d1      	bls.n	801280e <USBD_Device_Framework_Builder+0x146>
  }

  /* Check if there is a composite class and update device class */
  if (pdev->NumClasses > 1)
 801286a:	68fb      	ldr	r3, [r7, #12]
 801286c:	689b      	ldr	r3, [r3, #8]
 801286e:	2b01      	cmp	r3, #1
 8012870:	d90c      	bls.n	801288c <USBD_Device_Framework_Builder+0x1c4>
  {
    pDevDesc->bDeviceClass = 0xEF;
 8012872:	4b11      	ldr	r3, [pc, #68]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 8012874:	681b      	ldr	r3, [r3, #0]
 8012876:	22ef      	movs	r2, #239	; 0xef
 8012878:	711a      	strb	r2, [r3, #4]
    pDevDesc->bDeviceSubClass = 0x02;
 801287a:	4b0f      	ldr	r3, [pc, #60]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 801287c:	681b      	ldr	r3, [r3, #0]
 801287e:	2202      	movs	r2, #2
 8012880:	715a      	strb	r2, [r3, #5]
    pDevDesc->bDeviceProtocol = 0x01;
 8012882:	4b0d      	ldr	r3, [pc, #52]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 8012884:	681b      	ldr	r3, [r3, #0]
 8012886:	2201      	movs	r2, #1
 8012888:	719a      	strb	r2, [r3, #6]
 801288a:	e00f      	b.n	80128ac <USBD_Device_Framework_Builder+0x1e4>
  }
  else
  {
    /* Check if the CDC ACM class is set and update device class */
    if (UserClassInstance[0] == CLASS_TYPE_CDC_ACM)
 801288c:	687b      	ldr	r3, [r7, #4]
 801288e:	781b      	ldrb	r3, [r3, #0]
 8012890:	2b02      	cmp	r3, #2
 8012892:	d10b      	bne.n	80128ac <USBD_Device_Framework_Builder+0x1e4>
    {
      pDevDesc->bDeviceClass = 0x02;
 8012894:	4b08      	ldr	r3, [pc, #32]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 8012896:	681b      	ldr	r3, [r3, #0]
 8012898:	2202      	movs	r2, #2
 801289a:	711a      	strb	r2, [r3, #4]
      pDevDesc->bDeviceSubClass = 0x02;
 801289c:	4b06      	ldr	r3, [pc, #24]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 801289e:	681b      	ldr	r3, [r3, #0]
 80128a0:	2202      	movs	r2, #2
 80128a2:	715a      	strb	r2, [r3, #5]
      pDevDesc->bDeviceProtocol = 0x00;
 80128a4:	4b04      	ldr	r3, [pc, #16]	; (80128b8 <USBD_Device_Framework_Builder+0x1f0>)
 80128a6:	681b      	ldr	r3, [r3, #0]
 80128a8:	2200      	movs	r2, #0
 80128aa:	719a      	strb	r2, [r3, #6]
    }
  }

  return pDevFrameWorkDesc;
 80128ac:	68bb      	ldr	r3, [r7, #8]
}
 80128ae:	4618      	mov	r0, r3
 80128b0:	3718      	adds	r7, #24
 80128b2:	46bd      	mov	sp, r7
 80128b4:	bd80      	pop	{r7, pc}
 80128b6:	bf00      	nop
 80128b8:	2000793c 	.word	0x2000793c
 80128bc:	20007940 	.word	0x20007940

080128c0 <USBD_FrameWork_AddClass>:
  */
uint8_t  USBD_FrameWork_AddClass(USBD_DevClassHandleTypeDef *pdev,
                                 USBD_CompositeClassTypeDef class,
                                 uint8_t cfgidx, uint8_t Speed,
                                 uint8_t *pCmpstConfDesc)
{
 80128c0:	b580      	push	{r7, lr}
 80128c2:	b082      	sub	sp, #8
 80128c4:	af00      	add	r7, sp, #0
 80128c6:	6078      	str	r0, [r7, #4]
 80128c8:	4608      	mov	r0, r1
 80128ca:	4611      	mov	r1, r2
 80128cc:	461a      	mov	r2, r3
 80128ce:	4603      	mov	r3, r0
 80128d0:	70fb      	strb	r3, [r7, #3]
 80128d2:	460b      	mov	r3, r1
 80128d4:	70bb      	strb	r3, [r7, #2]
 80128d6:	4613      	mov	r3, r2
 80128d8:	707b      	strb	r3, [r7, #1]
  static uint8_t interface_idx = 0U;

  if ((pdev->classId < USBD_MAX_SUPPORTED_CLASS) &&
 80128da:	687b      	ldr	r3, [r7, #4]
 80128dc:	685b      	ldr	r3, [r3, #4]
 80128de:	2b02      	cmp	r3, #2
 80128e0:	d853      	bhi.n	801298a <USBD_FrameWork_AddClass+0xca>
      (pdev->tclasslist[pdev->classId].Active == 0U))
 80128e2:	687b      	ldr	r3, [r7, #4]
 80128e4:	685b      	ldr	r3, [r3, #4]
 80128e6:	687a      	ldr	r2, [r7, #4]
 80128e8:	215c      	movs	r1, #92	; 0x5c
 80128ea:	fb01 f303 	mul.w	r3, r1, r3
 80128ee:	4413      	add	r3, r2
 80128f0:	3318      	adds	r3, #24
 80128f2:	681b      	ldr	r3, [r3, #0]
  if ((pdev->classId < USBD_MAX_SUPPORTED_CLASS) &&
 80128f4:	2b00      	cmp	r3, #0
 80128f6:	d148      	bne.n	801298a <USBD_FrameWork_AddClass+0xca>
  {
    /* Store the class parameters in the global tab */
    pdev->tclasslist[pdev->classId].ClassId = pdev->classId;
 80128f8:	687b      	ldr	r3, [r7, #4]
 80128fa:	685b      	ldr	r3, [r3, #4]
 80128fc:	687a      	ldr	r2, [r7, #4]
 80128fe:	6852      	ldr	r2, [r2, #4]
 8012900:	6879      	ldr	r1, [r7, #4]
 8012902:	205c      	movs	r0, #92	; 0x5c
 8012904:	fb00 f303 	mul.w	r3, r0, r3
 8012908:	440b      	add	r3, r1
 801290a:	3310      	adds	r3, #16
 801290c:	601a      	str	r2, [r3, #0]
    pdev->tclasslist[pdev->classId].Active = 1U;
 801290e:	687b      	ldr	r3, [r7, #4]
 8012910:	685b      	ldr	r3, [r3, #4]
 8012912:	687a      	ldr	r2, [r7, #4]
 8012914:	215c      	movs	r1, #92	; 0x5c
 8012916:	fb01 f303 	mul.w	r3, r1, r3
 801291a:	4413      	add	r3, r2
 801291c:	3318      	adds	r3, #24
 801291e:	2201      	movs	r2, #1
 8012920:	601a      	str	r2, [r3, #0]
    pdev->tclasslist[pdev->classId].ClassType = class;
 8012922:	687b      	ldr	r3, [r7, #4]
 8012924:	685b      	ldr	r3, [r3, #4]
 8012926:	687a      	ldr	r2, [r7, #4]
 8012928:	215c      	movs	r1, #92	; 0x5c
 801292a:	fb01 f303 	mul.w	r3, r1, r3
 801292e:	4413      	add	r3, r2
 8012930:	330c      	adds	r3, #12
 8012932:	78fa      	ldrb	r2, [r7, #3]
 8012934:	701a      	strb	r2, [r3, #0]

    if (class == CLASS_TYPE_HID)
 8012936:	78fb      	ldrb	r3, [r7, #3]
 8012938:	2b01      	cmp	r3, #1
 801293a:	d11b      	bne.n	8012974 <USBD_FrameWork_AddClass+0xb4>
    {
      pdev->tclasslist[pdev->classId].InterfaceType = UserHIDInterface[interface_idx];
 801293c:	4b15      	ldr	r3, [pc, #84]	; (8012994 <USBD_FrameWork_AddClass+0xd4>)
 801293e:	781b      	ldrb	r3, [r3, #0]
 8012940:	4619      	mov	r1, r3
 8012942:	687b      	ldr	r3, [r7, #4]
 8012944:	685b      	ldr	r3, [r3, #4]
 8012946:	4a14      	ldr	r2, [pc, #80]	; (8012998 <USBD_FrameWork_AddClass+0xd8>)
 8012948:	5c50      	ldrb	r0, [r2, r1]
 801294a:	687a      	ldr	r2, [r7, #4]
 801294c:	215c      	movs	r1, #92	; 0x5c
 801294e:	fb01 f303 	mul.w	r3, r1, r3
 8012952:	4413      	add	r3, r2
 8012954:	3314      	adds	r3, #20
 8012956:	4602      	mov	r2, r0
 8012958:	701a      	strb	r2, [r3, #0]

      interface_idx++;
 801295a:	4b0e      	ldr	r3, [pc, #56]	; (8012994 <USBD_FrameWork_AddClass+0xd4>)
 801295c:	781b      	ldrb	r3, [r3, #0]
 801295e:	3301      	adds	r3, #1
 8012960:	b2da      	uxtb	r2, r3
 8012962:	4b0c      	ldr	r3, [pc, #48]	; (8012994 <USBD_FrameWork_AddClass+0xd4>)
 8012964:	701a      	strb	r2, [r3, #0]

      if (interface_idx == sizeof(UserHIDInterface))
 8012966:	4b0b      	ldr	r3, [pc, #44]	; (8012994 <USBD_FrameWork_AddClass+0xd4>)
 8012968:	781b      	ldrb	r3, [r3, #0]
 801296a:	2b01      	cmp	r3, #1
 801296c:	d102      	bne.n	8012974 <USBD_FrameWork_AddClass+0xb4>
      {
        interface_idx = 0U;
 801296e:	4b09      	ldr	r3, [pc, #36]	; (8012994 <USBD_FrameWork_AddClass+0xd4>)
 8012970:	2200      	movs	r2, #0
 8012972:	701a      	strb	r2, [r3, #0]
      }
    }

    /* Call configuration descriptor builder and endpoint configuration builder */
    if (USBD_FrameWork_AddToConfDesc(pdev, Speed, pCmpstConfDesc) != UX_SUCCESS)
 8012974:	787b      	ldrb	r3, [r7, #1]
 8012976:	693a      	ldr	r2, [r7, #16]
 8012978:	4619      	mov	r1, r3
 801297a:	6878      	ldr	r0, [r7, #4]
 801297c:	f000 f80e 	bl	801299c <USBD_FrameWork_AddToConfDesc>
 8012980:	4603      	mov	r3, r0
 8012982:	2b00      	cmp	r3, #0
 8012984:	d001      	beq.n	801298a <USBD_FrameWork_AddClass+0xca>
    {
      return UX_ERROR;
 8012986:	23ff      	movs	r3, #255	; 0xff
 8012988:	e000      	b.n	801298c <USBD_FrameWork_AddClass+0xcc>
    }
  }

  UNUSED(cfgidx);

  return UX_SUCCESS;
 801298a:	2300      	movs	r3, #0
}
 801298c:	4618      	mov	r0, r3
 801298e:	3708      	adds	r7, #8
 8012990:	46bd      	mov	sp, r7
 8012992:	bd80      	pop	{r7, pc}
 8012994:	20007944 	.word	0x20007944
 8012998:	200076a4 	.word	0x200076a4

0801299c <USBD_FrameWork_AddToConfDesc>:
  * @param  pCmpstConfDesc: to composite device configuration descriptor
  * @retval status
  */
uint8_t  USBD_FrameWork_AddToConfDesc(USBD_DevClassHandleTypeDef *pdev, uint8_t Speed,
                                      uint8_t *pCmpstConfDesc)
{
 801299c:	b580      	push	{r7, lr}
 801299e:	b086      	sub	sp, #24
 80129a0:	af00      	add	r7, sp, #0
 80129a2:	60f8      	str	r0, [r7, #12]
 80129a4:	460b      	mov	r3, r1
 80129a6:	607a      	str	r2, [r7, #4]
 80129a8:	72fb      	strb	r3, [r7, #11]
  uint8_t interface = 0U;
 80129aa:	2300      	movs	r3, #0
 80129ac:	75fb      	strb	r3, [r7, #23]
  /* USER CODE FrameWork_AddToConfDesc_0 */

  /* USER CODE FrameWork_AddToConfDesc_0 */

  /* The USB drivers do not set the speed value, so set it here before starting */
  pdev->Speed = Speed;
 80129ae:	68fb      	ldr	r3, [r7, #12]
 80129b0:	7afa      	ldrb	r2, [r7, #11]
 80129b2:	701a      	strb	r2, [r3, #0]

  /* start building the config descriptor common part */
  if (pdev->classId == 0U)
 80129b4:	68fb      	ldr	r3, [r7, #12]
 80129b6:	685b      	ldr	r3, [r3, #4]
 80129b8:	2b00      	cmp	r3, #0
 80129ba:	d107      	bne.n	80129cc <USBD_FrameWork_AddToConfDesc+0x30>
  {
    /* Add configuration and IAD descriptors */
    USBD_FrameWork_AddConfDesc((uint32_t)pCmpstConfDesc, &pdev->CurrConfDescSz);
 80129bc:	687a      	ldr	r2, [r7, #4]
 80129be:	68fb      	ldr	r3, [r7, #12]
 80129c0:	f503 7392 	add.w	r3, r3, #292	; 0x124
 80129c4:	4619      	mov	r1, r3
 80129c6:	4610      	mov	r0, r2
 80129c8:	f000 f8e1 	bl	8012b8e <USBD_FrameWork_AddConfDesc>
  }

  switch (pdev->tclasslist[pdev->classId].ClassType)
 80129cc:	68fb      	ldr	r3, [r7, #12]
 80129ce:	685b      	ldr	r3, [r3, #4]
 80129d0:	68fa      	ldr	r2, [r7, #12]
 80129d2:	215c      	movs	r1, #92	; 0x5c
 80129d4:	fb01 f303 	mul.w	r3, r1, r3
 80129d8:	4413      	add	r3, r2
 80129da:	330c      	adds	r3, #12
 80129dc:	781b      	ldrb	r3, [r3, #0]
 80129de:	2b01      	cmp	r3, #1
 80129e0:	d002      	beq.n	80129e8 <USBD_FrameWork_AddToConfDesc+0x4c>
 80129e2:	2b03      	cmp	r3, #3
 80129e4:	d056      	beq.n	8012a94 <USBD_FrameWork_AddToConfDesc+0xf8>

    default:
      /* USER CODE FrameWork_AddToConfDesc_2 */

      /* USER CODE FrameWork_AddToConfDesc_2 */
      break;
 80129e6:	e0a0      	b.n	8012b2a <USBD_FrameWork_AddToConfDesc+0x18e>
      switch(pdev->tclasslist[pdev->classId].InterfaceType)
 80129e8:	68fb      	ldr	r3, [r7, #12]
 80129ea:	685b      	ldr	r3, [r3, #4]
 80129ec:	68fa      	ldr	r2, [r7, #12]
 80129ee:	215c      	movs	r1, #92	; 0x5c
 80129f0:	fb01 f303 	mul.w	r3, r1, r3
 80129f4:	4413      	add	r3, r2
 80129f6:	3314      	adds	r3, #20
 80129f8:	781b      	ldrb	r3, [r3, #0]
 80129fa:	2b00      	cmp	r3, #0
 80129fc:	d148      	bne.n	8012a90 <USBD_FrameWork_AddToConfDesc+0xf4>
          interface = USBD_FrameWork_FindFreeIFNbr(pdev);
 80129fe:	68f8      	ldr	r0, [r7, #12]
 8012a00:	f000 f898 	bl	8012b34 <USBD_FrameWork_FindFreeIFNbr>
 8012a04:	4603      	mov	r3, r0
 8012a06:	75fb      	strb	r3, [r7, #23]
          pdev->tclasslist[pdev->classId].NumIf = 1U;
 8012a08:	68fb      	ldr	r3, [r7, #12]
 8012a0a:	685b      	ldr	r3, [r3, #4]
 8012a0c:	68fa      	ldr	r2, [r7, #12]
 8012a0e:	215c      	movs	r1, #92	; 0x5c
 8012a10:	fb01 f303 	mul.w	r3, r1, r3
 8012a14:	4413      	add	r3, r2
 8012a16:	3320      	adds	r3, #32
 8012a18:	2201      	movs	r2, #1
 8012a1a:	601a      	str	r2, [r3, #0]
          pdev->tclasslist[pdev->classId].Ifs[0] = interface;
 8012a1c:	68fb      	ldr	r3, [r7, #12]
 8012a1e:	685b      	ldr	r3, [r3, #4]
 8012a20:	68fa      	ldr	r2, [r7, #12]
 8012a22:	215c      	movs	r1, #92	; 0x5c
 8012a24:	fb01 f303 	mul.w	r3, r1, r3
 8012a28:	4413      	add	r3, r2
 8012a2a:	335a      	adds	r3, #90	; 0x5a
 8012a2c:	7dfa      	ldrb	r2, [r7, #23]
 8012a2e:	701a      	strb	r2, [r3, #0]
          pdev->tclasslist[pdev->classId].NumEps = 2U; /* EP_IN, EP_OUT */
 8012a30:	68fb      	ldr	r3, [r7, #12]
 8012a32:	685b      	ldr	r3, [r3, #4]
 8012a34:	68fa      	ldr	r2, [r7, #12]
 8012a36:	215c      	movs	r1, #92	; 0x5c
 8012a38:	fb01 f303 	mul.w	r3, r1, r3
 8012a3c:	4413      	add	r3, r2
 8012a3e:	331c      	adds	r3, #28
 8012a40:	2202      	movs	r2, #2
 8012a42:	601a      	str	r2, [r3, #0]
          if (pdev->Speed == USBD_HIGH_SPEED)
 8012a44:	68fb      	ldr	r3, [r7, #12]
 8012a46:	781b      	ldrb	r3, [r3, #0]
 8012a48:	2b01      	cmp	r3, #1
 8012a4a:	d10c      	bne.n	8012a66 <USBD_FrameWork_AddToConfDesc+0xca>
            USBD_FrameWork_AssignEp(pdev, USBD_HID_CUSTOM_EPIN_ADDR,
 8012a4c:	2304      	movs	r3, #4
 8012a4e:	2203      	movs	r2, #3
 8012a50:	2181      	movs	r1, #129	; 0x81
 8012a52:	68f8      	ldr	r0, [r7, #12]
 8012a54:	f000 f8c8 	bl	8012be8 <USBD_FrameWork_AssignEp>
            USBD_FrameWork_AssignEp(pdev, USBD_HID_CUSTOM_EPOUT_ADDR,
 8012a58:	2304      	movs	r3, #4
 8012a5a:	2203      	movs	r2, #3
 8012a5c:	2101      	movs	r1, #1
 8012a5e:	68f8      	ldr	r0, [r7, #12]
 8012a60:	f000 f8c2 	bl	8012be8 <USBD_FrameWork_AssignEp>
 8012a64:	e00b      	b.n	8012a7e <USBD_FrameWork_AddToConfDesc+0xe2>
            USBD_FrameWork_AssignEp(pdev, USBD_HID_CUSTOM_EPIN_ADDR,
 8012a66:	2301      	movs	r3, #1
 8012a68:	2203      	movs	r2, #3
 8012a6a:	2181      	movs	r1, #129	; 0x81
 8012a6c:	68f8      	ldr	r0, [r7, #12]
 8012a6e:	f000 f8bb 	bl	8012be8 <USBD_FrameWork_AssignEp>
            USBD_FrameWork_AssignEp(pdev, USBD_HID_CUSTOM_EPOUT_ADDR,
 8012a72:	2304      	movs	r3, #4
 8012a74:	2203      	movs	r2, #3
 8012a76:	2101      	movs	r1, #1
 8012a78:	68f8      	ldr	r0, [r7, #12]
 8012a7a:	f000 f8b5 	bl	8012be8 <USBD_FrameWork_AssignEp>
          USBD_FrameWork_HID_Desc(pdev, (uint32_t)pCmpstConfDesc, &pdev->CurrConfDescSz);
 8012a7e:	6879      	ldr	r1, [r7, #4]
 8012a80:	68fb      	ldr	r3, [r7, #12]
 8012a82:	f503 7392 	add.w	r3, r3, #292	; 0x124
 8012a86:	461a      	mov	r2, r3
 8012a88:	68f8      	ldr	r0, [r7, #12]
 8012a8a:	f000 f921 	bl	8012cd0 <USBD_FrameWork_HID_Desc>
          break;
 8012a8e:	e000      	b.n	8012a92 <USBD_FrameWork_AddToConfDesc+0xf6>
          break;
 8012a90:	bf00      	nop
      break;
 8012a92:	e04a      	b.n	8012b2a <USBD_FrameWork_AddToConfDesc+0x18e>
      interface = USBD_FrameWork_FindFreeIFNbr(pdev);
 8012a94:	68f8      	ldr	r0, [r7, #12]
 8012a96:	f000 f84d 	bl	8012b34 <USBD_FrameWork_FindFreeIFNbr>
 8012a9a:	4603      	mov	r3, r0
 8012a9c:	75fb      	strb	r3, [r7, #23]
      pdev->tclasslist[pdev->classId].NumIf = 1U;
 8012a9e:	68fb      	ldr	r3, [r7, #12]
 8012aa0:	685b      	ldr	r3, [r3, #4]
 8012aa2:	68fa      	ldr	r2, [r7, #12]
 8012aa4:	215c      	movs	r1, #92	; 0x5c
 8012aa6:	fb01 f303 	mul.w	r3, r1, r3
 8012aaa:	4413      	add	r3, r2
 8012aac:	3320      	adds	r3, #32
 8012aae:	2201      	movs	r2, #1
 8012ab0:	601a      	str	r2, [r3, #0]
      pdev->tclasslist[pdev->classId].Ifs[0] = interface;
 8012ab2:	68fb      	ldr	r3, [r7, #12]
 8012ab4:	685b      	ldr	r3, [r3, #4]
 8012ab6:	68fa      	ldr	r2, [r7, #12]
 8012ab8:	215c      	movs	r1, #92	; 0x5c
 8012aba:	fb01 f303 	mul.w	r3, r1, r3
 8012abe:	4413      	add	r3, r2
 8012ac0:	335a      	adds	r3, #90	; 0x5a
 8012ac2:	7dfa      	ldrb	r2, [r7, #23]
 8012ac4:	701a      	strb	r2, [r3, #0]
      pdev->tclasslist[pdev->classId].NumEps = 2; /* EP_IN, EP_OUT */
 8012ac6:	68fb      	ldr	r3, [r7, #12]
 8012ac8:	685b      	ldr	r3, [r3, #4]
 8012aca:	68fa      	ldr	r2, [r7, #12]
 8012acc:	215c      	movs	r1, #92	; 0x5c
 8012ace:	fb01 f303 	mul.w	r3, r1, r3
 8012ad2:	4413      	add	r3, r2
 8012ad4:	331c      	adds	r3, #28
 8012ad6:	2202      	movs	r2, #2
 8012ad8:	601a      	str	r2, [r3, #0]
      if (pdev->Speed == USBD_HIGH_SPEED)
 8012ada:	68fb      	ldr	r3, [r7, #12]
 8012adc:	781b      	ldrb	r3, [r3, #0]
 8012ade:	2b01      	cmp	r3, #1
 8012ae0:	d10e      	bne.n	8012b00 <USBD_FrameWork_AddToConfDesc+0x164>
        USBD_FrameWork_AssignEp(pdev, USBD_MSC_EPIN_ADDR,
 8012ae2:	f44f 7300 	mov.w	r3, #512	; 0x200
 8012ae6:	2202      	movs	r2, #2
 8012ae8:	2181      	movs	r1, #129	; 0x81
 8012aea:	68f8      	ldr	r0, [r7, #12]
 8012aec:	f000 f87c 	bl	8012be8 <USBD_FrameWork_AssignEp>
        USBD_FrameWork_AssignEp(pdev, USBD_MSC_EPOUT_ADDR,
 8012af0:	f44f 7300 	mov.w	r3, #512	; 0x200
 8012af4:	2202      	movs	r2, #2
 8012af6:	2101      	movs	r1, #1
 8012af8:	68f8      	ldr	r0, [r7, #12]
 8012afa:	f000 f875 	bl	8012be8 <USBD_FrameWork_AssignEp>
 8012afe:	e00b      	b.n	8012b18 <USBD_FrameWork_AddToConfDesc+0x17c>
        USBD_FrameWork_AssignEp(pdev, USBD_MSC_EPIN_ADDR,
 8012b00:	2340      	movs	r3, #64	; 0x40
 8012b02:	2202      	movs	r2, #2
 8012b04:	2181      	movs	r1, #129	; 0x81
 8012b06:	68f8      	ldr	r0, [r7, #12]
 8012b08:	f000 f86e 	bl	8012be8 <USBD_FrameWork_AssignEp>
        USBD_FrameWork_AssignEp(pdev, USBD_MSC_EPOUT_ADDR,
 8012b0c:	2340      	movs	r3, #64	; 0x40
 8012b0e:	2202      	movs	r2, #2
 8012b10:	2101      	movs	r1, #1
 8012b12:	68f8      	ldr	r0, [r7, #12]
 8012b14:	f000 f868 	bl	8012be8 <USBD_FrameWork_AssignEp>
      USBD_FrameWork_MSCDesc(pdev, (uint32_t)pCmpstConfDesc, &pdev->CurrConfDescSz);
 8012b18:	6879      	ldr	r1, [r7, #4]
 8012b1a:	68fb      	ldr	r3, [r7, #12]
 8012b1c:	f503 7392 	add.w	r3, r3, #292	; 0x124
 8012b20:	461a      	mov	r2, r3
 8012b22:	68f8      	ldr	r0, [r7, #12]
 8012b24:	f000 fa6e 	bl	8013004 <USBD_FrameWork_MSCDesc>
      break;
 8012b28:	bf00      	nop
  }

  return UX_SUCCESS;
 8012b2a:	2300      	movs	r3, #0
}
 8012b2c:	4618      	mov	r0, r3
 8012b2e:	3718      	adds	r7, #24
 8012b30:	46bd      	mov	sp, r7
 8012b32:	bd80      	pop	{r7, pc}

08012b34 <USBD_FrameWork_FindFreeIFNbr>:
  *         Find the first interface available slot
  * @param  pdev: device instance
  * @retval The interface number to be used
  */
static uint8_t USBD_FrameWork_FindFreeIFNbr(USBD_DevClassHandleTypeDef *pdev)
{
 8012b34:	b480      	push	{r7}
 8012b36:	b087      	sub	sp, #28
 8012b38:	af00      	add	r7, sp, #0
 8012b3a:	6078      	str	r0, [r7, #4]
  uint32_t idx = 0U;
 8012b3c:	2300      	movs	r3, #0
 8012b3e:	617b      	str	r3, [r7, #20]

  /* Unroll all already activated classes */
  for (uint32_t i = 0U; i < pdev->NumClasses; i++)
 8012b40:	2300      	movs	r3, #0
 8012b42:	613b      	str	r3, [r7, #16]
 8012b44:	e016      	b.n	8012b74 <USBD_FrameWork_FindFreeIFNbr+0x40>
  {
    /* Unroll each class interfaces */
    for (uint32_t j = 0U; j < pdev->tclasslist[i].NumIf; j++)
 8012b46:	2300      	movs	r3, #0
 8012b48:	60fb      	str	r3, [r7, #12]
 8012b4a:	e005      	b.n	8012b58 <USBD_FrameWork_FindFreeIFNbr+0x24>
    {
      /* Increment the interface counter index */
      idx++;
 8012b4c:	697b      	ldr	r3, [r7, #20]
 8012b4e:	3301      	adds	r3, #1
 8012b50:	617b      	str	r3, [r7, #20]
    for (uint32_t j = 0U; j < pdev->tclasslist[i].NumIf; j++)
 8012b52:	68fb      	ldr	r3, [r7, #12]
 8012b54:	3301      	adds	r3, #1
 8012b56:	60fb      	str	r3, [r7, #12]
 8012b58:	687a      	ldr	r2, [r7, #4]
 8012b5a:	693b      	ldr	r3, [r7, #16]
 8012b5c:	215c      	movs	r1, #92	; 0x5c
 8012b5e:	fb01 f303 	mul.w	r3, r1, r3
 8012b62:	4413      	add	r3, r2
 8012b64:	3320      	adds	r3, #32
 8012b66:	681b      	ldr	r3, [r3, #0]
 8012b68:	68fa      	ldr	r2, [r7, #12]
 8012b6a:	429a      	cmp	r2, r3
 8012b6c:	d3ee      	bcc.n	8012b4c <USBD_FrameWork_FindFreeIFNbr+0x18>
  for (uint32_t i = 0U; i < pdev->NumClasses; i++)
 8012b6e:	693b      	ldr	r3, [r7, #16]
 8012b70:	3301      	adds	r3, #1
 8012b72:	613b      	str	r3, [r7, #16]
 8012b74:	687b      	ldr	r3, [r7, #4]
 8012b76:	689b      	ldr	r3, [r3, #8]
 8012b78:	693a      	ldr	r2, [r7, #16]
 8012b7a:	429a      	cmp	r2, r3
 8012b7c:	d3e3      	bcc.n	8012b46 <USBD_FrameWork_FindFreeIFNbr+0x12>
    }
  }

  /* Return the first available interface slot */
  return (uint8_t)idx;
 8012b7e:	697b      	ldr	r3, [r7, #20]
 8012b80:	b2db      	uxtb	r3, r3
}
 8012b82:	4618      	mov	r0, r3
 8012b84:	371c      	adds	r7, #28
 8012b86:	46bd      	mov	sp, r7
 8012b88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012b8c:	4770      	bx	lr

08012b8e <USBD_FrameWork_AddConfDesc>:
  * @param  Conf: configuration descriptor
  * @param  pSze: pointer to the configuration descriptor size
  * @retval none
  */
static void  USBD_FrameWork_AddConfDesc(uint32_t Conf, uint32_t *pSze)
{
 8012b8e:	b480      	push	{r7}
 8012b90:	b085      	sub	sp, #20
 8012b92:	af00      	add	r7, sp, #0
 8012b94:	6078      	str	r0, [r7, #4]
 8012b96:	6039      	str	r1, [r7, #0]
  /* Intermediate variable to comply with MISRA-C Rule 11.3 */
  USBD_ConfigDescTypedef *ptr = (USBD_ConfigDescTypedef *)Conf;
 8012b98:	687b      	ldr	r3, [r7, #4]
 8012b9a:	60fb      	str	r3, [r7, #12]

  ptr->bLength = (uint8_t)sizeof(USBD_ConfigDescTypedef);
 8012b9c:	68fb      	ldr	r3, [r7, #12]
 8012b9e:	2209      	movs	r2, #9
 8012ba0:	701a      	strb	r2, [r3, #0]
  ptr->bDescriptorType = USB_DESC_TYPE_CONFIGURATION;
 8012ba2:	68fb      	ldr	r3, [r7, #12]
 8012ba4:	2202      	movs	r2, #2
 8012ba6:	705a      	strb	r2, [r3, #1]
  ptr->wDescriptorLength = 0U;
 8012ba8:	68fb      	ldr	r3, [r7, #12]
 8012baa:	2200      	movs	r2, #0
 8012bac:	709a      	strb	r2, [r3, #2]
 8012bae:	2200      	movs	r2, #0
 8012bb0:	70da      	strb	r2, [r3, #3]
  ptr->bNumInterfaces = 0U;
 8012bb2:	68fb      	ldr	r3, [r7, #12]
 8012bb4:	2200      	movs	r2, #0
 8012bb6:	711a      	strb	r2, [r3, #4]
  ptr->bConfigurationValue = 1U;
 8012bb8:	68fb      	ldr	r3, [r7, #12]
 8012bba:	2201      	movs	r2, #1
 8012bbc:	715a      	strb	r2, [r3, #5]
  ptr->iConfiguration = USBD_CONFIG_STR_DESC_IDX;
 8012bbe:	68fb      	ldr	r3, [r7, #12]
 8012bc0:	2200      	movs	r2, #0
 8012bc2:	719a      	strb	r2, [r3, #6]
  ptr->bmAttributes = USBD_CONFIG_BMATTRIBUTES;
 8012bc4:	68fb      	ldr	r3, [r7, #12]
 8012bc6:	22c0      	movs	r2, #192	; 0xc0
 8012bc8:	71da      	strb	r2, [r3, #7]
  ptr->bMaxPower = USBD_CONFIG_MAXPOWER;
 8012bca:	68fb      	ldr	r3, [r7, #12]
 8012bcc:	2219      	movs	r2, #25
 8012bce:	721a      	strb	r2, [r3, #8]
  *pSze += sizeof(USBD_ConfigDescTypedef);
 8012bd0:	683b      	ldr	r3, [r7, #0]
 8012bd2:	681b      	ldr	r3, [r3, #0]
 8012bd4:	f103 0209 	add.w	r2, r3, #9
 8012bd8:	683b      	ldr	r3, [r7, #0]
 8012bda:	601a      	str	r2, [r3, #0]
}
 8012bdc:	bf00      	nop
 8012bde:	3714      	adds	r7, #20
 8012be0:	46bd      	mov	sp, r7
 8012be2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012be6:	4770      	bx	lr

08012be8 <USBD_FrameWork_AssignEp>:
  * @param  Sze: Endpoint max packet size
  * @retval none
  */
static void  USBD_FrameWork_AssignEp(USBD_DevClassHandleTypeDef *pdev,
                                     uint8_t Add, uint8_t Type, uint32_t Sze)
{
 8012be8:	b490      	push	{r4, r7}
 8012bea:	b086      	sub	sp, #24
 8012bec:	af00      	add	r7, sp, #0
 8012bee:	60f8      	str	r0, [r7, #12]
 8012bf0:	607b      	str	r3, [r7, #4]
 8012bf2:	460b      	mov	r3, r1
 8012bf4:	72fb      	strb	r3, [r7, #11]
 8012bf6:	4613      	mov	r3, r2
 8012bf8:	72bb      	strb	r3, [r7, #10]
  uint32_t idx = 0U;
 8012bfa:	2300      	movs	r3, #0
 8012bfc:	617b      	str	r3, [r7, #20]

  /* Find the first available endpoint slot */
  while (((idx < (pdev->tclasslist[pdev->classId]).NumEps) && \
 8012bfe:	e002      	b.n	8012c06 <USBD_FrameWork_AssignEp+0x1e>
          ((pdev->tclasslist[pdev->classId].Eps[idx].is_used) != 0U)))
  {
    /* Increment the index */
    idx++;
 8012c00:	697b      	ldr	r3, [r7, #20]
 8012c02:	3301      	adds	r3, #1
 8012c04:	617b      	str	r3, [r7, #20]
  while (((idx < (pdev->tclasslist[pdev->classId]).NumEps) && \
 8012c06:	68fb      	ldr	r3, [r7, #12]
 8012c08:	685b      	ldr	r3, [r3, #4]
 8012c0a:	68fa      	ldr	r2, [r7, #12]
 8012c0c:	215c      	movs	r1, #92	; 0x5c
 8012c0e:	fb01 f303 	mul.w	r3, r1, r3
 8012c12:	4413      	add	r3, r2
 8012c14:	331c      	adds	r3, #28
 8012c16:	681b      	ldr	r3, [r3, #0]
 8012c18:	697a      	ldr	r2, [r7, #20]
 8012c1a:	429a      	cmp	r2, r3
 8012c1c:	d210      	bcs.n	8012c40 <USBD_FrameWork_AssignEp+0x58>
          ((pdev->tclasslist[pdev->classId].Eps[idx].is_used) != 0U)))
 8012c1e:	68fb      	ldr	r3, [r7, #12]
 8012c20:	6858      	ldr	r0, [r3, #4]
 8012c22:	68f9      	ldr	r1, [r7, #12]
 8012c24:	697a      	ldr	r2, [r7, #20]
 8012c26:	4613      	mov	r3, r2
 8012c28:	005b      	lsls	r3, r3, #1
 8012c2a:	4413      	add	r3, r2
 8012c2c:	005b      	lsls	r3, r3, #1
 8012c2e:	225c      	movs	r2, #92	; 0x5c
 8012c30:	fb00 f202 	mul.w	r2, r0, r2
 8012c34:	4413      	add	r3, r2
 8012c36:	440b      	add	r3, r1
 8012c38:	3328      	adds	r3, #40	; 0x28
 8012c3a:	781b      	ldrb	r3, [r3, #0]
  while (((idx < (pdev->tclasslist[pdev->classId]).NumEps) && \
 8012c3c:	2b00      	cmp	r3, #0
 8012c3e:	d1df      	bne.n	8012c00 <USBD_FrameWork_AssignEp+0x18>
  }

  /* Configure the endpoint */
  pdev->tclasslist[pdev->classId].Eps[idx].add = Add;
 8012c40:	68fb      	ldr	r3, [r7, #12]
 8012c42:	6858      	ldr	r0, [r3, #4]
 8012c44:	68f9      	ldr	r1, [r7, #12]
 8012c46:	697a      	ldr	r2, [r7, #20]
 8012c48:	4613      	mov	r3, r2
 8012c4a:	005b      	lsls	r3, r3, #1
 8012c4c:	4413      	add	r3, r2
 8012c4e:	005b      	lsls	r3, r3, #1
 8012c50:	225c      	movs	r2, #92	; 0x5c
 8012c52:	fb00 f202 	mul.w	r2, r0, r2
 8012c56:	4413      	add	r3, r2
 8012c58:	440b      	add	r3, r1
 8012c5a:	3324      	adds	r3, #36	; 0x24
 8012c5c:	7afa      	ldrb	r2, [r7, #11]
 8012c5e:	701a      	strb	r2, [r3, #0]
  pdev->tclasslist[pdev->classId].Eps[idx].type = Type;
 8012c60:	68fb      	ldr	r3, [r7, #12]
 8012c62:	6858      	ldr	r0, [r3, #4]
 8012c64:	68f9      	ldr	r1, [r7, #12]
 8012c66:	697a      	ldr	r2, [r7, #20]
 8012c68:	4613      	mov	r3, r2
 8012c6a:	005b      	lsls	r3, r3, #1
 8012c6c:	4413      	add	r3, r2
 8012c6e:	005b      	lsls	r3, r3, #1
 8012c70:	225c      	movs	r2, #92	; 0x5c
 8012c72:	fb00 f202 	mul.w	r2, r0, r2
 8012c76:	4413      	add	r3, r2
 8012c78:	440b      	add	r3, r1
 8012c7a:	3325      	adds	r3, #37	; 0x25
 8012c7c:	7aba      	ldrb	r2, [r7, #10]
 8012c7e:	701a      	strb	r2, [r3, #0]
  pdev->tclasslist[pdev->classId].Eps[idx].size = (uint16_t) Sze;
 8012c80:	68fb      	ldr	r3, [r7, #12]
 8012c82:	6858      	ldr	r0, [r3, #4]
 8012c84:	687b      	ldr	r3, [r7, #4]
 8012c86:	b29c      	uxth	r4, r3
 8012c88:	68f9      	ldr	r1, [r7, #12]
 8012c8a:	697a      	ldr	r2, [r7, #20]
 8012c8c:	4613      	mov	r3, r2
 8012c8e:	005b      	lsls	r3, r3, #1
 8012c90:	4413      	add	r3, r2
 8012c92:	005b      	lsls	r3, r3, #1
 8012c94:	225c      	movs	r2, #92	; 0x5c
 8012c96:	fb00 f202 	mul.w	r2, r0, r2
 8012c9a:	4413      	add	r3, r2
 8012c9c:	440b      	add	r3, r1
 8012c9e:	3326      	adds	r3, #38	; 0x26
 8012ca0:	4622      	mov	r2, r4
 8012ca2:	801a      	strh	r2, [r3, #0]
  pdev->tclasslist[pdev->classId].Eps[idx].is_used = 1U;
 8012ca4:	68fb      	ldr	r3, [r7, #12]
 8012ca6:	6858      	ldr	r0, [r3, #4]
 8012ca8:	68f9      	ldr	r1, [r7, #12]
 8012caa:	697a      	ldr	r2, [r7, #20]
 8012cac:	4613      	mov	r3, r2
 8012cae:	005b      	lsls	r3, r3, #1
 8012cb0:	4413      	add	r3, r2
 8012cb2:	005b      	lsls	r3, r3, #1
 8012cb4:	225c      	movs	r2, #92	; 0x5c
 8012cb6:	fb00 f202 	mul.w	r2, r0, r2
 8012cba:	4413      	add	r3, r2
 8012cbc:	440b      	add	r3, r1
 8012cbe:	3328      	adds	r3, #40	; 0x28
 8012cc0:	2201      	movs	r2, #1
 8012cc2:	701a      	strb	r2, [r3, #0]
}
 8012cc4:	bf00      	nop
 8012cc6:	3718      	adds	r7, #24
 8012cc8:	46bd      	mov	sp, r7
 8012cca:	bc90      	pop	{r4, r7}
 8012ccc:	4770      	bx	lr
	...

08012cd0 <USBD_FrameWork_HID_Desc>:
  * @param  Sze: pointer to the current configuration descriptor size
  * @retval None
  */
static void  USBD_FrameWork_HID_Desc(USBD_DevClassHandleTypeDef *pdev,
                                     uint32_t pConf, uint32_t *Sze)
{
 8012cd0:	b590      	push	{r4, r7, lr}
 8012cd2:	b085      	sub	sp, #20
 8012cd4:	af00      	add	r7, sp, #0
 8012cd6:	60f8      	str	r0, [r7, #12]
 8012cd8:	60b9      	str	r1, [r7, #8]
 8012cda:	607a      	str	r2, [r7, #4]
  static USBD_IfDescTypedef       *pIfDesc;
  static USBD_EpDescTypedef       *pEpDesc;
  static USBD_HIDDescTypedef      *pHidDesc;

  switch(pdev->tclasslist[pdev->classId].InterfaceType)
 8012cdc:	68fb      	ldr	r3, [r7, #12]
 8012cde:	685b      	ldr	r3, [r3, #4]
 8012ce0:	68fa      	ldr	r2, [r7, #12]
 8012ce2:	215c      	movs	r1, #92	; 0x5c
 8012ce4:	fb01 f303 	mul.w	r3, r1, r3
 8012ce8:	4413      	add	r3, r2
 8012cea:	3314      	adds	r3, #20
 8012cec:	781b      	ldrb	r3, [r3, #0]
 8012cee:	2b00      	cmp	r3, #0
 8012cf0:	f040 8175 	bne.w	8012fde <USBD_FrameWork_HID_Desc+0x30e>

#if USBD_HID_CUSTOM_ACTIVATED == 1U
    case  INTERFACE_HID_CUSTOM:

      /* Append HID Interface descriptor to Configuration descriptor */
      __USBD_FRAMEWORK_SET_IF(pdev->tclasslist[pdev->classId].Ifs[0], 0U, \
 8012cf4:	687b      	ldr	r3, [r7, #4]
 8012cf6:	681a      	ldr	r2, [r3, #0]
 8012cf8:	68bb      	ldr	r3, [r7, #8]
 8012cfa:	4413      	add	r3, r2
 8012cfc:	461a      	mov	r2, r3
 8012cfe:	4b91      	ldr	r3, [pc, #580]	; (8012f44 <USBD_FrameWork_HID_Desc+0x274>)
 8012d00:	601a      	str	r2, [r3, #0]
 8012d02:	4b90      	ldr	r3, [pc, #576]	; (8012f44 <USBD_FrameWork_HID_Desc+0x274>)
 8012d04:	681b      	ldr	r3, [r3, #0]
 8012d06:	2209      	movs	r2, #9
 8012d08:	701a      	strb	r2, [r3, #0]
 8012d0a:	4b8e      	ldr	r3, [pc, #568]	; (8012f44 <USBD_FrameWork_HID_Desc+0x274>)
 8012d0c:	681b      	ldr	r3, [r3, #0]
 8012d0e:	2204      	movs	r2, #4
 8012d10:	705a      	strb	r2, [r3, #1]
 8012d12:	68fb      	ldr	r3, [r7, #12]
 8012d14:	685a      	ldr	r2, [r3, #4]
 8012d16:	4b8b      	ldr	r3, [pc, #556]	; (8012f44 <USBD_FrameWork_HID_Desc+0x274>)
 8012d18:	681b      	ldr	r3, [r3, #0]
 8012d1a:	68f9      	ldr	r1, [r7, #12]
 8012d1c:	205c      	movs	r0, #92	; 0x5c
 8012d1e:	fb00 f202 	mul.w	r2, r0, r2
 8012d22:	440a      	add	r2, r1
 8012d24:	325a      	adds	r2, #90	; 0x5a
 8012d26:	7812      	ldrb	r2, [r2, #0]
 8012d28:	709a      	strb	r2, [r3, #2]
 8012d2a:	4b86      	ldr	r3, [pc, #536]	; (8012f44 <USBD_FrameWork_HID_Desc+0x274>)
 8012d2c:	681b      	ldr	r3, [r3, #0]
 8012d2e:	2200      	movs	r2, #0
 8012d30:	70da      	strb	r2, [r3, #3]
 8012d32:	68fb      	ldr	r3, [r7, #12]
 8012d34:	685b      	ldr	r3, [r3, #4]
 8012d36:	68fa      	ldr	r2, [r7, #12]
 8012d38:	215c      	movs	r1, #92	; 0x5c
 8012d3a:	fb01 f303 	mul.w	r3, r1, r3
 8012d3e:	4413      	add	r3, r2
 8012d40:	331c      	adds	r3, #28
 8012d42:	681a      	ldr	r2, [r3, #0]
 8012d44:	4b7f      	ldr	r3, [pc, #508]	; (8012f44 <USBD_FrameWork_HID_Desc+0x274>)
 8012d46:	681b      	ldr	r3, [r3, #0]
 8012d48:	b2d2      	uxtb	r2, r2
 8012d4a:	711a      	strb	r2, [r3, #4]
 8012d4c:	4b7d      	ldr	r3, [pc, #500]	; (8012f44 <USBD_FrameWork_HID_Desc+0x274>)
 8012d4e:	681b      	ldr	r3, [r3, #0]
 8012d50:	2203      	movs	r2, #3
 8012d52:	715a      	strb	r2, [r3, #5]
 8012d54:	4b7b      	ldr	r3, [pc, #492]	; (8012f44 <USBD_FrameWork_HID_Desc+0x274>)
 8012d56:	681b      	ldr	r3, [r3, #0]
 8012d58:	2200      	movs	r2, #0
 8012d5a:	719a      	strb	r2, [r3, #6]
 8012d5c:	4b79      	ldr	r3, [pc, #484]	; (8012f44 <USBD_FrameWork_HID_Desc+0x274>)
 8012d5e:	681b      	ldr	r3, [r3, #0]
 8012d60:	2200      	movs	r2, #0
 8012d62:	71da      	strb	r2, [r3, #7]
 8012d64:	4b77      	ldr	r3, [pc, #476]	; (8012f44 <USBD_FrameWork_HID_Desc+0x274>)
 8012d66:	681b      	ldr	r3, [r3, #0]
 8012d68:	2200      	movs	r2, #0
 8012d6a:	721a      	strb	r2, [r3, #8]
 8012d6c:	687b      	ldr	r3, [r7, #4]
 8012d6e:	681b      	ldr	r3, [r3, #0]
 8012d70:	f103 0209 	add.w	r2, r3, #9
 8012d74:	687b      	ldr	r3, [r7, #4]
 8012d76:	601a      	str	r2, [r3, #0]
                              (uint8_t)(pdev->tclasslist[pdev->classId].NumEps),
                              UX_DEVICE_CLASS_HID_CLASS,
                              0x00U, INTERFACE_HID_CUSTOM, 0U);

      /* Append HID Functional descriptor to Configuration descriptor */
      pHidDesc = ((USBD_HIDDescTypedef *)(pConf + *Sze));
 8012d78:	687b      	ldr	r3, [r7, #4]
 8012d7a:	681a      	ldr	r2, [r3, #0]
 8012d7c:	68bb      	ldr	r3, [r7, #8]
 8012d7e:	4413      	add	r3, r2
 8012d80:	461a      	mov	r2, r3
 8012d82:	4b71      	ldr	r3, [pc, #452]	; (8012f48 <USBD_FrameWork_HID_Desc+0x278>)
 8012d84:	601a      	str	r2, [r3, #0]
      pHidDesc->bLength = (uint8_t)sizeof(USBD_HIDDescTypedef);
 8012d86:	4b70      	ldr	r3, [pc, #448]	; (8012f48 <USBD_FrameWork_HID_Desc+0x278>)
 8012d88:	681b      	ldr	r3, [r3, #0]
 8012d8a:	2209      	movs	r2, #9
 8012d8c:	701a      	strb	r2, [r3, #0]
      pHidDesc->bDescriptorType = UX_DEVICE_CLASS_HID_DESCRIPTOR_HID;
 8012d8e:	4b6e      	ldr	r3, [pc, #440]	; (8012f48 <USBD_FrameWork_HID_Desc+0x278>)
 8012d90:	681b      	ldr	r3, [r3, #0]
 8012d92:	2221      	movs	r2, #33	; 0x21
 8012d94:	705a      	strb	r2, [r3, #1]
      pHidDesc->bcdHID = 0x0111U;
 8012d96:	4b6c      	ldr	r3, [pc, #432]	; (8012f48 <USBD_FrameWork_HID_Desc+0x278>)
 8012d98:	681b      	ldr	r3, [r3, #0]
 8012d9a:	2200      	movs	r2, #0
 8012d9c:	f042 0211 	orr.w	r2, r2, #17
 8012da0:	709a      	strb	r2, [r3, #2]
 8012da2:	2200      	movs	r2, #0
 8012da4:	f042 0201 	orr.w	r2, r2, #1
 8012da8:	70da      	strb	r2, [r3, #3]
      pHidDesc->bCountryCode = 0x00U;
 8012daa:	4b67      	ldr	r3, [pc, #412]	; (8012f48 <USBD_FrameWork_HID_Desc+0x278>)
 8012dac:	681b      	ldr	r3, [r3, #0]
 8012dae:	2200      	movs	r2, #0
 8012db0:	711a      	strb	r2, [r3, #4]
      pHidDesc->bNumDescriptors = 0x01U;
 8012db2:	4b65      	ldr	r3, [pc, #404]	; (8012f48 <USBD_FrameWork_HID_Desc+0x278>)
 8012db4:	681b      	ldr	r3, [r3, #0]
 8012db6:	2201      	movs	r2, #1
 8012db8:	715a      	strb	r2, [r3, #5]
      pHidDesc->bHIDDescriptorType = 0x22U;
 8012dba:	4b63      	ldr	r3, [pc, #396]	; (8012f48 <USBD_FrameWork_HID_Desc+0x278>)
 8012dbc:	681b      	ldr	r3, [r3, #0]
 8012dbe:	2222      	movs	r2, #34	; 0x22
 8012dc0:	719a      	strb	r2, [r3, #6]
      pHidDesc->wDescriptorLength = USBD_HID_ReportDesc_length(INTERFACE_HID_CUSTOM);
 8012dc2:	4b61      	ldr	r3, [pc, #388]	; (8012f48 <USBD_FrameWork_HID_Desc+0x278>)
 8012dc4:	681c      	ldr	r4, [r3, #0]
 8012dc6:	2000      	movs	r0, #0
 8012dc8:	f7ff fc1c 	bl	8012604 <USBD_HID_ReportDesc_length>
 8012dcc:	4603      	mov	r3, r0
 8012dce:	f8a4 3007 	strh.w	r3, [r4, #7]
      *Sze += (uint32_t)sizeof(USBD_HIDDescTypedef);
 8012dd2:	687b      	ldr	r3, [r7, #4]
 8012dd4:	681b      	ldr	r3, [r3, #0]
 8012dd6:	f103 0209 	add.w	r2, r3, #9
 8012dda:	687b      	ldr	r3, [r7, #4]
 8012ddc:	601a      	str	r2, [r3, #0]

      if (pdev->Speed == USBD_HIGH_SPEED)
 8012dde:	68fb      	ldr	r3, [r7, #12]
 8012de0:	781b      	ldrb	r3, [r3, #0]
 8012de2:	2b01      	cmp	r3, #1
 8012de4:	d17a      	bne.n	8012edc <USBD_FrameWork_HID_Desc+0x20c>
      {
        /* Append Endpoint descriptor to Configuration descriptor */
        __USBD_FRAMEWORK_SET_EP(pdev->tclasslist[pdev->classId].Eps[0].add,
 8012de6:	687b      	ldr	r3, [r7, #4]
 8012de8:	681a      	ldr	r2, [r3, #0]
 8012dea:	68bb      	ldr	r3, [r7, #8]
 8012dec:	4413      	add	r3, r2
 8012dee:	461a      	mov	r2, r3
 8012df0:	4b56      	ldr	r3, [pc, #344]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012df2:	601a      	str	r2, [r3, #0]
 8012df4:	4b55      	ldr	r3, [pc, #340]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012df6:	681b      	ldr	r3, [r3, #0]
 8012df8:	2207      	movs	r2, #7
 8012dfa:	701a      	strb	r2, [r3, #0]
 8012dfc:	4b53      	ldr	r3, [pc, #332]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012dfe:	681b      	ldr	r3, [r3, #0]
 8012e00:	2205      	movs	r2, #5
 8012e02:	705a      	strb	r2, [r3, #1]
 8012e04:	68fb      	ldr	r3, [r7, #12]
 8012e06:	685a      	ldr	r2, [r3, #4]
 8012e08:	4b50      	ldr	r3, [pc, #320]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012e0a:	681b      	ldr	r3, [r3, #0]
 8012e0c:	68f9      	ldr	r1, [r7, #12]
 8012e0e:	205c      	movs	r0, #92	; 0x5c
 8012e10:	fb00 f202 	mul.w	r2, r0, r2
 8012e14:	440a      	add	r2, r1
 8012e16:	3224      	adds	r2, #36	; 0x24
 8012e18:	7812      	ldrb	r2, [r2, #0]
 8012e1a:	709a      	strb	r2, [r3, #2]
 8012e1c:	4b4b      	ldr	r3, [pc, #300]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012e1e:	681b      	ldr	r3, [r3, #0]
 8012e20:	2203      	movs	r2, #3
 8012e22:	70da      	strb	r2, [r3, #3]
 8012e24:	68fb      	ldr	r3, [r7, #12]
 8012e26:	685a      	ldr	r2, [r3, #4]
 8012e28:	4b48      	ldr	r3, [pc, #288]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012e2a:	681b      	ldr	r3, [r3, #0]
 8012e2c:	68f9      	ldr	r1, [r7, #12]
 8012e2e:	205c      	movs	r0, #92	; 0x5c
 8012e30:	fb00 f202 	mul.w	r2, r0, r2
 8012e34:	440a      	add	r2, r1
 8012e36:	3226      	adds	r2, #38	; 0x26
 8012e38:	8812      	ldrh	r2, [r2, #0]
 8012e3a:	809a      	strh	r2, [r3, #4]
 8012e3c:	68fb      	ldr	r3, [r7, #12]
 8012e3e:	781b      	ldrb	r3, [r3, #0]
 8012e40:	2b01      	cmp	r3, #1
 8012e42:	d104      	bne.n	8012e4e <USBD_FrameWork_HID_Desc+0x17e>
 8012e44:	4b41      	ldr	r3, [pc, #260]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012e46:	681b      	ldr	r3, [r3, #0]
 8012e48:	2205      	movs	r2, #5
 8012e4a:	719a      	strb	r2, [r3, #6]
 8012e4c:	e003      	b.n	8012e56 <USBD_FrameWork_HID_Desc+0x186>
 8012e4e:	4b3f      	ldr	r3, [pc, #252]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012e50:	681b      	ldr	r3, [r3, #0]
 8012e52:	2205      	movs	r2, #5
 8012e54:	719a      	strb	r2, [r3, #6]
 8012e56:	687b      	ldr	r3, [r7, #4]
 8012e58:	681b      	ldr	r3, [r3, #0]
 8012e5a:	1dda      	adds	r2, r3, #7
 8012e5c:	687b      	ldr	r3, [r7, #4]
 8012e5e:	601a      	str	r2, [r3, #0]
                                USBD_EP_TYPE_INTR,
                                (uint16_t)pdev->tclasslist[pdev->classId].Eps[0].size,
                                USBD_HID_CUSTOM_EPIN_FS_BINTERVAL,
                                USBD_HID_CUSTOM_EPIN_HS_BINTERVAL);

        __USBD_FRAMEWORK_SET_EP(pdev->tclasslist[pdev->classId].Eps[1].add,
 8012e60:	687b      	ldr	r3, [r7, #4]
 8012e62:	681a      	ldr	r2, [r3, #0]
 8012e64:	68bb      	ldr	r3, [r7, #8]
 8012e66:	4413      	add	r3, r2
 8012e68:	461a      	mov	r2, r3
 8012e6a:	4b38      	ldr	r3, [pc, #224]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012e6c:	601a      	str	r2, [r3, #0]
 8012e6e:	4b37      	ldr	r3, [pc, #220]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012e70:	681b      	ldr	r3, [r3, #0]
 8012e72:	2207      	movs	r2, #7
 8012e74:	701a      	strb	r2, [r3, #0]
 8012e76:	4b35      	ldr	r3, [pc, #212]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012e78:	681b      	ldr	r3, [r3, #0]
 8012e7a:	2205      	movs	r2, #5
 8012e7c:	705a      	strb	r2, [r3, #1]
 8012e7e:	68fb      	ldr	r3, [r7, #12]
 8012e80:	685a      	ldr	r2, [r3, #4]
 8012e82:	4b32      	ldr	r3, [pc, #200]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012e84:	681b      	ldr	r3, [r3, #0]
 8012e86:	68f9      	ldr	r1, [r7, #12]
 8012e88:	205c      	movs	r0, #92	; 0x5c
 8012e8a:	fb00 f202 	mul.w	r2, r0, r2
 8012e8e:	440a      	add	r2, r1
 8012e90:	322a      	adds	r2, #42	; 0x2a
 8012e92:	7812      	ldrb	r2, [r2, #0]
 8012e94:	709a      	strb	r2, [r3, #2]
 8012e96:	4b2d      	ldr	r3, [pc, #180]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012e98:	681b      	ldr	r3, [r3, #0]
 8012e9a:	2203      	movs	r2, #3
 8012e9c:	70da      	strb	r2, [r3, #3]
 8012e9e:	68fb      	ldr	r3, [r7, #12]
 8012ea0:	685a      	ldr	r2, [r3, #4]
 8012ea2:	4b2a      	ldr	r3, [pc, #168]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012ea4:	681b      	ldr	r3, [r3, #0]
 8012ea6:	68f9      	ldr	r1, [r7, #12]
 8012ea8:	205c      	movs	r0, #92	; 0x5c
 8012eaa:	fb00 f202 	mul.w	r2, r0, r2
 8012eae:	440a      	add	r2, r1
 8012eb0:	322c      	adds	r2, #44	; 0x2c
 8012eb2:	8812      	ldrh	r2, [r2, #0]
 8012eb4:	809a      	strh	r2, [r3, #4]
 8012eb6:	68fb      	ldr	r3, [r7, #12]
 8012eb8:	781b      	ldrb	r3, [r3, #0]
 8012eba:	2b01      	cmp	r3, #1
 8012ebc:	d104      	bne.n	8012ec8 <USBD_FrameWork_HID_Desc+0x1f8>
 8012ebe:	4b23      	ldr	r3, [pc, #140]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012ec0:	681b      	ldr	r3, [r3, #0]
 8012ec2:	2205      	movs	r2, #5
 8012ec4:	719a      	strb	r2, [r3, #6]
 8012ec6:	e003      	b.n	8012ed0 <USBD_FrameWork_HID_Desc+0x200>
 8012ec8:	4b20      	ldr	r3, [pc, #128]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012eca:	681b      	ldr	r3, [r3, #0]
 8012ecc:	2205      	movs	r2, #5
 8012ece:	719a      	strb	r2, [r3, #6]
 8012ed0:	687b      	ldr	r3, [r7, #4]
 8012ed2:	681b      	ldr	r3, [r3, #0]
 8012ed4:	1dda      	adds	r2, r3, #7
 8012ed6:	687b      	ldr	r3, [r7, #4]
 8012ed8:	601a      	str	r2, [r3, #0]
                                (uint16_t)pdev->tclasslist[pdev->classId].Eps[1].size,
                                USBD_HID_CUSTOM_EPOUT_HS_BINTERVAL,
                                USBD_HID_CUSTOM_EPOUT_FS_BINTERVAL);
      }

      break;
 8012eda:	e081      	b.n	8012fe0 <USBD_FrameWork_HID_Desc+0x310>
        __USBD_FRAMEWORK_SET_EP(pdev->tclasslist[pdev->classId].Eps[0].add,
 8012edc:	687b      	ldr	r3, [r7, #4]
 8012ede:	681a      	ldr	r2, [r3, #0]
 8012ee0:	68bb      	ldr	r3, [r7, #8]
 8012ee2:	4413      	add	r3, r2
 8012ee4:	461a      	mov	r2, r3
 8012ee6:	4b19      	ldr	r3, [pc, #100]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012ee8:	601a      	str	r2, [r3, #0]
 8012eea:	4b18      	ldr	r3, [pc, #96]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012eec:	681b      	ldr	r3, [r3, #0]
 8012eee:	2207      	movs	r2, #7
 8012ef0:	701a      	strb	r2, [r3, #0]
 8012ef2:	4b16      	ldr	r3, [pc, #88]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012ef4:	681b      	ldr	r3, [r3, #0]
 8012ef6:	2205      	movs	r2, #5
 8012ef8:	705a      	strb	r2, [r3, #1]
 8012efa:	68fb      	ldr	r3, [r7, #12]
 8012efc:	685a      	ldr	r2, [r3, #4]
 8012efe:	4b13      	ldr	r3, [pc, #76]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012f00:	681b      	ldr	r3, [r3, #0]
 8012f02:	68f9      	ldr	r1, [r7, #12]
 8012f04:	205c      	movs	r0, #92	; 0x5c
 8012f06:	fb00 f202 	mul.w	r2, r0, r2
 8012f0a:	440a      	add	r2, r1
 8012f0c:	3224      	adds	r2, #36	; 0x24
 8012f0e:	7812      	ldrb	r2, [r2, #0]
 8012f10:	709a      	strb	r2, [r3, #2]
 8012f12:	4b0e      	ldr	r3, [pc, #56]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012f14:	681b      	ldr	r3, [r3, #0]
 8012f16:	2203      	movs	r2, #3
 8012f18:	70da      	strb	r2, [r3, #3]
 8012f1a:	68fb      	ldr	r3, [r7, #12]
 8012f1c:	685a      	ldr	r2, [r3, #4]
 8012f1e:	4b0b      	ldr	r3, [pc, #44]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012f20:	681b      	ldr	r3, [r3, #0]
 8012f22:	68f9      	ldr	r1, [r7, #12]
 8012f24:	205c      	movs	r0, #92	; 0x5c
 8012f26:	fb00 f202 	mul.w	r2, r0, r2
 8012f2a:	440a      	add	r2, r1
 8012f2c:	3226      	adds	r2, #38	; 0x26
 8012f2e:	8812      	ldrh	r2, [r2, #0]
 8012f30:	809a      	strh	r2, [r3, #4]
 8012f32:	68fb      	ldr	r3, [r7, #12]
 8012f34:	781b      	ldrb	r3, [r3, #0]
 8012f36:	2b01      	cmp	r3, #1
 8012f38:	d10a      	bne.n	8012f50 <USBD_FrameWork_HID_Desc+0x280>
 8012f3a:	4b04      	ldr	r3, [pc, #16]	; (8012f4c <USBD_FrameWork_HID_Desc+0x27c>)
 8012f3c:	681b      	ldr	r3, [r3, #0]
 8012f3e:	2205      	movs	r2, #5
 8012f40:	719a      	strb	r2, [r3, #6]
 8012f42:	e009      	b.n	8012f58 <USBD_FrameWork_HID_Desc+0x288>
 8012f44:	20007948 	.word	0x20007948
 8012f48:	2000794c 	.word	0x2000794c
 8012f4c:	20007950 	.word	0x20007950
 8012f50:	4b2b      	ldr	r3, [pc, #172]	; (8013000 <USBD_FrameWork_HID_Desc+0x330>)
 8012f52:	681b      	ldr	r3, [r3, #0]
 8012f54:	2205      	movs	r2, #5
 8012f56:	719a      	strb	r2, [r3, #6]
 8012f58:	687b      	ldr	r3, [r7, #4]
 8012f5a:	681b      	ldr	r3, [r3, #0]
 8012f5c:	1dda      	adds	r2, r3, #7
 8012f5e:	687b      	ldr	r3, [r7, #4]
 8012f60:	601a      	str	r2, [r3, #0]
        __USBD_FRAMEWORK_SET_EP(pdev->tclasslist[pdev->classId].Eps[1].add,
 8012f62:	687b      	ldr	r3, [r7, #4]
 8012f64:	681a      	ldr	r2, [r3, #0]
 8012f66:	68bb      	ldr	r3, [r7, #8]
 8012f68:	4413      	add	r3, r2
 8012f6a:	461a      	mov	r2, r3
 8012f6c:	4b24      	ldr	r3, [pc, #144]	; (8013000 <USBD_FrameWork_HID_Desc+0x330>)
 8012f6e:	601a      	str	r2, [r3, #0]
 8012f70:	4b23      	ldr	r3, [pc, #140]	; (8013000 <USBD_FrameWork_HID_Desc+0x330>)
 8012f72:	681b      	ldr	r3, [r3, #0]
 8012f74:	2207      	movs	r2, #7
 8012f76:	701a      	strb	r2, [r3, #0]
 8012f78:	4b21      	ldr	r3, [pc, #132]	; (8013000 <USBD_FrameWork_HID_Desc+0x330>)
 8012f7a:	681b      	ldr	r3, [r3, #0]
 8012f7c:	2205      	movs	r2, #5
 8012f7e:	705a      	strb	r2, [r3, #1]
 8012f80:	68fb      	ldr	r3, [r7, #12]
 8012f82:	685a      	ldr	r2, [r3, #4]
 8012f84:	4b1e      	ldr	r3, [pc, #120]	; (8013000 <USBD_FrameWork_HID_Desc+0x330>)
 8012f86:	681b      	ldr	r3, [r3, #0]
 8012f88:	68f9      	ldr	r1, [r7, #12]
 8012f8a:	205c      	movs	r0, #92	; 0x5c
 8012f8c:	fb00 f202 	mul.w	r2, r0, r2
 8012f90:	440a      	add	r2, r1
 8012f92:	322a      	adds	r2, #42	; 0x2a
 8012f94:	7812      	ldrb	r2, [r2, #0]
 8012f96:	709a      	strb	r2, [r3, #2]
 8012f98:	4b19      	ldr	r3, [pc, #100]	; (8013000 <USBD_FrameWork_HID_Desc+0x330>)
 8012f9a:	681b      	ldr	r3, [r3, #0]
 8012f9c:	2203      	movs	r2, #3
 8012f9e:	70da      	strb	r2, [r3, #3]
 8012fa0:	68fb      	ldr	r3, [r7, #12]
 8012fa2:	685a      	ldr	r2, [r3, #4]
 8012fa4:	4b16      	ldr	r3, [pc, #88]	; (8013000 <USBD_FrameWork_HID_Desc+0x330>)
 8012fa6:	681b      	ldr	r3, [r3, #0]
 8012fa8:	68f9      	ldr	r1, [r7, #12]
 8012faa:	205c      	movs	r0, #92	; 0x5c
 8012fac:	fb00 f202 	mul.w	r2, r0, r2
 8012fb0:	440a      	add	r2, r1
 8012fb2:	322c      	adds	r2, #44	; 0x2c
 8012fb4:	8812      	ldrh	r2, [r2, #0]
 8012fb6:	809a      	strh	r2, [r3, #4]
 8012fb8:	68fb      	ldr	r3, [r7, #12]
 8012fba:	781b      	ldrb	r3, [r3, #0]
 8012fbc:	2b01      	cmp	r3, #1
 8012fbe:	d104      	bne.n	8012fca <USBD_FrameWork_HID_Desc+0x2fa>
 8012fc0:	4b0f      	ldr	r3, [pc, #60]	; (8013000 <USBD_FrameWork_HID_Desc+0x330>)
 8012fc2:	681b      	ldr	r3, [r3, #0]
 8012fc4:	2205      	movs	r2, #5
 8012fc6:	719a      	strb	r2, [r3, #6]
 8012fc8:	e003      	b.n	8012fd2 <USBD_FrameWork_HID_Desc+0x302>
 8012fca:	4b0d      	ldr	r3, [pc, #52]	; (8013000 <USBD_FrameWork_HID_Desc+0x330>)
 8012fcc:	681b      	ldr	r3, [r3, #0]
 8012fce:	2205      	movs	r2, #5
 8012fd0:	719a      	strb	r2, [r3, #6]
 8012fd2:	687b      	ldr	r3, [r7, #4]
 8012fd4:	681b      	ldr	r3, [r3, #0]
 8012fd6:	1dda      	adds	r2, r3, #7
 8012fd8:	687b      	ldr	r3, [r7, #4]
 8012fda:	601a      	str	r2, [r3, #0]
      break;
 8012fdc:	e000      	b.n	8012fe0 <USBD_FrameWork_HID_Desc+0x310>

#endif /* USBD_HID_CUSTOM_ACTIVATED == 1U */

    default:
      break;
 8012fde:	bf00      	nop
  }

  /* Update Config Descriptor and IAD descriptor */
  ((USBD_ConfigDescTypedef *)pConf)->bNumInterfaces += 1U;
 8012fe0:	68bb      	ldr	r3, [r7, #8]
 8012fe2:	791a      	ldrb	r2, [r3, #4]
 8012fe4:	68bb      	ldr	r3, [r7, #8]
 8012fe6:	3201      	adds	r2, #1
 8012fe8:	b2d2      	uxtb	r2, r2
 8012fea:	711a      	strb	r2, [r3, #4]
  ((USBD_ConfigDescTypedef *)pConf)->wDescriptorLength = *Sze;
 8012fec:	687b      	ldr	r3, [r7, #4]
 8012fee:	681a      	ldr	r2, [r3, #0]
 8012ff0:	68bb      	ldr	r3, [r7, #8]
 8012ff2:	b292      	uxth	r2, r2
 8012ff4:	805a      	strh	r2, [r3, #2]

}
 8012ff6:	bf00      	nop
 8012ff8:	3714      	adds	r7, #20
 8012ffa:	46bd      	mov	sp, r7
 8012ffc:	bd90      	pop	{r4, r7, pc}
 8012ffe:	bf00      	nop
 8013000:	20007950 	.word	0x20007950

08013004 <USBD_FrameWork_MSCDesc>:
  * @param  Sze: pointer to the current configuration descriptor size
  * @retval None
  */
static void  USBD_FrameWork_MSCDesc(USBD_DevClassHandleTypeDef *pdev,
                                    uint32_t pConf, uint32_t *Sze)
{
 8013004:	b480      	push	{r7}
 8013006:	b087      	sub	sp, #28
 8013008:	af00      	add	r7, sp, #0
 801300a:	60f8      	str	r0, [r7, #12]
 801300c:	60b9      	str	r1, [r7, #8]
 801300e:	607a      	str	r2, [r7, #4]
  USBD_IfDescTypedef       *pIfDesc;
  USBD_EpDescTypedef       *pEpDesc;

  /* Append MSC Interface descriptor */
  __USBD_FRAMEWORK_SET_IF((pdev->tclasslist[pdev->classId].Ifs[0]), (0U), \
 8013010:	687b      	ldr	r3, [r7, #4]
 8013012:	681a      	ldr	r2, [r3, #0]
 8013014:	68bb      	ldr	r3, [r7, #8]
 8013016:	4413      	add	r3, r2
 8013018:	617b      	str	r3, [r7, #20]
 801301a:	697b      	ldr	r3, [r7, #20]
 801301c:	2209      	movs	r2, #9
 801301e:	701a      	strb	r2, [r3, #0]
 8013020:	697b      	ldr	r3, [r7, #20]
 8013022:	2204      	movs	r2, #4
 8013024:	705a      	strb	r2, [r3, #1]
 8013026:	68fb      	ldr	r3, [r7, #12]
 8013028:	685b      	ldr	r3, [r3, #4]
 801302a:	68fa      	ldr	r2, [r7, #12]
 801302c:	215c      	movs	r1, #92	; 0x5c
 801302e:	fb01 f303 	mul.w	r3, r1, r3
 8013032:	4413      	add	r3, r2
 8013034:	335a      	adds	r3, #90	; 0x5a
 8013036:	781a      	ldrb	r2, [r3, #0]
 8013038:	697b      	ldr	r3, [r7, #20]
 801303a:	709a      	strb	r2, [r3, #2]
 801303c:	697b      	ldr	r3, [r7, #20]
 801303e:	2200      	movs	r2, #0
 8013040:	70da      	strb	r2, [r3, #3]
 8013042:	68fb      	ldr	r3, [r7, #12]
 8013044:	685b      	ldr	r3, [r3, #4]
 8013046:	68fa      	ldr	r2, [r7, #12]
 8013048:	215c      	movs	r1, #92	; 0x5c
 801304a:	fb01 f303 	mul.w	r3, r1, r3
 801304e:	4413      	add	r3, r2
 8013050:	331c      	adds	r3, #28
 8013052:	681b      	ldr	r3, [r3, #0]
 8013054:	b2da      	uxtb	r2, r3
 8013056:	697b      	ldr	r3, [r7, #20]
 8013058:	711a      	strb	r2, [r3, #4]
 801305a:	697b      	ldr	r3, [r7, #20]
 801305c:	2208      	movs	r2, #8
 801305e:	715a      	strb	r2, [r3, #5]
 8013060:	697b      	ldr	r3, [r7, #20]
 8013062:	2206      	movs	r2, #6
 8013064:	719a      	strb	r2, [r3, #6]
 8013066:	697b      	ldr	r3, [r7, #20]
 8013068:	2250      	movs	r2, #80	; 0x50
 801306a:	71da      	strb	r2, [r3, #7]
 801306c:	697b      	ldr	r3, [r7, #20]
 801306e:	2200      	movs	r2, #0
 8013070:	721a      	strb	r2, [r3, #8]
 8013072:	687b      	ldr	r3, [r7, #4]
 8013074:	681b      	ldr	r3, [r3, #0]
 8013076:	f103 0209 	add.w	r2, r3, #9
 801307a:	687b      	ldr	r3, [r7, #4]
 801307c:	601a      	str	r2, [r3, #0]
                          (uint8_t)(pdev->tclasslist[pdev->classId].NumEps),
                          (0x08U), (0x06U), (0x50U), (0U));

  /* Append Endpoint descriptor to Configuration descriptor */
  __USBD_FRAMEWORK_SET_EP((pdev->tclasslist[pdev->classId].Eps[0].add),
 801307e:	687b      	ldr	r3, [r7, #4]
 8013080:	681a      	ldr	r2, [r3, #0]
 8013082:	68bb      	ldr	r3, [r7, #8]
 8013084:	4413      	add	r3, r2
 8013086:	613b      	str	r3, [r7, #16]
 8013088:	693b      	ldr	r3, [r7, #16]
 801308a:	2207      	movs	r2, #7
 801308c:	701a      	strb	r2, [r3, #0]
 801308e:	693b      	ldr	r3, [r7, #16]
 8013090:	2205      	movs	r2, #5
 8013092:	705a      	strb	r2, [r3, #1]
 8013094:	68fb      	ldr	r3, [r7, #12]
 8013096:	685b      	ldr	r3, [r3, #4]
 8013098:	68fa      	ldr	r2, [r7, #12]
 801309a:	215c      	movs	r1, #92	; 0x5c
 801309c:	fb01 f303 	mul.w	r3, r1, r3
 80130a0:	4413      	add	r3, r2
 80130a2:	3324      	adds	r3, #36	; 0x24
 80130a4:	781a      	ldrb	r2, [r3, #0]
 80130a6:	693b      	ldr	r3, [r7, #16]
 80130a8:	709a      	strb	r2, [r3, #2]
 80130aa:	693b      	ldr	r3, [r7, #16]
 80130ac:	2202      	movs	r2, #2
 80130ae:	70da      	strb	r2, [r3, #3]
 80130b0:	68fb      	ldr	r3, [r7, #12]
 80130b2:	685b      	ldr	r3, [r3, #4]
 80130b4:	68fa      	ldr	r2, [r7, #12]
 80130b6:	215c      	movs	r1, #92	; 0x5c
 80130b8:	fb01 f303 	mul.w	r3, r1, r3
 80130bc:	4413      	add	r3, r2
 80130be:	3326      	adds	r3, #38	; 0x26
 80130c0:	881a      	ldrh	r2, [r3, #0]
 80130c2:	693b      	ldr	r3, [r7, #16]
 80130c4:	809a      	strh	r2, [r3, #4]
 80130c6:	68fb      	ldr	r3, [r7, #12]
 80130c8:	781b      	ldrb	r3, [r3, #0]
 80130ca:	2b01      	cmp	r3, #1
 80130cc:	d103      	bne.n	80130d6 <USBD_FrameWork_MSCDesc+0xd2>
 80130ce:	693b      	ldr	r3, [r7, #16]
 80130d0:	2200      	movs	r2, #0
 80130d2:	719a      	strb	r2, [r3, #6]
 80130d4:	e002      	b.n	80130dc <USBD_FrameWork_MSCDesc+0xd8>
 80130d6:	693b      	ldr	r3, [r7, #16]
 80130d8:	2200      	movs	r2, #0
 80130da:	719a      	strb	r2, [r3, #6]
 80130dc:	687b      	ldr	r3, [r7, #4]
 80130de:	681b      	ldr	r3, [r3, #0]
 80130e0:	1dda      	adds	r2, r3, #7
 80130e2:	687b      	ldr	r3, [r7, #4]
 80130e4:	601a      	str	r2, [r3, #0]
                          (USBD_EP_TYPE_BULK),
                          (uint16_t)(pdev->tclasslist[pdev->classId].Eps[0].size),
                          (0U), (0U));

  /* Append Endpoint descriptor to Configuration descriptor */
  __USBD_FRAMEWORK_SET_EP((pdev->tclasslist[pdev->classId].Eps[1].add),
 80130e6:	687b      	ldr	r3, [r7, #4]
 80130e8:	681a      	ldr	r2, [r3, #0]
 80130ea:	68bb      	ldr	r3, [r7, #8]
 80130ec:	4413      	add	r3, r2
 80130ee:	613b      	str	r3, [r7, #16]
 80130f0:	693b      	ldr	r3, [r7, #16]
 80130f2:	2207      	movs	r2, #7
 80130f4:	701a      	strb	r2, [r3, #0]
 80130f6:	693b      	ldr	r3, [r7, #16]
 80130f8:	2205      	movs	r2, #5
 80130fa:	705a      	strb	r2, [r3, #1]
 80130fc:	68fb      	ldr	r3, [r7, #12]
 80130fe:	685b      	ldr	r3, [r3, #4]
 8013100:	68fa      	ldr	r2, [r7, #12]
 8013102:	215c      	movs	r1, #92	; 0x5c
 8013104:	fb01 f303 	mul.w	r3, r1, r3
 8013108:	4413      	add	r3, r2
 801310a:	332a      	adds	r3, #42	; 0x2a
 801310c:	781a      	ldrb	r2, [r3, #0]
 801310e:	693b      	ldr	r3, [r7, #16]
 8013110:	709a      	strb	r2, [r3, #2]
 8013112:	693b      	ldr	r3, [r7, #16]
 8013114:	2202      	movs	r2, #2
 8013116:	70da      	strb	r2, [r3, #3]
 8013118:	68fb      	ldr	r3, [r7, #12]
 801311a:	685b      	ldr	r3, [r3, #4]
 801311c:	68fa      	ldr	r2, [r7, #12]
 801311e:	215c      	movs	r1, #92	; 0x5c
 8013120:	fb01 f303 	mul.w	r3, r1, r3
 8013124:	4413      	add	r3, r2
 8013126:	332c      	adds	r3, #44	; 0x2c
 8013128:	881a      	ldrh	r2, [r3, #0]
 801312a:	693b      	ldr	r3, [r7, #16]
 801312c:	809a      	strh	r2, [r3, #4]
 801312e:	68fb      	ldr	r3, [r7, #12]
 8013130:	781b      	ldrb	r3, [r3, #0]
 8013132:	2b01      	cmp	r3, #1
 8013134:	d103      	bne.n	801313e <USBD_FrameWork_MSCDesc+0x13a>
 8013136:	693b      	ldr	r3, [r7, #16]
 8013138:	2200      	movs	r2, #0
 801313a:	719a      	strb	r2, [r3, #6]
 801313c:	e002      	b.n	8013144 <USBD_FrameWork_MSCDesc+0x140>
 801313e:	693b      	ldr	r3, [r7, #16]
 8013140:	2200      	movs	r2, #0
 8013142:	719a      	strb	r2, [r3, #6]
 8013144:	687b      	ldr	r3, [r7, #4]
 8013146:	681b      	ldr	r3, [r3, #0]
 8013148:	1dda      	adds	r2, r3, #7
 801314a:	687b      	ldr	r3, [r7, #4]
 801314c:	601a      	str	r2, [r3, #0]
                          (USBD_EP_TYPE_BULK),
                          (uint16_t)(pdev->tclasslist[pdev->classId].Eps[1].size),
                          (0U), (0U));

  /* Update Config Descriptor and IAD descriptor */
  ((USBD_ConfigDescTypedef *)pConf)->bNumInterfaces += 1U;
 801314e:	68bb      	ldr	r3, [r7, #8]
 8013150:	791a      	ldrb	r2, [r3, #4]
 8013152:	68bb      	ldr	r3, [r7, #8]
 8013154:	3201      	adds	r2, #1
 8013156:	b2d2      	uxtb	r2, r2
 8013158:	711a      	strb	r2, [r3, #4]
  ((USBD_ConfigDescTypedef *)pConf)->wDescriptorLength = *Sze;
 801315a:	687b      	ldr	r3, [r7, #4]
 801315c:	681a      	ldr	r2, [r3, #0]
 801315e:	68bb      	ldr	r3, [r7, #8]
 8013160:	b292      	uxth	r2, r2
 8013162:	805a      	strh	r2, [r3, #2]
}
 8013164:	bf00      	nop
 8013166:	371c      	adds	r7, #28
 8013168:	46bd      	mov	sp, r7
 801316a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801316e:	4770      	bx	lr

08013170 <USBD_STORAGE_Activate>:
  *         This function is called when insertion of a storage device.
  * @param  storage_instance: Pointer to the storage class instance.
  * @retval none
  */
VOID USBD_STORAGE_Activate(VOID *storage_instance)
{
 8013170:	b480      	push	{r7}
 8013172:	b083      	sub	sp, #12
 8013174:	af00      	add	r7, sp, #0
 8013176:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN USBD_STORAGE_Activate */
  UX_PARAMETER_NOT_USED(storage_instance);
  /* USER CODE END USBD_STORAGE_Activate */

  return;
 8013178:	bf00      	nop
}
 801317a:	370c      	adds	r7, #12
 801317c:	46bd      	mov	sp, r7
 801317e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013182:	4770      	bx	lr

08013184 <USBD_STORAGE_Deactivate>:
  *         This function is called when extraction of a storage device.
  * @param  storage_instance: Pointer to the storage class instance.
  * @retval none
  */
VOID USBD_STORAGE_Deactivate(VOID *storage_instance)
{
 8013184:	b480      	push	{r7}
 8013186:	b083      	sub	sp, #12
 8013188:	af00      	add	r7, sp, #0
 801318a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN USBD_STORAGE_Activate */
  UX_PARAMETER_NOT_USED(storage_instance);
  /* USER CODE END USBD_STORAGE_Activate */

  return;
 801318c:	bf00      	nop
}
 801318e:	370c      	adds	r7, #12
 8013190:	46bd      	mov	sp, r7
 8013192:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013196:	4770      	bx	lr

08013198 <USBD_STORAGE_Read>:
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Read(VOID *storage_instance, ULONG lun, UCHAR *data_pointer,
                       ULONG number_blocks, ULONG lba, ULONG *media_status)
{
 8013198:	b480      	push	{r7}
 801319a:	b087      	sub	sp, #28
 801319c:	af00      	add	r7, sp, #0
 801319e:	60f8      	str	r0, [r7, #12]
 80131a0:	60b9      	str	r1, [r7, #8]
 80131a2:	607a      	str	r2, [r7, #4]
 80131a4:	603b      	str	r3, [r7, #0]
  UINT status = UX_SUCCESS;
 80131a6:	2300      	movs	r3, #0
 80131a8:	617b      	str	r3, [r7, #20]
  UX_PARAMETER_NOT_USED(number_blocks);
  UX_PARAMETER_NOT_USED(lba);
  UX_PARAMETER_NOT_USED(media_status);
  /* USER CODE END USBD_STORAGE_Read */

  return status;
 80131aa:	697b      	ldr	r3, [r7, #20]
}
 80131ac:	4618      	mov	r0, r3
 80131ae:	371c      	adds	r7, #28
 80131b0:	46bd      	mov	sp, r7
 80131b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80131b6:	4770      	bx	lr

080131b8 <USBD_STORAGE_Write>:
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Write(VOID *storage_instance, ULONG lun, UCHAR *data_pointer,
                        ULONG number_blocks, ULONG lba, ULONG *media_status)
{
 80131b8:	b480      	push	{r7}
 80131ba:	b087      	sub	sp, #28
 80131bc:	af00      	add	r7, sp, #0
 80131be:	60f8      	str	r0, [r7, #12]
 80131c0:	60b9      	str	r1, [r7, #8]
 80131c2:	607a      	str	r2, [r7, #4]
 80131c4:	603b      	str	r3, [r7, #0]
  UINT status = UX_SUCCESS;
 80131c6:	2300      	movs	r3, #0
 80131c8:	617b      	str	r3, [r7, #20]
  UX_PARAMETER_NOT_USED(number_blocks);
  UX_PARAMETER_NOT_USED(lba);
  UX_PARAMETER_NOT_USED(media_status);
  /* USER CODE END USBD_STORAGE_Write */

  return status;
 80131ca:	697b      	ldr	r3, [r7, #20]
}
 80131cc:	4618      	mov	r0, r3
 80131ce:	371c      	adds	r7, #28
 80131d0:	46bd      	mov	sp, r7
 80131d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80131d6:	4770      	bx	lr

080131d8 <USBD_STORAGE_Flush>:
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Flush(VOID *storage_instance, ULONG lun, ULONG number_blocks,
                        ULONG lba, ULONG *media_status)
{
 80131d8:	b480      	push	{r7}
 80131da:	b087      	sub	sp, #28
 80131dc:	af00      	add	r7, sp, #0
 80131de:	60f8      	str	r0, [r7, #12]
 80131e0:	60b9      	str	r1, [r7, #8]
 80131e2:	607a      	str	r2, [r7, #4]
 80131e4:	603b      	str	r3, [r7, #0]
  UINT status = UX_SUCCESS;
 80131e6:	2300      	movs	r3, #0
 80131e8:	617b      	str	r3, [r7, #20]
  UX_PARAMETER_NOT_USED(number_blocks);
  UX_PARAMETER_NOT_USED(lba);
  UX_PARAMETER_NOT_USED(media_status);
  /* USER CODE END USBD_STORAGE_Flush */

  return status;
 80131ea:	697b      	ldr	r3, [r7, #20]
}
 80131ec:	4618      	mov	r0, r3
 80131ee:	371c      	adds	r7, #28
 80131f0:	46bd      	mov	sp, r7
 80131f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80131f6:	4770      	bx	lr

080131f8 <USBD_STORAGE_Status>:
  *                       callback return value.
  * @retval status
  */
UINT USBD_STORAGE_Status(VOID *storage_instance, ULONG lun, ULONG media_id,
                         ULONG *media_status)
{
 80131f8:	b480      	push	{r7}
 80131fa:	b087      	sub	sp, #28
 80131fc:	af00      	add	r7, sp, #0
 80131fe:	60f8      	str	r0, [r7, #12]
 8013200:	60b9      	str	r1, [r7, #8]
 8013202:	607a      	str	r2, [r7, #4]
 8013204:	603b      	str	r3, [r7, #0]
  UINT status = UX_SUCCESS;
 8013206:	2300      	movs	r3, #0
 8013208:	617b      	str	r3, [r7, #20]
  UX_PARAMETER_NOT_USED(lun);
  UX_PARAMETER_NOT_USED(media_id);
  UX_PARAMETER_NOT_USED(media_status);
  /* USER CODE END USBD_STORAGE_Status */

  return status;
 801320a:	697b      	ldr	r3, [r7, #20]
}
 801320c:	4618      	mov	r0, r3
 801320e:	371c      	adds	r7, #28
 8013210:	46bd      	mov	sp, r7
 8013212:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013216:	4770      	bx	lr

08013218 <USBD_STORAGE_Notification>:
  * @retval status
  */
UINT USBD_STORAGE_Notification(VOID *storage_instance, ULONG lun, ULONG media_id,
                               ULONG notification_class, UCHAR **media_notification,
                               ULONG *media_notification_length)
{
 8013218:	b480      	push	{r7}
 801321a:	b087      	sub	sp, #28
 801321c:	af00      	add	r7, sp, #0
 801321e:	60f8      	str	r0, [r7, #12]
 8013220:	60b9      	str	r1, [r7, #8]
 8013222:	607a      	str	r2, [r7, #4]
 8013224:	603b      	str	r3, [r7, #0]
  UINT status = UX_SUCCESS;
 8013226:	2300      	movs	r3, #0
 8013228:	617b      	str	r3, [r7, #20]
  UX_PARAMETER_NOT_USED(notification_class);
  UX_PARAMETER_NOT_USED(media_notification);
  UX_PARAMETER_NOT_USED(media_notification_length);
  /* USER CODE END USBD_STORAGE_Notification */

  return status;
 801322a:	697b      	ldr	r3, [r7, #20]
}
 801322c:	4618      	mov	r0, r3
 801322e:	371c      	adds	r7, #28
 8013230:	46bd      	mov	sp, r7
 8013232:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013236:	4770      	bx	lr

08013238 <USBD_STORAGE_GetMediaLastLba>:
  *         Get Media last LBA.
  * @param  none
  * @retval last lba
  */
ULONG USBD_STORAGE_GetMediaLastLba(VOID)
{
 8013238:	b480      	push	{r7}
 801323a:	b083      	sub	sp, #12
 801323c:	af00      	add	r7, sp, #0
  ULONG LastLba = 0U;
 801323e:	2300      	movs	r3, #0
 8013240:	607b      	str	r3, [r7, #4]

  /* USER CODE BEGIN USBD_STORAGE_GetMediaLastLba */

  /* USER CODE END USBD_STORAGE_GetMediaLastLba */

  return LastLba;
 8013242:	687b      	ldr	r3, [r7, #4]
}
 8013244:	4618      	mov	r0, r3
 8013246:	370c      	adds	r7, #12
 8013248:	46bd      	mov	sp, r7
 801324a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801324e:	4770      	bx	lr

08013250 <USBD_STORAGE_GetMediaBlocklength>:
  *         Get Media block length.
  * @param  none.
  * @retval block length.
  */
ULONG USBD_STORAGE_GetMediaBlocklength(VOID)
{
 8013250:	b480      	push	{r7}
 8013252:	b083      	sub	sp, #12
 8013254:	af00      	add	r7, sp, #0
  ULONG MediaBlockLen = 0U;
 8013256:	2300      	movs	r3, #0
 8013258:	607b      	str	r3, [r7, #4]

  /* USER CODE BEGIN USBD_STORAGE_GetMediaBlocklength */

  /* USER CODE END USBD_STORAGE_GetMediaBlocklength */

  return MediaBlockLen;
 801325a:	687b      	ldr	r3, [r7, #4]
}
 801325c:	4618      	mov	r0, r3
 801325e:	370c      	adds	r7, #12
 8013260:	46bd      	mov	sp, r7
 8013262:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013266:	4770      	bx	lr

08013268 <memset>:
 8013268:	4402      	add	r2, r0
 801326a:	4603      	mov	r3, r0
 801326c:	4293      	cmp	r3, r2
 801326e:	d100      	bne.n	8013272 <memset+0xa>
 8013270:	4770      	bx	lr
 8013272:	f803 1b01 	strb.w	r1, [r3], #1
 8013276:	e7f9      	b.n	801326c <memset+0x4>

08013278 <__libc_init_array>:
 8013278:	b570      	push	{r4, r5, r6, lr}
 801327a:	4d0d      	ldr	r5, [pc, #52]	; (80132b0 <__libc_init_array+0x38>)
 801327c:	4c0d      	ldr	r4, [pc, #52]	; (80132b4 <__libc_init_array+0x3c>)
 801327e:	1b64      	subs	r4, r4, r5
 8013280:	10a4      	asrs	r4, r4, #2
 8013282:	2600      	movs	r6, #0
 8013284:	42a6      	cmp	r6, r4
 8013286:	d109      	bne.n	801329c <__libc_init_array+0x24>
 8013288:	4d0b      	ldr	r5, [pc, #44]	; (80132b8 <__libc_init_array+0x40>)
 801328a:	4c0c      	ldr	r4, [pc, #48]	; (80132bc <__libc_init_array+0x44>)
 801328c:	f000 f826 	bl	80132dc <_init>
 8013290:	1b64      	subs	r4, r4, r5
 8013292:	10a4      	asrs	r4, r4, #2
 8013294:	2600      	movs	r6, #0
 8013296:	42a6      	cmp	r6, r4
 8013298:	d105      	bne.n	80132a6 <__libc_init_array+0x2e>
 801329a:	bd70      	pop	{r4, r5, r6, pc}
 801329c:	f855 3b04 	ldr.w	r3, [r5], #4
 80132a0:	4798      	blx	r3
 80132a2:	3601      	adds	r6, #1
 80132a4:	e7ee      	b.n	8013284 <__libc_init_array+0xc>
 80132a6:	f855 3b04 	ldr.w	r3, [r5], #4
 80132aa:	4798      	blx	r3
 80132ac:	3601      	adds	r6, #1
 80132ae:	e7f2      	b.n	8013296 <__libc_init_array+0x1e>
 80132b0:	080135cc 	.word	0x080135cc
 80132b4:	080135cc 	.word	0x080135cc
 80132b8:	080135cc 	.word	0x080135cc
 80132bc:	080135d8 	.word	0x080135d8

080132c0 <memcpy>:
 80132c0:	440a      	add	r2, r1
 80132c2:	4291      	cmp	r1, r2
 80132c4:	f100 33ff 	add.w	r3, r0, #4294967295
 80132c8:	d100      	bne.n	80132cc <memcpy+0xc>
 80132ca:	4770      	bx	lr
 80132cc:	b510      	push	{r4, lr}
 80132ce:	f811 4b01 	ldrb.w	r4, [r1], #1
 80132d2:	f803 4f01 	strb.w	r4, [r3, #1]!
 80132d6:	4291      	cmp	r1, r2
 80132d8:	d1f9      	bne.n	80132ce <memcpy+0xe>
 80132da:	bd10      	pop	{r4, pc}

080132dc <_init>:
 80132dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80132de:	bf00      	nop
 80132e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80132e2:	bc08      	pop	{r3}
 80132e4:	469e      	mov	lr, r3
 80132e6:	4770      	bx	lr

080132e8 <_fini>:
 80132e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80132ea:	bf00      	nop
 80132ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80132ee:	bc08      	pop	{r3}
 80132f0:	469e      	mov	lr, r3
 80132f2:	4770      	bx	lr
